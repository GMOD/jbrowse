{"/home/cdiesh/src/jbrowse/src/JBrowse/BehaviorManager.js":{"size":3796,"mtime":1738905960886,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/BehaviorManager.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([], function () {\n  /**\n   * Stores, applies, and removes a named set of behaviors.  A behavior\n   * is a set of event handlers that need to be connected and then\n   * disconnected repeatedly as a group.\n   * @constructor\n   * @class\n   * @param {Object} args.behaviors object containing the behaviors to be managed, as:\n   * <pre>\n   *     {\n   *        behavior_name: {\n   *          apply_on_init: true if this behavior should be applied when the manager is initialized,\n   *          apply: function( manager_object, handles_array ) {\n   *            // required function that returns an array of dojo event handles.  for example:\n   *            return [\n   *                dojo.connect(document.body, \"mouseup\",   this, 'rubberExecute'  ),\n   *                dojo.connect(document.body, \"mousemove\", this, 'rubberMove'     )\n   *            ];\n   *          },\n   *          remove: function( manager_object, handles_array ) {\n   *              // optional function that removes the behavior.  by\n   *              // default dojo.disconnect() is just called on each\n   *              // of the event handles that were returned by the\n   *              // apply function\n   *          }\n   *        },\n   *        ...\n   *     }\n   * </pre>\n   * @param {Object} [args.context=BehaviorManager itself] context\n   *    (i.e. <code>this</code>) in which each of the behavior\n   *    <code>apply()</code> and <code>remove()</code> functions will be\n   *    called.\n   * @lends JBrowse.BehaviorManager\n   */\n  function BehaviorManager(args) {\n    this.context = args.context\n    this.behaviors = args.behaviors\n  }\n\n  /**\n   * Apply the behaviors that have <code>apply_on_init</code> true.\n   */\n  BehaviorManager.prototype.initialize = function () {\n    this.removeAll()\n    for (var bname in this.behaviors) {\n      var b = this.behaviors[bname]\n      if (b.apply_on_init) {\n        this.applyBehaviors(bname)\n      }\n    }\n  }\n\n  /**\n   * Apply each of the behaviors named as arguments to this function.\n   * @param {String} [...] Zero or more string behavior names to apply.\n   */\n  BehaviorManager.prototype.applyBehaviors = function () {\n    dojo.forEach(\n      arguments,\n      function (name) {\n        var b = this._get(name)\n        if (!b.applied) {\n          b.handles = b.handles || []\n          b.handles = b.apply.call(this.context || this, this, b.handles)\n          b.applied = true\n        }\n      },\n      this,\n    )\n  }\n\n  /**\n   * Look up a behavior by name, throw an exception if it's not there.\n   * @private\n   */\n  BehaviorManager.prototype._get = function (name) {\n    var b = this.behaviors[name]\n    if (!b) {throw \"no behavior registed with name '\" + \"'name\"}\n    return b\n  }\n\n  /**\n   * Given two behavior names, remove the first one and apply the second\n   * one.  For convenience.\n   */\n  BehaviorManager.prototype.swapBehaviors = function (off, on) {\n    this.removeBehaviors(off)\n    this.applyBehaviors(on)\n  }\n\n  /**\n   * Remove each of the behaviors named as arguments to this function.\n   * @param {String} [...] Zero or more string behavior names to remove.\n   */\n  BehaviorManager.prototype.removeBehaviors = function () {\n    dojo.forEach(\n      arguments,\n      function (name) {\n        var b = this._get(name)\n        if (b.applied) {\n          var remove =\n            b.remove ||\n            function (m, h) {\n              dojo.forEach(h, dojo.disconnect, dojo)\n            }\n          remove.call(this.context || this, this, b.handles)\n          b.applied = false\n        }\n      },\n      this,\n    )\n  }\n\n  /**\n   * Remove all behaviors that are currently applied.\n   */\n  BehaviorManager.prototype.removeAll = function () {\n    for (var bname in this.behaviors) {\n      this.removeBehaviors(bname)\n    }\n  }\n\n  return BehaviorManager\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/Browser.js":{"size":135881,"mtime":1738905961144,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Browser.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"const url = cjsRequire('url')\n\nimport dompurify from 'dompurify'\n\nimport packagejson from './package.json'\ndefine([\n  'dojo/_base/declare',\n  'dojo/_base/lang',\n  'dojo/on',\n  'dojo/html',\n  'dojo/query',\n  'dojo/dom-construct',\n  'dojo/keys',\n  'dojo/Deferred',\n  'dojo/DeferredList',\n  'dojo/topic',\n  'dojo/aspect',\n  'dojo/request',\n  'dojo/io-query',\n  'JBrowse/has',\n  'dojo/_base/array',\n  'dijit/layout/ContentPane',\n  'dijit/layout/BorderContainer',\n  'dijit/Dialog',\n  'dijit/form/ComboBox',\n  'dojo/store/Memory',\n  'dijit/form/Button',\n  'dijit/form/Select',\n  'dijit/form/ToggleButton',\n  'dijit/form/DropDownButton',\n  'dijit/DropDownMenu',\n  'dijit/CheckedMenuItem',\n  'dijit/MenuItem',\n  'dijit/MenuSeparator',\n  'dojox/form/TriStateCheckBox',\n  'dojox/html/entities',\n  'JBrowse/Util',\n  'JBrowse/Store/LazyTrie',\n  'JBrowse/Store/Names/LazyTrieDojoData',\n  'dojo/store/DataStore',\n  'JBrowse/FeatureFiltererMixin',\n  'JBrowse/GenomeView',\n  'JBrowse/TouchScreenSupport',\n  'JBrowse/ConfigManager',\n  'JBrowse/View/InfoDialog',\n  'JBrowse/View/FileDialog',\n  'JBrowse/View/FastaFileDialog',\n  'JBrowse/Model/Location',\n  'JBrowse/View/LocationChoiceDialog',\n  'JBrowse/View/Dialog/SetHighlight',\n  'JBrowse/View/Dialog/Preferences',\n  'JBrowse/View/Dialog/OpenDirectory',\n  'JBrowse/View/Dialog/SetTrackHeight',\n  'JBrowse/View/Dialog/QuickHelp',\n  'JBrowse/View/StandaloneDatasetList',\n  'JBrowse/Store/SeqFeature/ChromSizes',\n  'JBrowse/Store/SeqFeature/UnindexedFasta',\n  'JBrowse/Store/SeqFeature/IndexedFasta',\n  'JBrowse/Store/SeqFeature/BgzipIndexedFasta',\n  'JBrowse/Store/SeqFeature/TwoBit',\n  'dijit/focus',\n  '../lazyload.js', // for dynamic CSS loading\n\n  // extras for webpack\n  'dojox/data/CsvStore',\n  'dojox/data/JsonRestStore',\n], function (\n  declare,\n  lang,\n  on,\n  html,\n  query,\n  domConstruct,\n  keys,\n  Deferred,\n  DeferredList,\n  topic,\n  aspect,\n  request,\n  ioQuery,\n  has,\n  array,\n  dijitContentPane,\n  dijitBorderContainer,\n  dijitDialog,\n  dijitComboBox,\n  dojoMemoryStore,\n  dijitButton,\n  dijitSelectBox,\n  dijitToggleButton,\n  dijitDropDownButton,\n  dijitDropDownMenu,\n  dijitCheckedMenuItem,\n  dijitMenuItem,\n  dijitMenuSeparator,\n  dojoxTriStateCheckBox,\n  dojoxHtmlEntities,\n  Util,\n  LazyTrie,\n  NamesLazyTrieDojoDataStore,\n  DojoDataStore,\n  FeatureFiltererMixin,\n  GenomeView,\n  Touch,\n  ConfigManager,\n  InfoDialog,\n  FileDialog,\n  FastaFileDialog,\n  Location,\n  LocationChoiceDialog,\n  SetHighlightDialog,\n  PreferencesDialog,\n  OpenDirectoryDialog,\n  SetTrackHeightDialog,\n  HelpDialog,\n  StandaloneDatasetList,\n  ChromSizes,\n  UnindexedFasta,\n  IndexedFasta,\n  BgzipIndexedFasta,\n  TwoBit,\n  dijitFocus,\n  LazyLoad,\n) {\n  var dojof = Util.dojof\n\n  require.on('error', function (error) {\n    let errString =\n      error.info && error.info[0] && error.info[0].mid\n        ? error.info.map(({ mid }) => mid).join(', ')\n        : error\n    window.JBrowse.fatalError('Failed to load resource: ' + errString)\n  })\n\n  /**\n   * Construct a new Browser object.\n   * @class This class is the main interface between JBrowse and embedders\n   * @constructor\n   * @param params an object with the following properties:<br>\n   * <ul>\n   * <li><code>config</code> - list of objects with \"url\" property that points to a config JSON file</li>\n   * <li><code>containerID</code> - ID of the HTML element that contains the browser</li>\n   * <li><code>refSeqs</code> - object with \"url\" property that is the URL to list of reference sequence information items</li>\n   * <li><code>browserRoot</code> - (optional) URL prefix for the browser code</li>\n   * <li><code>tracks</code> - (optional) comma-delimited string containing initial list of tracks to view</li>\n   * <li><code>location</code> - (optional) string describing the initial location</li>\n   * <li><code>defaultTracks</code> - (optional) comma-delimited string containing initial list of tracks to view if there are no cookies and no \"tracks\" parameter</li>\n   * <li><code>defaultLocation</code> - (optional) string describing the initial location if there are no cookies and no \"location\" parameter</li>\n   * <li><code>show_nav</code> - (optional) string describing the on/off state of navigation box</li>\n   * <li><code>show_tracklist</code> - (optional) string describing the on/off state of track bar</li>\n   * <li><code>show_overview</code> - (optional) string describing the on/off state of overview</li>\n   * </ul>\n   */\n\n  return declare(FeatureFiltererMixin, {\n    constructor: function (params) {\n      this.globalKeyboardShortcuts = {}\n\n      this.config = params || {}\n\n      // if we're in the unit tests, stop here and don't do any more initialization\n      if (this.config.unitTestMode) {return}\n\n      // hook for externally applied initialization that can be setup in index.html\n      if (typeof this.config.initExtra === 'function')\n        {this.config.initExtra(this, params)}\n\n      this.startTime = new Date()\n\n      // start the initialization process\n      var thisB = this\n\n      dojo.addOnLoad(function () {\n        if (Util.isElectron() && !thisB.config.dataRoot) {\n          dojo.addClass(document.body, 'jbrowse')\n          dojo.addClass(document.body, thisB.config.theme || 'tundra')\n          thisB.welcomeScreen(document.body)\n          return\n        }\n        thisB.loadConfig().then(function () {\n          thisB.container = dojo.byId(thisB.config.containerID)\n          thisB.container.onselectstart = function () {\n            return false\n          }\n\n          // initialize our highlight if one was set in the config\n          if (\n            thisB.config.initialHighlight &&\n            thisB.config.initialHighlight != '/'\n          )\n            {thisB.setHighlight(new Location(thisB.config.initialHighlight))}\n\n          thisB.initPlugins().then(function () {\n            thisB.loadNames()\n            thisB.loadUserCSS().then(function () {\n              thisB.initTrackMetadata()\n              thisB.loadRefSeqs().then(function () {\n                // figure out our initial location\n                var initialLocString = thisB._initialLocation()\n                var initialLoc = Util.parseLocString(initialLocString)\n                if (\n                  initialLoc &&\n                  initialLoc.ref &&\n                  thisB.allRefs[initialLoc.ref]\n                ) {\n                  thisB.refSeq = thisB.allRefs[initialLoc.ref]\n                }\n\n                // before we init the view, make sure that our container has nonzero height and width\n                thisB.ensureNonzeroContainerDimensions()\n\n                thisB.initView().then(function () {\n                  Touch.loadTouch() // init touch device support\n                  if (initialLocString) {\n                    thisB.navigateTo(initialLocString, true)\n                  }\n\n                  // figure out what initial track list we will use:\n                  var tracksToShow = []\n                  // always add alwaysOnTracks, regardless of any other track params\n                  if (thisB.config.alwaysOnTracks) {\n                    tracksToShow = tracksToShow.concat(\n                      thisB.config.alwaysOnTracks.split(','),\n                    )\n                  }\n                  // add tracks specified in URL track param,\n                  //    if no URL track param then add last viewed tracks via tracks cookie\n                  //    if no URL param and no tracks cookie, then use defaultTracks\n                  if (thisB.config.forceTracks) {\n                    tracksToShow = tracksToShow.concat(\n                      thisB.config.forceTracks.split(','),\n                    )\n                  } else if (thisB.cookie('tracks')) {\n                    tracksToShow = tracksToShow.concat(\n                      thisB.cookie('tracks').split(','),\n                    )\n                  } else if (thisB.config.defaultTracks) {\n                    // In rare cases thisB.config.defaultTracks already contained an array that appeared to\n                    // have been split in a previous invocation of this function. Thus, we only try and split\n                    // it if it isn't already split.\n                    if (!(thisB.config.defaultTracks instanceof Array)) {\n                      tracksToShow = tracksToShow.concat(\n                        thisB.config.defaultTracks.split(','),\n                      )\n                    }\n                  }\n                  // currently, force \"DNA\" _only_ if no other guides as to what to show?\n                  //    or should this be changed to always force DNA to show?\n                  if (tracksToShow.length == 0) {\n                    tracksToShow.push('DNA')\n                  }\n                  // eliminate track duplicates (may have specified in both alwaysOnTracks and defaultTracks)\n                  tracksToShow = Util.uniq(tracksToShow)\n                  thisB.showTracks(tracksToShow)\n\n                  thisB.passMilestone('completely initialized', {\n                    success: true,\n                  })\n                })\n                thisB.reportUsageStats()\n              })\n            })\n          })\n        })\n      })\n    },\n\n    _initialLocation: function () {\n      var oldLocMap = dojo.fromJson(this.cookie('location')) || {}\n      if (this.config.location) {\n        return this.config.location\n      } else if (oldLocMap[this.refSeq.name]) {\n        return oldLocMap[this.refSeq.name].l || oldLocMap[this.refSeq.name]\n      } else if (this.config.defaultLocation) {\n        return this.config.defaultLocation\n      } else {\n        return Util.assembleLocString({\n          ref: this.refSeq.name,\n          start: 0.4 * (this.refSeq.start + this.refSeq.end),\n          end: 0.6 * (this.refSeq.start + this.refSeq.end),\n        })\n      }\n    },\n\n    version: function () {\n      // when a build is put together, the build system assigns a string\n      // to the variable below.\n      return packagejson.version\n    }.call(),\n\n    /**\n     * Get a plugin, if it is present.  Note that, if plugin\n     * initialization is not yet complete, it may be a while before the\n     * callback is called.\n     *\n     * Callback is called with one parameter, the desired plugin object,\n     * or undefined if it does not exist.\n     */\n    getPlugin: function (name, callback) {\n      this.afterMilestone(\n        'initPlugins',\n        dojo.hitch(this, function () {\n          callback(this.plugins[name])\n        }),\n      )\n    },\n\n    _corePlugins: function () {\n      return ['RegexSequenceSearch']\n    },\n\n    /**\n     * Load and instantiate any plugins defined in the configuration.\n     */\n    initPlugins: function () {\n      return this._milestoneFunction('initPlugins', function (deferred) {\n        this.plugins = {}\n\n        var plugins = this.config.plugins || this.config.Plugins || {}\n\n        // coerce plugins to array of objects\n        if (!lang.isArray(plugins) && !plugins.name) {\n          // plugins like  { Foo: {...}, Bar: {...} }\n          plugins = function () {\n            var newplugins = []\n            for (var pname in plugins) {\n              if (\n                lang.isObject(plugins[pname]) &&\n                !('name' in plugins[pname])\n              ) {\n                plugins[pname].name = pname\n              }\n              newplugins.push(plugins[pname])\n            }\n            return newplugins\n          }.call(this)\n        }\n        if (!lang.isArray(plugins)) {plugins = [plugins]}\n\n        plugins.unshift.apply(plugins, this._corePlugins())\n\n        // coerce string plugin names to {name: 'Name'}\n        plugins = array.map(plugins, function (p) {\n          return typeof p == 'object' ? p : { name: p }\n        })\n\n        if (!plugins.length) {\n          deferred.resolve({ success: true })\n          return\n        }\n\n        // set default locations for each plugin\n        plugins.forEach(p => {\n          // find the entry in the dojoConfig for this plugin\n          let configEntry = dojoConfig.packages.find(c => c.name === p.name)\n          if (configEntry) {\n            p.css = configEntry.css\n              ? configEntry.pluginDir + '/' + configEntry.css\n              : false\n            p.js = configEntry.location\n          } else {\n            this.fatalError(\n              `plugin ${p.name} not found. You can rebuild JBrowse with a -dev release or github clone with this plugin in the plugin folder`,\n            )\n          }\n        })\n\n        var pluginDeferreds = array.map(plugins, function (p) {\n          return new Deferred()\n        })\n\n        // fire the \"all plugins done\" deferred when all of the plugins are done loading\n        new DeferredList(pluginDeferreds).then(function () {\n          deferred.resolve({ success: true })\n        })\n\n        dojo.global.require(\n          array.map(plugins, function (p) {\n            return p.name + '/main'\n          }),\n          dojo.hitch(this, function () {\n            array.forEach(\n              arguments,\n              function (pluginClass, i) {\n                var plugin = plugins[i]\n                var thisPluginDone = pluginDeferreds[i]\n                if (typeof pluginClass == 'string') {\n                  console.error(\n                    'could not load plugin ' + plugin.name + ': ' + pluginClass,\n                  )\n                } else {\n                  // make the plugin's arguments out of\n                  // its little obj in 'plugins', and\n                  // also anything in the top-level\n                  // conf under its plugin name\n                  var args = dojo.mixin(dojo.clone(plugins[i]), {\n                    config: this.config[plugin.name] || {},\n                  })\n                  args.browser = this\n                  args = dojo.mixin(args, { browser: this })\n\n                  // load its css\n                  var cssLoaded\n                  if (plugin.css) {\n                    cssLoaded = this._loadCSS({\n                      url: this.resolveUrl(plugin.css + '/main.css'),\n                    })\n                  } else {\n                    cssLoaded = new Deferred()\n                    cssLoaded.resolve()\n                  }\n                  cssLoaded.then(function () {\n                    thisPluginDone.resolve({\n                      success: true,\n                    })\n                  })\n\n                  // give the plugin access to the CSS\n                  // promise so it can know when its\n                  // CSS is ready\n                  args.cssLoaded = cssLoaded\n\n                  // instantiate the plugin\n                  this.plugins[plugin.name] = new pluginClass(args)\n                }\n              },\n              this,\n            )\n          }),\n        )\n      })\n    },\n\n    /**\n     * Resolve a URL relative to the browserRoot.\n     */\n    resolveUrl: function (url) {\n      var browserRoot = this.config.browserRoot || this.config.baseUrl || ''\n\n      return Util.resolveUrl(browserRoot, url)\n    },\n\n    welcomeScreen: function (container, error) {\n      var thisB = this\n      require(['dojo/text!JBrowse/View/Resource/Welcome.html'], function (\n        Welcome,\n      ) {\n        container.innerHTML = Welcome\n        var topPane = dojo.create(\n          'div',\n          { style: { overflow: 'hidden' } },\n          thisB.container,\n        )\n        dojo.byId('welcome').innerHTML =\n          'Welcome! To get started with <i>JBrowse-' +\n          thisB.version +\n          '</i>, select a sequence file or an existing data directory'\n\n        on(\n          dojo.byId('newOpen'),\n          'click',\n          dojo.hitch(thisB, 'openFastaElectron'),\n        )\n        on(dojo.byId('newOpenDirectory'), 'click', function () {\n          new OpenDirectoryDialog({\n            browser: thisB,\n            setCallback: dojo.hitch(thisB, 'openDirectoryElectron'),\n          }).show()\n        })\n\n        try {\n          thisB.loadSessions()\n        } catch (e) {\n          console.error(e)\n        }\n\n        if (error) {\n          console.log(error)\n          var errors_div = dojo.byId('fatal_error_list')\n          dojo.create(\n            'div',\n            { className: 'error', innerHTML: error },\n            errors_div,\n          )\n        }\n\n        request(\n          thisB.resolveUrl('sample_data/json/volvox/successfully_run'),\n        ).then(function () {\n          try {\n            document.getElementById('volvox_data_placeholder').innerHTML =\n              'The example dataset is also available. View <a href=\"?data=sample_data/json/volvox\">Volvox test data here</a>.'\n          } catch (e) {}\n        })\n      })\n    },\n\n    /**\n     * Make sure the browser container has nonzero container dimensions.  If not,\n     * set some hardcoded dimensions and log a warning.\n     */\n    ensureNonzeroContainerDimensions() {\n      const containerWidth = this.container.offsetWidth\n      const containerHeight = this.container.offsetHeight\n      if (!containerWidth) {\n        console.warn(\n          `JBrowse container element #${this.config.containerID} has no width, please set one with CSS. Setting fallback width of 640 pixels`,\n        )\n        this.container.style.width = '640px'\n      }\n      if (!containerHeight) {\n        console.warn(\n          `JBrowse container element #${this.config.containerID} has no height, please set one with CSS. Setting fallback height of 480 pixels`,\n        )\n        this.container.style.height = '480px'\n      }\n    },\n\n    /**\n     * Main error handler.  Displays links to configuration help or a\n     * dataset selector in the main window.  Called when the main browser\n     * cannot run at all, because of configuration errors or whatever.\n     */\n    fatalError: function (error) {\n      function formatError(error) {\n        if (error) {\n          if (error.status) {\n            error =\n              error.status +\n              ' (' +\n              error.statusText +\n              ') when attempting to fetch ' +\n              error.url\n          }\n          console.error(error.stack || '' + error)\n          error = error + ''\n          if (!/\\.$/.exec(error)) {error = error + '.'}\n\n          error = dojoxHtmlEntities.encode(error)\n        }\n        return dompurify.sanitize(error)\n      }\n\n      if (!this.renderedFatalErrors) {\n        // if the error is just that there are no ref seqs defined,\n        // and there are datasets defined in the conf file, then just\n        // show a little HTML list of available datasets\n        if (\n          /^Could not load reference sequence/.test(error) &&\n          this.config.datasets &&\n          !this.config.datasets._DEFAULT_EXAMPLES\n        ) {\n          dojo.empty(this.container)\n          new StandaloneDatasetList({\n            datasets: this.config.datasets,\n          }).placeAt(this.container)\n        } else {\n          var container = this.container || document.body\n          var thisB = this\n\n          dojo.addClass(document.body, this.config.theme || 'tundra') //< tundra dijit theme\n\n          if (!Util.isElectron()) {\n            require([\n              'dojo/text!JBrowse/View/Resource/Welcome_old.html',\n            ], function (Welcome_old) {\n              container.innerHTML = Welcome_old\n              if (error) {\n                var errors_div = dojo.byId('fatal_error_list')\n                dojo.create(\n                  'div',\n                  {\n                    className: 'error',\n                    innerHTML: formatError(error) + '',\n                  },\n                  errors_div,\n                )\n              }\n              request(\n                thisB.resolveUrl('sample_data/json/volvox/successfully_run'),\n              ).then(function () {\n                try {\n                  dojo.byId('volvox_data_placeholder').innerHTML =\n                    'However, it appears you have successfully run <code>./setup.sh</code>, so you can see the <a href=\"?data=sample_data/json/volvox\">Volvox test data here</a>.'\n                } catch (e) {}\n              })\n            })\n          } else {\n            this.welcomeScreen(container, formatError(error))\n          }\n\n          this.renderedFatalErrors = true\n        }\n      } else {\n        var errors_div = dojo.byId('fatal_error_list') || document.body\n        dojo.create(\n          'div',\n          { className: 'error', innerHTML: formatError(error) + '' },\n          errors_div,\n        )\n      }\n    },\n    loadSessions: function () {\n      var fs = electronRequire('fs')\n      var app = electronRequire('electron').remote.app\n      var path = this.config.electronData + '/sessions.json'\n\n      var obj = JSON.parse(fs.readFileSync(path, 'utf8'))\n      var table = dojo.create(\n        'table',\n        {\n          id: 'previousSessionsTable',\n          style: { overflow: 'hidden', width: '90%' },\n        },\n        dojo.byId('previousSessions'),\n      )\n      var thisB = this\n\n      if (!obj.length) {\n        var tr = dojo.create('tr', {}, table)\n        dojo.create(\n          'div',\n          { innerHTML: '<ul><li>No sessions yet!</li></ul>' },\n          tr,\n        )\n      }\n      array.forEach(obj, function (session) {\n        var tr = dojo.create('tr', {}, table)\n        var url =\n          window.location.href.split('?')[0] +\n          '?data=' +\n          Util.replacePath(session.session)\n        dojo.create(\n          'div',\n          {\n            class: 'dijitIconDelete',\n            onclick: function (e) {\n              if (\n                confirm(\n                  \"This will simply delete your session from the list, it won't remove any data files. Are you sure you want to continue?\",\n                )\n              ) {\n                dojo.empty(table)\n                var index = obj.indexOf(session)\n                if (index != -1) {\n                  obj.splice(index, 1)\n                }\n                fs.writeFileSync(path, JSON.stringify(obj, null, 2), 'utf8')\n                thisB.loadSessions()\n              }\n            },\n          },\n          tr,\n        )\n        dojo.create(\n          'td',\n          {\n            innerHTML: '<a href=\"' + url + '\">' + session.session + '</a>',\n          },\n          tr,\n        )\n      })\n    },\n    loadRefSeqs: function () {\n      var thisB = this\n      return this._milestoneFunction('loadRefSeqs', function (deferred) {\n        // load our ref seqs\n        if (typeof this.config.refSeqs == 'string') {\n          // assume this.config.refSeqs is a url if it is string\n          this.config.refSeqs = {\n            url: this.config.refSeqs,\n          }\n        }\n\n        if (this.config.refSeqs.storeClass) {\n          dojo.global.require([this.config.refSeqs.storeClass], CLASS => {\n            const r = new CLASS(\n              Object.assign({ browser: this }, this.config.refSeqs),\n            )\n            r.getRefSeqs(\n              function (refSeqs) {\n                thisB.addRefseqs(refSeqs)\n                deferred.resolve({ success: true })\n              },\n              function (error) {\n                deferred.reject(error)\n              },\n            )\n          })\n        } else {\n          // check refseq urls\n          if (\n            this.config.refSeqs.url &&\n            this.config.refSeqs.url.match(/.fai$/)\n          ) {\n            new IndexedFasta({\n              browser: this,\n              faiUrlTemplate: this.config.refSeqs.url,\n            }).getRefSeqs(\n              function (refSeqs) {\n                thisB.addRefseqs(refSeqs)\n                deferred.resolve({ success: true })\n              },\n              function (error) {\n                deferred.reject(error)\n              },\n            )\n            return\n          } else if (\n            this.config.refSeqs.url &&\n            this.config.refSeqs.url.match(/.2bit$/)\n          ) {\n            new TwoBit({\n              browser: this,\n              urlTemplate: this.config.refSeqs.url,\n            }).getRefSeqs(\n              function (refSeqs) {\n                thisB.addRefseqs(refSeqs)\n                deferred.resolve({ success: true })\n              },\n              function (error) {\n                deferred.reject(error)\n              },\n            )\n          } else if (\n            this.config.refSeqs.url &&\n            (this.config.refSeqs.url.match(/.fa$/) ||\n              this.config.refSeqs.url.match(/.fasta$/))\n          ) {\n            new UnindexedFasta({\n              browser: this,\n              urlTemplate: this.config.refSeqs.url,\n            }).getRefSeqs(\n              function (refSeqs) {\n                thisB.addRefseqs(refSeqs)\n                deferred.resolve({ success: true })\n              },\n              function (error) {\n                deferred.reject(error)\n              },\n            )\n          } else if (\n            this.config.refSeqs.url &&\n            this.config.refSeqs.url.match(/.sizes/)\n          ) {\n            new ChromSizes({\n              browser: this,\n              urlTemplate: this.config.refSeqs.url,\n            }).getRefSeqs(\n              function (refSeqs) {\n                thisB.addRefseqs(refSeqs)\n                deferred.resolve({ success: true })\n              },\n              function (error) {\n                deferred.reject(error)\n              },\n            )\n          } else if ('data' in this.config.refSeqs) {\n            this.addRefseqs(this.config.refSeqs.data)\n            deferred.resolve({ success: true })\n          } else {\n            request(this.resolveUrl(this.config.refSeqs.url), {\n              handleAs: 'text',\n              headers: {\n                'X-Requested-With': null,\n              },\n            }).then(\n              function (o) {\n                thisB.addRefseqs(dojo.fromJson(o))\n                deferred.resolve({ success: true })\n              },\n              function (e) {\n                deferred.reject(\n                  'Could not load reference sequence definitions. ' + e,\n                )\n              },\n            )\n          }\n        }\n      })\n    },\n\n    loadUserCSS: function () {\n      return this._milestoneFunction('loadUserCSS', function (deferred) {\n        if (this.config.css && !lang.isArray(this.config.css))\n          {this.config.css = [this.config.css]}\n\n        var css = this.config.css || []\n        if (!css.length) {\n          deferred.resolve({ success: true })\n          return\n        }\n\n        var that = this\n        var cssDeferreds = array.map(css, function (css) {\n          return that._loadCSS(css)\n        })\n\n        new DeferredList(cssDeferreds).then(function () {\n          deferred.resolve({ success: true })\n        })\n      })\n    },\n\n    _loadCSS: function (css) {\n      var deferred = new Deferred()\n      if (typeof css == 'string') {\n        // if it has '{' in it, it probably is not a URL, but is a string of CSS statements\n        if (css.indexOf('{') > -1) {\n          dojo.create(\n            'style',\n            {\n              'data-from': 'JBrowse Config',\n              type: 'text/css',\n              innerHTML: css,\n            },\n            document.head,\n          )\n          deferred.resolve(true)\n        }\n        // otherwise, it must be a URL\n        else {\n          css = { url: css }\n        }\n      }\n      if (typeof css == 'object') {\n        LazyLoad.css(css.url, function () {\n          deferred.resolve(true)\n        })\n      }\n      return deferred\n    },\n\n    /**\n     * Load our name index.\n     */\n    loadNames: function () {\n      return this._milestoneFunction('loadNames', function (deferred) {\n        var conf = dojo.mixin(\n          dojo.clone(this.config.names || {}),\n          this.config.autocomplete || {},\n        )\n        if (!conf.url) {conf.url = this.config.nameUrl || 'data/names/'}\n\n        if (conf.baseUrl) {conf.url = Util.resolveUrl(conf.baseUrl, conf.url)}\n\n        var type\n        if ((type = conf.type)) {\n          var thisB = this\n          if (type.indexOf('/') == -1) {type = 'JBrowse/Store/Names/' + type}\n          dojo.global.require([type], function (CLASS) {\n            thisB.nameStore = new CLASS(dojo.mixin({ browser: thisB }, conf))\n            deferred.resolve({ success: true })\n          })\n        }\n        // no name type setting, must be the legacy store\n        else {\n          // wrap the older LazyTrieDojoDataStore with\n          // dojo.store.DataStore to conform with the dojo/store API\n          this.nameStore = new DojoDataStore({\n            store: new NamesLazyTrieDojoDataStore({\n              browser: this,\n              namesTrie: new LazyTrie(conf.url, 'lazy-{Chunk}.json'),\n              stopPrefixes: conf.stopPrefixes,\n              resultLimit: conf.resultLimit || 15,\n              tooManyMatchesMessage: conf.tooManyMatchesMessage,\n            }),\n          })\n          deferred.resolve({ success: true })\n        }\n      })\n    },\n\n    /**\n     * Compare two reference sequence names, returning -1, 0, or 1\n     * depending on the result.  Case insensitive, insensitive to the\n     * presence or absence of prefixes like 'chr', 'chrom', 'ctg',\n     * 'contig', 'scaffold', etc\n     */\n    compareReferenceNames: function (a, b) {\n      return this.regularizeReferenceName(a).localeCompare(\n        this.regularizeReferenceName(b),\n      )\n    },\n\n    /**\n     * Regularize the reference sequence name in a location.\n     */\n    regularizeLocation: function (location) {\n      var ref = this.findReferenceSequence(location.ref || location.objectName)\n      if (ref) {location.ref = ref.name}\n      return location\n    },\n\n    regularizeReferenceName: function (refname) {\n      if (this.config.replaceRefRename) {\n        return this.config.replaceRefRename(refname)\n      }\n      if (this.config.exactReferenceSequenceNames) {\n        return refname\n      }\n\n      refname = refname.toLowerCase()\n\n      // special case of double regularizing behaving badly\n      if (refname.match(/^chrm/)) {\n        return 'chrm'\n      }\n\n      refname = refname\n        .replace(/^chro?m?(osome)?/, 'chr')\n        .replace(/^co?n?ti?g/, 'ctg')\n        .replace(/^scaff?o?l?d?/, 'scaffold')\n        .replace(/^([a-z]*)0+/, '$1')\n        .replace(/^(\\d+l?r?|x|y)$/, 'chr$1')\n        .replace(/^(x?)(ix|iv|v?i{0,3})$/, 'chr$1$2')\n        .replace(/^mt?(dna)?$/, 'chrm')\n      if (this.config.customRefRename) {\n        refname = this.config.customRefRename(refname)\n      }\n\n      return refname\n    },\n\n    initView: function () {\n      var thisObj = this\n      return this._milestoneFunction('initView', function (deferred) {\n        //set up top nav/overview pane and main GenomeView pane\n        dojo.addClass(this.container, 'jbrowse') // browser container has an overall .jbrowse class\n        dojo.addClass(document.body, this.config.theme || 'tundra') //< tundra dijit theme\n\n        var topPane = dojo.create(\n          'div',\n          { style: { overflow: 'hidden' } },\n          this.container,\n        )\n\n        var about = this.browserMeta()\n        var aboutDialog = new InfoDialog({\n          title: 'About ' + about.title,\n          content: about.description,\n          className: 'about-dialog',\n        })\n\n        // make our top menu bar\n        var menuBar = dojo.create('div', {\n          className: this.config.show_nav ? 'menuBar' : 'topLink',\n        })\n        thisObj.menuBar = menuBar\n        if (this.config.show_menu) {\n          ;(this.config.show_nav ? topPane : this.container).appendChild(\n            menuBar,\n          )\n        }\n\n        var overview = dojo.create(\n          'div',\n          { className: 'overview', id: 'overview' },\n          topPane,\n        )\n        this.overviewDiv = overview\n        // overview=0 hides the overview, but we still need it to exist\n        if (!this.config.show_overview) {overview.style.cssText = 'display: none'}\n\n        if (Util.isElectron() && !this.config.hideGenomeOptions) {\n          this.addGlobalMenuItem(\n            this.config.classicMenu ? 'file' : 'dataset',\n            new dijitMenuItem({\n              id: 'menubar_dataset_file',\n              label: 'Open sequence file',\n              iconClass: 'dijitIconFolderOpen',\n              onClick: dojo.hitch(this, 'openFastaElectron'),\n            }),\n          )\n          this.addGlobalMenuItem(\n            this.config.classicMenu ? 'file' : 'dataset',\n            new dijitMenuItem({\n              id: 'menubar_dataset_directory',\n              label: 'Open data directory',\n              iconClass: 'dijitIconFolderOpen',\n              onClick: function () {\n                new OpenDirectoryDialog({\n                  browser: thisObj,\n                  setCallback: dojo.hitch(thisObj, 'openDirectoryElectron'),\n                }).show()\n              },\n            }),\n          )\n          this.addGlobalMenuItem(\n            this.config.classicMenu ? 'file' : 'dataset',\n            new dijitMenuItem({\n              id: 'menubar_dataset_save',\n              label: 'Save session',\n              iconClass: 'dijitIconSave',\n              onClick: dojo.hitch(this, 'saveData'),\n            }),\n          )\n          this.addGlobalMenuItem(\n            this.config.classicMenu ? 'file' : 'dataset',\n            new dijitMenuItem({\n              id: 'menubar_dataset_home',\n              label: 'Return to main menu',\n              iconClass: 'dijitIconTask',\n              onClick: dojo.hitch(this, function () {\n                var container = thisObj.container || document.body\n                thisObj.welcomeScreen(container)\n              }),\n            }),\n          )\n        } else if (!this.config.hideGenomeOptions) {\n          this.addGlobalMenuItem(\n            this.config.classicMenu ? 'file' : 'dataset',\n            new dijitMenuItem({\n              id: 'menubar_dataset_open',\n              label: 'Open sequence file',\n              iconClass: 'dijitIconFolderOpen',\n              onClick: dojo.hitch(this, 'openFasta'),\n            }),\n          )\n        }\n\n        if (this.config.show_nav) {\n          this.navbox = this.createNavBox(topPane)\n\n          // make the dataset menu\n          if (this.config.classicMenu) {\n            if (this.config.datasets && !this.config.dataset_id) {\n              console.warn(\n                'In JBrowse configuration, datasets specified, but dataset_id not set.  Dataset selector will not be shown.',\n              )\n            }\n            if (this.config.datasets && this.config.dataset_id) {\n              this.renderDatasetSelect(menuBar)\n            } else {\n              this.poweredByLink = dojo.create(\n                'a',\n                {\n                  className: 'powered_by',\n                  innerHTML: this.browserMeta().title,\n                  title: 'powered by JBrowse',\n                },\n                menuBar,\n              )\n              thisObj.poweredBy_clickHandle = dojo.connect(\n                this.poweredByLink,\n                'onclick',\n                dojo.hitch(aboutDialog, 'show'),\n              )\n            }\n          } else {this.renderDatasetSelect(menuBar)}\n\n          // make the file menu\n          this.addGlobalMenuItem(\n            'file',\n            new dijitMenuItem({\n              id: 'menubar_fileopen',\n              label: 'Open track file or URL',\n              iconClass: 'dijitIconFolderOpen',\n              onClick: dojo.hitch(this, 'openFileDialog'),\n            }),\n          )\n\n          this.addGlobalMenuItem('file', new dijitMenuSeparator())\n\n          this.fileDialog = new FileDialog({ browser: this })\n\n          this.addGlobalMenuItem(\n            'file',\n            new dijitMenuItem({\n              id: 'menubar_combotrack',\n              label: 'Add combination track',\n              iconClass: 'dijitIconSample',\n              onClick: dojo.hitch(this, 'createCombinationTrack'),\n            }),\n          )\n\n          this.renderGlobalMenu(\n            'file',\n            { text: this.config.classicMenu ? 'File' : 'Track' },\n            menuBar,\n          )\n\n          // make the view menu\n          this.addGlobalMenuItem(\n            'view',\n            new dijitMenuItem({\n              id: 'menubar_sethighlight',\n              label: 'Set highlight',\n              iconClass: 'dijitIconFilter',\n              onClick: function () {\n                new SetHighlightDialog({\n                  browser: thisObj,\n                  setCallback: dojo.hitch(thisObj, 'setHighlightAndRedraw'),\n                }).show()\n              },\n            }),\n          )\n          // make the menu item for clearing the current highlight\n          this._highlightClearButton = new dijitMenuItem({\n            id: 'menubar_clearhighlight',\n            label: 'Clear highlight',\n            iconClass: 'dijitIconFilter',\n            onClick: dojo.hitch(this, function () {\n              var h = this.getHighlight()\n              if (h) {\n                this.clearHighlight()\n                this.view.redrawRegion(h)\n              }\n            }),\n          })\n          this._updateHighlightClearButton() //< sets the label and disabled status\n          // update it every time the highlight changes\n          this.subscribe(\n            '/jbrowse/v1/n/globalHighlightChanged',\n            dojo.hitch(this, '_updateHighlightClearButton'),\n          )\n\n          this.addGlobalMenuItem('view', this._highlightClearButton)\n\n          // add a global menu item for resizing all visible quantitative tracks\n          this.addGlobalMenuItem(\n            'view',\n            new dijitMenuItem({\n              label: 'Resize quant. tracks',\n              id: 'menubar_settrackheight',\n              title: 'Set all visible quantitative tracks to a new height',\n              iconClass: 'jbrowseIconVerticalResize',\n              onClick: function () {\n                new SetTrackHeightDialog({\n                  setCallback: function (height) {\n                    var tracks = thisObj.view.visibleTracks()\n                    array.forEach(tracks, function (track) {\n                      // operate only on XYPlot or Density tracks\n                      if (!/\\b(XYPlot|Density)/.test(track.config.type)) {return}\n\n                      track.trackHeightChanged = true\n                      track.updateUserStyles({\n                        height: height,\n                      })\n                    })\n                  },\n                }).show()\n              },\n            }),\n          )\n\n          if (!this.config.disableSearch) {\n            this.addGlobalMenuItem(\n              'view',\n              new dijitMenuItem({\n                label: 'Search features',\n                id: 'menubar_search',\n                title: 'Search for features',\n                onClick: () => {\n                  var conf = dojo.mixin(\n                    dojo.clone(this.config.names || {}),\n                    this.config.autocomplete || {},\n                  )\n\n                  var type = conf.dialog || 'JBrowse/View/Dialog/Search'\n                  dojo.global.require([type], CLASS => {\n                    new CLASS(dojo.mixin({ browser: this }, conf)).show()\n                  })\n                },\n              }),\n            )\n          }\n\n          if (!this.config.disableReset) {\n            this.addGlobalMenuItem(\n              'view',\n              new dijitMenuItem({\n                label: 'Reset to defaults',\n                id: 'menubar_reset_button',\n                title: 'Reset view and tracks to defaults',\n\n                onClick: () => {\n                  // resets zoom and location to default\n                  thisObj.navigateToLocation({\n                    ref: thisObj.refSeq.name,\n                    start: 0.4 * (thisObj.refSeq.start + thisObj.refSeq.end),\n                    end: 0.6 * (thisObj.refSeq.start + thisObj.refSeq.end),\n                  })\n\n                  // hide all tracks\n                  thisObj.publish(\n                    '/jbrowse/v1/v/tracks/hide',\n                    thisObj.config.tracks,\n                  )\n\n                  let tracksToShow = []\n\n                  // the below code mainly follows the code that decides the default tracks in the constructor,\n                  // but it's different enough that it doesn't easily make a reusable function. Good idea for future refactor?\n\n                  // always add alwaysOnTracks, regardless of any other track params\n                  if (thisObj.config.alwaysOnTracks) {\n                    tracksToShow = tracksToShow.concat(\n                      thisObj.config.alwaysOnTracks.split(','),\n                    )\n                  }\n                  if (tracksToShow.length == 0) {\n                    tracksToShow.push('DNA')\n                  }\n                  if (thisObj.config.defaultTracks) {\n                    // In rare cases thisObj.config.defaultTracks already contained an array that appeared to\n                    // have been split in a previous invocation of this function. Thus, we only try and split\n                    // it if it isn't already split.\n                    if (!(thisObj.config.defaultTracks instanceof Array)) {\n                      tracksToShow = tracksToShow.concat(\n                        thisObj.config.defaultTracks.split(','),\n                      )\n                    }\n                  }\n                  tracksToShow = Util.uniq(tracksToShow)\n\n                  thisObj.showTracks(tracksToShow)\n                },\n              }),\n            )\n          }\n\n          this.renderGlobalMenu('view', { text: 'View' }, menuBar)\n\n          // make the options menu\n          this.renderGlobalMenu(\n            'options',\n            { text: 'Options', title: 'configure JBrowse' },\n            menuBar,\n          )\n        }\n        function showHelp() {\n          new HelpDialog(\n            lang.mixin(thisObj.config.quickHelp || {}, {\n              browser: thisObj,\n            }),\n          ).show()\n        }\n        if (this.config.show_nav) {\n          // make the help menu\n          this.addGlobalMenuItem(\n            'help',\n            new dijitMenuItem({\n              id: 'menubar_about',\n              label: 'About',\n              //iconClass: 'dijitIconFolderOpen',\n              onClick: dojo.hitch(aboutDialog, 'show'),\n            }),\n          )\n\n          this.setGlobalKeyboardShortcut('?', showHelp)\n          this.addGlobalMenuItem(\n            'help',\n            new dijitMenuItem({\n              id: 'menubar_generalhelp',\n              label: 'General',\n              iconClass: 'jbrowseIconHelp',\n              onClick: showHelp,\n            }),\n          )\n\n          this.renderGlobalMenu('help', {}, menuBar)\n\n          if (!this.config.classicMenu) {\n            let datasetName = lang.getObject(\n              `config.datasets.${this.config.dataset_id}.name`,\n              false,\n              this,\n            )\n            this.menuBarDatasetName = dojo.create(\n              'div',\n              {\n                className: 'dataset-name',\n                innerHTML: datasetName,\n                title: 'name of current dataset',\n                style: {\n                  display: datasetName ? 'inline-block' : 'none',\n                },\n              },\n              menuBar,\n            )\n          }\n        }\n\n        if (\n          this.config.show_nav &&\n          this.config.show_tracklist &&\n          this.config.show_overview &&\n          !Util.isElectron()\n        ) {\n          var shareLink = this.makeShareLink()\n          if (shareLink) {\n            menuBar.appendChild(shareLink)\n          }\n        } else if (Util.isElectron()) {\n          var snapLink = this.makeSnapLink()\n          if (snapLink) {\n            menuBar.appendChild(snapLink)\n          }\n        } else {\n          if (this.config.show_fullviewlink)\n            {menuBar.appendChild(this.makeFullViewLink())}\n        }\n\n        this.viewElem = document.createElement('div')\n        this.viewElem.className = 'dragWindow'\n        this.container.appendChild(this.viewElem)\n\n        this.containerWidget = new dijitBorderContainer(\n          {\n            liveSplitters: false,\n            design: 'sidebar',\n            gutters: false,\n          },\n          this.container,\n        )\n        var contentWidget = new dijitContentPane({ region: 'top' }, topPane)\n\n        // hook up GenomeView\n        this.view = this.viewElem.view = new GenomeView({\n          browser: this,\n          elem: this.viewElem,\n          config: this.config.view,\n          stripeWidth: 250,\n          refSeq: this.refSeq,\n        })\n\n        dojo.connect(this.view, 'onFineMove', this, 'onFineMove')\n        dojo.connect(this.view, 'onCoarseMove', this, 'onCoarseMove')\n\n        this.browserWidget = new dijitContentPane(\n          { region: 'center' },\n          this.viewElem,\n        )\n        dojo.connect(this.browserWidget, 'resize', this, 'onResize')\n        dojo.connect(this.browserWidget, 'resize', this.view, 'onResize')\n\n        //connect events to update the URL in the location bar\n        function updateLocationBar() {\n          var shareURL = thisObj.makeCurrentViewURL()\n          if (\n            thisObj.config.updateBrowserURL &&\n            window.history &&\n            window.history.replaceState\n          )\n            {window.history.replaceState({}, '', shareURL)}\n          if (thisObj.config.update_browser_title)\n            {document.title =\n              thisObj.browserMeta().title +\n              ' ' +\n              thisObj.view.visibleRegionLocString()}\n        }\n        dojo.connect(this, 'onCoarseMove', updateLocationBar)\n        this.subscribe('/jbrowse/v1/n/tracks/visibleChanged', updateLocationBar)\n        this.subscribe(\n          '/jbrowse/v1/n/globalHighlightChanged',\n          updateLocationBar,\n        )\n\n        //set initial location\n        this.afterMilestone(\n          'loadRefSeqs',\n          dojo.hitch(this, function () {\n            this.afterMilestone(\n              'initTrackMetadata',\n              dojo.hitch(this, function () {\n                this.createTrackList().then(\n                  dojo.hitch(this, function () {\n                    this.containerWidget.startup()\n                    this.onResize()\n\n                    // make our global keyboard shortcut handler\n                    on(\n                      document.body,\n                      'keypress',\n                      dojo.hitch(this, 'globalKeyHandler'),\n                    )\n\n                    // configure our event routing\n                    this._initEventRouting()\n\n                    // done with initView\n                    deferred.resolve({ success: true })\n                  }),\n                )\n              }),\n            )\n          }),\n        )\n      })\n    },\n\n    createCombinationTrack: function () {\n      if (this._combinationTrackCount === undefined)\n        {this._combinationTrackCount = 0}\n      var d = new Deferred()\n      var storeConf = {\n        browser: this,\n        refSeq: this.refSeq,\n        type: 'JBrowse/Store/SeqFeature/Combination',\n      }\n      var storeName = this.addStoreConfig(undefined, storeConf)\n      storeConf.name = storeName\n      this.getStore(storeName, function (store) {\n        d.resolve(true)\n      })\n      var thisB = this\n      d.promise.then(function () {\n        var combTrackConfig = {\n          type: 'JBrowse/View/Track/Combination',\n          label: 'combination_track' + thisB._combinationTrackCount++,\n          key: 'Combination Track ' + thisB._combinationTrackCount,\n          metadata: {\n            Description:\n              'Drag-and-drop interface that creates a track out of combinations of other tracks.',\n          },\n          store: storeName,\n        }\n        // send out a message about how the user wants to create the new tracks\n        thisB.publish('/jbrowse/v1/v/tracks/new', [combTrackConfig])\n\n        // Open the track immediately\n        thisB.publish('/jbrowse/v1/v/tracks/show', [combTrackConfig])\n      })\n    },\n\n    renderDatasetSelect: function (parent) {\n      var thisB = this\n\n      if (this.config.classicMenu) {\n        var dsconfig = this.config.datasets || {}\n        var datasetChoices = []\n        for (var id in dsconfig) {\n          if (!/^_/.test(id))\n            {datasetChoices.push(Object.assign({ id: id }, dsconfig[id]))}\n        }\n\n        const combobox = new dijitComboBox({\n          name: 'dataset',\n          className: 'dataset_select',\n          value: this.config.datasets[this.config.dataset_id].name,\n          store: new dojoMemoryStore({\n            data: datasetChoices,\n          }),\n          onChange: dsName => {\n            if (!dsName) {return false}\n            const dsID = datasetChoices.find(d => d.name === dsName).id\n            const ds = (this.config.datasets || {})[dsID]\n            let conf = this.config\n            if (ds) {\n              let link2Parent = conf.datasetLinkToParentIframe || false\n              if (link2Parent) {window.parent.location = ds.url}\n              else {window.location = ds.url}\n            }\n            return false\n          },\n        })\n        combobox.placeAt(parent)\n        combobox.focusNode.onclick = function () {\n          this.select()\n        }\n        if (this.config.datasetSelectorWidth) {\n          combobox.domNode.style.width = this.config.datasetSelectorWidth\n          combobox.focusNode.style.width = this.config.datasetSelectorWidth\n        }\n      } else {\n        let conf = this.config\n        if (this.config.datasets && this.config.dataset_id) {\n          this.addGlobalMenuItem('dataset', new dijitMenuSeparator())\n\n          for (var id in this.config.datasets) {\n            if (!/^_/.test(id)) {\n              var dataset = this.config.datasets[id]\n\n              this.addGlobalMenuItem(\n                'dataset',\n                new dijitMenuItem({\n                  id: 'menubar_dataset_bookmark_' + id,\n                  label:\n                    id == this.config.dataset_id\n                      ? '<b>' + dataset.name + '</b>'\n                      : dataset.name,\n                  iconClass: 'dijitIconBookmark',\n                  onClick: dojo.hitch(dataset, function () {\n                    // if datasetLinkToParentIframe=true, link to parent of iframe.\n                    let link2Parent = conf.datasetLinkToParentIframe || false\n                    if (link2Parent) {window.parent.location = this.url}\n                    else {window.location = this.url}\n                  }),\n                }),\n              )\n            }\n          }\n        }\n        this.renderGlobalMenu('dataset', { text: 'Genome' }, parent)\n      }\n    },\n\n    saveSessionDir: function (directory) {\n      var fs = electronRequire('fs')\n      var path = this.config.electronData + '/sessions.json'\n      var obj = []\n\n      try {\n        var obj = JSON.parse(fs.readFileSync(path, 'utf8'))\n      } catch (e) {\n        console.error(e)\n      }\n\n      var dir = Util.replacePath(directory)\n      if (\n        array.every(obj, function (elt) {\n          return elt.session != dir\n        })\n      )\n        {obj.push({ session: dir })}\n\n      fs.writeFileSync(path, JSON.stringify(obj, null, 2), 'utf8')\n    },\n\n    openDirectoryElectron: function (directory) {\n      this.saveSessionDir(directory)\n      window.location = '?data=' + Util.replacePath(directory)\n    },\n\n    openConfig: function (plugins) {\n      if (\n        !confirm(\n          'If you have opened any new tracks, please save them before continuing. Are you sure you want to continue?',\n        )\n      )\n        {return}\n      var fs = electronRequire('fs')\n\n      var dir = this.config.dataRoot\n      var trackList = JSON.parse(\n        fs.readFileSync(dir + '/trackList.json', 'utf8'),\n      )\n\n      //remap existing plugins to object form\n      trackList.plugins = trackList.plugins || {}\n      if (lang.isArray(trackList.plugins)) {\n        var temp = {}\n        array.forEach(trackList.plugins, function (p) {\n          temp[p] = { name: p, location: dir + '/' + p }\n        })\n        trackList.plugins = temp\n      }\n\n      // add new plugins\n      array.forEach(plugins, function (plugin) {\n        var name = plugin.match(/\\/(\\w+)$/)[1]\n        trackList.plugins[name] = { location: plugin, name: name }\n      })\n\n      try {\n        fs.writeFileSync(\n          dir + '/trackList.json',\n          JSON.stringify(trackList, null, 2),\n        )\n      } catch (e) {\n        console.error('Failed to save trackList.json', e)\n      }\n      window.location.reload()\n    },\n\n    saveData: function () {\n      if (\n        !confirm(\n          'This will overwrite tracks and config data in your data directory. Are you sure you want to continue?',\n        )\n      )\n        {return}\n\n      var fs = electronRequire('fs')\n      var dir = this.config.dataRoot\n\n      // use getstore to access the files that were loaded from local files, and create standard configs\n      var trackConfs = array.map(\n        this.config.tracks,\n        function (trackConfig) {\n          var temp = lang.clone(trackConfig)\n          this.getStore(\n            temp.store,\n            lang.hitch(this, function (obj) {\n              temp.storeClass = obj.config.type\n              if (!temp.urlTemplate) {\n                lang.mixin(temp, obj.saveStore())\n\n                if (temp.histograms && temp.histograms.store) {\n                  this.getStore(temp.histograms.store, function (obj) {\n                    lang.mixin(temp.histograms, obj.saveStore())\n                  })\n                }\n              }\n              delete temp.store\n            }),\n          )\n          return temp\n        },\n        this,\n      )\n\n      var plugins = array.filter(\n        Util.uniq(this.config.plugins),\n        function (elt) {\n          return elt != 'RegexSequenceSearch'\n        },\n      )\n      var tmp = {}\n\n      if (lang.isArray(this.config.plugins)) {\n        array.forEach(this.config.plugins, function (p) {\n          tmp[p] = typeof p == 'object' ? p : { name: p }\n        })\n      } else {tmp = this.config.plugins}\n      var minTrackList = {\n        tracks: trackConfs,\n        refSeqs: this.config.refSeqs,\n        refSeqOrder: this.config.refSeqOrder,\n        plugins: tmp,\n      }\n      try {\n        fs.writeFileSync(\n          Util.unReplacePath(dir) + '/trackList.json',\n          JSON.stringify(minTrackList, null, 2),\n        )\n      } catch (e) {\n        alert('Unable to save track data')\n        console.error(e)\n      }\n    },\n\n    openFastaElectron: function () {\n      this.fastaFileDialog =\n        this.fastaFileDialog || new FastaFileDialog({ browser: this })\n\n      var app = electronRequire('electron').remote.app\n      var fs = electronRequire('fs')\n      var path = electronRequire('path')\n\n      this.fastaFileDialog.show({\n        openCallback: dojo.hitch(this, function (results) {\n          var confs = results.trackConfs || []\n          if (confs.length) {\n            var trackList = {\n              tracks: [\n                {\n                  label: confs[0].label,\n                  key: confs[0].key,\n                  type: 'SequenceTrack',\n                  category: 'Reference sequence',\n                  useAsRefSeqStore: true,\n                  chunkSize: 20000,\n                },\n              ],\n              refSeqs: fai,\n              refSeqOrder: results.refSeqOrder,\n            }\n\n            if (\n              confs[0].store.bgzfa &&\n              confs[0].store.fai &&\n              confs[0].store.gzi\n            ) {\n              var fasta = Util.replacePath(confs[0].store.bgzfa.url)\n              var fai = Util.replacePath(confs[0].store.fai.url)\n              var gzi = Util.replacePath(confs[0].store.gzi.url)\n              trackList.tracks[0].storeClass =\n                'JBrowse/Store/SeqFeature/BgzipIndexedFasta'\n              trackList.tracks[0].urlTemplate = fasta\n              trackList.tracks[0].faiUrlTemplate = fai\n              trackList.tracks[0].gziUrlTemplate = gzi\n              trackList.refSeqs = {\n                faiUrlTemplate: fai,\n                storeClass: 'JBrowse/Store/SeqFeature/BgzipIndexedFasta',\n                gziUrlTemplate: gzi,\n              }\n            } else if (confs[0].store.fasta && confs[0].store.fai) {\n              var fasta = Util.replacePath(confs[0].store.fasta.url)\n              var fai = Util.replacePath(confs[0].store.fai.url)\n              trackList.tracks[0].storeClass =\n                'JBrowse/Store/SeqFeature/IndexedFasta'\n              trackList.tracks[0].urlTemplate = fasta\n              trackList.tracks[0].faiUrlTemplate = fai\n              trackList.refSeqs = {\n                faiUrlTemplate: fai,\n                storeClass: 'JBrowse/Store/SeqFeature/IndexedFasta',\n              }\n            } else if (\n              confs[0].store.type == 'JBrowse/Store/SeqFeature/TwoBit'\n            ) {\n              var f2bit = Util.replacePath(confs[0].store.blob.url)\n              trackList.tracks[0].storeClass = 'JBrowse/Store/SeqFeature/TwoBit'\n              trackList.tracks[0].urlTemplate = f2bit\n              trackList.refSeqs = f2bit\n              trackList.refSeqs = {\n                urlTemplate: f2bit,\n                storeClass: 'JBrowse/Store/SeqFeature/TwoBit',\n              }\n            } else if (\n              confs[0].store.type == 'JBrowse/Store/SeqFeature/ChromSizes'\n            ) {\n              var sizes = Util.replacePath(confs[0].store.blob.url)\n              delete trackList.tracks\n              trackList.refSeqs = sizes\n              trackList.refSeqs = {\n                urlTemplate: sizes,\n                storeClass: 'JBrowse/Store/SeqFeature/ChromSizes',\n              }\n            } else {\n              var fasta = Util.replacePath(confs[0].store.fasta.url)\n              try {\n                var stats = fs.statSync(fasta)\n                if (stats.size > 100000000) {\n                  alert(\n                    'Unindexed file too large. You must have an index file (.fai) for sequence files larger than 100 MB.',\n                  )\n                  return\n                }\n              } catch (e) {\n                console.error(e)\n              }\n              trackList.tracks[0].storeClass =\n                'JBrowse/Store/SeqFeature/UnindexedFasta'\n              trackList.tracks[0].urlTemplate = fasta\n              trackList.refSeqs = {\n                urlTemplate: fasta,\n                storeClass: 'JBrowse/Store/SeqFeature/UnindexedFasta',\n              }\n            }\n\n            // fix dir to be user data if we are accessing a url for fasta\n            var dir = this.config.electronData\n            fs.existsSync(dir) || fs.mkdirSync(dir) // make base folder exist first before subdir\n            dir += '/' + confs[0].label\n\n            try {\n              fs.existsSync(dir) || fs.mkdirSync(dir)\n              fs.writeFileSync(\n                dir + '/trackList.json',\n                JSON.stringify(trackList, null, 2),\n              )\n              fs.closeSync(fs.openSync(dir + '/tracks.conf', 'w'))\n              this.saveSessionDir(dir)\n              window.location =\n                window.location.href.split('?')[0] +\n                '?data=' +\n                Util.replacePath(dir)\n            } catch (e) {\n              alert('Failed to save session')\n              console.error(e)\n            }\n          }\n        }),\n      })\n    },\n\n    openFasta: function () {\n      this.fastaFileDialog =\n        this.fastaFileDialog || new FastaFileDialog({ browser: this })\n\n      this.fastaFileDialog.show({\n        openCallback: results => {\n          return new Promise((resolve, reject) => {\n            const trackConfigs = results.trackConfs || []\n            const [conf] = trackConfigs\n            if (!conf) {return reject('no track configs')}\n            const storeConf = conf.store\n            if (!storeConf) {return reject('no store config')}\n\n            dojo.global.require([storeConf.type], storeClass => {\n              if (\n                /\\/Unindexed/i.test(storeConf.type) &&\n                storeConf.fasta &&\n                storeConf.fasta.size > 100000000\n              ) {\n                alert(\n                  'Unindexed file too large. You must have an index file (.fai) for sequence files larger than 100 MB.',\n                )\n                return reject('sequence file too large')\n              }\n\n              const store = new storeClass(\n                Object.assign({ browser: this }, storeConf),\n              ).getRefSeqs(\n                refSeqs => {\n                  this.teardown()\n                  var newBrowser = new this.constructor({\n                    refSeqs: { data: refSeqs },\n                    refSeqOrder: results.refSeqOrder,\n                    dataRoot: null,\n                  })\n                  newBrowser.afterMilestone('completely initialized', () => {\n                    storeConf.name = 'refseqs' // important to make it the refseq store\n                    newBrowser.addStoreConfig(storeConf.name, storeConf)\n                    conf.store = 'refseqs'\n                    if (\n                      storeConf.type !== 'JBrowse/Store/SeqFeature/ChromSizes'\n                    ) {\n                      newBrowser.publish('/jbrowse/v1/v/tracks/new', [conf])\n                    }\n                  })\n                  resolve()\n                },\n                error => {\n                  this.fatalError('Error getting refSeq: ' + error)\n                  reject(error)\n                },\n              )\n            })\n          })\n        },\n      })\n    },\n\n    /**\n     * Get object like { title: \"title\", description: \"description\", ... }\n     * that contains metadata describing this browser.\n     */\n    browserMeta: function () {\n      var about = this.config.aboutThisBrowser || {}\n      about.title = about.title || 'JBrowse'\n\n      var verstring = this.version\n\n      if (about.description) {\n        about.description +=\n          '<div class=\"powered_by\">' +\n          'Powered by <a target=\"_blank\" href=\"http://jbrowse.org\">JBrowse ' +\n          verstring +\n          '</a>.' +\n          '</div>'\n      } else {\n        about.description =\n          '<div class=\"default_about\">' +\n          '  <img class=\"logo\" src=\"' +\n          this.resolveUrl('img/JBrowseLogo_small.png') +\n          '\">' +\n          '  <h1>JBrowse ' +\n          verstring +\n          '</h1>' +\n          '  <div class=\"tagline\">A next-generation genome browser<br> built with JavaScript and HTML5.</div>' +\n          '  <a class=\"mainsite\" target=\"_blank\" href=\"http://jbrowse.org\">JBrowse website</a>' +\n          '  <div class=\"gmod\">JBrowse is a <a target=\"_blank\" href=\"http://gmod.org\">GMOD</a> project.</div>' +\n          '  <div class=\"copyright\">' +\n          packagejson.copyright +\n          '</div>' +\n          (Object.keys(this.plugins).length > 1 &&\n          !this.config.noPluginsForAboutBox\n            ? '  <div class=\"loaded-plugins\">Loaded plugins<ul class=\"plugins-list\">' +\n              array\n                .map(\n                  Object.keys(this.plugins),\n                  function (elt) {\n                    var p = this.plugins[elt]\n                    return (\n                      '<li>' +\n                      (p.url ? '<a href=\"' + p.url + '\">' : '') +\n                      p.name +\n                      (p.url ? '</a>' : '') +\n                      (p.author ? ' (' + p.author + ')' : '') +\n                      '</li>'\n                    )\n                  },\n                  this,\n                )\n                .join('') +\n              '  </ul></div>'\n            : '') +\n          '</div>'\n      }\n      return about\n    },\n\n    /**\n     * Track type registry, used by GUI elements that need to offer\n     * options regarding selecting track types.  Can register a track\n     * type, and get the data structure describing what track types are\n     * known.\n     */\n    registerTrackType: function (args) {\n      var types = this.getTrackTypes()\n      var typeName = args.type\n      var defaultFor = args.defaultForStoreTypes || []\n      var humanLabel = args.label\n\n      // add it to known track types\n      types.knownTrackTypes.push(typeName)\n\n      // add its label\n      if (args.label) {types.trackTypeLabels[typeName] = args.label}\n\n      // uniqify knownTrackTypes\n      var seen = {}\n      types.knownTrackTypes = array.filter(\n        types.knownTrackTypes,\n        function (type) {\n          var s = seen[type]\n          seen[type] = true\n          return !s\n        },\n      )\n\n      // set it as default for the indicated types, if any\n      array.forEach(defaultFor, function (storeName) {\n        types.trackTypeDefaults[storeName] = typeName\n      })\n\n      // store the whole structure in this object\n      this._knownTrackTypes = types\n    },\n    getTrackTypes: function () {\n      // create the default types if necessary\n      if (!this._knownTrackTypes)\n        {this._knownTrackTypes = {\n          // map of store type -> default track type to use for the store\n          trackTypeDefaults: {\n            'JBrowse/Store/SeqFeature/BAM': 'JBrowse/View/Track/Alignments2',\n            'JBrowse/Store/SeqFeature/CRAM': 'JBrowse/View/Track/Alignments2',\n            'JBrowse/Store/SeqFeature/NCList':\n              'JBrowse/View/Track/CanvasFeatures',\n            'JBrowse/Store/SeqFeature/BigWig':\n              'JBrowse/View/Track/Wiggle/XYPlot',\n            'JBrowse/Store/SeqFeature/VCFTabix':\n              'JBrowse/View/Track/CanvasVariants',\n            'JBrowse/Store/SeqFeature/VCFTribble':\n              'JBrowse/View/Track/CanvasVariants',\n            'JBrowse/Store/SeqFeature/GFF3':\n              'JBrowse/View/Track/CanvasFeatures',\n            'JBrowse/Store/SeqFeature/BigBed':\n              'JBrowse/View/Track/CanvasFeatures',\n            'JBrowse/Store/SeqFeature/GFF3Tabix':\n              'JBrowse/View/Track/CanvasFeatures',\n            'JBrowse/Store/SeqFeature/BED': 'JBrowse/View/Track/CanvasFeatures',\n            'JBrowse/Store/SeqFeature/BEDTabix':\n              'JBrowse/View/Track/CanvasFeatures',\n            'JBrowse/Store/SeqFeature/GTF': 'JBrowse/View/Track/CanvasFeatures',\n            'JBrowse/Store/SeqFeature/StaticChunked':\n              'JBrowse/View/Track/Sequence',\n            'JBrowse/Store/SeqFeature/UnindexedFasta':\n              'JBrowse/View/Track/Sequence',\n            'JBrowse/Store/SeqFeature/IndexedFasta':\n              'JBrowse/View/Track/Sequence',\n            'JBrowse/Store/SeqFeature/BgzipIndexedFasta':\n              'JBrowse/View/Track/Sequence',\n            'JBrowse/Store/SeqFeature/TwoBit': 'JBrowse/View/Track/Sequence',\n          },\n\n          knownTrackTypes: [\n            'JBrowse/View/Track/Alignments',\n            'JBrowse/View/Track/Alignments2',\n            'JBrowse/View/Track/FeatureCoverage',\n            'JBrowse/View/Track/SNPCoverage',\n            'JBrowse/View/Track/HTMLFeatures',\n            'JBrowse/View/Track/CanvasFeatures',\n            'JBrowse/View/Track/HTMLVariants',\n            'JBrowse/View/Track/CanvasVariants',\n            'JBrowse/View/Track/Wiggle/XYPlot',\n            'JBrowse/View/Track/Wiggle/Density',\n            'JBrowse/View/Track/Sequence',\n          ],\n\n          trackTypeLabels: {},\n        }}\n\n      return this._knownTrackTypes\n    },\n\n    openFileDialog: function () {\n      this.fileDialog.show({\n        openCallback: dojo.hitch(this, function (results) {\n          var confs = results.trackConfs || []\n          if (confs.length) {\n            // tuck away each of the store configurations in\n            // our store configuration, and replace them with\n            // their names.\n            array.forEach(\n              confs,\n              function (conf) {\n                // do it for conf.store\n                var storeConf = conf.store\n                if (storeConf && typeof storeConf == 'object') {\n                  delete conf.store\n                  var name = this.addStoreConfig(storeConf.name, storeConf)\n                  conf.store = name\n                }\n\n                // do it for conf.histograms.store, if it exists\n                storeConf = conf.histograms && conf.histograms.store\n                if (storeConf && typeof storeConf == 'object') {\n                  delete conf.histograms.store\n                  var name = this.addStoreConfig(storeConf.name, storeConf)\n                  conf.histograms.store = name\n                }\n              },\n              this,\n            )\n\n            // send out a message about how the user wants to create the new tracks\n            this.publish('/jbrowse/v1/v/tracks/new', confs)\n\n            // if requested, send out another message that the user wants to show them\n            if (results.trackDisposition == 'openImmediately')\n              {this.publish('/jbrowse/v1/v/tracks/show', confs)}\n          }\n        }),\n      })\n    },\n\n    addTracks: function (confs) {\n      // just register the track configurations right now\n      this._addTrackConfigs(confs)\n    },\n    replaceTracks: function (confs) {\n      // just add-or-replace the track configurations\n      this._replaceTrackConfigs(confs)\n    },\n    deleteTracks: function (confs) {\n      // de-register the track configurations\n      this._deleteTrackConfigs(confs)\n    },\n\n    renderGlobalMenu: function (menuName, args, parent) {\n      this.afterMilestone(\n        'initView',\n        function () {\n          var menu = this.makeGlobalMenu(menuName)\n          if (menu) {\n            args = dojo.mixin(\n              {\n                className: menuName,\n                innerHTML:\n                  '<span class=\"icon\"></span> ' +\n                  (args.text || Util.ucFirst(menuName)),\n                dropDown: menu,\n                id: 'dropdownbutton_' + menuName,\n              },\n              args || {},\n            )\n\n            var menuButton = new dijitDropDownButton(args)\n            dojo.addClass(menuButton.domNode, 'menu')\n            parent.appendChild(menuButton.domNode)\n          }\n        },\n        this,\n      )\n    },\n\n    makeGlobalMenu: function (menuName) {\n      var items = (this._globalMenuItems || {})[menuName] || []\n      if (!items.length) {return null}\n\n      var menu = new dijitDropDownMenu({\n        id: 'dropdownmenu_' + menuName,\n        leftClickToOpen: true,\n      })\n      dojo.forEach(items, function (item) {\n        menu.addChild(item)\n      })\n      dojo.addClass(menu.domNode, 'jbrowse globalMenu')\n      dojo.addClass(menu.domNode, menuName)\n      menu.startup()\n      return menu\n    },\n\n    addGlobalMenuItem: function (menuName, item) {\n      if (!this._globalMenuItems) {this._globalMenuItems = {}}\n      if (!this._globalMenuItems[menuName]) {this._globalMenuItems[menuName] = []}\n      this._globalMenuItems[menuName].push(item)\n    },\n\n    /**\n     * Initialize our message routing, subscribing to messages, forwarding\n     * them around, and so forth.\n     *\n     * \"v\" (view)\n     *   Requests from the user.  These go only to the browser, which is\n     *   the central point forx deciding what to do about them.  This is\n     *   usually just forwarding the command as one or more \"c\" messages.\n     *\n     * \"c\" (command)\n     *   Commands from authority, like the Browser object.  These cause\n     *   things to actually happen in the UI: things to be shown or\n     *   hidden, actions taken, and so forth.\n     *\n     * \"n\" (notification)\n     *   Notification that something just happened.\n     *\n     * @private\n     */\n    _initEventRouting: function () {\n      var that = this\n\n      that.subscribe('/jbrowse/v1/v/store/new', function (storeConfigs) {\n        array.forEach(storeConfigs, function (storeConfig) {\n          storeConfig = lang.mixin({}, storeConfig)\n          var name = storeConfig.name\n          delete storeConfig.name\n          that.addStoreConfig(name, storeConfig)\n        })\n      })\n\n      that.subscribe('/jbrowse/v1/v/tracks/hide', function (trackConfigs) {\n        that.publish('/jbrowse/v1/c/tracks/hide', trackConfigs)\n      })\n      that.subscribe('/jbrowse/v1/v/tracks/show', function (trackConfigs) {\n        that.addRecentlyUsedTracks(\n          dojo.map(trackConfigs, function (c) {\n            return c.label\n          }),\n        )\n        that.publish('/jbrowse/v1/c/tracks/show', trackConfigs)\n      })\n\n      that.subscribe('/jbrowse/v1/v/tracks/new', function (trackConfigs) {\n        that.addTracks(trackConfigs)\n        that.publish('/jbrowse/v1/c/tracks/new', trackConfigs)\n        that.publish('/jbrowse/v1/n/tracks/new', trackConfigs)\n      })\n      that.subscribe('/jbrowse/v1/v/tracks/replace', function (trackConfigs) {\n        that.replaceTracks(trackConfigs)\n        that.publish('/jbrowse/v1/c/tracks/replace', trackConfigs)\n        that.publish('/jbrowse/v1/n/tracks/replace', trackConfigs)\n      })\n      that.subscribe('/jbrowse/v1/v/tracks/delete', function (trackConfigs) {\n        that.deleteTracks(trackConfigs)\n        that.publish('/jbrowse/v1/c/tracks/delete', trackConfigs)\n        that.publish('/jbrowse/v1/n/tracks/delete', trackConfigs)\n      })\n\n      that.subscribe('/jbrowse/v1/v/tracks/pin', function (trackNames) {\n        that.publish('/jbrowse/v1/c/tracks/pin', trackNames)\n        that.publish('/jbrowse/v1/n/tracks/pin', trackNames)\n      })\n\n      that.subscribe('/jbrowse/v1/v/tracks/unpin', function (trackNames) {\n        that.publish('/jbrowse/v1/c/tracks/unpin', trackNames)\n        that.publish('/jbrowse/v1/n/tracks/unpin', trackNames)\n      })\n    },\n\n    /**\n     * Reports some anonymous usage statistics about this browsing\n     * instance.  Currently reports the number of tracks in the instance\n     * and their type (feature, wiggle, etc), and the number of reference\n     * sequences and their average length.\n     */\n    reportUsageStats: function () {\n      if (this.config.suppressUsageStatistics) {return}\n\n      var stats = this._calculateClientStats()\n      this._reportGoogleUsageStats(stats)\n      this._reportCustomUsageStats(stats)\n    },\n\n    // phones home to google analytics\n    _reportGoogleUsageStats: function (stats) {\n      var thisB = this\n      // jbrowse.org account always\n      var jbrowseUser = 'UA-7115575-2'\n      var accounts = [jbrowseUser]\n\n      // add any custom Google Analytics accounts from config (comma-separated or array)\n      if (this.config.googleAnalytics) {\n        var userAccounts = this.config.googleAnalytics.accounts\n        if (accounts && !lang.isArray(userAccounts)) {\n          userAccounts = userAccounts.replace(/^\\s*|\\s*$/, '').split(/\\s*,\\s*/)\n        }\n        accounts.push.apply(accounts, userAccounts)\n      }\n\n      var analyticsScript =\n        \"(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ \"\n      analyticsScript +=\n        '(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), '\n      analyticsScript +=\n        'm=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) '\n      analyticsScript +=\n        \"})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\"\n\n      // set up users\n      accounts.forEach(function (user, trackerNum) {\n        // if we're adding jbrowse.org user, also include new dimension references (replacing ga.js custom variables)\n        if (user == jbrowseUser) {\n          analyticsScript +=\n            \"ga('create', '\" + user + \"', 'auto', 'jbrowseTracker');\"\n        } else {\n          analyticsScript +=\n            \"ga('create', '\" +\n            user +\n            \"', 'auto', 'customTracker\" +\n            trackerNum +\n            \"');\"\n        }\n      })\n\n      // send pageviews and custom variables\n      accounts.forEach(function (user, viewerNum) {\n        if (user == jbrowseUser) {\n          var gaData = {}\n          var googleDimensions =\n            'tracks-count refSeqs-count refSeqs-avgLen ver loadTime electron plugins'\n          var googleMetrics = 'loadTime'\n\n          googleDimensions.split(/\\s+/).forEach(function (key, index) {\n            gaData['dimension' + (index + 1)] = stats[key]\n          })\n\n          gaData.metric1 = Math.round(stats.loadTime * 1000)\n\n          analyticsScript +=\n            \"ga('jbrowseTracker.send', 'pageview',\" +\n            JSON.stringify(gaData) +\n            ');'\n        } else {\n          analyticsScript +=\n            \"ga('customTracker\" + viewerNum + \".send', 'pageview');\"\n        }\n      })\n\n      var analyticsScriptNode = document.createElement('script')\n      analyticsScriptNode.innerHTML = analyticsScript\n\n      document.getElementsByTagName('head')[0].appendChild(analyticsScriptNode)\n    },\n\n    // phones home to custom analytics at jbrowse.org\n    _reportCustomUsageStats: function (stats) {\n      var protocol = 'https'\n\n      // overridable protocol\n      if (\n        typeof this.config.clientReport != 'undefined' &&\n        typeof this.config.clientReport.protocol != 'undefined'\n      )\n        {protocol = this.config.clientReport.protocol}\n\n      // phone home with a GET request made by a script tag\n      var clientReport =\n        protocol +\n        '://jbrowse.org/analytics/clientReport?' +\n        dojo.objectToQuery(stats)\n\n      dojo.create(\n        'img',\n        {\n          style: {\n            display: 'none',\n          },\n          src: clientReport,\n        },\n        document.body,\n      )\n    },\n\n    /**\n     * Get a store object from the store registry, loading its code and\n     * instantiating it if necessary.\n     */\n    getStore: function (storeName, callback) {\n      if (!callback) {throw 'invalid arguments'}\n\n      var storeCache = this._storeCache || {}\n      this._storeCache = storeCache\n\n      var storeRecord = storeCache[storeName]\n      if (storeRecord) {\n        storeRecord.refCount++\n        callback(storeRecord.store)\n        return\n      }\n\n      var conf = this.config.stores[storeName]\n      if (!conf) {\n        console.warn(\"store '\" + storeName + \"' not found\")\n        callback(null)\n        return\n      }\n\n      var storeClassName = conf.type\n      if (!storeClassName) {\n        console.warn('store ' + storeName + ' has no type defined')\n        callback(null)\n        return\n      }\n\n      dojo.global.require(\n        [storeClassName],\n        dojo.hitch(this, function (storeClass) {\n          var storeArgs = {}\n          dojo.mixin(storeArgs, conf)\n          dojo.mixin(storeArgs, {\n            config: conf,\n            browser: this,\n            refSeq: this.refSeq,\n          })\n\n          var store = new storeClass(storeArgs)\n\n          var cache =\n            typeof storeArgs.storeCache === 'undefined' ||\n            storeArgs.storeCache !== false\n\n          if (cache)\n            {this._storeCache[storeName] = {\n              refCount: 1,\n              store: store,\n            }}\n\n          callback(store)\n          // release the callback because apparently require\n          // doesn't release this function\n          callback = undefined\n\n          //if (cache)\n          //    delete store;\n        }),\n      )\n    },\n\n    /**\n     * Add a store configuration to the browser.  If name is falsy, will\n     * autogenerate one.\n     * @private\n     */\n    uniqCounter: 0,\n    addStoreConfig: function (/**String*/ name, /**Object*/ storeConfig) {\n      name = name || 'addStore' + this.uniqCounter++\n\n      if (!this.config.stores) {this.config.stores = {}}\n      if (!this._storeCache) {this._storeCache = {}}\n\n      if (this.config.stores[name] || this._storeCache[name]) {\n        throw 'store ' + name + ' already exists!'\n      }\n\n      this.config.stores[name] = storeConfig\n      return name\n    },\n\n    clearStores: function () {\n      this._storeCache = {}\n    },\n\n    /**\n     * Notifies the browser that the given named store is no longer being\n     * used by the calling component.  Decrements the store's reference\n     * count, and if the store's reference count reaches zero, the store\n     * object will be discarded, to be recreated again later if needed.\n     */\n    // not actually being used yet\n    releaseStore: function (storeName) {\n      var storeRecord = this._storeCache[storeName]\n      if (storeRecord && !--storeRecord.refCount)\n        {delete this._storeCache[storeName]}\n    },\n\n    _calculateClientStats: function () {\n      var scn = screen || window.screen\n\n      // make a flat (i.e. non-nested) object for the stats, so that it\n      // encodes compactly in the query string\n      var date = new Date()\n      var stats = {\n        ver: this.version || 'dev',\n        'refSeqs-count': this.refSeqOrder.length,\n        'refSeqs-avgLen': !this.refSeqOrder.length\n          ? null\n          : dojof.reduce(\n              dojo.map(\n                this.refSeqOrder,\n                function (name) {\n                  var ref = this.allRefs[name]\n                  if (!ref) {return 0}\n                  return ref.end - ref.start\n                },\n                this,\n              ),\n              '+',\n            ),\n        'tracks-count': this.config.tracks.length,\n        plugins: dojof.keys(this.plugins).sort().join(','),\n\n        // screen geometry\n        'scn-h': scn ? scn.height : null,\n        'scn-w': scn ? scn.width : null,\n        // window geometry\n        'win-h': document.body.offsetHeight,\n        'win-w': document.body.offsetWidth,\n        // container geometry\n        'el-h': this.container.offsetHeight,\n        'el-w': this.container.offsetWidth,\n\n        // time param to prevent caching\n        t: date.getTime() / 1000,\n        electron: Util.isElectron(),\n\n        // also get local time zone offset\n        tzoffset: date.getTimezoneOffset(),\n\n        loadTime: (date.getTime() - this.startTime) / 1000,\n      }\n\n      // count the number and types of tracks\n      dojo.forEach(this.config.tracks, function (trackConfig) {\n        var typeKey = 'track-types-' + trackConfig.type || 'null'\n        stats[typeKey] = (stats[typeKey] || 0) + 1\n      })\n\n      return stats\n    },\n\n    publish: function () {\n      if (this.config.logMessages) {console.log(arguments)}\n\n      return topic.publish.apply(topic, arguments)\n    },\n\n    subscribe: function () {\n      this._uniqueSubscriptionId = this._uniqueSubscriptionId || 0\n      this._subscription = this._subscription || {}\n      var uniqId = ++this._uniqueSubscriptionId\n      var unsubber = topic.subscribe.apply(topic, arguments)\n      var thisB = this\n      this._subscription[uniqId] = unsubber\n      return (function (id) {\n        return {\n          remove: function () {\n            delete thisB._subscription[id]\n            unsubber.remove()\n          },\n        }\n      })(uniqId)\n    },\n\n    onResize: function () {\n      if (this.navbox)\n        {this.view.locationTrapHeight = dojo.marginBox(this.navbox).h}\n    },\n\n    /**\n     * Get the list of the most recently used tracks, stored for this user\n     * in a cookie.\n     * @returns {Array[Object]} as <code>[{ time: (integer), label: (track label)}]</code>\n     */\n    getRecentlyUsedTracks: function () {\n      return dojo.fromJson(this.cookie('recentTracks') || '[]')\n    },\n\n    /**\n     * Add the given list of tracks as being recently used.\n     * @param trackLabels {Array[String]} array of track labels to add\n     */\n    addRecentlyUsedTracks: function (trackLabels) {\n      var seen = {}\n      var newRecent = Util.uniq(\n        dojo\n          .map(\n            trackLabels,\n            function (label) {\n              return {\n                label: label,\n                time: Math.round(new Date() / 1000), // secs since epoch\n              }\n            },\n            this,\n          )\n          .concat(dojo.fromJson(this.cookie('recentTracks')) || []),\n        function (entry) {\n          return entry.label\n        },\n      )\n        // limit by default to 20 recent tracks\n        .slice(0, this.config.maxRecentTracks || 10)\n\n      // set the recentTracks cookie, good for one year\n      this.cookie('recentTracks', newRecent, { expires: 365 })\n\n      return newRecent\n    },\n\n    /**\n     * Run a function that will eventually resolve the named Deferred\n     * (milestone).\n     * @param {String} name the name of the Deferred\n     */\n    _milestoneFunction: function (/**String*/ name, func) {\n      var thisB = this\n      var args = Array.prototype.slice.call(arguments, 2)\n\n      var d = thisB._getDeferred(name)\n      args.unshift(d)\n      try {\n        func.apply(thisB, args)\n      } catch (e) {\n        console.error(e, e.stack)\n        d.reject(e)\n      }\n\n      return d\n    },\n\n    /**\n     * Fetch or create a named Deferred, which is how milestones are implemented.\n     */\n    _getDeferred: function (name) {\n      if (!this._deferred) {this._deferred = {}}\n      return (\n        this._deferred[name] ||\n        (this._deferred[name] = function () {\n          var d = new Deferred()\n          d.then(null, lang.hitch(this, 'fatalError'))\n          return d\n        }.call(this))\n      )\n    },\n    /**\n     * Attach a callback to a milestone.\n     */\n    afterMilestone: function (name, func, ctx) {\n      return this._getDeferred(name).then(function () {\n        try {\n          func.call(ctx || this)\n        } catch (e) {\n          console.error(e instanceof Error ? e : String(e), e.stack)\n        }\n      })\n    },\n    /**\n     * Indicate that we've reached a milestone in the initalization\n     * process.  Will run all the callbacks associated with that\n     * milestone.\n     */\n    passMilestone: function (name, result) {\n      return this._getDeferred(name).resolve(result)\n    },\n    /**\n     * Return true if we have reached the named milestone, false otherwise.\n     */\n    reachedMilestone: function (name) {\n      return this._getDeferred(name).isResolved()\n    },\n\n    /**\n     *  Load our configuration file(s) based on the parameters the\n     *  constructor was passed.  Does not return until all files are\n     *  loaded and merged in.\n     *  @returns nothing meaningful\n     */\n    loadConfig: function () {\n      return this._milestoneFunction('loadConfig', function (deferred) {\n        // check the config.dataRoot parameter before loading, unless allowCrossSiteDataRoot is on.\n        // this prevents an XSS attack served from a malicious server that has CORS enabled. thanks to @cmdcolin\n        // for noticing this.\n        if (\n          this.config.dataRoot &&\n          this.config.dataRoot !== 'data' &&\n          !this.config.allowCrossOriginDataRoot\n        ) {\n          const parsedDataRoot = url.parse(\n            url.resolve(window.location.href, this.config.dataRoot),\n          )\n          if (parsedDataRoot.host) {\n            const currentParsed = url.parse(window.location.href)\n            if (\n              !Util.isElectron() &&\n              (parsedDataRoot.host !== currentParsed.host ||\n                parsedDataRoot.protocol !== currentParsed.protocol)\n            )\n              {throw new Error(\n                'Invalid JBrowse dataRoot setting. For security, absolute URLs are not allowed. Set `allowCrossOriginDataRoot` to true to disable this security check.',\n              )}\n          }\n        }\n\n        var c = new ConfigManager({\n          bootConfig: this.config,\n          defaults: this._configDefaults(),\n          browser: this,\n        })\n        c.getFinalConfig().then(\n          dojo.hitch(this, function (finishedConfig) {\n            this.config = finishedConfig\n\n            //apply document.domain from a loaded conf file\n            if (this.config.documentDomain)\n              {document.domain = this.config.documentDomain}\n\n            // pass the tracks configurations through\n            // addTrackConfigs so that it will be indexed and such\n            var tracks = finishedConfig.tracks || []\n            delete finishedConfig.tracks\n            this._addTrackConfigs(tracks)\n\n            // coerce some config keys to boolean\n            ;[\n              'show_tracklist',\n              'show_nav',\n              'show_overview',\n              'show_menu',\n              'show_fullviewlink',\n              'show_tracklabels',\n              'update_browser_title',\n            ].forEach(v => {\n              this.config[v] = Util.coerceBoolean(this.config[v])\n            })\n\n            // set empty tracks array if we have none\n            if (!this.config.tracks) {this.config.tracks = []}\n\n            deferred.resolve({ success: true })\n          }),\n          deferred.reject,\n        )\n      })\n    },\n\n    /**\n     * Add new track configurations.\n     * @private\n     */\n    _addTrackConfigs: function (/**Array*/ configs) {\n      if (!this.config.tracks) {this.config.tracks = []}\n      if (!this.trackConfigsByName) {this.trackConfigsByName = {}}\n\n      array.forEach(\n        configs,\n        function (conf) {\n          // if( this.trackConfigsByName[ conf.label ] ) {\n          //     console.warn(\"track with label \"+conf.label+\" already exists, skipping\");\n          //     return;\n          // }\n\n          this.trackConfigsByName[conf.label] = conf\n          this.config.tracks.push(conf)\n        },\n        this,\n      )\n\n      return configs\n    },\n    /**\n     * Replace existing track configurations.\n     * @private\n     */\n    _replaceTrackConfigs: function (/**Array*/ newConfigs) {\n      if (!this.trackConfigsByName) {this.trackConfigsByName = {}}\n\n      array.forEach(\n        newConfigs,\n        function (conf) {\n          if (!this.trackConfigsByName[conf.label]) {\n            console.warn(\n              'track with label ' +\n                conf.label +\n                ' does not exist yet.  creating a new one.',\n            )\n          }\n\n          this.trackConfigsByName[conf.label] = dojo.mixin(\n            this.trackConfigsByName[conf.label] || {},\n            conf,\n          )\n        },\n        this,\n      )\n    },\n    /**\n     * Delete existing track configs.\n     * @private\n     */\n    _deleteTrackConfigs: function (configsToDelete) {\n      // remove from this.config.tracks\n      this.config.tracks = array.filter(\n        this.config.tracks || [],\n        function (conf) {\n          return !array.some(configsToDelete, function (toDelete) {\n            return toDelete.label == conf.label\n          })\n        },\n      )\n\n      // remove from trackConfigsByName\n      array.forEach(\n        configsToDelete,\n        function (toDelete) {\n          if (!this.trackConfigsByName[toDelete.label]) {\n            console.warn(\n              'track ' + toDelete.label + ' does not exist, cannot delete',\n            )\n            return\n          }\n\n          delete this.trackConfigsByName[toDelete.label]\n        },\n        this,\n      )\n    },\n\n    _configDefaults: function () {\n      return {\n        tracks: [],\n\n        containerID: 'GenomeBrowser',\n        dataRoot: 'data',\n        show_tracklist: true,\n        show_nav: true,\n        show_menu: true,\n        show_overview: true,\n        show_fullviewlink: true,\n        update_browser_title: true,\n        updateBrowserURL: true,\n\n        refSeqs: '{dataRoot}/seq/refSeqs.json',\n        include: ['jbrowse.conf', 'jbrowse_conf.json'],\n        nameUrl: '{dataRoot}/names/root.json',\n\n        datasets: {\n          _DEFAULT_EXAMPLES: true,\n          volvox: {\n            url: '?data=sample_data/json/volvox',\n            name: 'Volvox Example',\n          },\n          modencode: {\n            url: '?data=sample_data/json/modencode',\n            name: 'MODEncode Example',\n          },\n          yeast: {\n            url: '?data=sample_data/json/yeast',\n            name: 'Yeast Example',\n          },\n        },\n\n        highlightSearchedRegions: false,\n        highResolutionMode: 'auto',\n      }\n    },\n\n    /**\n     * get the numerical ID number of the given reference sequence name.  required for CRAM files, which\n     * only operate on reference sequence ID numbers.\n     * @param {string} refSeqName\n     */\n    getRefSeqNumber(refSeqName) {\n      return this.allRefs[refSeqName].id\n    },\n\n    /**\n     * get a reference sequence by its numerical id number. used mostly by CRAM stores.\n     * @param {number} id\n     */\n    getRefSeqById(id) {\n      return this.refSeqsById[id]\n    },\n\n    /**\n     * @param refSeqs {Array} array of refseq records to add to the browser\n     */\n    addRefseqs: function (refSeqs) {\n      if (!this.allRefs) {this.allRefs = {}}\n\n      refSeqs.forEach((r, id) => {\n        // save the original index of the reference for\n        // use with CRAM and other numerical-refseq-id stores\n        r.id = id\n        this.allRefs[r.name] = r\n      })\n\n      this.refSeqsById = refSeqs\n\n      // generate refSeqOrder\n      this.refSeqOrder = function () {\n        var order\n        if (!this.config.refSeqOrder) {\n          order = refSeqs\n        } else {\n          // if refSeqOrder 'by_list' and config parameter refSeqOrderList exists,\n          // split that into an array as an override to default refSeqs.json order\n          if (\n            this.config.refSeqOrder == 'by_list' &&\n            this.config.refSeqOrderList\n          ) {\n            if (lang.isArray(this.config.refSeqOrderList)) {\n              return this.config.refSeqOrderList\n            } else if (typeof this.config.refSeqOrderList === 'string') {\n              return this.config.refSeqOrderList.split(/\\s*,\\s*/)\n            }\n          }\n          order = refSeqs.slice(0)\n          order.sort(\n            this.config.refSeqOrder == 'length' ||\n              this.config.refSeqOrder == 'length ascending'\n              ? function (a, b) {\n                  return a.length - b.length\n                }\n              : this.config.refSeqOrder == 'length descending'\n                ? function (a, b) {\n                    return b.length - a.length\n                  }\n                : this.config.refSeqOrder == 'name descending'\n                  ? function (a, b) {\n                      return b.name.localeCompare(a.name)\n                    }\n                  : function (a, b) {\n                      return a.name.localeCompare(b.name)\n                    },\n          )\n        }\n        return array.map(order, function (r) {\n          return r.name\n        })\n      }.call(this)\n\n      var refCookie = this.cookie('refseq')\n      this.refSeq =\n        this.refSeq ||\n        this.allRefs[refCookie] ||\n        this.allRefs[this.refSeqOrder[0]]\n    },\n\n    /**\n     * Get the refseq object { name, start, end, .. } with the given name,\n     * or the currently shown ref seq if no name is given.\n     */\n    getRefSeq: function (name) {\n      if (typeof name != 'string') {return this.refSeq || undefined}\n\n      return this.allRefs[name]\n    },\n\n    /**\n     * @private\n     */\n    onFineMove: function (startbp, endbp) {\n      if (this.locationTrap) {\n        var length = this.view.ref.end - this.view.ref.start\n        var trapLeft = Math.round(\n          ((startbp - this.view.ref.start) / length) * this.view.overviewBox.w +\n            this.view.overviewBox.l,\n        )\n        var trapRight = Math.round(\n          ((endbp - this.view.ref.start) / length) * this.view.overviewBox.w +\n            this.view.overviewBox.l,\n        )\n        dojo.style(this.locationTrap, {\n          width: trapRight - trapLeft + 'px',\n          borderBottomWidth: this.view.locationTrapHeight + 'px',\n          borderLeftWidth: trapLeft + 'px',\n          borderRightWidth: this.view.overviewBox.w - trapRight + 'px',\n        })\n      }\n    },\n\n    /**\n     * Asynchronously initialize our track metadata.\n     */\n    initTrackMetadata: function (callback) {\n      var thisB = this\n      return this._milestoneFunction('initTrackMetadata', function (deferred) {\n        var metaDataSourceClasses = dojo.map(\n          (this.config.trackMetadata || {}).sources || [],\n          function (sourceDef) {\n            var url = sourceDef.relativeUrl\n              ? Util.resolveUrl(\n                  thisB.config.dataRoot + '/',\n                  sourceDef.relativeUrl,\n                )\n              : sourceDef.url || 'trackMeta.csv'\n            var type =\n              sourceDef.type ||\n              (/\\.csv$/i.test(url)\n                ? 'csv'\n                : /\\.js(on)?$/i.test(url)\n                  ? 'json'\n                  : 'csv')\n            var storeClass =\n              sourceDef['class'] ||\n              {\n                csv: 'dojox/data/CsvStore',\n                json: 'dojox/data/JsonRestStore',\n              }[type]\n            if (!storeClass) {\n              console.error(\n                \"No store class found for type '\" +\n                  type +\n                  \"', cannot load track metadata from URL \" +\n                  url,\n              )\n              return null\n            }\n            return { class_: storeClass, url: url }\n          },\n        )\n\n        dojo.global.require(\n          Array.prototype.concat.apply(\n            ['JBrowse/Store/TrackMetaData'],\n            dojo.map(metaDataSourceClasses, function (c) {\n              return c.class_\n            }),\n          ),\n          dojo.hitch(this, function (MetaDataStore) {\n            var mdStores = []\n            for (var i = 1; i < arguments.length; i++) {\n              mdStores.push(\n                new arguments[i]({\n                  url: metaDataSourceClasses[i - 1].url,\n                }),\n              )\n            }\n\n            this.trackMetaDataStore = new MetaDataStore(\n              dojo.mixin(dojo.clone(this.config.trackMetadata || {}), {\n                trackConfigs: this.config.tracks,\n                browser: this,\n                metadataStores: mdStores,\n              }),\n            )\n\n            deferred.resolve({ success: true })\n          }),\n        )\n      })\n    },\n\n    /**\n     * Asynchronously create the track list.\n     * @private\n     */\n    createTrackList: function () {\n      return this._milestoneFunction('createTrack', function (deferred) {\n        // find the tracklist class to use\n        var tl_class = !this.config.show_tracklist\n          ? 'Null'\n          : (this.config.trackSelector || {}).type\n            ? this.config.trackSelector.type\n            : 'Hierarchical'\n        if (!/\\//.test(tl_class))\n          {tl_class = 'JBrowse/View/TrackList/' + tl_class}\n\n        // load all the classes we need\n        dojo.global.require(\n          [tl_class],\n          dojo.hitch(this, function (trackListClass) {\n            // instantiate the tracklist and the track metadata object\n            this.trackListView = new trackListClass(\n              dojo.mixin(dojo.clone(this.config.trackSelector) || {}, {\n                trackConfigs: this.config.tracks,\n                browser: this,\n                trackMetaData: this.trackMetaDataStore,\n              }),\n            )\n\n            // bind the 't' key as a global keyboard shortcut\n            this.setGlobalKeyboardShortcut('t', this.trackListView, 'toggle')\n\n            // listen for track-visibility-changing messages from\n            // views and update our tracks cookie\n            this.subscribe(\n              '/jbrowse/v1/n/tracks/visibleChanged',\n              dojo.hitch(this, function () {\n                this.cookie('tracks', this.view.visibleTrackNames().join(','), {\n                  expires: 60,\n                })\n              }),\n            )\n\n            deferred.resolve({ success: true })\n          }),\n        )\n      })\n    },\n\n    /**\n     * @private\n     */\n\n    onVisibleTracksChanged: function () {},\n\n    /**\n     * Like <code>navigateToLocation()</code>, except it attempts to display the given\n     * location with a little bit of flanking sequence to each side, if\n     * possible.\n     */\n    showRegion: function (location) {\n      var flank = Math.round((location.end - location.start) * 0.2)\n      //go to location, with some flanking region\n      this.navigateToLocation({\n        ref: location.ref,\n        start: location.start - flank,\n        end: location.end + flank,\n      })\n\n      // if the location has a track associated with it, show it\n      if (location.tracks) {\n        this.showTracks(\n          array.map(location.tracks, function (t) {\n            return (t && (t.label || t.name)) || t\n          }),\n        )\n      }\n    },\n\n    /**\n     * navigate to a given location\n     * @example\n     * gb=dojo.byId(\"GenomeBrowser\").genomeBrowser\n     * gb.navigateTo(\"ctgA:100..200\")\n     * gb.navigateTo(\"f14\")\n     * @param loc can be either:<br>\n     * &lt;chromosome&gt;:&lt;start&gt; .. &lt;end&gt;<br>\n     * &lt;start&gt; .. &lt;end&gt;<br>\n     * &lt;center base&gt;<br>\n     * &lt;feature name/ID&gt;\n     */\n\n    navigateTo: function (loc, initial) {\n      var thisB = this\n      this.afterMilestone('initView', function () {\n        // lastly, try to search our feature names for it\n        var ret = thisB.searchNames(loc).then(function (found) {\n          if (found) {return}\n\n          // First check if loc is the name of a ref seq before attempting to parse the locstring for basepair location info\n          var ref = thisB.findReferenceSequence(loc)\n\n          if (ref) {\n            thisB.navigateToLocation({ ref: ref.name })\n            return\n          }\n\n          // Not a known ref seq name - now lets parse the loc string\n          // if it's a foo:123..456 location, go there\n          var location = typeof loc == 'string' ? Util.parseLocString(loc) : loc\n          // only call navigateToLocation() directly if location has start and end, otherwise try and fill in start/end from 'location' cookie\n          if (location && 'start' in location && 'end' in location) {\n            location.initial = initial\n            thisB.navigateToLocation(location)\n            return\n          }\n\n          new InfoDialog({\n            title: 'Not found',\n            content:\n              'Not found: <span class=\"locString\">' +\n              dompurify.sanitize(loc) +\n              '</span>',\n            className: 'notfound-dialog',\n          }).show()\n          if (!thisB.view.pxPerBp) {\n            thisB.navigateToLocation(thisB.refSeq)\n          }\n        })\n      })\n    },\n\n    findReferenceSequence: function (name) {\n      for (var n in this.allRefs) {\n        if (!this.compareReferenceNames(n, name)) {return this.allRefs[n]}\n      }\n      return null\n    },\n\n    // given an object like { ref: 'foo', start: 2, end: 100 }, set the\n    // browser's view to that location.  any of ref, start, or end may be\n    // missing, in which case the function will try set the view to\n    // something that seems intelligent\n    navigateToLocation: function (location) {\n      this.afterMilestone(\n        'initView',\n        dojo.hitch(this, function () {\n          // regularize the ref seq name we were passed\n          var ref = location.ref\n            ? this.findReferenceSequence(location.ref.name || location.ref)\n            : this.refSeq\n          if (location.initial && !ref) {\n            new InfoDialog({\n              title: 'Not found',\n              content:\n                'Not found: <span class=\"locString\">' +\n                Util.assembleLocString(location, false) +\n                '</span>',\n              className: 'notfound-dialog',\n            }).show()\n            ref = this.refSeq\n          }\n          if (!ref) {\n            return\n          }\n          location.ref = ref.name\n\n          if (\n            'ref' in location &&\n            !('start' in location && 'end' in location)\n          ) {\n            // see if we have a stored location for this ref seq in a\n            // cookie, and go there if we do\n            var oldLoc\n            try {\n              oldLoc = Util.parseLocString(\n                dojo.fromJson(this.cookie('location'))[location.ref].l,\n              )\n              oldLoc.ref = location.ref // force the refseq name; older cookies don't have it\n            } catch (x) {}\n            if (oldLoc) {\n              location = oldLoc\n            } else {\n              // if we don't have a previous location, just go to\n              // the middle 80% of that refseq,\n              // based on range that can be viewed (start to end)\n              // rather than total length, in case start != 0 || end != length\n              // this.navigateToLocation({ref: ref.name, start: ref.end*0.1, end: ref.end*0.9 });\n              var visibleLength = ref.end - ref.start\n              location.start = ref.start + visibleLength * 0.1\n              location.end = ref.start + visibleLength * 0.9\n            }\n          }\n\n          // clamp the start and end to the size of the ref seq\n          location.start = Math.max(0, location.start || 0)\n          location.end = Math.max(\n            location.start,\n            Math.min(ref.end, location.end || ref.end),\n          )\n\n          // if it's the same sequence, just go there\n          if (location.ref == this.refSeq.name) {\n            this.view.setLocation(this.refSeq, location.start, location.end)\n            this._updateLocationCookies(location)\n          }\n          // if different, we need to poke some other things before going there\n          else {\n            // record names of open tracks and re-open on new refseq\n            var curTracks = this.view.visibleTrackNames()\n\n            this.refSeq = this.allRefs[location.ref]\n            this.clearStores()\n\n            this.view.setLocation(this.refSeq, location.start, location.end)\n            this._updateLocationCookies(location)\n\n            this.showTracks(curTracks)\n          }\n        }),\n      )\n    },\n\n    /**\n     * Given a string name, search for matching feature names and set the\n     * view location to any that match.\n     */\n    searchNames: function (/**String*/ loc) {\n      return this._getDeferred('loadNames').then(() => {\n        return this.nameStore.query({ name: loc }).then(\n          nameMatches => {\n            // if we have no matches, pop up a dialog saying so, and\n            // do nothing more\n            if (!nameMatches.length) {\n              return false\n            }\n\n            var goingTo\n\n            //first check for exact case match\n            for (var i = 0; i < nameMatches.length; i++) {\n              if (nameMatches[i].name == loc) {goingTo = nameMatches[i]}\n            }\n            //if no exact case match, try a case-insentitive match\n            if (!goingTo) {\n              for (i = 0; i < nameMatches.length; i++) {\n                if (nameMatches[i].name.toLowerCase() == loc.toLowerCase())\n                  {goingTo = nameMatches[i]}\n              }\n            }\n            //else just pick a match\n            if (!goingTo) {goingTo = nameMatches[0]}\n\n            // if it has one location, go to it\n            if (goingTo.location) {\n              //go to location, with some flanking region\n              this.showRegionAfterSearch(goingTo.location)\n            }\n            // otherwise, pop up a dialog with a list of the locations to choose from\n            else if (goingTo.multipleLocations) {\n              if (!this.view.pxPerBp) {\n                this.navigateToLocation(this.refSeq)\n              }\n              new LocationChoiceDialog({\n                browser: this,\n                locationChoices: goingTo.multipleLocations,\n                title: 'Choose ' + goingTo.name + ' location',\n                prompt:\n                  '\"' +\n                  goingTo.name +\n                  '\" is found in multiple locations.  Please choose a location to view.',\n              }).show()\n            }\n            return true\n          },\n          function (e) {\n            console.error(e)\n            new InfoDialog({\n              title: 'Error',\n              content: 'Error reading from name store.',\n            }).show()\n            return false\n          },\n        )\n      })\n    },\n\n    /**\n     * load and display the given tracks\n     * @example\n     * gb=dojo.byId(\"GenomeBrowser\").genomeBrowser\n     * gb.showTracks([\"DNA\",\"gene\",\"mRNA\",\"noncodingRNA\"])\n     * @param trackNameList {Array|String} array or comma-separated string\n     * of track names, each of which should correspond to the \"label\"\n     * element of the track information\n     */\n\n    showTracks: function (trackNames) {\n      this.afterMilestone(\n        'initView',\n        dojo.hitch(this, function () {\n          if (typeof trackNames == 'string') {trackNames = trackNames.split(',')}\n\n          if (!trackNames) {return}\n\n          var trackConfs = dojo.filter(\n            dojo.map(\n              trackNames,\n              function (n) {\n                return this.trackConfigsByName[n]\n              },\n              this,\n            ),\n            function (c) {\n              return c\n            }, // filter out confs that are missing\n          )\n\n          // publish some events with the tracks to instruct the views to show them.\n          this.publish('/jbrowse/v1/c/tracks/show', trackConfs)\n          this.publish('/jbrowse/v1/n/tracks/visibleChanged')\n        }),\n      )\n    },\n\n    /**\n     * Create a global keyboard shortcut.\n     * @param keychar the character of the key that is typed\n     * @param [...] additional arguments passed to dojo.hitch for making the handler\n     */\n    setGlobalKeyboardShortcut: function (keychar) {\n      // warn if redefining\n      if (this.globalKeyboardShortcuts[keychar])\n        {console.warn(\n          \"WARNING: JBrowse global keyboard shortcut '\" +\n            keychar +\n            \"' redefined\",\n        )}\n\n      // make the wrapped handler func\n      var func = dojo.hitch.apply(\n        dojo,\n        Array.prototype.slice.call(arguments, 1),\n      )\n\n      // remember it\n      this.globalKeyboardShortcuts[keychar] = func\n    },\n\n    /**\n     * Key event handler that implements all global keyboard shortcuts.\n     */\n    globalKeyHandler: function (evt) {\n      // if some digit widget is focused, don't process any global keyboard shortcuts\n      if (dijitFocus.curNode) {return}\n\n      var shortcut =\n        this.globalKeyboardShortcuts[\n          evt.keyChar || String.fromCharCode(evt.charCode || evt.keyCode)\n        ]\n      if (shortcut) {\n        shortcut.call(this)\n        evt.stopPropagation()\n      }\n    },\n    makeSnapLink: function () {\n      var browser = this\n      var shareURL = '#'\n      var dataRoot = this.config.dataRoot\n\n      // make the share link\n      var button = new dijitButton({\n        className: 'share',\n        innerHTML: 'Screenshot',\n        title: 'share this view',\n        onClick: function () {\n          var fs = electronRequire('fs')\n          var remote = electronRequire('electron').remote\n          remote.dialog.showSaveDialog(\n            { defaultPath: '*/screenshot.png' },\n            fileName => {\n              if (fileName) {\n                remote\n                  .getCurrentWindow()\n                  .capturePage(img => fs.writeFileSync(fileName, img.toPNG()))\n              }\n            },\n          )\n        },\n      })\n\n      return button.domNode\n    },\n\n    makeShareLink: function () {\n      // don't make the link if we were explicitly configured not to\n      if ('share_link' in this.config && !this.config.share_link) {return null}\n\n      var browser = this\n      var shareURL = '#'\n\n      // make the share link\n      var button = new dijitButton({\n        className: 'share',\n        innerHTML: '<span class=\"icon\"></span> Share',\n        title: 'share this view',\n        onClick: function () {\n          URLinput.value = shareURL\n          previewLink.href = shareURL\n\n          sharePane.show()\n          URLinput.focus()\n          URLinput.select()\n          copyReminder.style.display = 'block'\n\n          return false\n        },\n      })\n\n      // make the 'share' popup\n      var container = dojo.create('div', {\n        innerHTML: 'Paste this link in <b>email</b> or <b>IM</b>',\n      })\n      var copyReminder = dojo.create('div', {\n        className: 'copyReminder',\n        innerHTML: 'Press CTRL-C to copy',\n      })\n      var URLinput = dojo.create('input', {\n        type: 'text',\n        value: shareURL,\n        size: 50,\n        readonly: 'readonly',\n        onclick: function () {\n          this.select()\n          copyReminder.style.display = 'block'\n        },\n        onblur: function () {\n          copyReminder.style.display = 'none'\n        },\n      })\n      var previewLink = dojo.create(\n        'a',\n        {\n          innerHTML: 'Preview',\n          target: '_blank',\n          href: shareURL,\n          style: { display: 'block', float: 'right' },\n        },\n        container,\n      )\n      var sharePane = new dijitDialog({\n        className: 'sharePane',\n        title: 'Share this view',\n        draggable: false,\n        content: [container, URLinput, copyReminder],\n        autofocus: false,\n      })\n\n      // connect moving and track-changing events to update it\n      var updateShareURL = function () {\n        shareURL = browser.makeCurrentViewURL()\n      }\n      dojo.connect(this, 'onCoarseMove', updateShareURL)\n      this.subscribe('/jbrowse/v1/n/tracks/visibleChanged', updateShareURL)\n      this.subscribe('/jbrowse/v1/n/globalHighlightChanged', updateShareURL)\n\n      return button.domNode\n    },\n\n    /**\n     * Return a string URL that encodes the complete viewing state of the\n     * browser.  Currently just data dir, visible tracks, and visible\n     * region.\n     * @param {Object} overrides optional key-value object containing\n     *                           components of the query string to override\n     */\n    makeCurrentViewURL: function (overrides) {\n      var t = typeof this.config.shareURL\n\n      if (t == 'function') {\n        return this.config.shareURL.call(this, this)\n      } else if (t == 'string') {\n        return this.config.shareURL\n      }\n\n      return ''.concat(\n        window.location.protocol,\n        '//',\n        window.location.host,\n        window.location.pathname,\n        '?',\n        dojo.objectToQuery(\n          dojo.mixin(\n            dojo.mixin({}, this.config.queryParams || {}),\n            dojo.mixin(\n              {\n                loc: this.view.visibleRegionLocString(),\n                tracks: this.view.visibleTrackNames().join(','),\n                highlight: (this.getHighlight() || '').toString(),\n              },\n              overrides || {},\n            ),\n          ),\n        ),\n      )\n    },\n\n    makeFullViewLink: function () {\n      var thisB = this\n      // make the link\n      var link = dojo.create('a', {\n        className: 'topLink',\n        href: window.location.href,\n        target: '_blank',\n        title: 'View in full-screen browser',\n        innerHTML: 'Full-screen view',\n      })\n\n      var makeURL = this.config.makeFullViewURL || this.makeCurrentViewURL\n\n      // update it when the view is moved or tracks are changed\n      var update_link = function () {\n        link.href = makeURL.call(thisB, thisB)\n      }\n      dojo.connect(this, 'onCoarseMove', update_link)\n      this.subscribe('/jbrowse/v1/n/tracks/visibleChanged', update_link)\n      this.subscribe('/jbrowse/v1/n/globalHighlightChanged', update_link)\n\n      return link\n    },\n\n    /**\n     * @private\n     */\n\n    onCoarseMove: function (startbp, endbp) {\n      var currRegion = {\n        start: startbp,\n        end: endbp,\n        ref: this.refSeq.name,\n      }\n      var searchVal = '' // the feature that was typed into the search field\n\n      // update the location box with our current location (in this case locationBox is the legacy search box)\n      if (this.locationBox) {\n        //this.searchVal = searchVal;\n        var searchVal = this.locationBox.get('value')\n        if (searchVal.length) {searchVal = ' \"' + searchVal + '\"'}\n        var locationVal = Util.assembleLocStringWithLength(currRegion)\n\n        this.locationBox.set(\n          'value',\n          locationVal,\n          false, //< don't fire any onchange handlers\n        )\n        this.locationBox.set('placeholder', 'search features, IDs')\n        this.goButton.set('disabled', true)\n      }\n      // update the id=location-box if it exists\n      var node = dojo.byId('location-info')\n      if (node) {\n        var location = Util.assembleLocStringWithLength(currRegion)\n        html.set(node, location + searchVal)\n        this.locationBox.set('value', '', false)\n      }\n\n      // also update the refseq selection dropdown if present\n      this._updateRefSeqSelectBox()\n\n      if (this.reachedMilestone('completely initialized')) {\n        this._updateLocationCookies(currRegion)\n      }\n\n      // send out a message notifying of the move\n      this.publish('/jbrowse/v1/n/navigate', currRegion)\n    },\n\n    _updateRefSeqSelectBox: function () {\n      if (this.refSeqSelectBox) {\n        // if none of the options in the select box match this\n        // reference sequence, add another one to the end for it\n        if (\n          !array.some(\n            this.refSeqSelectBox.getOptions(),\n            function (option) {\n              return option.value == this.refSeq.name\n            },\n            this,\n          )\n        ) {\n          this.refSeqSelectBox.set(\n            'options',\n            this.refSeqSelectBox.getOptions().concat({\n              label: this.refSeq.name,\n              value: this.refSeq.name,\n            }),\n          )\n        }\n\n        // set its value to the current ref seq\n        this.refSeqSelectBox.set('value', this.refSeq.name, false)\n      }\n    },\n\n    /**\n     * update the location and refseq cookies\n     */\n    _updateLocationCookies: function (location) {\n      var locString =\n        typeof location == 'string'\n          ? location\n          : Util.assembleLocString(location, false)\n      var oldLocMap = dojo.fromJson(this.cookie('location')) || {\n        _version: 1,\n      }\n      if (!oldLocMap['_version']) {oldLocMap = this._migrateLocMap(oldLocMap)}\n      oldLocMap[this.refSeq.name] = {\n        l: locString,\n        t: Math.round(new Date().getTime() / 1000) - 1340211510,\n      }\n      oldLocMap = this._limitLocMap(\n        oldLocMap,\n        this.config.maxSavedLocations || 10,\n      )\n      this.cookie('location', dojo.toJson(oldLocMap), { expires: 60 })\n      this.cookie('refseq', this.refSeq.name)\n    },\n\n    /**\n     * Migrate an old location map cookie to the new format that includes timestamps.\n     * @private\n     */\n    _migrateLocMap: function (locMap) {\n      var newLoc = { _version: 1 }\n      for (var loc in locMap) {\n        newLoc[loc] = { l: locMap[loc], t: 0 }\n      }\n      return newLoc\n    },\n\n    /**\n     * Limit the size of the saved location map, removing the least recently used.\n     * @private\n     */\n    _limitLocMap: function (locMap, maxEntries) {\n      // don't do anything if the loc map has fewer than the max\n      var locRefs = dojof.keys(locMap)\n      if (locRefs.length <= maxEntries) {return locMap}\n\n      // otherwise, calculate the least recently used that we need to\n      // get rid of to be under the size limit\n      locMap = dojo.clone(locMap)\n      var deleteLocs = locRefs\n        .sort(function (a, b) {\n          return locMap[b].t - locMap[a].t\n        })\n        .slice(maxEntries - 1)\n\n      // and delete them from the locmap\n      dojo.forEach(deleteLocs, function (locRef) {\n        delete locMap[locRef]\n      })\n\n      return locMap\n    },\n\n    /**\n     * Wrapper for dojo.cookie that namespaces our cookie names by\n     * prefixing them with this.config.containerID.\n     *\n     * Has one additional bit of smarts: if an object or array is passed\n     * instead of a string to set as the cookie contents, will serialize\n     * it with dojo.toJson before storing.\n     *\n     * @param [...] same as dojo.cookie\n     * @returns the new value of the cookie, same as dojo.cookie\n     */\n    cookie: function (keyWithoutId, value) {\n      keyWithoutId = this.config.containerID + '-' + keyWithoutId\n      var keyWithId = keyWithoutId + '-' + (this.config.dataset_id || '')\n      if (typeof value == 'object') {value = dojo.toJson(value)}\n\n      var sizeLimit = this.config.cookieSizeLimit || 1200\n      if (value != null && value.length > sizeLimit) {\n        console.warn(\n          \"not setting cookie '\" +\n            keyWithId +\n            \"', value too big (\" +\n            value.length +\n            ' > ' +\n            sizeLimit +\n            ')',\n        )\n        return localStorage.getItem(keyWithId)\n      } else if (value != null) {\n        try {\n          return localStorage.setItem(keyWithId, value)\n        } catch (e) {}\n      }\n\n      return localStorage.getItem(keyWithId) || dojo.cookie(keyWithoutId)\n    },\n    /**\n     * @private\n     */\n\n    createNavBox: function (parent) {\n      var thisB = this\n      var align = 'center'\n      var navbox = dojo.create(\n        'div',\n        { id: 'navbox', style: { 'text-align': align } },\n        parent,\n      )\n\n      // container adds a white backdrop to the locationTrap.\n      var locationTrapContainer = dojo.create(\n        'div',\n        { className: 'locationTrapContainer' },\n        navbox,\n      )\n\n      this.locationTrap = dojo.create(\n        'div',\n        { className: 'locationTrap' },\n        locationTrapContainer,\n      )\n\n      var four_nbsp = String.fromCharCode(160)\n      four_nbsp = four_nbsp + four_nbsp + four_nbsp + four_nbsp\n      navbox.appendChild(document.createTextNode(four_nbsp))\n\n      var moveLeft = document.createElement('img')\n      //moveLeft.type = \"image\";\n      moveLeft.src = this.resolveUrl('img/Empty.png')\n      moveLeft.id = 'moveLeft'\n      moveLeft.className = 'icon nav'\n      navbox.appendChild(moveLeft)\n      dojo.connect(moveLeft, 'click', this, function (event) {\n        dojo.stopEvent(event)\n        this.view.slide(0.9)\n      })\n\n      var moveRight = document.createElement('img')\n      //moveRight.type = \"image\";\n      moveRight.src = this.resolveUrl('img/Empty.png')\n      moveRight.id = 'moveRight'\n      moveRight.className = 'icon nav'\n      navbox.appendChild(moveRight)\n      dojo.connect(moveRight, 'click', this, function (event) {\n        dojo.stopEvent(event)\n        this.view.slide(-0.9)\n      })\n\n      navbox.appendChild(document.createTextNode(four_nbsp))\n\n      var bigZoomOut = document.createElement('img')\n      //bigZoomOut.type = \"image\";\n      bigZoomOut.src = this.resolveUrl('img/Empty.png')\n      bigZoomOut.id = 'bigZoomOut'\n      bigZoomOut.className = 'icon nav'\n      navbox.appendChild(bigZoomOut)\n      dojo.connect(bigZoomOut, 'click', this, function (event) {\n        dojo.stopEvent(event)\n        this.view.zoomOut(undefined, undefined, 2)\n      })\n\n      var zoomOut = document.createElement('img')\n      //zoomOut.type = \"image\";\n      zoomOut.src = this.resolveUrl('img/Empty.png')\n      zoomOut.id = 'zoomOut'\n      zoomOut.className = 'icon nav'\n      navbox.appendChild(zoomOut)\n      dojo.connect(zoomOut, 'click', this, function (event) {\n        dojo.stopEvent(event)\n        this.view.zoomOut()\n      })\n\n      var zoomIn = document.createElement('img')\n      //zoomIn.type = \"image\";\n      zoomIn.src = this.resolveUrl('img/Empty.png')\n      zoomIn.id = 'zoomIn'\n      zoomIn.className = 'icon nav'\n      navbox.appendChild(zoomIn)\n      dojo.connect(zoomIn, 'click', this, function (event) {\n        dojo.stopEvent(event)\n        this.view.zoomIn()\n      })\n\n      var bigZoomIn = document.createElement('img')\n      //bigZoomIn.type = \"image\";\n      bigZoomIn.src = this.resolveUrl('img/Empty.png')\n      bigZoomIn.id = 'bigZoomIn'\n      bigZoomIn.className = 'icon nav'\n      navbox.appendChild(bigZoomIn)\n      dojo.connect(bigZoomIn, 'click', this, function (event) {\n        dojo.stopEvent(event)\n        this.view.zoomIn(undefined, undefined, 2)\n      })\n\n      navbox.appendChild(document.createTextNode(four_nbsp))\n\n      // default search box is location box\n      var locationMode = ''\n      var locationWidth = '40ex'\n      if (this.config.locationBox === 'separate') {\n        // separate location box\n        locationMode = 'separate-location-box'\n        locationWidth = '25ex'\n      }\n\n      var searchbox = dojo.create(\n        'span',\n        {\n          id: 'search-box',\n          class: locationMode,\n        },\n        navbox,\n      )\n\n      // if we have fewer than 30 ref seqs, or `refSeqDropdown: true` is\n      // set in the config, then put in a dropdown box for selecting\n      // reference sequences\n      var refSeqSelectBoxPlaceHolder = dojo.create(\n        'span',\n        { id: 'search-refseq' },\n        searchbox,\n      )\n\n      // make the location search box\n      this.locationBox = new dijitComboBox(\n        {\n          id: 'location',\n          name: 'location',\n          style: { width: locationWidth },\n          maxLength: 400,\n          searchAttr: 'name',\n          title: 'Enter a chromosomal position, symbol or ID to search',\n        },\n        dojo.create('input', {}, searchbox),\n      )\n\n      this.afterMilestone(\n        'loadNames',\n        dojo.hitch(this, function () {\n          if (this.nameStore) {\n            this.locationBox.set('store', this.nameStore)\n          }\n        }),\n      )\n\n      this.locationBox.focusNode.spellcheck = false\n      dojo.query('div.dijitArrowButton', this.locationBox.domNode).orphan()\n      dojo.connect(\n        this.locationBox.focusNode,\n        'keydown',\n        this,\n        function (event) {\n          if (event.keyCode == keys.ESCAPE) {\n            this.locationBox.set('value', '')\n          } else if (event.keyCode == keys.ENTER) {\n            this.locationBox.closeDropDown(false)\n            this.navigateTo(this.locationBox.get('value'))\n            this.goButton.set('disabled', true)\n            dojo.stopEvent(event)\n          } else {\n            this.goButton.set('disabled', false)\n          }\n        },\n      )\n      dojo.connect(navbox, 'onselectstart', function (evt) {\n        evt.stopPropagation()\n        return true\n      })\n\n      // monkey-patch the combobox code to make a few modifications\n      ;(function () {\n        var PatchedDropDownClass = dojo.declare(\n          this.locationBox.dropDownClass,\n          {\n            // add a moreMatches class to our hacked-in \"more options\" option\n            _createOption: function (item) {\n              var option = this.inherited(arguments)\n              if (item.hitLimit) {dojo.addClass(option, 'moreMatches')}\n              return option\n            },\n            // prevent the \"more matches\" option from being clicked\n            onClick: function (node) {\n              if (dojo.hasClass(node, 'moreMatches')) {return null}\n\n              var ret = this.inherited(arguments)\n              thisB.navigateTo(thisB.locationBox.get('value'))\n              return ret\n            },\n          },\n        )\n        this.locationBox.dropDownClass = PatchedDropDownClass\n      }).call(this)\n\n      // make the 'Go' button\n      this.goButton = new dijitButton(\n        {\n          label: 'Go',\n          onClick: dojo.hitch(this, function (event) {\n            this.navigateTo(this.locationBox.get('value'))\n            this.goButton.set('disabled', true)\n            dojo.stopEvent(event)\n          }),\n          id: 'search-go-btn',\n        },\n        dojo.create('button', {}, searchbox),\n      )\n\n      this.highlightButtonPreviousState = false\n\n      // create location box\n      // if in config \"locationBox\": \"separate\", then the search box will be the location box.\n      if (this.config.locationBox === 'separate') {\n        this.locationInfoBox = domConstruct.place(\n          \"<div id='location-info'>location</div>\",\n          navbox,\n        )\n      }\n\n      // make the highligher button\n      this.highlightButton = new dojoxTriStateCheckBox(\n        {\n          //label: 'Highlight',\n          title: 'Highlight a Region',\n          id: 'highlight-btn',\n          states: [false, true, 'mixed'],\n          onChange: function () {\n            if (this.get('checked') == true) {\n              thisB.view._rubberStop()\n              thisB.view.behaviorManager.swapBehaviors(\n                'normalMouse',\n                'highlightingMouse',\n              )\n            } else if (this.get('checked') == false) {\n              var h = thisB.getHighlight()\n              if (h) {\n                thisB.clearHighlight()\n                thisB.view.redrawRegion(h)\n              }\n            } else {\n              // mixed\n              // Uncheck since user is cycling three-state instead\n              // of programmatically landing in mixed state\n              if (thisB.highlightButtonPreviousState != true) {\n                thisB.highlightButton.set('checked', false)\n              } else {\n                thisB.highlightButtonPreviousState = false\n              }\n              thisB.view._rubberStop()\n              thisB.view.behaviorManager.swapBehaviors(\n                'highlightingMouse',\n                'normalMouse',\n              )\n            }\n          },\n        },\n        dojo.create('button', { id: 'highlight-btn' }, navbox),\n      )\n\n      this.subscribe('/jbrowse/v1/n/globalHighlightChanged', function () {\n        thisB.highlightButton.set('checked', false)\n      })\n\n      this.afterMilestone(\n        'loadRefSeqs',\n        dojo.hitch(this, function () {\n          // make the refseq selection dropdown\n          if (this.refSeqOrder && this.refSeqOrder.length) {\n            var max = this.config.refSeqSelectorMaxSize || 30\n            var numrefs = Math.min(max, this.refSeqOrder.length)\n            var options = []\n            for (var i = 0; i < numrefs; i++) {\n              options.push({\n                label: this.refSeqOrder[i],\n                value: this.refSeqOrder[i],\n              })\n            }\n            var tooManyMessage = '(first ' + numrefs + ' ref seqs)'\n            if (this.refSeqOrder.length > max) {\n              options.push({\n                label: tooManyMessage,\n                value: tooManyMessage,\n                disabled: true,\n              })\n            }\n            this.refSeqSelectBox = new dijitSelectBox({\n              name: 'refseq',\n              value: this.refSeq ? this.refSeq.name : null,\n              options: options,\n              onChange: dojo.hitch(this, function (newRefName) {\n                // don't trigger nav if it's the too-many message\n                if (newRefName == tooManyMessage) {\n                  this.refSeqSelectBox.set('value', this.refSeq.name)\n                  return\n                }\n\n                // only trigger navigation if actually switching sequences\n                if (newRefName != this.refSeq.name) {\n                  this.navigateToLocation({\n                    ref: newRefName,\n                  })\n                }\n              }),\n            }).placeAt(refSeqSelectBoxPlaceHolder)\n          }\n\n          // calculate how big to make the location box:  make it big enough to hold the\n          var locLength =\n            this.config.locationBoxLength ||\n            function () {\n              // if we have no refseqs, just use 20 chars\n              if (!this.refSeqOrder.length) {return 20}\n\n              // if there are not tons of refseqs, pick the longest-named\n              // one.  otherwise just pick the last one\n              var ref =\n                (this.refSeqOrder.length < 1000 &&\n                  function () {\n                    var longestNamedRef\n                    array.forEach(\n                      this.refSeqOrder,\n                      function (name) {\n                        var ref = this.allRefs[name]\n                        if (!ref.length) {ref.length = ref.end - ref.start + 1}\n                        if (\n                          !longestNamedRef ||\n                          longestNamedRef.length < ref.length\n                        )\n                          {longestNamedRef = ref}\n                      },\n                      this,\n                    )\n                    return longestNamedRef\n                  }.call(this)) ||\n                (this.refSeqOrder.length &&\n                  this.allRefs[\n                    this.refSeqOrder[this.refSeqOrder.length - 1]\n                  ]) ||\n                20\n\n              var locstring = Util.assembleLocStringWithLength({\n                ref: ref.name,\n                start: ref.end - 1,\n                end: ref.end,\n                length: ref.length,\n              })\n              //console.log( locstring, locstring.length );\n              return locstring.length\n            }.call(this) ||\n            20\n\n          this.locationBox.domNode.style.width = locLength + 'ex'\n        }),\n      )\n\n      return navbox\n    },\n    /**\n     * Return the current highlight region, or null if none.\n     */\n    getHighlight: function () {\n      return this._highlight || null\n    },\n\n    getBookmarks: function () {\n      if (this.config.bookmarkService) {\n        return request(\n          this.config.bookmarkService +\n            '?' +\n            ioQuery.objectToQuery({\n              sequence: this.refSeq.name,\n              organism: this.config.dataset_id,\n            }),\n          {\n            handleAs: 'json',\n          },\n        )\n      } else {return this.config.bookmarks}\n    },\n\n    /**\n     * Set a new highlight.  Returns the new highlight.\n     */\n    setHighlight: function (newHighlight) {\n      if (newHighlight && newHighlight instanceof Location)\n        {this._highlight = newHighlight}\n      else if (newHighlight) {this._highlight = new Location(newHighlight)}\n\n      this.publish('/jbrowse/v1/n/globalHighlightChanged', [this._highlight])\n\n      return this.getHighlight()\n    },\n\n    _updateHighlightClearButton: function () {\n      var isHighlightSet = !!this._highlight\n      if (this._highlightClearButton) {\n        this._highlightClearButton.set('disabled', !isHighlightSet)\n        //this._highlightClearButton.set( 'label', 'Clear highlight' + ( this._highlight ? ' - ' + this._highlight : '' ));\n      }\n      if (this.highlightButton) {\n        this.highlightButton.set('checked', isHighlightSet ? 'mixed' : false)\n        this.highlightButtonPreviousState = isHighlightSet\n      }\n    },\n\n    clearHighlight: function () {\n      if (this._highlight) {\n        delete this._highlight\n        this.publish('/jbrowse/v1/n/globalHighlightChanged', [])\n      }\n    },\n\n    setHighlightAndRedraw: function (location) {\n      location = this.regularizeLocation(location)\n\n      var oldHighlight = this.getHighlight()\n      if (oldHighlight) {this.view.hideRegion(oldHighlight)}\n      this.view.hideRegion(location)\n      this.setHighlight(location)\n      this.view.showVisibleBlocks(false)\n    },\n\n    /**\n     * Shows a region that has been searched for someplace else in the UI.\n     * Highlights it if this.config.highlightSearchedRegions is true.\n     */\n    showRegionAfterSearch: function (location) {\n      location = this.regularizeLocation(location)\n\n      if (this.config.highlightSearchedRegions) {\n        var oldHighlight = this.getHighlight()\n        if (oldHighlight) {this.view.hideRegion(oldHighlight)}\n        this.view.hideRegion(location)\n        this.setHighlight(location)\n      }\n      this.showRegion(location)\n    },\n    showRegionWithHighlight: function () {\n      // backcompat\n      return this.showRegionAfterSearch.apply(this, arguments)\n    },\n\n    /**\n     * Tear it all down: remove all subscriptions, destroy widgets and DOM\n     */\n    teardown: function () {\n      for (var id in this._subscription) {\n        this._subscription[id].remove()\n      }\n\n      if (this.containerWidget) {this.containerWidget.destroyRecursive(true)}\n\n      while (this.container && this.container.firstChild) {\n        this.container.removeChild(this.container.firstChild)\n      }\n    },\n  })\n})\n\n/*\n\nCopyright (c) 2007-2009 The Evolutionary Software Foundation\n\nCreated by Mitchell Skinner <mitch_skinner@berkeley.edu>\n\nThis package and its accompanying libraries are free software; you can\nredistribute it and/or modify it under the terms of the LGPL (either\nversion 2.1, or at your option, any later version) or the Artistic\nLicense 2.0.  Refer to LICENSE for the full license text.\n\n*/\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/CodonTable.js":{"size":2331,"mtime":1738905961153,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/CodonTable.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/src/JBrowse/Component.js":{"size":3894,"mtime":1738905961165,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Component.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"/**\n * A JBrowse component keeps a reference to the main browser object, and is configurable.\n */\n\ndefine(['dojo/_base/declare', 'dojo/_base/lang', 'JBrowse/Util'], function (\n  declare,\n  lang,\n  Util,\n) {\n  return declare(null, {\n    constructor: function (args) {\n      args = args || {}\n\n      // merge our config with the config defaults\n      this._finalizeConfig(args.config)\n\n      this.browser = args.browser\n      if (!this.browser)\n        {throw 'a reference to the main browser is required by this constructor'}\n\n      this.compiledConfig = {}\n    },\n\n    _finalizeConfig: function (config) {\n      this.config = this._mergeConfigs(\n        dojo.clone(this._defaultConfig()),\n        config || {},\n      )\n    },\n\n    _defaultConfig: function () {\n      return {\n        baseUrl: '/',\n      }\n    },\n\n    resolveUrl: function (url, args) {\n      args = args || {}\n      return Util.resolveUrl(\n        this.getConf('baseUrl', []),\n        this.fillTemplate(url, args),\n      )\n    },\n\n    _mergeConfigs: function (a, b) {\n      if (b === null) {return null}\n      if (a === null) {a = {}}\n\n      for (var prop in b) {\n        if (\n          prop in a &&\n          'object' == typeof b[prop] &&\n          'object' == typeof a[prop]\n        ) {\n          a[prop] = this._mergeConfigs(a[prop], b[prop])\n        } else if (\n          typeof a[prop] == 'undefined' ||\n          typeof b[prop] != 'undefined'\n        ) {\n          a[prop] = b[prop]\n        }\n      }\n      return a\n    },\n\n    _compileConfigurationPath: function (path) {\n      var confVal = this.config\n\n      if (typeof path == 'string') {path = path.split('.')}\n      while (path.length && confVal) {confVal = confVal[path.shift()]}\n\n      if (path.length)\n        {return function () {\n          return null\n        }}\n\n      return typeof confVal == 'function'\n        ? confVal\n        : function () {\n            return confVal\n          }\n    },\n\n    /**\n     * Given a dot-separated string configuration path into the config\n     * (e.g. \"style.bg_color\"), get the value of the configuration.\n     *\n     * If args are given, evaluate the configuration using them.\n     * Otherwise, return a function that returns the value of the\n     * configuration when called.\n     */\n    getConf: function (path, args) {\n      var func = this.compiledConfig[path]\n      if (!func) {\n        func = this.compiledConfig[path] = this._compileConfigurationPath(path)\n      }\n\n      return args ? func.apply(this, args) : func.call(this)\n    },\n\n    /**\n     * Given a string with templating strings like {refseq}, fill them\n     * in using the given values.\n     *\n     * With no additional values given, knows how to interpolate\n     * {refseq}, {refSeq}, {refSeqNum}, and {refSeqNumNoLeadingZeroes}.\n     *\n     * @param {String} str string to interpolate values into\n     * @param {Object} values optional object with additional values that can be interpolated\n     * @returns new string with interpolations\n     */\n    fillTemplate: function (str, values) {\n      // skip if it's not a string or the string has no interpolations\n      if (typeof str != 'string' || str.indexOf('{') == -1) {return str}\n\n      // fill in a bunch of args for this.refSeq or this.ref\n      var templateFillArgs = {\n        refseq:\n          (this.refSeq || {}).name || (this.ref || {}).name || this.ref || '',\n      }\n      templateFillArgs.refSeq = templateFillArgs.refseq\n\n      if (templateFillArgs.refSeq) {\n        templateFillArgs.refSeqNum =\n          (/\\d+/.exec(templateFillArgs.refSeq) || [])[0] || ''\n      }\n      // make refseqNumNoLeadingZeroes\n      if (templateFillArgs.refSeqNum) {\n        templateFillArgs.refSeqNumNoLeadingZeroes =\n          (/^0*(\\d+)/.exec(templateFillArgs.refSeqNum) || [])[1] || ''\n      }\n\n      if (values) {lang.mixin(templateFillArgs, values)}\n\n      return Util.fillTemplate(str, templateFillArgs)\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/ConfigAdaptor/AdaptorUtil.js":{"size":976,"mtime":1738905961170,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/ConfigAdaptor/AdaptorUtil.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojox/lang/functional/object',\n  'dojox/lang/functional/fold',\n], function () {\n  var AdaptorUtil\n  AdaptorUtil = {\n    evalHooks: function (conf) {\n      for (var x in conf) {\n        if (typeof conf[x] == 'object')\n          // recur\n          {conf[x] = this.evalHooks(conf[x])}\n        else if (typeof conf[x] == 'string') {\n          // compile\n          var spec = conf[x]\n          if (/^\\s*function\\s*\\(/.test(spec)) {\n            conf[x] = this.evalHook(spec)\n          }\n        }\n      }\n      return conf\n    },\n\n    evalHook: function () {\n      // can't bind arguments because the closure compiler\n      // renames variables, and we need to assign in the eval\n      if ('string' != typeof arguments[0]) {return arguments[0]}\n      try {\n        eval('arguments[0]=' + arguments[0] + ';')\n      } catch (e) {\n        console.error(e + \" parsing config callback '\" + arguments[0] + \"'\")\n      }\n      return arguments[0]\n    },\n  }\n  return AdaptorUtil\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/ConfigAdaptor/conf.js":{"size":3594,"mtime":1738905961179,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/ConfigAdaptor/conf.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"/**\n * Configuration adaptor for JBrowse's text configuration format.\n * That is, the text configuration format that is not JSON.\n */\ndefine([\n  'dojo/_base/declare',\n  'dojo/_base/lang',\n  'dojo/_base/array',\n  'dojo/json',\n\n  'JBrowse/ConfigAdaptor/JB_json_v1',\n], function (\n  declare,\n  lang,\n  array,\n  JSON,\n\n  JB_json,\n) {\n  return declare([JB_json], {\n    _isAlwaysArray: function (varname) {\n      return { include: true }[varname]\n    },\n\n    parse_conf: function (text, load_args) {\n      var section = [],\n        keypath,\n        operation,\n        value\n      var data = {}\n      var lineNumber\n\n      function recordVal() {\n        if (value !== undefined) {\n          try {\n            var match\n            // parse json\n            if ((match = value.match(/^json:(.+)/i))) {\n              value = JSON.parse(match[1])\n            }\n            // parse numbers if it looks numeric\n            else if (/^[\\+\\-]?[\\d\\.,]+([eE][\\-\\+]?\\d+)?$/.test(value))\n              {value = parseFloat(value.replace(/,/g, ''))}\n\n            var path = section.concat(keypath).join('.')\n            if (operation == '+=') {\n              var existing = lang.getObject(path, false, data)\n              if (existing) {\n                if (!lang.isArray(existing)) {existing = [existing]}\n              } else {\n                existing = []\n              }\n              existing.push(value)\n              value = existing\n            }\n            if (value == 'true') {value = true}\n            if (value == 'false') {value = false}\n            lang.setObject(path, value, data)\n          } catch (e) {\n            throw new Error(\n              'syntax error' +\n                ((load_args.config || {}).url\n                  ? ' in ' + load_args.config.url\n                  : '') +\n                (lineNumber ? ' at line ' + (lineNumber - 1) : ''),\n            )\n          }\n        }\n      }\n\n      array.forEach(\n        text.split('\\n'),\n        function (line, i) {\n          lineNumber = i + 1\n          line = line.replace(/^\\s*#.+/, '')\n          var match\n\n          // new section\n          if ((match = line.match(/^\\s*\\[([^\\]]+)/))) {\n            // new section\n            recordVal()\n            keypath = value = undefined\n            section = match[1].trim().split(/\\s*\\.\\s*/)\n            if (section.length == 1 && section[0].toLowerCase() == 'general')\n              {section = []}\n          }\n          // new value\n          else if (\n            (match = line.match(\n              value == undefined\n                ? /^([^\\+=]+)(\\+?=)(.*)/\n                : /^(\\S[^\\+=]+)(\\+?=)(.*)/,\n            ))\n          ) {\n            recordVal()\n            keypath = match[1].trim().split(/\\s*\\.\\s*/)\n            operation = match[2]\n            if (this._isAlwaysArray(section.concat(keypath).join('.'))) {\n              operation = '+='\n            }\n            value = match[3].trim()\n          }\n          // add to existing array value\n          else if (\n            keypath !== undefined &&\n            (match = line.match(/^\\s{0,4}\\+\\s*(.+)/))\n          ) {\n            recordVal()\n            operation = '+='\n            value = match[1].trim()\n          }\n          // add to existing value\n          else if (value !== undefined && (match = line.match(/^\\s+(\\S.*)/))) {\n            value += value.length ? ' ' + match[1].trim() : match[1].trim()\n          }\n          // done with last value\n          else {\n            recordVal()\n            keypath = value = undefined\n          }\n        },\n        this,\n      )\n\n      recordVal()\n\n      return data\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/ConfigAdaptor/JB_json_v0.js":{"size":1866,"mtime":1738905961183,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/ConfigAdaptor/JB_json_v0.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/src/JBrowse/ConfigAdaptor/JB_json_v1.js":{"size":11212,"mtime":1738905961197,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/ConfigAdaptor/JB_json_v1.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"const hash = cjsRequire('object-hash')\n\ndefine([\n  'dojo/_base/declare',\n  'dojo/_base/lang',\n  'dojo/_base/array',\n  'dojo/_base/json',\n  'dojo/request',\n\n  'JBrowse/Util',\n  'JBrowse/Digest/Crc32',\n], function (\n  declare,\n  lang,\n  array,\n  json,\n  request,\n\n  Util,\n  digest,\n) {\n  var dojof = Util.dojof\n\n  return declare(\n    'JBrowse.ConfigAdaptor.JB_json_v1',\n    null,\n\n    /**\n     * @lends JBrowse.ConfigAdaptor.JB_json_v1.prototype\n     */\n    {\n      /**\n       * Configuration adaptor for JBrowse JSON version 1 configuration\n       * files (formerly known as trackList.json files).\n       * @constructs\n       */\n      constructor: function () {},\n\n      /**\n       * Load the configuration file from a URL.\n       *\n       * @param args.config.url {String} URL for fetching the config file.\n       */\n      load: function (/**Object*/ args) {\n        var that = this\n        if (args.config.url) {\n          var url = Util.resolveUrl(\n            args.baseUrl || window.location.href,\n            args.config.url,\n          )\n          return request(\n            url + (args.config.cacheBuster ? '?v=' + Math.random() : ''),\n            {\n              handleAs: 'text',\n              headers: { 'X-Requested-With': null },\n            },\n          ).then(function (o) {\n            o = that.parse_conf(o, args) || {}\n            o.sourceUrl = url\n            o = that.regularize_conf(o, args)\n            return o\n          })\n        } else if (args.config.data) {\n          return Util.resolved(this.regularize_conf(args.config.data, args))\n        }\n      },\n\n      /**\n       * In this adaptor, just evals the conf text to parse the JSON, but\n       * other conf adaptors might want to inherit and override this.\n       * @param {String} conf_text the configuration text\n       * @param {Object} load_args the arguments that were passed to <code>load()</code>\n       * @returns {Object} the parsed JSON\n       */\n      parse_conf: function (conf_text, load_args) {\n        try {\n          return json.fromJson(conf_text)\n        } catch (e) {\n          throw (\n            e +\n            ' when parsing ' +\n            (load_args.config.url || 'configuration') +\n            '.'\n          )\n        }\n      },\n\n      /**\n       * Applies defaults and any other necessary tweaks to the loaded JSON\n       * configuration.  Called by <code>load()</code> on the JSON\n       * configuration before it calls the <code>onSuccess</code> callback.\n       * @param {Object} o the object containing the configuration, which it\n       *                   modifies in-place\n       * @param {Object} load_args the arguments that were passed to <code>load()</code>\n       * @returns the same object it was passed\n       */\n      regularize_conf: function (o, load_args) {\n        // if tracks is not an array, convert it to one\n        if (o.tracks && !lang.isArray(o.tracks)) {\n          // if it's a single track config, wrap it in an arrayref\n          if (o.tracks.label) {\n            o.tracks = [o.tracks]\n          }\n          // otherwise, coerce it to an array\n          else {\n            var tracks = []\n            for (var label in o.tracks) {\n              if (!('label' in o.tracks[label])) {o.tracks[label].label = label}\n              tracks.push(o.tracks[label])\n            }\n            o.tracks = tracks\n          }\n        }\n\n        // regularize trackMetadata.sources\n        var meta = o.trackMetadata\n        if (meta && meta.sources) {\n          // if it's a single source config, wrap it in an arrayref\n          if (meta.sources.url || typeof meta.sources == 'string') {\n            meta.sources = [meta.sources]\n          }\n\n          if (!lang.isArray(meta.sources)) {\n            var sources = []\n            for (var name in meta.sources) {\n              if (!('name' in meta.sources)) {meta.sources[name].name = name}\n              sources.push(meta.sources[name])\n            }\n            meta.sources = sources\n          }\n\n          // coerce any string source defs to be URLs, and try to detect their types\n          array.forEach(meta.sources, function (sourceDef, i) {\n            if (typeof sourceDef == 'string') {\n              meta.sources[i] = { url: sourceDef }\n              var typeMatch = sourceDef.match(/\\.(\\w+)$/)\n              if (typeMatch) {meta.sources[i].type = typeMatch[1].toLowerCase()}\n            }\n          })\n        }\n\n        o.sourceUrl = o.sourceUrl || load_args.config.url\n        o.baseUrl = o.baseUrl || Util.resolveUrl(o.sourceUrl, '.')\n        if (o.baseUrl.length && !/\\/$/.test(o.baseUrl)) {o.baseUrl += '/'}\n\n        if (o.sourceUrl) {\n          // set a default baseUrl in each of the track and store\n          // confs, and the names conf, if needed\n          var addBase = []\n            .concat(o.tracks || [])\n            .concat(dojof.values(o.stores || {}))\n          if (o.names) {addBase.push(o.names)}\n\n          array.forEach(\n            addBase,\n            function (t) {\n              if (!t.baseUrl) {t.baseUrl = o.baseUrl || '/'}\n            },\n            this,\n          )\n\n          //resolve the refSeqs and nameUrl if present\n          if (o.refSeqs && typeof o.refSeqs == 'string')\n            {o.refSeqs = Util.resolveUrl(o.sourceUrl, o.refSeqs)}\n          if (o.nameUrl) {o.nameUrl = Util.resolveUrl(o.sourceUrl, o.nameUrl)}\n        }\n\n        o = this.regularizeTrackConfigs(o)\n\n        return o\n      },\n      regularizeTrackConfigs: function (conf) {\n        conf.stores = conf.stores || {}\n\n        array.forEach(\n          conf.tracks || [],\n          function (trackConfig) {\n            // if there is a `config` subpart,\n            // just copy its keys in to the\n            // top-level config\n            if (trackConfig.config) {\n              var c = trackConfig.config\n              delete trackConfig.config\n              for (var prop in c) {\n                if (!(prop in trackConfig) && c.hasOwnProperty(prop)) {\n                  trackConfig[prop] = c[prop]\n                }\n              }\n            }\n\n            // skip if it's a new-style track def\n            if (trackConfig.store) {return}\n\n            var trackClassName = this._regularizeClass(\n              'JBrowse/View/Track',\n              {\n                FeatureTrack: 'JBrowse/View/Track/HTMLFeatures',\n                ImageTrack: 'JBrowse/View/Track/FixedImage',\n                'ImageTrack.Wiggle': 'JBrowse/View/Track/FixedImage/Wiggle',\n                SequenceTrack: 'JBrowse/View/Track/Sequence',\n              }[trackConfig.type] || trackConfig.type,\n            )\n            trackConfig.type = trackClassName\n\n            this._synthesizeTrackStoreConfig(conf, trackConfig)\n\n            if (trackConfig.histograms) {\n              if (!trackConfig.histograms.baseUrl)\n                {trackConfig.histograms.baseUrl = trackConfig.baseUrl}\n              this._synthesizeTrackStoreConfig(conf, trackConfig.histograms)\n            }\n          },\n          this,\n        )\n\n        return conf\n      },\n\n      _synthesizeTrackStoreConfig: function (mainconf, trackConfig) {\n        // figure out what data store class to use with the track,\n        // applying some defaults if it is not explicit in the\n        // configuration\n        var urlTemplate = trackConfig.urlTemplate\n        var storeClass = this._regularizeClass(\n          'JBrowse/Store',\n          trackConfig.storeClass\n            ? trackConfig.storeClass\n            : /\\/FixedImage/.test(trackConfig.type)\n              ? 'JBrowse/Store/TiledImage/Fixed' +\n                (trackConfig.backendVersion == 0 ? '_v0' : '')\n              : /\\.jsonz?$/i.test(urlTemplate)\n                ? 'JBrowse/Store/SeqFeature/NCList' +\n                  (trackConfig.backendVersion == 0 ? '_v0' : '')\n                : /\\.bam$/i.test(urlTemplate)\n                  ? 'JBrowse/Store/SeqFeature/BAM'\n                  : /\\.cram$/i.test(urlTemplate)\n                    ? 'JBrowse/Store/SeqFeature/CRAM'\n                    : /\\.gff3?$/i.test(urlTemplate)\n                      ? 'JBrowse/Store/SeqFeature/GFF3'\n                      : /\\.bed$/i.test(urlTemplate)\n                        ? 'JBrowse/Store/SeqFeature/BED'\n                        : /\\.vcf.gz$/i.test(urlTemplate)\n                          ? 'JBrowse/Store/SeqFeature/VCFTabix'\n                          : /\\.gff3?.gz$/i.test(urlTemplate)\n                            ? 'JBrowse/Store/SeqFeature/GFF3Tabix'\n                            : /\\.bed.gz$/i.test(urlTemplate)\n                              ? 'JBrowse/Store/SeqFeature/BEDTabix'\n                              : /\\.(bw|bigwig)$/i.test(urlTemplate)\n                                ? 'JBrowse/Store/SeqFeature/BigWig'\n                                : /\\.(bb|bigbed)$/i.test(urlTemplate)\n                                  ? 'JBrowse/Store/SeqFeature/BigBed'\n                                  : /\\.(fa|fasta)$/i.test(urlTemplate)\n                                    ? 'JBrowse/Store/SeqFeature/IndexedFasta'\n                                    : /\\.(fa|fasta)\\.gz$/i.test(urlTemplate)\n                                      ? 'JBrowse/Store/SeqFeature/BgzipIndexedFasta'\n                                      : /\\.2bit$/i.test(urlTemplate)\n                                        ? 'JBrowse/Store/SeqFeature/TwoBit'\n                                        : /\\/Sequence$/.test(trackConfig.type)\n                                          ? 'JBrowse/Store/Sequence/StaticChunked'\n                                          : null,\n        )\n\n        if (!storeClass) {\n          console.warn(\n            \"Unable to determine an appropriate data store to use with track '\" +\n              trackConfig.label +\n              \"', please explicitly specify a \" +\n              'storeClass in the configuration.',\n          )\n          return\n        }\n\n        // synthesize a separate store conf\n        var storeConf = lang.mixin({}, trackConfig)\n        lang.mixin(storeConf, {\n          type: storeClass,\n        })\n\n        // if this is the first sequence store we see, and we\n        // have no refseqs store defined explicitly, make this the refseqs store.\n        if (\n          (storeClass == 'JBrowse/Store/Sequence/StaticChunked' ||\n            storeClass == 'JBrowse/Store/Sequence/IndexedFasta' ||\n            storeClass == 'JBrowse/Store/SeqFeature/IndexedFasta' ||\n            storeClass == 'JBrowse/Store/SeqFeature/BgzipIndexedFasta' ||\n            storeClass == 'JBrowse/Store/SeqFeature/TwoBit' ||\n            storeClass == 'JBrowse/Store/Sequence/TwoBit' ||\n            trackConfig.useAsRefSeqStore) &&\n          !mainconf.stores['refseqs']\n        ) {\n          storeConf.name = 'refseqs'\n        } else {\n          storeConf.name = 'store' + hash(storeConf)\n        }\n        // record it\n        mainconf.stores[storeConf.name] = storeConf\n\n        // connect it to the track conf\n        trackConfig.store = storeConf.name\n      },\n\n      _regularizeClass: function (root, class_) {\n        if (!class_) {return null}\n\n        // prefix the class names with JBrowse/* if they contain no slashes\n        if (!/\\//.test(class_)) {class_ = root + '/' + class_}\n        class_ = class_.replace(/^\\//)\n        return class_\n      },\n    },\n  )\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/ConfigManager.js":{"size":9909,"mtime":1738905961220,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/ConfigManager.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'dojo/_base/lang',\n  'dojo/_base/array',\n  'dojo/Deferred',\n  'dojo/promise/all',\n  'JBrowse/Util',\n  'JBrowse/ConfigAdaptor/AdaptorUtil',\n], function (declare, lang, array, Deferred, all, Util, AdaptorUtil) {\n  return declare(\n    null,\n\n    /**\n     * @lends JBrowse.ConfigManager.prototype\n     */\n    {\n      /**\n       * @constructs\n       */\n      constructor: function (args) {\n        this.bootConfig = lang.clone(args.bootConfig || {})\n        this.defaults = lang.clone(args.defaults || {})\n        this.browser = args.browser\n        this.skipValidation = args.skipValidation\n\n        this.bootConfig = this._regularizeIncludes([this.bootConfig])[0]\n        if (this.bootConfig.cacheBuster === false) {\n          this.bootConfig.cacheBuster = false\n        } else {\n          this.bootConfig.cacheBuster = true\n        }\n        var thisB = this\n        this._getConfigAdaptor(this.bootConfig).then(function (adaptor) {\n          thisB.bootConfig = adaptor.regularizeTrackConfigs(thisB.bootConfig)\n        })\n\n        // this.topLevelIncludes = this._fillTemplates(\n        //     lang.clone( this.config.include || this.defaults.include ),\n        //     this._applyDefaults( lang.clone( this.config ), this.defaults )\n        // );\n        // delete this.defaults.include;\n        // delete this.config.include;\n      },\n\n      /**\n       * @param callback {Function} callback, receives a single arguments,\n       * which is the final processed configuration object\n       */\n      getFinalConfig: function () {\n        return (\n          this.finalConfig ||\n          (this.finalConfig = function () {\n            var thisB = this\n            var bootstrapConf = this._applyDefaults(\n              lang.clone(this.bootConfig),\n              this.defaults,\n            )\n            return this._loadIncludes(bootstrapConf).then(\n              function (includedConfig) {\n                // merge the boot config *into* the included config last, so\n                // that values in the boot config override the others\n                var finalConf = thisB._mergeConfigs(\n                  includedConfig,\n                  thisB.bootConfig,\n                )\n\n                thisB._fillTemplates(finalConf, finalConf)\n\n                finalConf = AdaptorUtil.evalHooks(finalConf)\n\n                if (!thisB.skipValidation) {thisB._validateConfig(finalConf)}\n\n                return finalConf\n              },\n            )\n          }.call(this))\n        )\n      },\n\n      /**\n       * Instantiate the right config adaptor for a given configuration source.\n       * @param {Object} config the configuraiton\n       * @param {Function} callback called with the new config object\n       * @returns {Object} the right configuration adaptor to use, or\n       * undefined if one could not be found\n       * @private\n       */\n\n      _getConfigAdaptor: function (config_def, callback) {\n        var adaptor_name = 'JBrowse/ConfigAdaptor/' + config_def.format\n        if ('version' in config_def) {adaptor_name += '_v' + config_def.version}\n        adaptor_name.replace(/\\W/g, '')\n        return Util.loadJS([adaptor_name]).then(function (modules) {\n          return new modules[0](config_def)\n        })\n      },\n\n      _fillTemplates: function (subconfig, config) {\n        // skip \"menuTemplate\" keys to prevent messing\n        // up their feature-based {} interpolation\n        //var skip = { menuTemplate: true };\n        var skip = {}\n\n        var type = typeof subconfig\n        if (lang.isArray(subconfig)) {\n          for (var i = 0; i < subconfig.length; i++)\n            {subconfig[i] = this._fillTemplates(subconfig[i], config)}\n        } else if (type == 'object') {\n          for (var name in subconfig) {\n            if (subconfig.hasOwnProperty(name) && !skip[name])\n              {subconfig[name] = this._fillTemplates(subconfig[name], config)}\n          }\n        } else if (type == 'string') {\n          return Util.fillTemplate(subconfig, config)\n        }\n\n        return subconfig\n      },\n\n      /**\n       * Recursively fetch, parse, and merge all the includes in the given\n       * config object.  Calls the callback with the resulting configuration\n       * when finished.\n       * @private\n       */\n      _loadIncludes: function (inputConfig) {\n        var thisB = this\n        inputConfig = lang.clone(inputConfig)\n\n        function _loadRecur(config, upstreamConf) {\n          var sourceUrl = config.sourceUrl || config.baseUrl\n          var newUpstreamConf = thisB._mergeConfigs(\n            lang.clone(upstreamConf),\n            config,\n          )\n          var includes = thisB._fillTemplates(\n            thisB._regularizeIncludes(config.include || []),\n            newUpstreamConf,\n          )\n          delete config.include\n\n          var loads = includes.map(include => {\n            include.cacheBuster = inputConfig.cacheBuster\n            return thisB\n              ._loadInclude(include, sourceUrl)\n              .then(includedData => _loadRecur(includedData, newUpstreamConf))\n          })\n          return all(loads).then(function (includedDataObjects) {\n            array.forEach(includedDataObjects, function (includedData) {\n              config = thisB._mergeConfigs(config, includedData)\n            })\n            return config\n          })\n        }\n\n        return _loadRecur(inputConfig, {})\n      },\n\n      _loadInclude: function (include, baseUrl) {\n        var thisB = this\n        // instantiate the adaptor and load the config\n        return this._getConfigAdaptor(include)\n          .then(function (adaptor) {\n            if (!adaptor)\n              {throw new Error(\n                'Could not load config ' +\n                  include.url +\n                  ', ' +\n                  'no configuration adaptor found for config format ' +\n                  include.format +\n                  ' version ' +\n                  include.version,\n              )}\n\n            return adaptor.load({\n              config: include,\n              baseUrl: baseUrl,\n            })\n          })\n          .then(null, function (error) {\n            try {\n              if (error.response.status == 404) {return {}}\n            } catch (e) {}\n\n            throw error\n          })\n      },\n\n      _regularizeIncludes: function (includes) {\n        if (!includes) {return []}\n\n        // coerce include to an array\n        if (typeof includes != 'object') {includes = [includes]}\n\n        // include array might have undefined elements in it if\n        // somebody left a trailing comma in and we are running under\n        // IE\n        includes = array.filter(includes, function (r) {\n          return r\n        })\n\n        return array.map(includes, function (include) {\n          // coerce bare strings in the includes to URLs\n          if (typeof include == 'string') {include = { url: include }}\n\n          // set defaults for format and version\n          if (!('format' in include)) {\n            include.format = /\\.conf$/.test(include.url) ? 'conf' : 'JB_json'\n          }\n          if (include.format == 'JB_json' && !('version' in include)) {\n            include.version = 1\n          }\n          return include\n        })\n      },\n\n      /**\n       * @private\n       */\n      _applyDefaults: function (config, defaults) {\n        return Util.deepUpdate(dojo.clone(defaults), config)\n      },\n\n      /**\n       * Examine the loaded and merged configuration for errors.  Throws\n       * exceptions if it finds anything amiss.\n       * @private\n       * @returns nothing meaningful\n       */\n      _validateConfig: function (c) {\n        if (!c.tracks) {c.tracks = []}\n        if (!c.baseUrl) {\n          this._fatalError('Must provide a `baseUrl` in configuration')\n        }\n        if (this.hasFatalErrors) {throw 'Errors in configuration, cannot start.'}\n      },\n\n      /**\n       * @private\n       */\n      _fatalError: function (error) {\n        this.hasFatalErrors = true\n        // if( error.url )\n        //     error = error + ' when loading '+error.url;\n        this.browser.fatalError(error)\n      },\n\n      // list of config properties that should not be recursively merged\n      _noRecursiveMerge: function (propName) {\n        return propName == 'datasets'\n      },\n\n      /**\n       * Merges config object b into a.  a <- b\n       * @private\n       */\n      _mergeConfigs: function (a, b) {\n        if (b === null) {return null}\n\n        if (a === null) {a = {}}\n\n        for (var prop in b) {\n          if (prop == 'tracks' && prop in a) {\n            a[prop] = this._mergeTrackConfigs(a[prop] || [], b[prop] || [])\n          } else if (\n            !this._noRecursiveMerge(prop) &&\n            prop in a &&\n            'object' == typeof b[prop] &&\n            'object' == typeof a[prop]\n          ) {\n            a[prop] = Util.deepUpdate(a[prop], b[prop])\n          } else if (prop == 'dataRoot') {\n            if (\n              a[prop] === undefined ||\n              (a[prop] == 'data' && b[prop] !== undefined)\n            ) {\n              a[prop] = b[prop]\n            }\n          } else if (a[prop] === undefined || b[prop] !== undefined) {\n            a[prop] = b[prop]\n          }\n        }\n        return a\n      },\n\n      /**\n       * Special-case merging of two <code>tracks</code> configuration\n       * arrays.\n       * @private\n       */\n      _mergeTrackConfigs: function (a, b) {\n        if (!b.length) {return a}\n\n        // index the tracks in `a` by track label\n        var aTracks = {}\n        array.forEach(a, function (t, i) {\n          t.index = i\n          aTracks[t.label] = t\n        })\n\n        array.forEach(\n          b,\n          function (bT) {\n            var aT = aTracks[bT.label]\n            if (aT) {\n              this._mergeConfigs(aT, bT)\n            } else {\n              a.push(bT)\n            }\n          },\n          this,\n        )\n\n        return a\n      },\n    },\n  )\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/Digest/Crc32.js":{"size":4427,"mtime":1738905961228,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Digest/Crc32.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/src/JBrowse/Errors.js":{"size":1126,"mtime":1738905961233,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Errors.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"/**\n * All of the different JBrowse Error objects.  This amounts to a\n * taxonomy of the different errors that JBrowse code can reason\n * about.\n */\ndefine(['dojo/_base/declare'], function (declare) {\n  var Base = declare(Error, {\n    constructor: function (args) {\n      if (typeof args == 'object') {\n        if (args instanceof Error) {\n          this._originalError = args\n          this.message = '' + args\n          this.stack = args.stack\n        } else {dojo.mixin(this, args)}\n      } else if (typeof args == 'string') {\n        this._originalError = new Error()\n        this.message = args\n        this.stack = this._originalError.stack\n      }\n\n      if (!this.message) {this.message = this._defaultMessage}\n    },\n  })\n\n  var Errors = {}\n\n  Errors.Fatal = declare(Base, {\n    _defaultMessage: 'Unknown fatal error.',\n  })\n\n  /**\n   * Took too long to handle data.\n   */\n  Errors.TimeOut = declare(Base, {\n    _defaultMessage: 'Data took too long to fetch.',\n  })\n\n  /**\n   * Too much data to handle.\n   */\n  Errors.DataOverflow = declare(Base, {\n    _defaultMessage: 'Too much data to show.',\n  })\n\n  return Errors\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/FeatureFiltererMixin.js":{"size":2774,"mtime":1738905961240,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/FeatureFiltererMixin.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"/**\n * Mixin that dynamically defines and redefines a filterFeature()\n * method, and supports a filtering hierarchy, and filter chaining at\n * each level of the hierarchy.  Designed to be really fast, because\n * filterFeature() is going to be called many, many times.\n */\ndefine(['dojo/_base/declare', 'dojo/_base/array'], function (declare, array) {\n  var serialNumber = 0\n\n  return declare(null, {\n    filterFeature: function (feature) {\n      return true\n    },\n\n    _featureFilterChain: [],\n\n    addFeatureFilter: function (filter, uniqName) {\n      uniqName = this._getFeatureFilterName(uniqName)\n      this._featureFilterChain.push({ name: uniqName, filter: filter })\n      this._buildFeatureFilter()\n      return uniqName\n    },\n\n    // need to have a unique name for every function we're passed so\n    // that we can tell them apart.  stringification and strict\n    // equality don't always work.\n    _getFeatureFilterName: function (uniqName) {\n      if (uniqName === undefined) {return 'featureFilter_' + ++serialNumber}\n      return uniqName\n    },\n\n    removeFeatureFilter: function (uniqName) {\n      var newchain = []\n      for (var i = 0; i < this._featureFilterChain.length; i++) {\n        if (this._featureFilterChain[i].name !== uniqName)\n          {newchain.push(this._featureFilterChain[i])}\n      }\n      this._featureFilterChain = newchain\n      this._buildFeatureFilter()\n    },\n\n    _buildFeatureFilter: function () {\n      var filterChain = this._featureFilterChain.slice()\n\n      if (!filterChain.length)\n        {this.filterFeature = function (feat) {\n          return this.featureFilterParentComponent.filterFeature(feat)\n        }}\n      else if (filterChain.length == 1) {\n        var single = filterChain[0].filter\n        this.filterFeature = function (feat) {\n          return (\n            single.call(this, feat) &&\n            this.featureFilterParentComponent.filterFeature(feat)\n          )\n        }\n      } else\n        {this.filterFeature = function (feat) {\n          for (var i = 0; i < filterChain.length; i++)\n            {if (!filterChain[i].filter.call(this, feat)) {return false}}\n\n          if (!this.featureFilterParentComponent.filterFeature(feat))\n            {return false}\n\n          return true\n        }}\n    },\n\n    featureFilterParentComponent: {\n      filterFeature: function () {\n        return true\n      },\n    },\n\n    setFeatureFilter: function (filter, uniqName) {\n      this._featureFilterChain = []\n      this.addFeatureFilter(filter, uniqName)\n    },\n\n    clearFeatureFilter: function () {\n      this._featureFilterChain = []\n      this._buildFeatureFilter()\n    },\n\n    setFeatureFilterParentComponent: function (parent) {\n      this.featureFilterParentComponent = parent\n      this._buildFeatureFilter()\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/Finisher.js":{"size":450,"mtime":1738905961243,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Finisher.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/src/JBrowse/GenomeView.js":{"size":94795,"mtime":1738905961378,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/GenomeView.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"import normalizeWheel from 'normalize-wheel'\ndefine([\n  'dojo/_base/declare',\n  'dojo/_base/array',\n  'dojo/dom-construct',\n  'JBrowse/Util',\n  'JBrowse/has',\n  'dojo/dnd/move',\n  'dojo/dnd/Source',\n  'dijit/focus',\n  'JBrowse/Component',\n  'JBrowse/FeatureFiltererMixin',\n  'JBrowse/View/Track/LocationScale',\n  'JBrowse/View/Track/GridLines',\n  'JBrowse/BehaviorManager',\n  'JBrowse/View/Animation/Zoomer',\n  'JBrowse/View/Animation/Slider',\n  'JBrowse/View/InfoDialog',\n], function (\n  declare,\n  array,\n  domConstruct,\n  Util,\n  has,\n  dndMove,\n  dndSource,\n  dijitFocus,\n  Component,\n  FeatureFiltererMixin,\n  LocationScaleTrack,\n  GridLinesTrack,\n  BehaviorManager,\n  Zoomer,\n  Slider,\n  InfoDialog,\n) {\n  var dojof = Util.dojof\n\n  // weird subclass of dojo dnd constrained mover to make the location\n  // thumb behave better\n  var locationThumbMover = declare(dndMove.constrainedMoveable, {\n    constructor: function (node, params) {\n      this.constraints = function () {\n        var n = this.node.parentNode,\n          mb = dojo.marginBox(n)\n        mb.t = 0\n        return mb\n      }\n    },\n  })\n\n  /**\n   * Main view class, shows a scrollable, horizontal view of annotation\n   * tracks.  NOTE: All coordinates are interbase.\n   * @class\n   * @constructor\n   */\n\n  return declare([Component, FeatureFiltererMixin], {\n    constructor: function (args) {\n      var browser = args.browser\n      var elem = args.elem\n      var stripeWidth = args.stripeWidth\n      var refseq = args.refSeq\n      var zoomLevel = args.zoomLevel\n      this.desiredTracks = {}\n      // keep a reference to the main browser object\n      this.browser = browser\n      this.setFeatureFilterParentComponent(this.browser)\n\n      this.focusTrack = null\n\n      //the page element that the GenomeView lives in\n      this.elem = elem\n\n      this.posHeight = this.calculatePositionLabelHeight(elem)\n      // Add an arbitrary 50% padding between the position labels and the\n      // topmost track\n      this.topSpace = this.posHeight * 1.5\n\n      // handle trackLabels option\n      if (\n        typeof browser.config.trackLabels !== 'undefined' &&\n        browser.config.trackLabels === 'no-block'\n      ) {\n        this.config.trackPadding = 35\n        this.topSpace = this.posHeight * 3\n      }\n\n      // WebApollo needs max zoom level to be sequence residues char width\n      this.maxPxPerBp = this.config.maxPxPerBp\n\n      //the reference sequence\n      this.ref = refseq\n      //current scale, in pixels per bp\n      this.pxPerBp = zoomLevel\n\n      //width, in pixels, of the vertical stripes\n      this.stripeWidth = stripeWidth\n\n      // the scrollContainer is the element that changes position\n      // when the user scrolls\n      this.scrollContainer = dojo.create(\n        'div',\n        {\n          id: 'container',\n          style: { position: 'absolute', left: '0px', top: '0px' },\n        },\n        elem,\n      )\n\n      this._renderVerticalScrollBar()\n\n      // we have a separate zoomContainer as a child of the scrollContainer.\n      // they used to be the same element, but making zoomContainer separate\n      // enables it to be narrower than this.elem.\n      this.zoomContainer = document.createElement('div')\n      this.zoomContainer.id = 'zoomContainer'\n      this.zoomContainer.style.cssText =\n        'position: absolute; left: 0px; top: 0px; height: 100%;'\n      this.scrollContainer.appendChild(this.zoomContainer)\n\n      this.outerTrackContainer = document.createElement('div')\n      this.outerTrackContainer.className = 'trackContainer outerTrackContainer'\n      this.outerTrackContainer.style.cssText = 'height: 100%;'\n      this.zoomContainer.appendChild(this.outerTrackContainer)\n\n      this.trackContainer = document.createElement('div')\n      this.trackContainer.className =\n        'trackContainer innerTrackContainer draggable'\n      this.trackContainer.style.cssText = 'height: 100%;'\n      this.outerTrackContainer.appendChild(this.trackContainer)\n\n      //width, in pixels of the \"regular\" (not min or max zoom) stripe\n      this.regularStripe = stripeWidth\n\n      this.overview = this.browser.overviewDiv\n      this.overviewBox = dojo.marginBox(this.overview)\n\n      this.tracks = []\n      this.uiTracks = []\n      this.trackIndices = {}\n\n      //set up size state (zoom levels, stripe percentage, etc.)\n      this.sizeInit()\n\n      //distance, in pixels, from the beginning of the reference sequence\n      //to the beginning of the first active stripe\n      //  should always be a multiple of stripeWidth\n      this.offset = 0\n      //largest value for the sum of this.offset and this.getX()\n      //this prevents us from scrolling off the right end of the ref seq\n      this.maxLeft = this.bpToPx(this.ref.end + 1) - this.getWidth()\n      //smallest value for the sum of this.offset and this.getX()\n      //this prevents us from scrolling off the left end of the ref seq\n      this.minLeft = this.bpToPx(this.ref.start)\n      //extra margin to draw around the visible area, in multiples of the visible area\n      //0: draw only the visible area; 0.1: draw an extra 10% around the visible area, etc.\n      this.drawMargin = 0.2\n      //slide distance (pixels) * slideTimeMultiple + 200 = milliseconds for slide\n      //1=1 pixel per millisecond average slide speed, larger numbers are slower\n      this.slideTimeMultiple = 0.8\n      this.trackHeights = []\n      this.trackTops = []\n      this.waitElems = dojo.filter(\n        [\n          dojo.byId('moveLeft'),\n          dojo.byId('moveRight'),\n          dojo.byId('zoomIn'),\n          dojo.byId('zoomOut'),\n          dojo.byId('bigZoomIn'),\n          dojo.byId('bigZoomOut'),\n          document.body,\n          elem,\n        ],\n        function (e) {\n          return e\n        },\n      )\n      this.prevCursors = []\n      this.locationThumb = document.createElement('div')\n      this.locationThumb.className = 'locationThumb'\n      this.overview.appendChild(this.locationThumb)\n      this.locationThumbMover = new locationThumbMover(this.locationThumb, {\n        area: 'content',\n        within: true,\n      })\n\n      this.x = this.elem.scrollLeft\n      this.y = 0\n\n      var scaleTrackDiv = document.createElement('div')\n      scaleTrackDiv.className = 'track static_track rubberBandAvailable'\n      scaleTrackDiv.style.height = this.posHeight + 'px'\n      scaleTrackDiv.id = 'static_track'\n\n      this.scaleTrackDiv = scaleTrackDiv\n      this.staticTrack = new LocationScaleTrack({\n        label: 'static_track',\n        labelClass: 'pos-label',\n        posHeight: this.posHeight,\n        browser: this.browser,\n        refSeq: this.ref,\n      })\n      this.staticTrack.setViewInfo(\n        this,\n        function (height) {},\n        this.stripeCount,\n        this.scaleTrackDiv,\n        this.stripePercent,\n        this.stripeWidth,\n        this.pxPerBp,\n        this.config.trackPadding,\n      )\n      this.zoomContainer.appendChild(this.scaleTrackDiv)\n      this.waitElems.push(this.scaleTrackDiv)\n\n      var gridTrackDiv = document.createElement('div')\n      gridTrackDiv.className = 'track'\n      gridTrackDiv.style.cssText = 'top: 0px; height: 100%;'\n      gridTrackDiv.id = 'gridtrack'\n      var gridTrack = new GridLinesTrack({\n        browser: this.browser,\n        refSeq: this.ref,\n      })\n      gridTrack.setViewInfo(\n        this,\n        function (height) {},\n        this.stripeCount,\n        gridTrackDiv,\n        this.stripePercent,\n        this.stripeWidth,\n        this.pxPerBp,\n        this.config.trackPadding,\n      )\n      this.trackContainer.appendChild(gridTrackDiv)\n      this.uiTracks = [this.staticTrack, gridTrack]\n\n      // accept tracks being dragged into this\n      this.trackDndWidget = new dndSource(this.trackContainer, {\n        accept: ['track'], //accepts only tracks into the viewing field\n        withHandles: true,\n        creator: dojo.hitch(this, function (trackConfig, hint) {\n          return {\n            data: trackConfig,\n            type: ['track'],\n            node:\n              hint == 'avatar'\n                ? dojo.create('div', {\n                    innerHTML: trackConfig.key || trackConfig.label,\n                    className: 'track-label dragging',\n                  })\n                : this.renderTrack(trackConfig),\n          }\n        }),\n      })\n\n      // subscribe to showTracks commands\n      this.browser.subscribe(\n        '/dnd/drop',\n        dojo.hitch(this, function (source, nodes, copy, target) {\n          this.updateTrackList()\n          if (target.node === this.trackContainer) {\n            // if dragging into the trackcontainer, we are showing some tracks\n            // get the configs from the tracks being dragged in\n            var confs = dojo.filter(\n              dojo.map(nodes, function (n) {\n                return n.track && n.track.config\n              }),\n              function (c) {\n                return c\n              },\n            )\n            this.browser.publish('/jbrowse/v1/v/tracks/show', confs)\n          }\n        }),\n      )\n      this.browser.subscribe(\n        '/jbrowse/v1/c/tracks/show',\n        dojo.hitch(this, 'showTracks'),\n      )\n      this.browser.subscribe(\n        '/jbrowse/v1/c/tracks/hide',\n        dojo.hitch(this, 'hideTracks'),\n      )\n      this.browser.subscribe(\n        '/jbrowse/v1/c/tracks/replace',\n        dojo.hitch(this, 'replaceTracks'),\n      )\n      this.browser.subscribe(\n        '/jbrowse/v1/c/tracks/delete',\n        dojo.hitch(this, 'hideTracks'),\n      )\n      this.browser.subscribe(\n        '/jbrowse/v1/c/tracks/pin',\n        dojo.hitch(this, 'pinTracks'),\n      )\n      this.browser.subscribe(\n        '/jbrowse/v1/c/tracks/unpin',\n        dojo.hitch(this, 'unpinTracks'),\n      )\n\n      // render our UI tracks (horizontal scale tracks, grid lines, and so forth)\n      dojo.forEach(\n        this.uiTracks,\n        function (track) {\n          track.showRange(\n            0,\n            this.stripeCount - 1,\n            Math.round(this.pxToBp(this.offset)),\n            Math.round(this.stripeWidth / this.pxPerBp),\n            this.pxPerBp,\n          )\n        },\n        this,\n      )\n\n      this.addOverviewTrack(\n        new LocationScaleTrack({\n          label: 'overview_loc_track',\n          labelClass: 'overview-pos',\n          posHeight: this.overviewPosHeight,\n          browser: this.browser,\n          refSeq: this.ref,\n        }),\n      )\n      this.showFine()\n      this.showCoarse()\n\n      // initialize the behavior manager used for setting what this view\n      // does (i.e. the behavior it has) for mouse and keyboard events\n      this.behaviorManager = new BehaviorManager({\n        context: this,\n        behaviors: this._behaviors(),\n      })\n      this.behaviorManager.initialize()\n    },\n\n    _defaultConfig: function () {\n      return {\n        maxPxPerBp: 20,\n        trackPadding: 20, // distance in pixels between each track\n      }\n    },\n\n    /**\n     * @returns {Object} containing ref, start, and end members for the currently displayed location\n     */\n    visibleRegion: function () {\n      return {\n        ref: this.ref.name,\n        start: this.minVisible(),\n        end: this.maxVisible(),\n      }\n    },\n\n    /**\n     * @returns {String} locstring representation of the current location<br>\n     * (suitable for passing to the browser's navigateTo)\n     */\n    visibleRegionLocString: function () {\n      return Util.assembleLocString(this.visibleRegion())\n    },\n\n    /**\n     * Create and place the elements for the vertical scrollbar.\n     * @private\n     */\n    _renderVerticalScrollBar: function () {\n      var container = dojo.create(\n        'div',\n        {\n          className: 'vertical_scrollbar',\n          style: {\n            position: 'absolute',\n            right: '0px',\n            bottom: '0px',\n            height: '100%',\n            width: '10px',\n            zIndex: 1000,\n          },\n        },\n        this.browser.container,\n      )\n\n      var positionMarker = dojo.create(\n        'div',\n        {\n          className: 'vertical_position_marker',\n          style: {\n            position: 'absolute',\n            height: '100%',\n          },\n        },\n        container,\n      )\n      this.verticalScrollBar = {\n        container: container,\n        positionMarker: positionMarker,\n        width: container.offsetWidth,\n      }\n    },\n\n    /**\n     * Update the position and look of the vertical scroll bar as our\n     * y-scroll offset changes.\n     * @private\n     */\n    _updateVerticalScrollBar: function (newDims) {\n      if (typeof newDims.height == 'number') {\n        var heightAdjust = this.staticTrack\n          ? -this.staticTrack.div.offsetHeight\n          : 0\n        var trackPaneHeight = newDims.height + heightAdjust\n        this.verticalScrollBar.container.style.height =\n          trackPaneHeight -\n          (this.pinUnderlay\n            ? this.pinUnderlay.offsetHeight + heightAdjust\n            : 0) +\n          'px'\n        var markerHeight = (newDims.height / (this.containerHeight || 1)) * 100\n        this.verticalScrollBar.positionMarker.style.height =\n          markerHeight > 0.5 ? markerHeight + '%' : '1px'\n        if (newDims.height / (this.containerHeight || 1) > 0.98) {\n          this.verticalScrollBar.container.style.display = 'none'\n          this.verticalScrollBar.visible = false\n        } else {\n          this.verticalScrollBar.container.style.display = 'block'\n          this.verticalScrollBar.visible = true\n        }\n      }\n\n      if (typeof newDims.y == 'number' || typeof newDims.height == 'number') {\n        this.verticalScrollBar.positionMarker.style.top =\n          (((newDims.y || this.getY() || 0) / (this.containerHeight || 1)) *\n            100 || 0) + '%'\n      }\n    },\n\n    verticalScrollBarVisibleWidth: function () {\n      return (\n        (this.verticalScrollBar.visible && this.verticalScrollBar.width) || 0\n      )\n    },\n\n    /**\n     * @returns {Array[Track]} of the tracks that are currently visible in\n     * this genomeview\n     */\n    visibleTracks: function () {\n      return this.tracks\n    },\n\n    /**\n     *  @returns {Array[String]} of the names of tracks that are currently visible in this genomeview\n     */\n    visibleTrackNames: function () {\n      return dojo.map(this.visibleTracks(), function (t) {\n        return t.name\n      })\n    },\n\n    /**\n     * Called in response to a keyboard or mouse event to slide the view\n     * left or right.\n     */\n    keySlideX: function (offset) {\n      this.setX(this.getX() + offset)\n\n      var thisB = this\n      if (!this._keySlideTimeout)\n        {this._keySlideTimeout = window.setTimeout(function () {\n          thisB.afterSlide()\n          delete thisB._keySlideTimeout\n        }, 300)}\n    },\n\n    /**\n     * Behaviors (event handler bundles) for various states that the\n     * GenomeView might be in.\n     * @private\n     * @returns {Object} description of behaviors\n     */\n    _behaviors: function () {\n      return {\n        // behaviors that don't change\n        always: {\n          apply_on_init: true,\n          apply: function () {\n            var handles = []\n            handles.push(\n              dojo.connect(\n                this.overview,\n                'mousedown',\n                dojo.hitch(\n                  this,\n                  'startRubberZoom',\n                  dojo.hitch(this, 'overview_absXtoBp'),\n                  this.overview,\n                  this.overview,\n                ),\n              ),\n            )\n            var wheelevent =\n              'onwheel' in document.createElement('div')\n                ? 'wheel'\n                : document.onmousewheel !== undefined\n                  ? 'mousewheel'\n                  : 'DOMMouseScroll'\n            handles.push(\n              dojo.connect(\n                this.scrollContainer,\n                wheelevent,\n                this,\n                'wheelScroll',\n                false,\n              ),\n\n              dojo.connect(\n                this.verticalScrollBar.container,\n                'onclick',\n                this,\n                'scrollBarClickScroll',\n                false,\n              ),\n\n              dojo.connect(\n                this.scaleTrackDiv,\n                'mousedown',\n                dojo.hitch(\n                  this,\n                  'startRubberZoom',\n                  dojo.hitch(this, 'absXtoBp'),\n                  this.scrollContainer,\n                  this.scaleTrackDiv,\n                ),\n              ),\n\n              dojo.connect(\n                this.outerTrackContainer,\n                'dblclick',\n                this,\n                'doubleClickZoom',\n              ),\n\n              dojo.connect(\n                this.locationThumbMover,\n                'onMoveStop',\n                this,\n                'thumbMoved',\n              ),\n\n              dojo.connect(this.overview, 'onclick', this, 'overviewClicked'),\n\n              dojo.connect(this.scaleTrackDiv, 'onclick', this, 'scaleClicked'),\n              dojo.connect(\n                this.scaleTrackDiv,\n                'mouseover',\n                this,\n                'scaleMouseOver',\n              ),\n              dojo.connect(\n                this.scaleTrackDiv,\n                'mouseout',\n                this,\n                'scaleMouseOut',\n              ),\n              dojo.connect(\n                this.scaleTrackDiv,\n                'mousemove',\n                this,\n                'scaleMouseMove',\n              ),\n\n              dojo.connect(document.body, 'onkeyup', this, function (evt) {\n                if (evt.keyCode == dojo.keys.SHIFT)\n                  // shift\n                  {this.behaviorManager.swapBehaviors(\n                    'shiftMouse',\n                    'normalMouse',\n                  )}\n              }),\n              dojo.connect(window, 'blur', this, function (evt) {\n                // Simulate releasing shift if user switches tabs with ctrl+shift+tab\n                this.behaviorManager.swapBehaviors('shiftMouse', 'normalMouse')\n              }),\n              dojo.connect(document.body, 'onkeydown', this, function (evt) {\n                if (evt.keyCode == dojo.keys.SHIFT)\n                  // shift\n                  {this.behaviorManager.swapBehaviors(\n                    'normalMouse',\n                    'shiftMouse',\n                  )}\n              }),\n\n              // scroll the view around in response to keyboard arrow keys\n              dojo.connect(document.body, 'onkeypress', this, function (evt) {\n                // if some digit widget is focused, don't move the\n                // genome view with arrow keys\n                if (dijitFocus.curNode) {return}\n\n                var that = this\n                if (\n                  evt.keyCode == dojo.keys.LEFT_ARROW ||\n                  evt.keyCode == dojo.keys.RIGHT_ARROW\n                ) {\n                  var offset = evt.keyCode == dojo.keys.LEFT_ARROW ? -40 : 40\n                  if (evt.shiftKey) {offset *= 5}\n                  this.keySlideX(offset)\n                } else if (\n                  evt.keyCode == dojo.keys.DOWN_ARROW ||\n                  evt.keyCode == dojo.keys.UP_ARROW\n                ) {\n                  // shift-up/down zooms in and out\n                  if (evt.shiftKey) {\n                    this[\n                      evt.keyCode == dojo.keys.UP_ARROW ? 'zoomIn' : 'zoomOut'\n                    ](evt, 0.5, evt.altKey ? 2 : 1)\n                  }\n                  // without shift, scrolls up and down\n                  else {\n                    var offset = evt.keyCode == dojo.keys.UP_ARROW ? -40 : 40\n                    this.setY(this.getY() + offset)\n                  }\n                }\n              }),\n\n              // when the track pane is clicked, unfocus any dijit\n              // widgets that would otherwise not give up the focus\n              dojo.connect(\n                this.scrollContainer,\n                'onclick',\n                this,\n                function (evt) {\n                  dijitFocus.curNode && dijitFocus.curNode.blur()\n                },\n              ),\n            )\n            return handles\n          },\n        },\n\n        // mouse events connected for \"normal\" behavior\n        normalMouse: {\n          apply_on_init: true,\n          apply: function () {\n            return [\n              dojo.connect(\n                this.outerTrackContainer,\n                'mousedown',\n                this,\n                'startMouseDragScroll',\n              ),\n              dojo.connect(\n                this.verticalScrollBar.container,\n                'mousedown',\n                this,\n                'startVerticalMouseDragScroll',\n              ),\n            ]\n          },\n        },\n\n        // mouse events connected when we are in 'highlighting' mode,\n        // where dragging the mouse sets the global highlight\n        highlightingMouse: {\n          apply: function () {\n            dojo.removeClass(this.trackContainer, 'draggable')\n            dojo.addClass(this.trackContainer, 'highlightingAvailable')\n            return [\n              dojo.connect(\n                this.outerTrackContainer,\n                'mousedown',\n                dojo.hitch(\n                  this,\n                  'startMouseHighlight',\n                  dojo.hitch(this, 'absXtoBp'),\n                  this.scrollContainer,\n                  this.scaleTrackDiv,\n                ),\n              ),\n              dojo.connect(\n                this.outerTrackContainer,\n                'mouseover',\n                this,\n                'maybeDrawVerticalPositionLine',\n              ),\n              dojo.connect(\n                this.outerTrackContainer,\n                'mousemove',\n                this,\n                'maybeDrawVerticalPositionLine',\n              ),\n            ]\n          },\n          remove: function (mgr, handles) {\n            dojo.forEach(handles, dojo.disconnect, dojo)\n            dojo.removeClass(this.trackContainer, 'highlightingAvailable')\n            dojo.addClass(this.trackContainer, 'draggable')\n          },\n        },\n\n        // mouse events connected when the shift button is being held down\n        shiftMouse: {\n          apply: function () {\n            if (!dojo.hasClass(this.trackContainer, 'highlightingAvailable')) {\n              dojo.removeClass(this.trackContainer, 'draggable')\n              dojo.addClass(this.trackContainer, 'rubberBandAvailable')\n              return [\n                dojo.connect(\n                  this.outerTrackContainer,\n                  'mousedown',\n                  dojo.hitch(\n                    this,\n                    'startRubberZoom',\n                    dojo.hitch(this, 'absXtoBp'),\n                    this.scrollContainer,\n                    this.scaleTrackDiv,\n                  ),\n                ),\n                dojo.connect(\n                  this.outerTrackContainer,\n                  'onclick',\n                  this,\n                  'scaleClicked',\n                ),\n                dojo.connect(\n                  this.outerTrackContainer,\n                  'mouseover',\n                  this,\n                  'maybeDrawVerticalPositionLine',\n                ),\n                dojo.connect(\n                  this.outerTrackContainer,\n                  'mousemove',\n                  this,\n                  'maybeDrawVerticalPositionLine',\n                ),\n              ]\n            }\n          },\n          remove: function (mgr, handles) {\n            this.clearBasePairLabels()\n            this.clearVerticalPositionLine()\n            dojo.forEach(handles, dojo.disconnect, dojo)\n            dojo.removeClass(this.trackContainer, 'rubberBandAvailable')\n            dojo.addClass(this.trackContainer, 'draggable')\n          },\n        },\n\n        // mouse events that are connected when we are in the middle of a\n        // drag-scrolling operation\n        mouseDragScrolling: {\n          apply: function () {\n            return [\n              dojo.connect(document.body, 'mouseup', this, 'dragEnd'),\n              dojo.connect(document.body, 'mousemove', this, 'dragMove'),\n              dojo.connect(document.body, 'mouseout', this, 'checkDragOut'),\n            ]\n          },\n        },\n\n        // mouse events that are connected when we are in the middle of a\n        // vertical-drag-scrolling operation\n        verticalMouseDragScrolling: {\n          apply: function () {\n            return [\n              dojo.connect(document.body, 'mouseup', this, 'dragEnd'),\n              dojo.connect(\n                document.body,\n                'mousemove',\n                this,\n                'verticalDragMove',\n              ),\n              dojo.connect(document.body, 'mouseout', this, 'checkDragOut'),\n            ]\n          },\n        },\n\n        // mouse events that are connected when we are in the middle of a\n        // rubber-band zooming operation\n        mouseRubberBanding: {\n          apply: function () {\n            return [\n              dojo.connect(document.body, 'mouseup', this, 'rubberExecute'),\n              dojo.connect(document.body, 'mousemove', this, 'rubberMove'),\n              dojo.connect(document.body, 'mouseout', this, 'rubberCancel'),\n              dojo.connect(window, 'onkeydown', this, function (e) {\n                if (e.keyCode !== dojo.keys.SHIFT) {this.rubberCancel(e)}\n              }),\n            ]\n          },\n        },\n      }\n    },\n\n    /**\n     * Conduct a DOM test to calculate the height of div.pos-label\n     * elements with a line of text in them.\n     */\n    calculatePositionLabelHeight: function (containerElement) {\n      // measure the height of some arbitrary text in whatever font this\n      // shows up in (set by an external CSS file)\n      var heightTest = document.createElement('div')\n      heightTest.className = 'pos-label'\n      heightTest.style.visibility = 'hidden'\n      heightTest.appendChild(document.createTextNode('42'))\n      containerElement.appendChild(heightTest)\n      var h = heightTest.clientHeight\n      containerElement.removeChild(heightTest)\n      return h\n    },\n\n    scrollBarClickScroll: function (event) {\n      if (!event) {event = window.event}\n\n      var containerHeight = parseInt(\n        this.verticalScrollBar.container.style.height,\n        10,\n      )\n      var markerHeight = parseInt(\n        this.verticalScrollBar.positionMarker.style.height,\n        10,\n      )\n      var trackContainerHeight = this.trackContainer.clientHeight\n      var absY = this.getY() * (trackContainerHeight / containerHeight)\n      if (absY > event.clientY) {this.setY(this.getY() - 300)}\n      else if (absY + markerHeight < event.clientY) {this.setY(this.getY() + 300)}\n\n      //the timeout is so that we don't have to run showVisibleBlocks\n      //for every scroll wheel click (we just wait until so many ms\n      //after the last one).\n\n      if (this.wheelScrollTimeout) {window.clearTimeout(this.wheelScrollTimeout)}\n\n      // 100 milliseconds since the last scroll event is an arbitrary\n      // cutoff for deciding when the user is done scrolling\n      // (set by a bit of experimentation)\n      this.wheelScrollTimeout = window.setTimeout(\n        dojo.hitch(\n          this,\n          function () {\n            this.showVisibleBlocks(true)\n            this.wheelScrollTimeout = null\n          },\n          100,\n        ),\n      )\n\n      dojo.stopEvent(event)\n    },\n\n    wheelScroll: function (event) {\n      if (!event) {event = window.event}\n\n      let { pixelX: x, pixelY: y } = normalizeWheel(event)\n\n      var didScroll = false\n\n      if (x) {\n        this.keySlideX(x)\n        didScroll = true\n      }\n      if (y) {\n        y = -y\n        // 60 pixels per mouse wheel event\n        var prevY = this.getY()\n        var currY = this.setY(prevY - y)\n        // check if clamping happened\n        if (currY !== prevY) {\n          didScroll = true\n        }\n      }\n\n      //the timeout is so that we don't have to run showVisibleBlocks\n      //for every scroll wheel click (we just wait until so many ms\n      //after the last one).\n      if (this.wheelScrollTimeout) {window.clearTimeout(this.wheelScrollTimeout)}\n\n      // 100 milliseconds since the last scroll event is an arbitrary\n      // cutoff for deciding when the user is done scrolling\n      // (set by a bit of experimentation)\n      this.wheelScrollTimeout = window.setTimeout(\n        dojo.hitch(\n          this,\n          function () {\n            this.showVisibleBlocks(true)\n            this.wheelScrollTimeout = null\n          },\n          100,\n        ),\n      )\n\n      // allow event to bubble out of iframe for example\n      if (didScroll || this.browser.config.alwaysStopScrollBubble)\n        {dojo.stopEvent(event)}\n    },\n\n    getX: function () {\n      return this.x || 0\n    },\n\n    getY: function () {\n      return this.y || 0\n    },\n\n    getHeight: function () {\n      return this.elemBox.h\n    },\n    getWidth: function () {\n      return this.elemBox.w\n    },\n\n    clampX: function (x) {\n      return Math.round(\n        Math.max(\n          Math.min(this.maxLeft - this.offset, x || 0),\n          this.minLeft - this.offset,\n        ),\n      )\n    },\n\n    clampY: function (y) {\n      return Math.round(\n        Math.min(Math.max(0, y || 0), this.containerHeight - this.getHeight()),\n      )\n    },\n\n    rawSetX: function (x) {\n      this.elem.scrollLeft = x\n      this.x = x\n    },\n\n    /**\n     * @returns the new x value that was set\n     */\n    setX: function (x) {\n      x = this.clampX(x)\n      this.rawSetX(x)\n      this.updateStaticElements({ x: x })\n      this.showFine()\n      return x\n    },\n\n    rawSetY: function (y) {\n      this.y = y\n      this.layoutTracks()\n    },\n\n    /**\n     * @returns the new y value that was set\n     */\n    setY: function (y) {\n      y = this.clampY(y)\n      this.rawSetY(y)\n      this.updateStaticElements({ y: y })\n      return y\n    },\n\n    /**\n     * @private\n     */\n    rawSetPosition: function (pos) {\n      this.rawSetX(pos.x)\n      this.rawSetY(pos.y)\n      return pos\n    },\n\n    /**\n     * @param pos.x new x position\n     * @param pos.y new y position\n     */\n    setPosition: function (pos) {\n      var x = this.clampX(pos.x)\n      var y = this.clampY(pos.y)\n      this.updateStaticElements({ x: x, y: y })\n      this.rawSetX(x)\n      this.rawSetY(y)\n      this.showFine()\n    },\n\n    /**\n     * @returns {Object} as <code>{ x: 123, y: 456 }</code>\n     */\n    getPosition: function () {\n      return { x: this.x, y: this.y }\n    },\n\n    zoomCallback: function () {\n      this.zoomUpdate()\n    },\n\n    afterSlide: function () {\n      this.showCoarse()\n      this.scrollUpdate()\n      this.showVisibleBlocks(true)\n    },\n\n    /**\n     * Suppress double-click events in the genome view for a certain amount of time, default 100 ms.\n     */\n    suppressDoubleClick: function (/** Number */ time) {\n      if (this._noDoubleClick) {\n        window.clearTimeout(this._noDoubleClick)\n      }\n\n      var thisB = this\n      this._noDoubleClick = window.setTimeout(function () {\n        delete thisB._noDoubleClick\n      }, time || 100)\n    },\n\n    doubleClickZoom: function (event) {\n      if (this._noDoubleClick) {return}\n      if (this.dragging) {return}\n      if ('animation' in this) {return}\n\n      // if we have a timeout in flight from a scaleClicked click,\n      // cancel it, cause it looks now like the user has actually\n      // double-clicked\n      if (this.scaleClickedTimeout)\n        {window.clearTimeout(this.scaleClickedTimeout)}\n\n      var zoomLoc =\n        (event.pageX - dojo.position(this.elem, true).x) / this.getWidth()\n      if (event.shiftKey) {\n        this.zoomOut(event, zoomLoc, 2)\n      } else {\n        this.zoomIn(event, zoomLoc, 2)\n      }\n      dojo.stopEvent(event)\n    },\n\n    /** @private */\n    _beforeMouseDrag: function (event) {\n      if (this.animation) {\n        if (this.animation instanceof Zoomer) {\n          dojo.stopEvent(event)\n          return 0\n        } else {\n          this.animation.stop()\n        }\n      }\n      if (Util.isRightButton(event)) {return 0}\n      dojo.stopEvent(event)\n      return 1\n    },\n\n    /**\n     * Event fired when a user's mouse button goes down inside the main\n     * element of the genomeview.\n     */\n    startMouseDragScroll: function (event) {\n      if (!this._beforeMouseDrag(event)) {return}\n\n      this.behaviorManager.applyBehaviors('mouseDragScrolling')\n\n      this.dragStartPos = { x: event.clientX, y: event.clientY }\n      this.winStartPos = this.getPosition()\n    },\n\n    /**\n     * Event fired when a user's mouse button goes down inside the vertical\n     * scroll bar element of the genomeview.\n     */\n    startVerticalMouseDragScroll: function (event) {\n      if (!this._beforeMouseDrag(event)) {return} // not sure what this is for.\n\n      this.behaviorManager.applyBehaviors('verticalMouseDragScrolling')\n\n      this.dragStartPos = { x: event.clientX, y: event.clientY }\n      this.winStartPos = this.getPosition()\n    },\n\n    startMouseHighlight: function (absToBp, container, scaleDiv, event) {\n      if (!this._beforeMouseDrag(event)) {return}\n\n      this.behaviorManager.applyBehaviors('mouseRubberBanding')\n\n      this.rubberbanding = {\n        absFunc: absToBp,\n        container: container,\n        scaleDiv: scaleDiv,\n        message: 'Highlight region',\n        start: { x: event.clientX, y: event.clientY },\n        execute: function (start, end) {\n          this.browser.setHighlightAndRedraw({\n            ref: this.ref.name,\n            start: start,\n            end: end,\n          })\n        },\n      }\n\n      this.winStartPos = this.getPosition()\n    },\n\n    /**\n     * Start a rubber-band dynamic zoom.\n     *\n     * @param {Function} absToBp function to convert page X coordinates to\n     *   base pair positions on the reference sequence.  Called in the\n     *   context of the GenomeView object.\n     * @param {HTMLElement} container element in which to draw the\n     *   rubberbanding highlight\n     * @param {Event} event the mouse event that's starting the zoom\n     */\n    startRubberZoom: function (absToBp, container, scaleDiv, event) {\n      if (!this._beforeMouseDrag(event)) {return}\n\n      this.behaviorManager.applyBehaviors('mouseRubberBanding')\n\n      this.rubberbanding = {\n        absFunc: absToBp,\n        container: container,\n        scaleDiv: scaleDiv,\n        message: 'Zoom to region',\n        start: { x: event.clientX, y: event.clientY },\n        execute: function (h_start_bp, h_end_bp) {\n          this.setLocation(this.ref, h_start_bp, h_end_bp)\n        },\n      }\n\n      this.winStartPos = this.getPosition()\n      this.clearVerticalPositionLine()\n      this.clearBasePairLabels()\n    },\n\n    _rubberStop: function (event) {\n      this.behaviorManager.removeBehaviors('mouseRubberBanding')\n      this.hideRubberHighlight()\n      this.clearBasePairLabels()\n      if (event) {dojo.stopEvent(event)}\n      delete this.rubberbanding\n    },\n\n    rubberCancel: function (event) {\n      var htmlNode = document.body.parentNode\n      var bodyNode = document.body\n\n      if (\n        !event ||\n        !(event.relatedTarget || event.toElement) ||\n        htmlNode === (event.relatedTarget || event.toElement) ||\n        bodyNode === (event.relatedTarget || event.toElement)\n      ) {\n        this._rubberStop(event)\n      }\n    },\n\n    rubberMove: function (event) {\n      this.setRubberHighlight(this.rubberbanding.start, {\n        x: event.clientX,\n        y: event.clientY,\n      })\n    },\n\n    rubberExecute: function (event) {\n      var start = this.rubberbanding.start\n      var end = { x: event.clientX, y: event.clientY }\n\n      var h_start_bp = Math.floor(\n        this.rubberbanding.absFunc(Math.min(start.x, end.x)),\n      )\n      var h_end_bp = Math.ceil(\n        this.rubberbanding.absFunc(Math.max(start.x, end.x)),\n      )\n\n      var exec = this.rubberbanding.execute\n\n      this._rubberStop(event)\n\n      // cancel the rubber-zoom if the user has moved less than 3 pixels\n      if (Math.abs(start.x - end.x) < 3) {\n        return\n      }\n\n      exec.call(this, h_start_bp, h_end_bp)\n    },\n\n    // draws the rubber-banding highlight region from start.x to end.x\n    setRubberHighlight: function (start, end) {\n      var container = this.rubberbanding.container,\n        container_coords = dojo.position(container, true)\n\n      var h =\n        this.rubberHighlight ||\n        function () {\n          var main = (this.rubberHighlight = document.createElement('div'))\n          main.className = 'rubber-highlight'\n          main.style.position = 'absolute'\n          main.style.zIndex = 20\n          var text = document.createElement('div')\n          text.appendChild(document.createTextNode(this.rubberbanding.message))\n          main.appendChild(text)\n          text.style.position = 'relative'\n          text.style.top = 50 - container_coords.y + 'px'\n\n          container.appendChild(main)\n          return main\n        }.call(this)\n\n      h.style.visibility = 'visible'\n      h.style.left = Math.min(start.x, end.x) - container_coords.x + 'px'\n      h.style.width = Math.abs(end.x - start.x) + 'px'\n\n      // draw basepair-position labels for the start and end of the highlight\n      this.drawBasePairLabel({\n        name: 'rubberLeft',\n        xToBp: this.rubberbanding.absFunc,\n        scaleDiv: this.rubberbanding.scaleDiv,\n        offset: 0,\n        x: Math.min(start.x, end.x),\n        parent: container,\n        className: 'rubber',\n      })\n      this.drawBasePairLabel({\n        name: 'rubberRight',\n        xToBp: this.rubberbanding.absFunc,\n        scaleDiv: this.rubberbanding.scaleDiv,\n        offset: 0,\n        x: Math.max(start.x, end.x) + 1,\n        parent: container,\n        className: 'rubber',\n      })\n\n      // turn off the red position line if it's on\n      this.clearVerticalPositionLine()\n    },\n\n    dragEnd: function (event) {\n      this.behaviorManager.removeBehaviors(\n        'mouseDragScrolling',\n        'verticalMouseDragScrolling',\n      )\n\n      dojo.stopEvent(event)\n      this.showCoarse()\n\n      this.scrollUpdate()\n      this.showVisibleBlocks(true)\n\n      // wait 100 ms before releasing our drag indication, since onclick\n      // events from during the drag might fire after the dragEnd event\n      window.setTimeout(\n        dojo.hitch(this, function () {\n          this.dragging = false\n        }),\n        100,\n      )\n    },\n\n    /** stop the drag if we mouse out of the view */\n    checkDragOut: function (event) {\n      var htmlNode = document.body.parentNode\n      var bodyNode = document.body\n\n      if (\n        !(event.relatedTarget || event.toElement) ||\n        htmlNode === (event.relatedTarget || event.toElement) ||\n        bodyNode === (event.relatedTarget || event.toElement)\n      ) {\n        this.dragEnd(event)\n      }\n    },\n\n    dragMove: function (event) {\n      this.dragging = true\n      this.setPosition({\n        x: this.winStartPos.x - (event.clientX - this.dragStartPos.x),\n        y: this.winStartPos.y - (event.clientY - this.dragStartPos.y),\n      })\n      dojo.stopEvent(event)\n    },\n\n    // Similar to \"dragMove\". Consider merging.\n    verticalDragMove: function (event) {\n      this.dragging = true\n      var containerHeight = parseInt(\n        this.verticalScrollBar.container.style.height,\n        10,\n      )\n      var trackContainerHeight = this.trackContainer.clientHeight\n      this.setPosition({\n        x: this.winStartPos.x,\n        y:\n          this.winStartPos.y +\n          (event.clientY - this.dragStartPos.y) *\n            (trackContainerHeight / containerHeight),\n      })\n      dojo.stopEvent(event)\n    },\n\n    hideRubberHighlight: function (start, end) {\n      if (this.rubberHighlight) {\n        this.rubberHighlight.parentNode.removeChild(this.rubberHighlight)\n        delete this.rubberHighlight\n      }\n    },\n\n    /* moves the view by (distance times the width of the view) pixels */\n    slide: function (distance) {\n      if (this.animation) {this.animation.stop()}\n      this.trimVertical()\n      // slide for an amount of time that's a function of the distance being\n      // traveled plus an arbitrary extra 200 milliseconds so that\n      // short slides aren't too fast (200 chosen by experimentation)\n      new Slider(\n        this,\n        this.afterSlide,\n        Math.abs(distance) * this.getWidth() * this.slideTimeMultiple + 200,\n        distance * this.getWidth(),\n      )\n    },\n\n    setLocation: function (refseq, startbp, endbp) {\n      if (startbp === undefined) {startbp = this.minVisible()}\n      if (endbp === undefined) {endbp = this.maxVisible()}\n      if (typeof refseq == 'string') {\n        // if a string was passed, need to get the refseq object for it\n        refseq = this.browser.getRefSeq(refseq)\n      }\n      if (!refseq) {refseq = this.ref}\n\n      if (startbp < refseq.start || startbp > refseq.end) {startbp = refseq.start}\n      if (endbp < refseq.start || endbp > refseq.end) {endbp = refseq.end}\n\n      function removeTrack(track) {\n        delete thisB.desiredTracks[track.name]\n        if (track.div && track.div.parentNode)\n          {track.div.parentNode.removeChild(track.div)}\n      }\n\n      if (this.ref !== refseq) {\n        var thisB = this\n        this.ref = refseq\n        this._unsetPosBeforeZoom() // if switching to different sequence, flush zoom position tracking\n\n        array.forEach(this.tracks, removeTrack)\n\n        this.tracks = []\n        this.trackIndices = {}\n        this.trackHeights = []\n        this.trackTops = []\n\n        array.forEach(this.uiTracks, function (track) {\n          track.refSeq = thisB.ref\n          track.clear()\n        })\n\n        this.overviewTrackIterate(removeTrack)\n\n        this.addOverviewTrack(\n          new LocationScaleTrack({\n            label: 'overview_loc_track',\n            labelClass: 'overview-pos',\n            posHeight: this.overviewPosHeight,\n            browser: this.browser,\n            refSeq: this.ref,\n          }),\n        )\n        this.sizeInit()\n        this.setY(0)\n        this.behaviorManager.initialize()\n      }\n\n      this.pxPerBp = Math.min(\n        this.getWidth() / (endbp - startbp),\n        this.maxPxPerBp,\n      )\n      this.curZoom = Util.findNearest(this.zoomLevels, this.pxPerBp)\n\n      if (\n        Math.abs(this.pxPerBp - this.zoomLevels[this.zoomLevels.length - 1]) <\n        0.2\n      ) {\n        //the cookie-saved location is in round bases, so if the saved\n        //location was at the highest zoom level, the new zoom level probably\n        //won't be exactly at the highest zoom (which is necessary to trigger\n        //the sequence track), so we nudge the zoom level to be exactly at\n        //the highest level if it's close.\n        //Exactly how close is arbitrary; 0.2 was chosen to be close\n        //enough that people wouldn't notice if we fudged that much.\n        //console.log(\"nudging zoom level from %d to %d\", this.pxPerBp, this.zoomLevels[this.zoomLevels.length - 1]);\n        this.pxPerBp = this.zoomLevels[this.zoomLevels.length - 1]\n      }\n      this.stripeWidth =\n        (this.stripeWidthForZoom(this.curZoom) /\n          this.zoomLevels[this.curZoom]) *\n        this.pxPerBp\n      this.instantZoomUpdate()\n\n      this.centerAtBase((startbp + endbp) / 2, true)\n    },\n\n    stripeWidthForZoom: function (zoomLevel) {\n      if (this.zoomLevels.length - 1 == zoomLevel) {\n        // width, in pixels, of stripes at full zoom, is 10bp\n        return (this.regularStripe / 10) * this.maxPxPerBp\n      } else if (0 == zoomLevel) {\n        return this.minZoomStripe\n      } else {\n        return this.regularStripe\n      }\n    },\n\n    instantZoomUpdate: function () {\n      this.scrollContainer.style.width =\n        this.stripeCount * this.stripeWidth + 'px'\n      this.zoomContainer.style.width =\n        this.stripeCount * this.stripeWidth + 'px'\n      this.maxOffset =\n        this.bpToPx(this.ref.end) - this.stripeCount * this.stripeWidth\n      this.maxLeft = this.bpToPx(this.ref.end + 1) - this.getWidth()\n      this.minLeft = this.bpToPx(this.ref.start)\n    },\n\n    centerAtBase: function (base, instantly) {\n      base = Math.min(Math.max(base, this.ref.start), this.ref.end)\n      if (instantly) {\n        var pxDist = this.bpToPx(base)\n        var containerWidth = this.stripeCount * this.stripeWidth\n        var stripesLeft = Math.floor(\n          (pxDist - containerWidth / 2) / this.stripeWidth,\n        )\n        this.offset = stripesLeft * this.stripeWidth\n        this.setX(pxDist - this.offset - this.getWidth() / 2)\n        this.trackIterate(function (track) {\n          track.clear()\n        })\n        this.showVisibleBlocks(true)\n        this.showCoarse()\n      } else {\n        var startbp = this.pxToBp(this.x + this.offset)\n        var halfWidth = this.getWidth() / this.pxPerBp / 2\n        var endbp = startbp + halfWidth + halfWidth\n        var center = startbp + halfWidth\n        if (base >= startbp - halfWidth && base <= endbp + halfWidth) {\n          //we're moving somewhere nearby, so move smoothly\n          if (this.animation) {this.animation.stop()}\n          var distance = (center - base) * this.pxPerBp\n          this.trimVertical()\n          // slide for an amount of time that's a function of the\n          // distance being traveled plus an arbitrary extra 200\n          // milliseconds so that short slides aren't too fast\n          // (200 chosen by experimentation)\n          new Slider(\n            this,\n            this.afterSlide,\n            Math.abs(distance) * this.slideTimeMultiple + 200,\n            distance,\n          )\n        } else {\n          //we're moving far away, move instantly\n          this.centerAtBase(base, true)\n        }\n      }\n    },\n\n    /**\n     * @returns {Number} minimum basepair coordinate of the current\n     * reference sequence visible in the genome view\n     */\n    minVisible: function () {\n      var mv = this.pxToBp(this.x + this.offset)\n\n      // if we are less than one pixel from the beginning of the ref\n      // seq, just say we are at the beginning.\n      if (mv < this.pxToBp(1)) {return 0}\n      else {return Math.round(mv)}\n    },\n\n    /**\n     * @returns {Number} maximum basepair coordinate of the current\n     * reference sequence visible in the genome view\n     */\n    maxVisible: function () {\n      var mv = this.pxToBp(this.x + this.offset + this.getWidth())\n      var scrollbar = Math.round(\n        this.pxToBp(this.verticalScrollBarVisibleWidth()),\n      )\n      // if we are less than one pixel from the end of the ref\n      // seq, just say we are at the end.\n      if (mv > this.ref.end - this.pxToBp(1)) {return this.ref.end - scrollbar}\n      else {return Math.round(mv) - scrollbar}\n    },\n\n    showFine: function () {\n      this.onFineMove(this.minVisible(), this.maxVisible())\n    },\n    showCoarse: function () {\n      this.onCoarseMove(this.minVisible(), this.maxVisible())\n    },\n\n    /**\n     * Hook for other components to dojo.connect to.\n     */\n    onFineMove: function (startbp, endbp) {\n      this.updateLocationThumb()\n    },\n\n    /**\n     * Hook for other components to dojo.connect to.\n     */\n    onCoarseMove: function (startbp, endbp) {\n      this.updateLocationThumb()\n    },\n\n    /**\n     * Hook to be called on a window resize.\n     */\n    onResize: function () {\n      this.sizeInit()\n      this.showVisibleBlocks()\n      this.showFine()\n      this.showCoarse()\n    },\n\n    /**\n     * Event handler fired when the overview bar is single-clicked.\n     */\n    overviewClicked: function (evt) {\n      this.centerAtBase(this.overview_absXtoBp(evt.clientX))\n    },\n\n    /**\n     * Event handler fired when mouse is over the scale bar.\n     */\n    scaleMouseOver: function (evt) {\n      if (!this.rubberbanding)\n        {this.drawVerticalPositionLine(this.scaleTrackDiv, evt)}\n    },\n\n    /**\n     * Event handler fired when mouse moves over the scale bar.\n     */\n    scaleMouseMove: function (evt) {\n      if (!this.rubberbanding)\n        {this.drawVerticalPositionLine(this.scaleTrackDiv, evt)}\n    },\n\n    /**\n     * Event handler fired when mouse leaves the scale bar.\n     */\n    scaleMouseOut: function (evt) {\n      this.clearVerticalPositionLine()\n      this.clearBasePairLabels()\n    },\n\n    /**\n     *  draws the vertical position line only if\n     *  we are not rubberbanding\n     */\n    maybeDrawVerticalPositionLine: function (evt) {\n      if (this.rubberbanding) {return}\n      this.drawVerticalPositionLine(this.scaleTrackDiv, evt)\n    },\n\n    /**\n     * Draws the red line across the work area, or updates it if it already exists.\n     */\n    drawVerticalPositionLine: function (parent, evt) {\n      var numX = evt.pageX + 2\n\n      if (!this.verticalPositionLine) {\n        // if line does not exist, create it\n        this.verticalPositionLine = dojo.create(\n          'div',\n          {\n            className: 'trackVerticalPositionIndicatorMain',\n          },\n          this.staticTrack.div,\n        )\n      }\n\n      var line = this.verticalPositionLine\n      line.style.display = 'block' //make line visible\n      line.style.left = numX + 'px' //set location on screen\n      var scaleTrackPos = dojo.position(this.scaleTrackDiv)\n      line.style.top = scaleTrackPos.y + 'px'\n\n      this.drawBasePairLabel({\n        name: 'single',\n        offset: 0,\n        x: numX,\n        parent: parent,\n        scaleDiv: parent,\n      })\n    },\n\n    /**\n     * Draws the label for the line.\n     * @param {Number} args.numX X-coordinate at which to draw the label's origin\n     * @param {Number} args.name unique name used to cache this label\n     * @param {Number} args.offset offset in pixels from numX at which the label should actually be drawn\n     * @param {HTMLElement} args.scaleDiv\n     * @param {Function} args.xToBp\n     */\n    drawBasePairLabel: function (args) {\n      var name = args.name || 0\n      var offset = args.offset || 0\n      var numX = args.x\n      this.basePairLabels = this.basePairLabels || {}\n\n      if (!this.basePairLabels[name]) {\n        var scaleTrackPos = dojo.position(args.scaleDiv || this.scaleTrackDiv)\n        this.basePairLabels[name] = dojo.create(\n          'div',\n          {\n            className:\n              'basePairLabel' + (args.className ? ' ' + args.className : ''),\n            style: {\n              top: scaleTrackPos.y + scaleTrackPos.h - 3 + 'px',\n            },\n          },\n          this.browser.container,\n        )\n      }\n\n      var label = this.basePairLabels[name]\n\n      if (typeof numX == 'object') {\n        numX = numX.clientX\n      }\n\n      label.style.display = 'block' //make label visible\n      var absfunc = args.xToBp || dojo.hitch(this, 'absXtoBp')\n      //set text to BP location (adding 1 to convert from interbase)\n      label.innerHTML = Util.addCommas(Math.floor(absfunc(numX)) + 1)\n\n      //label.style.top = args.top + 'px';\n\n      // 15 pixels on either side of the label\n      if (window.innerWidth - numX > 8 + label.offsetWidth) {\n        label.style.left = numX + offset + 'px' //set location on screen to the right\n      } else {\n        label.style.left = numX + 1 - offset - label.offsetWidth + 'px' //set location on screen to the left\n      }\n    },\n\n    /**\n     * Turn off the basepair-position line if it is being displayed.\n     */\n    clearVerticalPositionLine: function () {\n      if (this.verticalPositionLine)\n        {this.verticalPositionLine.style.display = 'none'}\n    },\n\n    /**\n     * Delete any base pair labels that are being displayed.\n     */\n    clearBasePairLabels: function () {\n      for (var name in this.basePairLabels) {\n        var label = this.basePairLabels[name]\n        if (label.parentNode) {label.parentNode.removeChild(label)}\n      }\n      this.basePairLabels = {}\n    },\n\n    /**\n     * Convert absolute X pixel position to base pair position on the\n     * <b>overview</b> track.  This needs refactoring; a scale bar should\n     * itself know how to convert an absolute X position to base pairs.\n     * @param {Number} x absolute pixel X position (for example, from a click event's clientX property)\n     */\n    overview_absXtoBp: function (x) {\n      var overviewBox = dojo.position(this.overview)\n      return (\n        ((x - overviewBox.x) / overviewBox.w) *\n          (this.ref.end - this.ref.start) +\n        this.ref.start\n      )\n    },\n\n    /**\n     * Event handler fired when the track scale bar is single-clicked.\n     */\n    scaleClicked: function (evt) {\n      var bp = this.absXtoBp(evt.clientX)\n\n      this.scaleClickedTimeout = window.setTimeout(\n        dojo.hitch(\n          this,\n          function () {\n            this.centerAtBase(bp)\n          },\n          100,\n        ),\n      )\n    },\n\n    /**\n     * Event handler fired when the region thumbnail in the overview bar\n     * is dragged.\n     */\n    thumbMoved: function (mover) {\n      var pxLeft = parseInt(this.locationThumb.style.left)\n      var pxWidth = parseInt(this.locationThumb.style.width)\n      var pxCenter = pxLeft + pxWidth / 2\n      this.centerAtBase(\n        (pxCenter / this.overviewBox.w) * (this.ref.end - this.ref.start) +\n          this.ref.start,\n      )\n    },\n\n    /**\n     * Updates the position of the red box in the overview that indicates\n     * the region being shown by the detail pane.\n     */\n    updateLocationThumb: function () {\n      var startbp = this.minVisible()\n      var endbp = this.maxVisible()\n\n      var length = this.ref.end - this.ref.start\n      var trapLeft = Math.round(\n        ((startbp - this.ref.start) / length) * this.overviewBox.w +\n          this.overviewBox.l,\n      )\n      var trapRight = Math.round(\n        ((endbp - this.ref.start) / length) * this.overviewBox.w +\n          this.overviewBox.l,\n      )\n\n      this.locationThumb.style.cssText =\n        'height: ' +\n        (this.overviewBox.h - 4) +\n        'px; ' +\n        'left: ' +\n        trapLeft +\n        'px; ' +\n        'width: ' +\n        (trapRight - trapLeft) +\n        'px;' +\n        'z-index: 20'\n    },\n\n    checkY: function (y) {\n      return Math.min(y < 0 ? 0 : y, this.containerHeight - this.getHeight())\n    },\n\n    /**\n     * Given a new X and Y pixels position for the main track container,\n     * reposition static elements that \"float\" over it, like track labels,\n     * Y axis labels, the main track ruler, and so on.\n     *\n     * @param [args.x] the new X coordinate.  if not provided,\n     *   elements that only need updates on the X position are not\n     *   updated.\n     * @param [args.y] the new Y coordinate.  if not provided,\n     *   elements that only need updates on the Y position are not\n     *   updated.\n     * @param [args.width] the new width of the view.  if not provided,\n     *   elements that only need updates on the width are not\n     *   updated.\n     * @param [args.height] the new height of the view. if not provided,\n     *   elements that only need updates on the height are not\n     *   updated.\n     */\n    updateStaticElements: function (args) {\n      this.trackIterate(function (t) {\n        t.updateStaticElements(args)\n      }, this)\n\n      this._updateVerticalScrollBar(args)\n    },\n\n    showWait: function () {\n      var oldCursors = []\n      for (var i = 0; i < this.waitElems.length; i++) {\n        oldCursors[i] = this.waitElems[i].style.cursor\n        this.waitElems[i].style.cursor = 'wait'\n      }\n      this.prevCursors.push(oldCursors)\n    },\n\n    showDone: function () {\n      var oldCursors = this.prevCursors.pop()\n      for (var i = 0; i < this.waitElems.length; i++) {\n        this.waitElems[i].style.cursor = oldCursors[i]\n      }\n    },\n\n    pxToBp: function (pixels) {\n      return pixels / this.pxPerBp\n    },\n\n    /**\n     * Convert absolute pixels X position to base pair position on the\n     * current reference sequence.\n     * @returns {Number}\n     */\n    absXtoBp: function (/**Number*/ pixels) {\n      return (\n        this.pxToBp(\n          this.getPosition().x +\n            this.offset -\n            dojo.position(this.elem, true).x +\n            pixels,\n        ) - 1\n      )\n    },\n\n    bpToPx: function (bp) {\n      return bp * this.pxPerBp\n    },\n\n    /**\n     * Update the view's state, and that of its tracks, for the current\n     * width and height of its container.\n     * @returns nothing\n     */\n    sizeInit: function () {\n      this.overviewBox = dojo.marginBox(this.overview)\n      this.elemBox = {\n        h: this.elem.offsetHeight,\n        w: this.elem.offsetWidth,\n      }\n\n      //scale values, in pixels per bp, for all zoom levels\n      var desiredZoomLevels = [\n        1 / 500000,\n        1 / 200000,\n        1 / 100000,\n        1 / 50000,\n        1 / 20000,\n        1 / 10000,\n        1 / 5000,\n        1 / 2000,\n        1 / 1000,\n        1 / 500,\n        1 / 200,\n        1 / 100,\n        1 / 50,\n        1 / 20,\n        1 / 10,\n        1 / 5,\n        1 / 2,\n        1,\n        2,\n        5,\n        10,\n        20,\n      ]\n\n      this.zoomLevels = []\n      for (var i = 0; i < desiredZoomLevels.length; i++) {\n        var zlevel = desiredZoomLevels[i]\n        if (zlevel < this.maxPxPerBp) {this.zoomLevels.push(zlevel)}\n        else {break} // once get to zoom level >= maxPxPerBp, quit\n      }\n      this.zoomLevels.push(this.maxPxPerBp)\n\n      //make sure we don't zoom out too far\n      while (\n        (this.ref.end - this.ref.start) * this.zoomLevels[0] <\n        this.getWidth()\n      ) {\n        this.zoomLevels.shift()\n      }\n      this.zoomLevels.unshift(this.getWidth() / (this.ref.end - this.ref.start))\n\n      //width, in pixels, of stripes at min zoom (so the view covers\n      //the whole ref seq)\n      this.minZoomStripe =\n        this.regularStripe * (this.zoomLevels[0] / this.zoomLevels[1])\n\n      this.curZoom = 0\n      while (this.pxPerBp > this.zoomLevels[this.curZoom]) {this.curZoom++}\n      this.maxLeft = this.bpToPx(this.ref.end + 1) - this.getWidth()\n\n      delete this.stripePercent\n      //25, 50, 100 don't work as well due to the way scrollUpdate works\n      var possiblePercents = [20, 10, 5, 4, 2, 1]\n      for (var i = 0; i < possiblePercents.length; i++) {\n        // we'll have (100 / possiblePercents[i]) stripes.\n        // multiplying that number of stripes by the minimum stripe width\n        // gives us the total width of the \"container\" div.\n        // (or what that width would be if we used possiblePercents[i]\n        // as our stripePercent)\n        // That width should be wide enough to make sure that the user can\n        // scroll at least one page-width in either direction without making\n        // the container div bump into the edge of its parent element, taking\n        // into account the fact that the container won't always be perfectly\n        // centered (it may be as much as 1/2 stripe width off center)\n        // So, (this.getWidth() * 3) gives one screen-width on either side,\n        // and we add a regularStripe width to handle the slightly off-center\n        // cases.\n        // The minimum stripe width is going to be halfway between\n        // \"canonical\" zoom levels; the widest distance between those\n        // zoom levels is 2.5-fold, so halfway between them is 0.7 times\n        // the stripe width at the higher zoom level\n        if (\n          (100 / possiblePercents[i]) * (this.regularStripe * 0.7) >\n          this.getWidth() * 3 + this.regularStripe\n        ) {\n          this.stripePercent = possiblePercents[i]\n          break\n        }\n      }\n\n      if (!this.stripePercent) {\n        console.warn(\n          'stripeWidth too small: ' + this.stripeWidth + ', ' + this.getWidth(),\n        )\n        this.stripePercent = 1\n      }\n\n      var oldX\n      var oldStripeCount = this.stripeCount\n      if (oldStripeCount) {oldX = this.getX()}\n      this.stripeCount = Math.round(100 / this.stripePercent)\n\n      this.scrollContainer.style.width =\n        this.stripeCount * this.stripeWidth + 'px'\n      this.zoomContainer.style.width =\n        this.stripeCount * this.stripeWidth + 'px'\n\n      var blockDelta\n      if (oldStripeCount && oldStripeCount != this.stripeCount) {\n        blockDelta = Math.floor((oldStripeCount - this.stripeCount) / 2)\n        var delta = blockDelta * this.stripeWidth\n        var newX = this.getX() - delta\n        this.offset += delta\n        this.updateStaticElements({ x: newX })\n        this.rawSetX(newX)\n      }\n\n      // update the sizes for each of the tracks\n      this.trackIterate(function (track, view) {\n        track.sizeInit(view.stripeCount, view.stripePercent, blockDelta)\n      })\n\n      var newHeight =\n        this.trackHeights && this.trackHeights.length\n          ? Math.max(\n              dojof.reduce(this.trackHeights, '+') +\n                this.config.trackPadding * this.trackHeights.length,\n              this.getHeight(),\n            )\n          : this.getHeight()\n      this.scrollContainer.style.height = newHeight + 'px'\n      this.containerHeight = newHeight\n\n      var refLength = this.ref.end - this.ref.start\n      if (refLength < 0)\n        {throw new Error(\n          'reference sequence ' +\n            this.ref.name +\n            ' has an invalid start coordinate, it is greater than its end coordinate.',\n        )}\n\n      var posSize = document.createElement('div')\n      posSize.className = 'overview-pos'\n      posSize.appendChild(document.createTextNode(Util.addCommas(this.ref.end)))\n      posSize.style.visibility = 'hidden'\n      this.overview.appendChild(posSize)\n      // we want the stripes to be at least as wide as the position labels,\n      // plus an arbitrary 20% padding so it's clear which grid line\n      // a position label corresponds to.\n      var minStripe = posSize.clientWidth * 1.2\n      this.overviewPosHeight = posSize.clientHeight * 1.2\n      this.overview.removeChild(posSize)\n      for (var n = 1; n < 30; n++) {\n        //http://research.att.com/\\x7enjas/sequences/A051109\n        // JBrowse uses this sequence (1, 2, 5, 10, 20, 50, 100, 200, 500...)\n        // as its set of zoom levels.  That gives nice round numbers for\n        // bases per block, and it gives zoom transitions that feel about the\n        // right size to me. -MS\n        this.overviewStripeBases =\n          (Math.pow(n % 3, 2) + 1) * Math.pow(10, Math.floor(n / 3))\n        this.overviewStripes = Math.ceil(refLength / this.overviewStripeBases)\n        if (this.overviewBox.w / this.overviewStripes > minStripe) {break}\n        if (this.overviewStripes < 2) {break}\n      }\n\n      // update our overview tracks\n      var overviewStripePct = 100 / (refLength / this.overviewStripeBases)\n      var overviewHeight = 0\n      this.overviewTrackIterate(function (track, view) {\n        track.clear()\n        track.sizeInit(view.overviewStripes, overviewStripePct)\n        track.showRange(\n          0,\n          view.overviewStripes - 1,\n          view.ref.start - 1,\n          view.overviewStripeBases,\n          view.overviewBox.w / (view.ref.end - view.ref.start),\n        )\n      })\n      this.updateOverviewHeight()\n\n      this.updateScroll()\n    },\n\n    /**\n     * @private\n     */\n    updateScroll: function () {\n      // may need to update our Y position if our height has changed\n      var update = { height: this.getHeight() }\n      if (this.getY() > 0) {\n        if (this.containerHeight - this.getY() < update.height) {\n          //console.log( this.totalTrackHeight, update.height, this.getY() );\n          update.y = this.setY(\n            Math.max(0, this.containerHeight - update.height),\n          )\n        }\n      }\n\n      // update any static (i.e. fixed-position) elements that need to\n      // float in one position over the scrolling track div (can't use\n      // CSS position:fixed for these)\n      this.updateStaticElements(update)\n    },\n\n    overviewTrackIterate: function (callback) {\n      var overviewTrack = this.overview.firstChild\n      do {\n        if (overviewTrack && overviewTrack.track)\n          {callback.call(this, overviewTrack.track, this)}\n      } while (overviewTrack && (overviewTrack = overviewTrack.nextSibling))\n    },\n\n    updateOverviewHeight: function (trackName, height) {\n      var overviewHeight = 0\n      this.overviewTrackIterate(function (track, view) {\n        overviewHeight += track.height\n        track.div.style.height = track.height + 'px'\n      })\n      this.overview.style.height = overviewHeight + 'px'\n      this.overviewBox = dojo.marginBox(this.overview)\n    },\n\n    addOverviewTrack: function (track) {\n      var refLength = this.ref.end - this.ref.start\n\n      var overviewStripePct = 100 / (refLength / this.overviewStripeBases)\n      var trackDiv = document.createElement('div')\n      trackDiv.className = 'track'\n      trackDiv.style.height = this.overviewBox.h + 'px'\n      trackDiv.id = 'overviewtrack_' + track.name\n      trackDiv.track = track\n      var view = this\n      var heightUpdate = function (height) {\n        view.updateOverviewHeight()\n      }\n      track.setViewInfo(\n        this,\n        heightUpdate,\n        this.overviewStripes,\n        trackDiv,\n        overviewStripePct,\n        this.overviewStripeBases,\n        this.pxPerBp,\n        this.config.trackPadding,\n      )\n      this.overview.appendChild(trackDiv)\n      this.updateOverviewHeight()\n\n      return trackDiv\n    },\n\n    trimVertical: function (y) {\n      if (y === undefined) {y = this.getY()}\n      var trackBottom\n      var trackTop = this.topSpace\n      var bottom = y + this.getHeight()\n      for (var i = 0; i < this.tracks.length; i++) {\n        if (this.tracks[i].shown) {\n          trackBottom = trackTop + this.trackHeights[i]\n          if (!(trackBottom > y && trackTop < bottom)) {\n            this.tracks[i].hideAll()\n          }\n          trackTop = trackBottom + this.config.trackPadding\n        }\n      }\n    },\n\n    redrawTracks: function () {\n      this.trackIterate(function (t) {\n        t.hideAll()\n      })\n      this.showVisibleBlocks(false)\n    },\n\n    hideRegion: function (location) {\n      this.overviewTrackIterate(function (t) {\n        t.hideRegion(location)\n      })\n      this.trackIterate(function (t) {\n        t.hideRegion(location)\n      })\n    },\n\n    redrawRegion: function (location) {\n      this.hideRegion(location)\n      this.showVisibleBlocks(false)\n    },\n\n    zoomIn: function (e, zoomLoc, steps) {\n      if (this.animation) {return}\n      this._unsetPosBeforeZoom()\n      if (zoomLoc === undefined) {zoomLoc = 0.5}\n      if (steps === undefined) {steps = 1}\n      steps = Math.min(steps, this.zoomLevels.length - 1 - this.curZoom)\n      if (0 == steps && this.pxPerBp == this.zoomLevels[this.curZoom]) {return}\n\n      this.showWait()\n      var pos = this.getPosition()\n      this.trimVertical(pos.y)\n\n      var scale = this.zoomLevels[this.curZoom + steps] / this.pxPerBp\n      var fixedBp = this.pxToBp(pos.x + this.offset + zoomLoc * this.getWidth())\n      this.curZoom += steps\n      this.pxPerBp = this.zoomLevels[this.curZoom]\n      this.maxLeft = this.bpToPx(this.ref.end + 1) - this.getWidth()\n\n      for (var track = 0; track < this.tracks.length; track++)\n        {this.tracks[track].startZoom(\n          this.pxPerBp,\n          fixedBp - (zoomLoc * this.getWidth()) / this.pxPerBp,\n          fixedBp + ((1 - zoomLoc) * this.getWidth()) / this.pxPerBp,\n        )}\n      //YAHOO.log(\"centerBp: \" + centerBp + \"; estimated post-zoom start base: \" + (centerBp - ((zoomLoc * this.getWidth()) / this.pxPerBp)) + \", end base: \" + (centerBp + (((1 - zoomLoc) * this.getWidth()) / this.pxPerBp)));\n\n      // Zooms take an arbitrary 700 milliseconds, which feels about right\n      // to me, although if the zooms were smoother they could probably\n      // get faster without becoming off-putting. -MS\n      new Zoomer(\n        scale,\n        this,\n        function () {\n          this.zoomUpdate(zoomLoc, fixedBp)\n        },\n        700,\n        zoomLoc,\n      )\n    },\n\n    /** WebApollo support for zooming directly to base level, and later restoring previous zoom level before zooming to base */\n    zoomToBaseLevel: function (e, pos) {\n      if (this.animation) {return}\n      //   if (this.zoomLevels[this.curZoom] === this.charWidth)  {  console.log(\"already zoomed to base level\"); return; }\n      // if at max zoomLevel then already zoomed to bases, so then no-op\n      var baseZoomIndex = this.zoomLevels.length - 1\n\n      if (this.curZoom === baseZoomIndex) {\n        console.log('already zoomed to base level')\n        return\n      }\n      this._setPosBeforeZoom(this.minVisible(), this.maxVisible(), this.curZoom)\n      var zoomLoc = 0.5\n\n      this.showWait()\n      this.trimVertical()\n\n      var relativeScale = this.zoomLevels[baseZoomIndex] / this.pxPerBp\n      var fixedBp = pos\n      this.curZoom = baseZoomIndex\n      this.pxPerBp = this.zoomLevels[baseZoomIndex]\n\n      this.maxLeft = this.pxPerBp * this.ref.end - this.getWidth()\n\n      for (var track = 0; track < this.tracks.length; track++)\n        {this.tracks[track].startZoom(\n          this.pxPerBp,\n          fixedBp - (zoomLoc * this.getWidth()) / this.pxPerBp,\n          fixedBp + ((1 - zoomLoc) * this.getWidth()) / this.pxPerBp,\n        )}\n      //YAHOO.log(\"centerBp: \" + centerBp + \"; estimated post-zoom start base: \" + (centerBp - ((zoomLoc * this.getWidth()) / this.pxPerBp)) + \", end base: \" + (centerBp + (((1 - zoomLoc) * this.getWidth()) / this.pxPerBp)));\n      new Zoomer(\n        relativeScale,\n        this,\n        function () {\n          this.zoomUpdate(zoomLoc, fixedBp)\n        },\n        700,\n        zoomLoc,\n      )\n    },\n\n    zoomOut: function (e, zoomLoc, steps) {\n      if (this.animation) {return}\n      this._unsetPosBeforeZoom()\n      if (steps === undefined) {steps = 1}\n      steps = Math.min(steps, this.curZoom)\n      if (0 == steps) {return}\n\n      this.showWait()\n      var pos = this.getPosition()\n      this.trimVertical(pos.y)\n      if (zoomLoc === undefined) {zoomLoc = 0.5}\n      var scale = this.zoomLevels[this.curZoom - steps] / this.pxPerBp\n      var edgeDist =\n        this.bpToPx(this.ref.end) - (this.offset + pos.x + this.getWidth())\n      //zoomLoc is a number on [0,1] that indicates\n      //the fixed point of the zoom\n      zoomLoc = Math.max(\n        zoomLoc,\n        1 - (edgeDist * scale) / (1 - scale) / this.getWidth(),\n      )\n      edgeDist = pos.x + this.offset - this.bpToPx(this.ref.start)\n      zoomLoc = Math.min(\n        zoomLoc,\n        (edgeDist * scale) / (1 - scale) / this.getWidth(),\n      )\n      var fixedBp = this.pxToBp(pos.x + this.offset + zoomLoc * this.getWidth())\n      this.curZoom -= steps\n      this.pxPerBp = this.zoomLevels[this.curZoom]\n\n      for (var track = 0; track < this.tracks.length; track++)\n        {this.tracks[track].startZoom(\n          this.pxPerBp,\n          fixedBp - (zoomLoc * this.getWidth()) / this.pxPerBp,\n          fixedBp + ((1 - zoomLoc) * this.getWidth()) / this.pxPerBp,\n        )}\n\n      //YAHOO.log(\"centerBp: \" + centerBp + \"; estimated post-zoom start base: \" + (centerBp - ((zoomLoc * this.getWidth()) / this.pxPerBp)) + \", end base: \" + (centerBp + (((1 - zoomLoc) * this.getWidth()) / this.pxPerBp)));\n      this.minLeft = this.pxPerBp * this.ref.start\n\n      // Zooms take an arbitrary 700 milliseconds, which feels about right\n      // to me, although if the zooms were smoother they could probably\n      // get faster without becoming off-putting. -MS\n      new Zoomer(\n        scale,\n        this,\n        function () {\n          this.zoomUpdate(zoomLoc, fixedBp)\n        },\n        700,\n        zoomLoc,\n      )\n    },\n\n    /** WebApollo support for zooming directly to base level, and later restoring previous zoom level before zooming to base */\n    zoomBackOut: function (e) {\n      if (this.animation) {\n        return\n      }\n      if (!this.isZoomedToBase()) {\n        return\n      }\n\n      var min = this.posBeforeZoom.min\n      var max = this.posBeforeZoom.max\n      var zoomIndex = this.posBeforeZoom.zoomIndex\n      this.posBeforeZoom = undefined\n\n      var zoomLoc = 0.5\n      this.showWait()\n\n      var scale = this.zoomLevels[zoomIndex] / this.pxPerBp\n      var fixedBp = (min + max) / 2\n      this.curZoom = zoomIndex\n      this.pxPerBp = this.zoomLevels[zoomIndex]\n\n      for (var track = 0; track < this.tracks.length; track++) {\n        this.tracks[track].startZoom(\n          this.pxPerBp,\n          fixedBp - (zoomLoc * this.getWidth()) / this.pxPerBp,\n          fixedBp + ((1 - zoomLoc) * this.getWidth()) / this.pxPerBp,\n        )\n      }\n\n      this.minLeft = this.pxPerBp * this.ref.start\n      var thisObj = this\n      // Zooms take an arbitrary 700 milliseconds, which feels about right\n      // to me, although if the zooms were smoother they could probably\n      // get faster without becoming off-putting. -MS\n      new Zoomer(\n        scale,\n        this,\n        function () {\n          thisObj.setLocation(thisObj.ref, min, max)\n          thisObj.zoomUpdate(zoomLoc, fixedBp)\n        },\n        700,\n        zoomLoc,\n      )\n    },\n\n    /** WebApollo support for zooming directly to base level, and later restoring previous zoom level before zooming to base */\n    isZoomedToBase: function () {\n      return this.posBeforeZoom !== undefined\n    },\n\n    /** WebApollo support for zooming directly to base level, and later restoring previous zoom level before zooming to base */\n    _setPosBeforeZoom: function (min, max, zoomIndex) {\n      this.posBeforeZoom = { min: min, max: max, zoomIndex: zoomIndex }\n    },\n\n    /** WebApollo support for zooming directly to base level, and later restoring previous zoom level before zooming to base */\n    _unsetPosBeforeZoom: function () {\n      this.posBeforeZoom = undefined\n    },\n\n    zoomUpdate: function (zoomLoc, fixedBp) {\n      var eWidth = this.elem.clientWidth\n      var centerPx = this.bpToPx(fixedBp) - zoomLoc * eWidth + eWidth / 2\n      // stripeWidth: pixels per block\n      this.stripeWidth = this.stripeWidthForZoom(this.curZoom)\n      this.scrollContainer.style.width =\n        this.stripeCount * this.stripeWidth + 'px'\n      this.zoomContainer.style.width =\n        this.stripeCount * this.stripeWidth + 'px'\n      var centerStripe = Math.round(centerPx / this.stripeWidth)\n      var firstStripe = (centerStripe - this.stripeCount / 2) | 0\n      this.offset = firstStripe * this.stripeWidth\n      this.maxOffset =\n        this.bpToPx(this.ref.end + 1) - this.stripeCount * this.stripeWidth\n      this.maxLeft = this.bpToPx(this.ref.end + 1) - this.getWidth()\n      this.minLeft = this.bpToPx(this.ref.start)\n      this.zoomContainer.style.left = '0px'\n      this.setX(centerPx - this.offset - eWidth / 2)\n\n      dojo.forEach(this.uiTracks, function (track) {\n        track.clear()\n      })\n\n      this.trackIterate(function (track) {\n        track.endZoom(this.pxPerBp, Math.round(this.stripeWidth / this.pxPerBp))\n      })\n\n      this.showVisibleBlocks(true)\n      this.showDone()\n      this.showCoarse()\n    },\n\n    scrollUpdate: function () {\n      var x = this.getX()\n      var numStripes = this.stripeCount\n      var cWidth = numStripes * this.stripeWidth\n      var eWidth = this.getWidth()\n      //dx: horizontal distance between the centers of\n      //this.scrollContainer and this.elem\n      var dx = cWidth / 2 - (eWidth / 2 + x)\n      //If dx is negative, we add stripes on the right, if positive,\n      //add on the left.\n      //We remove stripes from the other side to keep cWidth the same.\n      //The end goal is to minimize dx while making sure the surviving\n      //stripes end up in the same place.\n\n      var dStripes = (dx / this.stripeWidth) | 0\n      if (0 == dStripes) {return}\n      var changedStripes = Math.abs(dStripes)\n\n      var newOffset = this.offset - dStripes * this.stripeWidth\n\n      if (this.offset == newOffset) {return}\n      this.offset = newOffset\n\n      this.trackIterate(function (track) {\n        track.moveBlocks(dStripes)\n      })\n\n      var newX = x + dStripes * this.stripeWidth\n      this.updateStaticElements({ x: newX })\n      this.rawSetX(newX)\n      var firstVisible = (newX / this.stripeWidth) | 0\n    },\n\n    trackHeightUpdate: function (trackName, height) {\n      var y = this.getY()\n      if (!(trackName in this.trackIndices)) {return}\n      var track = this.trackIndices[trackName]\n      if (Math.abs(height - this.trackHeights[track]) < 1) {return}\n\n      //console.log(\"trackHeightUpdate: \" + trackName + \" \" + this.trackHeights[track] + \" -> \" + height);\n      // if the bottom of this track is a above the halfway point,\n      // and we're not all the way at the top,\n      if (\n        this.trackTops[track] + this.trackHeights[track] - y <\n          this.getHeight() / 2 &&\n        y > 0\n      ) {\n        // scroll so that lower tracks stay in place on screen\n        this.setY(y + (height - this.trackHeights[track]))\n        //console.log(\"track \" + trackName + \": \" + this.trackHeights[track] + \" -> \" + height + \"; y: \" + y + \" -> \" + this.getY());\n      }\n      this.trackHeights[track] = height\n      this.tracks[track].div.style.height =\n        height + this.config.trackPadding + 'px'\n\n      this.layoutTracks()\n\n      this.setY(this.getY())\n\n      this.updateStaticElements({ height: this.getHeight() })\n    },\n\n    showVisibleBlocks: function (\n      updateHeight,\n      pos,\n      startX,\n      endX,\n      finishCallback,\n    ) {\n      if (pos === undefined) {pos = this.getPosition()}\n      if (startX === undefined)\n        {startX = pos.x - this.drawMargin * this.getWidth()}\n      if (endX === undefined)\n        {endX = pos.x + (1 + this.drawMargin) * this.getWidth()}\n      var leftVisible = Math.max(0, (startX / this.stripeWidth) | 0)\n      var rightVisible = Math.min(\n        this.stripeCount - 1,\n        (endX / this.stripeWidth) | 0,\n      )\n\n      var bpPerBlock = Math.round(this.stripeWidth / this.pxPerBp)\n\n      var startBase = Math.round(\n        this.pxToBp(leftVisible * this.stripeWidth + this.offset),\n      )\n      startBase -= 1\n      var containerStart = Math.round(this.pxToBp(this.offset))\n      var containerEnd = Math.round(\n        this.pxToBp(this.offset + this.stripeCount * this.stripeWidth),\n      )\n\n      // Track update will be carried after the maxVisible has a value\n      if (!this.maxVisible()) {return}\n\n      let showingPromises = []\n      this.overviewTrackIterate(function (track, view) {\n        showingPromises.push(\n          new Promise((resolve, reject) => {\n            track.showRange(\n              0,\n              view.overviewStripes - 1,\n              view.ref.start - 1,\n              view.overviewStripeBases,\n              view.overviewBox.w / (view.ref.end - view.ref.start),\n              undefined,\n              undefined,\n              resolve,\n            )\n          }),\n        )\n      })\n      this.trackIterate(function (track, view) {\n        showingPromises.push(\n          new Promise((resolve, reject) => {\n            track.showRange(\n              leftVisible,\n              rightVisible,\n              startBase,\n              bpPerBlock,\n              view.pxPerBp,\n              containerStart,\n              containerEnd,\n              resolve,\n            )\n          }),\n        )\n      })\n\n      this.updateStaticElements({\n        height: this.getHeight(),\n        width: this.getWidth(),\n        x: this.getX(),\n        y: this.getY(),\n      })\n\n      this.browser.publish('/jbrowse/v1/n/tracks/redraw')\n\n      const after = () => {\n        if (finishCallback) {finishCallback()}\n        this.browser.publish('/jbrowse/v1/n/tracks/redrawFinished')\n      }\n      Promise.all(showingPromises).then(after, after)\n    },\n\n    /**\n     * Add the given track configurations to the genome view.\n     * @param trackConfigs {Array[Object]} array of track configuration\n     * objects to add\n     */\n    showTracks: function (trackConfigs) {\n      // filter out any track configs that are already displayed\n      var needed = dojo.filter(\n        trackConfigs,\n        function (conf) {\n          return (\n            this._getTracks([conf.label]).length == 0 &&\n            !this.desiredTracks[conf.label]\n          )\n        },\n        this,\n      )\n      if (!needed.length) {return}\n      array.forEach(\n        trackConfigs,\n        function (ret) {\n          this.desiredTracks[ret.label] = true\n        },\n        this,\n      )\n\n      // insert the track configs into the trackDndWidget ( the widget\n      // will call create() on the confs to render them)\n      this.trackDndWidget.insertNodes(false, needed)\n\n      this.updateTrackList()\n\n      // scroll the view to the bottom so we can see the new track\n      var thisB = this\n      window.setTimeout(function () {\n        thisB.setY(Infinity)\n      }, 300)\n    },\n\n    /**\n     * Replace the track configurations that are currently visible in the genome view.\n     * @param trackConfigs {Array[Object]} array of track configuration\n     * objects to add\n     */\n    replaceTracks: function (trackConfigs) {\n      // for each one\n      array.forEach(\n        trackConfigs,\n        function (conf) {\n          // figure out its position in the genome view and delete it\n          var anchor\n          var done\n          var listNode = this.trackDndWidget.parent\n          array.forEach(\n            listNode.children,\n            function (item) {\n              if (done) {return}\n\n              var track = item.track\n              if (track && track.config.label == conf.label) {\n                done = 1\n                this.trackDndWidget.delItem(item.id)\n                if (item && item.parentNode) {item.parentNode.removeChild(item)}\n              } else {\n                anchor = item\n              }\n            },\n            this,\n          )\n\n          this.updateTrackList()\n\n          // insert the new track config into the trackDndWidget after the 'before'\n          this.trackDndWidget.insertNodes(false, [conf], false, anchor)\n        },\n        this,\n      )\n\n      if (trackConfigs.length) {this.updateTrackList()}\n    },\n\n    /**\n     * Remove the given track (configs) from the genome view.\n     * @param trackConfigs {Array[Object]} array of track configurations\n     */\n    hideTracks: function (/**Array[String]*/ trackConfigs) {\n      // filter out any track configs that are not displayed\n      var displayed = dojo.filter(\n        trackConfigs,\n        function (conf) {\n          return this._getTracks([conf.label]).length != 0\n        },\n        this,\n      )\n      if (!displayed.length) {return}\n      array.forEach(\n        trackConfigs,\n        function (ret) {\n          delete this.desiredTracks[ret.label]\n        },\n        this,\n      )\n\n      // remove the track configs from the trackDndWidget ( the widget\n      // will call create() on the confs to render them )\n      dojo.forEach(\n        displayed,\n        function (conf) {\n          this.trackDndWidget.forInItems(function (obj, id, map) {\n            if (conf.label === obj.data.label) {\n              this.trackDndWidget.delItem(id)\n              var item = dojo.byId(id)\n              if (item && item.parentNode) {item.parentNode.removeChild(item)}\n            }\n          }, this)\n        },\n        this,\n      )\n\n      this.updateTrackList()\n    },\n\n    /**\n     * Pin the tracks with the given names.  Returns an array with the\n     * names of tracks that were actually pinned.\n     */\n    pinTracks: function (/**Array[String]*/ trackNames) {\n      var tracks = this._getTracks(trackNames)\n      array.forEach(tracks, function (track) {\n        track.setPinned(true)\n      })\n      this.updateTrackList()\n      return array.map(tracks, function (t) {\n        return t.name\n      })\n    },\n\n    /**\n     * Unpin the tracks with the given names.  Returns an array with the\n     * names of tracks that were actually unpinned.\n     */\n    unpinTracks: function (/**Array[String]*/ trackNames) {\n      var tracks = this._getTracks(trackNames)\n      array.forEach(tracks, function (track) {\n        track.setPinned(false)\n      })\n      this.updateTrackList()\n      return array.map(tracks, function (t) {\n        return t.name\n      })\n    },\n\n    /**\n     * For an array of track names, get the track object if it exists.\n     * @private\n     * @returns {Array[Track]} the track objects that were found\n     */\n    _getTracks: function (/**Array[String]*/ trackNames) {\n      var tracks = [],\n        tn = { count: trackNames.length }\n      dojo.forEach(trackNames, function (n) {\n        tn[n] = 1\n      })\n      dojo.some(\n        this.tracks,\n        function (t) {\n          if (tn[t.name]) {\n            tracks.push(t)\n            tn.count--\n          }\n          return !tn.count\n        },\n        this,\n      )\n      return tracks\n    },\n\n    /**\n     * Create the DOM elements that will contain the rendering of the\n     * given track in this genome view.\n     * @private\n     * @returns {HTMLElement} the HTML element that will contain the\n     *                        rendering of this track\n     */\n    renderTrack: function (/**Object*/ trackConfig) {\n      var thisB = this\n\n      if (!trackConfig) {return null}\n\n      // just return its div if this track is already on\n      var existingTrack\n      if (\n        dojo.some(this.tracks, function (t) {\n          if (t.name == trackConfig.label) {\n            existingTrack = t\n            return true\n          }\n          return false\n        })\n      ) {\n        return existingTrack.div\n      }\n\n      var cssName = function (str) {\n        // replace weird characters and lowercase\n        return str.replace(/[^A-Za-z_0-9]/g, '_').toLowerCase()\n      }\n\n      var trackName = trackConfig.label\n      var trackDiv = dojo.create('div', {\n        className: [\n          'track',\n          cssName('track_' + trackConfig.type),\n          cssName('track_' + trackName),\n        ].join(' '),\n        id: 'track_' + trackName,\n      })\n      trackDiv.trackName = trackName\n\n      var trackClass, store\n\n      var makeTrack = dojo.hitch(this, function () {\n        // if there is no key for this track in its configuration, attempt to load the key from the track metadata\n        var metadataKey\n        try {\n          metadataKey = this.browser.trackMetaDataStore.getItem(\n            trackConfig.label,\n          ).key\n        } catch (e) {}\n\n        // create the track\n\n        var track = new trackClass({\n          key: trackConfig.key || metadataKey,\n          refSeq: this.ref,\n          config: trackConfig,\n          changeCallback: dojo.hitch(this, 'showVisibleBlocks', true),\n          trackPadding: this.config.trackPadding,\n          store: store,\n          browser: this.browser,\n        })\n        if (typeof store.setTrack == 'function') {store.setTrack(track)}\n\n        trackDiv.track = track\n\n        // track focus handler\n        dojo.connect(trackDiv, 'onclick', function (evt) {\n          thisB.setTrackFocus(track, 1)\n        })\n\n        var heightUpdate = dojo.hitch(this, 'trackHeightUpdate', trackName)\n        track.setViewInfo(\n          this,\n          heightUpdate,\n          this.stripeCount,\n          trackDiv,\n          this.stripePercent,\n          this.stripeWidth,\n          this.pxPerBp,\n          this.config.trackPadding,\n        )\n\n        track.updateStaticElements({\n          x: this.getX(),\n          y: this.getY(),\n          height: this.getHeight(),\n          width: this.getWidth(),\n        })\n\n        this.updateTrackList()\n      })\n\n      // might need to load both the store and the track class, so do it in\n      // parallel and have whichever one completes last do the actual\n      // track making.\n\n      if (!trackConfig.store)\n        {console.warn(\n          'configuration for track ' + trackConfig.label + ' has no store set',\n          trackConfig,\n        )}\n\n      // get the store\n      this.browser.getStore(trackConfig.store, function (s) {\n        store = s\n        // get the track class\n        var trackType =\n          trackConfig.type ||\n          thisB.browser.getTrackTypes().trackTypeDefaults[store.config.type]\n        dojo.global.require([trackType], function (class_) {\n          if (typeof class_ === 'string') {\n            console.error('Failed to load module: ' + trackConfig.type)\n            return\n          }\n          trackClass = class_\n          makeTrack()\n        })\n      })\n\n      return trackDiv\n    },\n    /**\n     *\n     * @param {type} track\n     * @param {type} state\n     * @returns {undefined}\n     */\n    setTrackFocus: function (track, state) {\n      var thisB = this\n\n      if (state === 1) {\n        if (this.focusTrack !== null) {\n          // if already in focus, don't do anything\n          if (this.focusTrack == track) {return}\n\n          thisB.browser.publish('/jbrowse/v1/n/tracks/unfocus', this.focusTrack)\n          this.focusTrack = null\n        }\n        thisB.focusTrack = track\n        thisB.browser.publish('/jbrowse/v1/n/tracks/focus', track)\n      }\n      if (state === 0) {\n        // if already in focus, don't do anything\n        if (this.focusTrack === null) {\n          console.log('no track in focus')\n          return\n        }\n        thisB.browser.publish('/jbrowse/v1/n/tracks/unfocus', this.focusTrack)\n        this.focusTrack = null\n      }\n    },\n\n    trackIterate: function (callback) {\n      var i\n      for (i = 0; i < this.uiTracks.length; i++)\n        {callback.call(this, this.uiTracks[i], this)}\n      for (i = 0; i < this.tracks.length; i++)\n        {callback.call(this, this.tracks[i], this)}\n    },\n\n    /* this function must be called whenever tracks in the GenomeView\n     * are added, removed, or reordered\n     */\n    updateTrackList: function () {\n      var tracks = [],\n        oldtracks = dojo.toJson(this.trackIndices || {})\n\n      // after a track has been dragged, the DOM is the only place\n      // that knows the new ordering\n      var containerChild = this.trackContainer.firstChild\n      do {\n        // this test excludes UI tracks, whose divs don't have a track property\n        if (containerChild.track) {tracks.push(containerChild.track)}\n      } while ((containerChild = containerChild.nextSibling))\n\n      // sort so that the pinned tracks come first.  also, sorting is\n      // not stable in all implementations, need to stabilize it\n      // ourselves by doing a schwartzian transform with the indices\n      tracks = array.map(tracks, function (t, i) {\n        return [t, i]\n      })\n      tracks = tracks.sort(function (a, b) {\n        var ap = a[0].isPinned() ? 1 : 0,\n          bp = b[0].isPinned() ? 1 : 0\n        return bp - ap || a[1] - b[1]\n      })\n      tracks = array.map(tracks, function (tr) {\n        return tr[0]\n      })\n\n      // create or destroy the pinned-track underlay as needed\n      if (tracks[0] && tracks[0].isPinned()) {\n        if (!this.pinUnderlay)\n          {this.pinUnderlay = domConstruct.create(\n            'div',\n            {\n              className: 'pin_underlay',\n              style: 'top: ' + this.topSpace,\n            },\n            this.trackContainer,\n          )}\n        if (!this.pinGridlinesTrack) {\n          var gridTrackDiv = domConstruct.create(\n            'div',\n            { className: 'track', style: 'top: 0px; height: 100%' },\n            this.pinUnderlay,\n          )\n          this.pinGridlinesTrack = new GridLinesTrack({\n            browser: this.browser,\n            refSeq: this.ref,\n          })\n          this.pinGridlinesTrack.setViewInfo(\n            this,\n            function () {},\n            this.stripeCount,\n            gridTrackDiv,\n            this.stripePercent,\n            this.stripeWidth,\n            this.pxPerBp,\n            this.config.trackPadding,\n          )\n          this.uiTracks.push(this.pinGridlinesTrack)\n        }\n      } else if (this.pinUnderlay) {\n        domConstruct.destroy(this.pinUnderlay)\n        delete this.pinUnderlay\n        this.uiTracks = array.filter(\n          this.uiTracks,\n          function (t) {\n            return t !== this.pinGridlinesTrack\n          },\n          this,\n        )\n        delete this.pinGridlinesTrack\n      }\n\n      // set the new tracklist\n      var oldTracks = this.tracks\n      this.tracks = tracks\n\n      // recalculate this.trackHeights and this.trackIndices\n      var newIndices = {}\n      var newHeights = new Array(this.tracks.length)\n      var totalHeight = 0\n      for (var i = 0; i < tracks.length; i++) {\n        newIndices[tracks[i].name] = i\n        if (tracks[i].name in this.trackIndices) {\n          newHeights[i] = this.trackHeights[this.trackIndices[tracks[i].name]]\n        } else {\n          newHeights[i] = 0\n        }\n        totalHeight += newHeights[i]\n        this.trackIndices[tracks[i].name] = i\n      }\n      this.trackIndices = newIndices\n      this.trackHeights = newHeights\n\n      // call destroy on any tracks that are being thrown out\n      array.forEach(\n        oldTracks || [],\n        function (track) {\n          if (!(track.name in newIndices)) {\n            Util.removeAttribute(track.div, 'track') //< because this file put it there\n            track.destroy()\n          }\n        },\n        this,\n      )\n\n      // lay the tracks out bottom to top\n      this.layoutTracks()\n\n      this.updateScroll()\n\n      // publish a message if the visible tracks or their ordering has changed\n      if (oldtracks != dojo.toJson(this.trackIndices || {})) {\n        this.browser.publish('/jbrowse/v1/n/tracks/visibleChanged', [\n          this.visibleTrackNames(),\n        ])\n        this.showVisibleBlocks()\n      }\n    },\n\n    /**\n     * Lay out all shown tracks.\n     */\n    layoutTracks: function () {\n      // lay out the track tops\n      var nextTop = this.topSpace\n      var lastTop = 0\n      var pinnedHeight = 0\n      var lastWasPinned = false\n      array.forEach(\n        this.tracks,\n        function (track, i) {\n          this.trackTops[i] = nextTop\n          lastTop = nextTop\n\n          if (track.isPinned()) {\n            track.div.style.top = nextTop + 'px'\n            lastWasPinned = true\n          } else {\n            track.div.style.top =\n              nextTop - this.y + (lastWasPinned ? 15 : 0) + 'px'\n            lastWasPinned = false\n          }\n\n          if (track.shown) {\n            nextTop += this.trackHeights[i] + this.config.trackPadding\n            if (track.isPinned()) {pinnedHeight = nextTop}\n          }\n        },\n        this,\n      )\n      if (pinnedHeight && this.pinUnderlay) {\n        this.pinUnderlay.style.height = pinnedHeight + 'px'\n      }\n\n      this.containerHeight = Math.max(\n        nextTop || 0,\n        Math.min(this.getY(), lastTop) + this.getHeight(),\n      )\n      this.scrollContainer.style.height = this.containerHeight + 'px'\n    },\n  })\n})\n\n/*\n\nCopyright (c) 2007-2009 The Evolutionary Software Foundation\n\nCreated by Mitchell Skinner <mitch_skinner@berkeley.edu>\n\nThis package and its accompanying libraries are free software; you can\nredistribute it and/or modify it under the terms of the LGPL (either\nversion 2.1, or at your option, any later version) or the Artistic\nLicense 2.0.  Refer to LICENSE for the full license text.\n\n*/\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/has.js":{"size":1277,"mtime":1738905961383,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/has.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/src/JBrowse/main.js":{"size":3940,"mtime":1738905961391,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/main.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"import 'babel-polyfill'\n\nrequire([\n  'JBrowse/Browser',\n  'JBrowse/Util',\n  'JBrowse/QueryParamConfigMapper',\n  'dojo/io-query',\n  'dojo/json',\n  'css!../../css/genome.scss',\n\n  // instruct build/glob-loader.js to insert includes for every bit of JBrowse and plugin code\n  //!! glob-loader, please include every JBrowse and plugin module here\n], function (Browser, Util, QueryParamConfigMapper, ioQuery, JSON) {\n  // the initial configuration of this JBrowse\n  // instance\n\n  // NOTE: this initial config is the same as any\n  // other JBrowse config in any other file.  this\n  // one just sets defaults from URL query params.\n  // If you are embedding JBrowse in some other app,\n  // you might as well just set this initial config\n  // to something like { include: '../my/dynamic/conf.json' },\n  // or you could put the entire\n  // dynamically-generated JBrowse config here.\n\n  // parse the query vars in the page URL\n  var queryParams = ioQuery.queryToObject(window.location.search.slice(1))\n\n  var config = {\n    containerID: 'GenomeBrowser',\n\n    dataRoot: queryParams.data,\n    queryParams: queryParams,\n    location: queryParams.loc,\n    forceTracks: queryParams.tracks,\n    initialHighlight: queryParams.highlight,\n    show_nav: queryParams.nav,\n    show_tracklist: queryParams.tracklist,\n    show_overview: queryParams.overview,\n    show_menu: queryParams.menu,\n    show_fullviewlink: queryParams.fullviewlink,\n    show_tracklabels: queryParams.tracklabels,\n    update_browser_title: queryParams.browsertitle,\n    highResolutionMode: queryParams.highres,\n    stores: {\n      url: { type: 'JBrowse/Store/SeqFeature/FromConfig', features: [] },\n    },\n    bookmarks: {},\n    makeFullViewURL: function (browser) {\n      // the URL for the 'Full view' link\n      // in embedded mode should be the current\n      // view URL, except with 'nav', 'tracklist',\n      // and 'overview' parameters forced to 1.\n\n      return browser.makeCurrentViewURL({\n        nav: 1,\n        tracklist: 1,\n        overview: 1,\n      })\n    },\n    electronData:\n      queryParams.electronData ||\n      (Util.isElectron() &&\n        electronRequire('electron').remote.app.getPath('userData')),\n  }\n  dojo.addOnLoad(() => {\n    // see if we can load some configuration from the data-config attribute of our container\n    try {\n      let elementConfig = document\n        .getElementById(config.containerID)\n        .getAttribute('data-config')\n      if (elementConfig) {\n        if (!/^\\s*{/.test(elementConfig)) {elementConfig = `{${elementConfig}}`}\n        elementConfig = JSON.parse(elementConfig)\n        config = Object.assign({}, config, elementConfig)\n      }\n    } catch (e) {\n      console.error(e)\n    }\n\n    //if there is ?addFeatures in the query params,\n    //define a store for data from the URL\n    if (queryParams.addFeatures) {\n      config.stores.url.features = JSON.parse(queryParams.addFeatures)\n    }\n\n    // if there is ?addTracks in the query params, add\n    // those track configurations to our initial\n    // configuration\n    if (queryParams.addTracks) {\n      config.tracks = JSON.parse(queryParams.addTracks)\n    }\n\n    // if there is ?addBookmarks, add those to configuration\n    if (queryParams.addBookmarks) {\n      config.bookmarks.features = JSON.parse(queryParams.addBookmarks)\n    }\n\n    // if there is ?addStores in the query params, add\n    // those store configurations to our initial\n    // configuration\n    if (queryParams.addStores) {\n      config.stores = JSON.parse(queryParams.addStores)\n    }\n\n    // this handles dot notation versions of addTracks, addBookmarks, and addStores\n    // see config doc for details\n    QueryParamConfigMapper().handleQueryParams(config, queryParams)\n\n    // create a JBrowse global variable holding the JBrowse instance\n    window.JBrowse = new Browser(config)\n\n    window.JBrowse.afterMilestone('loadRefSeqs', function () {\n      dojo.destroy(dojo.byId('LoadingScreen'))\n    })\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/Model/ArrayRepr.js":{"size":9293,"mtime":1738905961404,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Model/ArrayRepr.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([], function () {\n  /**\n   * @class JBrowse.Model.ArrayRepr\n   * @constructor\n   *\n   * @description\n   *\n   * Class for operating on indexed array representations of objects.\n   *\n   * For example, if we have a lot of objects with similar attrbutes, e.g.:\n   *\n   * <pre class=\"code\">\n   *     [\n   *         {start: 1, end: 2, strand: -1},\n   *         {start: 5, end: 6, strand: 1},\n   *         ...\n   *     ]\n   * </pre>\n   *\n   * @description\n   * we can represent them more compactly (e.g., in JSON) something like this:\n   *\n   * <pre class=\"code\">\n   *     class = [\"start\", \"end\", \"strand\"]\n   *     [\n   *         [1, 2, -1],\n   *         [5, 6, 1],\n   *         ...\n   *     ]\n   * </pre>\n   *\n   * If we want to represent a few different kinds of objects in our big list,\n   * we can have multiple \"class\" arrays, and tag each object to identify\n   * which \"class\" array describes it.\n   *\n   * For example, if we have a lot of instances of a few types of objects,\n   * like this:\n   *\n   * <pre class=\"code\">\n   *     [\n   *         {start: 1, end: 2, strand: 1, id: 1},\n   *         {start: 5, end: 6, strand: 1, id: 2},\n   *         ...\n   *         {start: 10, end: 20, chunk: 1},\n   *         {start: 30, end: 40, chunk: 2},\n   *         ...\n   *     ]\n   * </pre>\n   *\n   * We could use the first array position to indicate the \"class\" for the\n   * object, like this:\n   *\n   * <pre class=\"code\">\n   *     classes = [[\"start\", \"end\", \"strand\", \"id\"], [\"start\", \"end\", \"chunk\"]]\n   *     [\n   *         [0, 1, 2, 1, 1],\n   *         [0, 5, 6, 1, 2],\n   *         ...\n   *         [1, 10, 20, 1],\n   *         [1, 30, 40, 1]\n   *     ]\n   * </pre>\n   *\n   * Also, if we occasionally want to add an ad-hoc attribute, we could just\n   * stick an optional dictionary onto the end:\n   *\n   * <pre class=\"code\">\n   *     classes = [[\"start\", \"end\", \"strand\", \"id\"], [\"start\", \"end\", \"chunk\"]]\n   *     [\n   *         [0, 1, 2, 1, 1],\n   *         [0, 5, 6, 1, 2, {foo: 1}]\n   *     ]\n   * </pre>\n   *\n   * Given that individual objects are being represented by arrays, generic\n   * code needs some way to differentiate arrays that are meant to be objects\n   * from arrays that are actually meant to be arrays.\n   * So for each class, we include a dict with <attribute name>: true mappings\n   * for each attribute that is meant to be an array.\n   *\n   * Also, in cases where some attribute values are the same for all objects\n   * in a particular set, it may be convenient to define a \"prototype\"\n   * with default values for all objects in the set\n   *\n   * In the end, we get something like this:\n   *\n   * <pre class=\"code\">\n   *     classes=[\n   *         {'attributes': ['Start', 'End', 'Subfeatures'],\n   *          'proto': {'Chrom': 'chr1'},\n   *          'isArrayAttr': {Subfeatures: true}}\n   *         ]\n   * </pre>\n   *\n   * That's what this class facilitates.\n   */\n  function ArrayRepr(classes) {\n    this.classes = classes\n    this.fields = []\n    for (var cl = 0; cl < classes.length; cl++) {\n      this.fields[cl] = {}\n      for (var f = 0; f < classes[cl].attributes.length; f++) {\n        this.fields[cl][classes[cl].attributes[f]] = f + 1\n      }\n      if (classes[cl].proto === undefined) {classes[cl].proto = {}}\n      if (classes[cl].isArrayAttr === undefined) {classes[cl].isArrayAttr = {}}\n    }\n  }\n\n  /**\n   * @private\n   */\n  ArrayRepr.prototype.attrIndices = function (attr) {\n    return this.classes.map(function (x) {\n      return (\n        x.attributes.indexOf(attr) + 1 ||\n        x.attributes.indexOf(attr.toLowerCase()) + 1 ||\n        undefined\n      )\n    })\n  }\n\n  ArrayRepr.prototype.get = function (obj, attr) {\n    if (attr in this.fields[obj[0]]) {\n      return obj[this.fields[obj[0]][attr]]\n    } else {\n      // try lowercase\n      var lcattr = attr.toLowerCase()\n      if (lcattr in this.fields[obj[0]]) {\n        return obj[this.fields[obj[0]][lcattr]]\n      } else {\n        var adhocIndex = this.classes[obj[0]].attributes.length + 1\n        if (adhocIndex >= obj.length || !(attr in obj[adhocIndex])) {\n          if (attr in this.classes[obj[0]].proto)\n            {return this.classes[obj[0]].proto[attr]}\n          return undefined\n        }\n        return obj[adhocIndex][attr]\n      }\n    }\n  }\n\n  ArrayRepr.prototype.set = function (obj, attr, val) {\n    if (attr in this.fields[obj[0]]) {\n      obj[this.fields[obj[0]][attr]] = val\n    } else {\n      // try lowercase\n      var lcattr = attr.toLowerCase()\n      if (lcattr in this.fields[obj[0]]) {\n        obj[this.fields[obj[0]][lcattr]] = val\n      } else {\n        var adhocIndex = this.classes[obj[0]].attributes.length + 1\n        if (adhocIndex >= obj.length) {obj[adhocIndex] = {}}\n        obj[adhocIndex][attr] = val\n      }\n    }\n  }\n\n  ArrayRepr.prototype.makeSetter = function (attr) {\n    var self = this\n    return function (obj, val) {\n      self.set(obj, attr, val)\n    }\n  }\n\n  ArrayRepr.prototype.makeGetter = function (attr) {\n    var self = this\n    return function (obj) {\n      return self.get(obj, attr)\n    }\n  }\n\n  ArrayRepr.prototype.makeFastSetter = function (attr) {\n    // can be used only if attr is guaranteed to be in\n    // the \"classes\" array for this object\n    var indices = this.attrIndices(attr)\n    return function (obj, val) {\n      if (indices[obj[0]] !== undefined) {obj[indices[obj[0]]] = val}\n    }\n  }\n\n  ArrayRepr.prototype.makeFastGetter = function (attr) {\n    // can be used only if attr is guaranteed to be in\n    // the \"classes\" array for this object\n    var indices = this.attrIndices(attr)\n    return function (obj) {\n      if (indices[obj[0]] !== undefined) {return obj[indices[obj[0]]]}\n      else {return undefined}\n    }\n  }\n\n  ArrayRepr.prototype.construct = function (self, obj, klass) {\n    var result = new Array(self.classes[klass].length)\n    for (var attr in obj) {\n      this.set(result, attr, obj[attr])\n    }\n    return result\n  }\n\n  /**\n\nReturns fast pre-compiled getter and setter functions for use with\nArrays that use this representation.\n\nWhen the returned <code>get</code> and <code>set</code> functions are\nadded as methods to an Array that contains data in this\nrepresentation, they provide fast access by name to the data.\n\n@returns {Object} <code>{ get: function() {...}, set: function(val) {...} }</code>\n\n@example\nvar accessors = attrs.accessors();\nvar feature = get_feature_from_someplace();\nfeature.get = accessors.get;\n// print out the feature start and end\nconsole.log( feature.get('start') + ',' + feature.get('end') );\n\n*/\n  ArrayRepr.prototype.accessors = function () {\n    return (this._accessors = this._accessors || this._makeAccessors())\n  }\n\n  /**\n   * @private\n   */\n  ArrayRepr.prototype._makeAccessors = function () {\n    var that = this,\n      indices = {},\n      tags,\n      accessors = {\n        get: function (field) {\n          var f = this.get.field_accessors[field.toLowerCase()]\n          if (f) {return f.call(this)}\n          else {return undefined}\n        },\n        set: function (field, val) {\n          var f = this.set.field_accessors[field]\n          if (f) {return f.call(this, val)}\n          else {return undefined}\n        },\n        tags: function () {\n          return tags[this[0]] || []\n        },\n      }\n    accessors.get.field_accessors = {}\n    accessors.set.field_accessors = {}\n\n    // make a data structure as: { attr_name: [offset,offset,offset], }\n    // that will be convenient for finding the location of the attr\n    // for a given class like: indexForAttr{attrname}[classnum]\n    dojo.forEach(this.classes, function (cdef, classnum) {\n      dojo.forEach(cdef.attributes || [], function (attrname, offset) {\n        indices[attrname] = indices[attrname] || []\n        indices[attrname][classnum] = offset + 1\n\n        attrname = attrname.toLowerCase()\n\n        indices[attrname] = indices[attrname] || []\n        indices[attrname][classnum] = offset + 1\n      })\n    })\n\n    // lowercase all the class attributes\n    tags = dojo.map(this.classes, function (c) {\n      return c.attributes\n    })\n\n    // use that to make precalculated get and set accessors for each field\n    for (var attrname in indices) {\n      if (!indices.hasOwnProperty(attrname)) {continue}\n\n      // get\n      accessors.get.field_accessors[attrname] = (function () {\n        var attr_indices = indices[attrname]\n        return !attr_indices\n          ? function () {\n              return undefined\n            }\n          : function () {\n              return this[attr_indices[this[0]]]\n            }\n      })()\n\n      // set\n      accessors.set.field_accessors[attrname] = (function () {\n        var attr_indices = indices[attrname]\n        return !attr_indices\n          ? function () {\n              return undefined\n            }\n          : function (v) {\n              return (this[attr_indices[this[0]]] = v)\n            }\n      })()\n    }\n\n    return accessors\n  }\n\n  return ArrayRepr\n})\n/*\n\nCopyright (c) 2007-2010 The Evolutionary Software Foundation\n\nCreated by Mitchell Skinner <mitch_skinner@berkeley.edu>\n\nThis package and its accompanying libraries are free software; you can\nredistribute it and/or modify it under the terms of the LGPL (either\nversion 2.1, or at your option, any later version) or the Artistic\nLicense 2.0.  Refer to LICENSE for the full license text.\n\n*/\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/Model/BGZip/BGZBlob.js":{"size":3622,"mtime":1738905961411,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Model/BGZip/BGZBlob.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/src/JBrowse/Model/BGZip/VirtualOffset.js":{"size":1132,"mtime":1738905961415,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Model/BGZip/VirtualOffset.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/src/JBrowse/Model/BinaryTreeNode.js":{"size":3886,"mtime":1738905961421,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Model/BinaryTreeNode.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/src/JBrowse/Model/BlobFilehandleWrapper.js":{"size":811,"mtime":1738905961426,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Model/BlobFilehandleWrapper.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/src/JBrowse/Model/CoverageFeature.js":{"size":440,"mtime":1738905961429,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Model/CoverageFeature.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/src/JBrowse/Model/CSIIndex.js":{"size":6663,"mtime":1738905961445,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Model/CSIIndex.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'JBrowse/Util',\n  'JBrowse/Model/DataView',\n  'JBrowse/Model/TabixIndex',\n  'JBrowse/Model/BGZip/VirtualOffset',\n], function (declare, Util, jDataView, TabixIndex, VirtualOffset) {\n  function lshift(num, bits) {\n    return num * Math.pow(2, bits)\n  }\n  function rshift(num, bits) {\n    return Math.floor(num / Math.pow(2, bits))\n  }\n  // inner class representing a chunk\n  var Chunk = Util.fastDeclare({\n    constructor: function (minv, maxv, bin) {\n      this.minv = minv\n      this.maxv = maxv\n      this.bin = bin\n    },\n    toUniqueString: function () {\n      return this.minv + '..' + this.maxv + ' (bin ' + this.bin + ')'\n    },\n    toString: function () {\n      return this.toUniqueString()\n    },\n    compareTo: function (b) {\n      return (\n        this.minv.compareTo(b.minv) ||\n        this.maxv.compareTo(b.maxv) ||\n        this.bin - b.bin\n      )\n    },\n    compare: function (b) {\n      return this.compareTo(b)\n    },\n    fetchedSize: function () {\n      return this.maxv.block + lshift(1, 16) - this.minv.block + 1\n    },\n  })\n\n  return declare(TabixIndex, {\n    // fetch and parse the index\n    _parseIndex: function (bytes, deferred) {\n      this._littleEndian = true\n      var data = new jDataView(bytes, 0, undefined, this._littleEndian)\n\n      // check TBI magic numbers\n      if (data.getInt32() != 21582659 /* \"CSI\\1\" */) {\n        // try the other endianness if no magic\n        this._littleEndian = false\n        data = new jDataView(bytes, 0, undefined, this._littleEndian)\n        if (data.getInt32() != 21582659 /* \"CSI\\1\" */) {\n          console.error('Not a CSI file')\n          deferred.reject('Not a CSI file')\n          return\n        }\n      }\n\n      // number of reference sequences in the index\n      this.minShift = data.getInt32()\n      this.depth = data.getInt32()\n      var l_aux = data.getInt32()\n      var aux = data.getBytes(l_aux, undefined, false)\n      var refCount = data.getInt32()\n\n      // read sequence dictionary\n      this._refIDToName = new Array(refCount)\n      this._refNameToID = {}\n\n      if (l_aux) {\n        this._parseAux(aux)\n      }\n\n      // read the per-reference-sequence indexes\n      this._indices = new Array(refCount)\n      for (var i = 0; i < refCount; ++i) {\n        // the binning index\n        var binCount = data.getInt32()\n        var idx = (this._indices[i] = { binIndex: {} })\n        for (var j = 0; j < binCount; ++j) {\n          var bin = data.getInt32()\n          var loffset = new VirtualOffset(data.getBytes(8))\n          var chunkCount = data.getInt32()\n          var chunks = new Array(chunkCount)\n          for (var k = 0; k < chunkCount; ++k) {\n            var u = new VirtualOffset(data.getBytes(8))\n            var v = new VirtualOffset(data.getBytes(8))\n            this._findFirstData(u)\n            chunks[k] = new Chunk(u, v, bin)\n          }\n          idx.binIndex[bin] = chunks\n        }\n        // the linear index\n      }\n\n      this.minAlignmentVO = this.firstDataLine\n      deferred.resolve({ success: true })\n    },\n\n    _parseAux: function (aux) {\n      var data = new jDataView(new Uint8Array(aux).buffer, 0, undefined, true)\n      var ret = data.getInt32()\n      this.columnNumbers = {\n        ref: data.getInt32(),\n        start: data.getInt32(),\n        end: data.getInt32(),\n      }\n      this.metaValue = data.getInt32()\n      this.metaChar = this.metaValue\n        ? String.fromCharCode(this.metaValue)\n        : null\n      this.skipLines = data.getInt32()\n      var nameSectionLength = data.getInt32()\n\n      this._parseNameBytes(data.getBytes(nameSectionLength, undefined, false))\n    },\n\n    TAD_LIDX_SHIFT: 14,\n\n    featureCount: function (refName, refNameIsID) {\n      var tid\n      if (refNameIsID) {tid = refName}\n      else {tid = this.getRefId(refName)}\n\n      var indexes = this._indices[tid]\n      if (!indexes) {return -1}\n      var bl = this._bin_limit(this.minShift, this.depth)\n      var ret = indexes.binIndex[bl + 1]\n      return ret ? ret[ret.length - 1].minv.offset : -1\n    },\n    blocksForRange: function (refName, beg, end, refNameIsID) {\n      if (beg < 0) {beg = 0}\n\n      var tid\n      if (refNameIsID) {tid = refName}\n      else {tid = this.getRefId(refName)}\n\n      var indexes = this._indices[tid]\n      if (!indexes) {return []}\n\n      var linearIndex = indexes.linearIndex,\n        binIndex = indexes.binIndex\n\n      var bins = this._reg2bins(beg, end, this.minShift, this.depth)\n      // var linearCount = data.getInt32();\n      // var linear = idx.linearIndex = new Array( linearCount );\n      // for (var k = 0; k < linearCount; ++k) {\n      //     linear[k] = new VirtualOffset( data.getBytes(8) );\n      //     this._findFirstData( linear[k] );\n      // }\n      var min_off = new VirtualOffset(0, 0)\n\n      var i,\n        l,\n        n_off = 0\n      for (i = 0; i < bins.length; ++i) {\n        n_off += (binIndex[bins[i]] || []).length\n      }\n\n      if (n_off == 0) {return []}\n\n      var off = []\n\n      var chunks\n      for (i = n_off = 0; i < bins.length; ++i)\n        {if ((chunks = binIndex[bins[i]]))\n          {for (var j = 0; j < chunks.length; ++j)\n            //if( min_off.compareTo( chunks[j].maxv ) < 0 )\n            {off[n_off++] = new Chunk(\n              chunks[j].minv,\n              chunks[j].maxv,\n              chunks[j].bin,\n            )}}}\n\n      if (!off.length) {return []}\n\n      off = off.sort(function (a, b) {\n        return a.compareTo(b)\n      })\n\n      // resolve completely contained adjacent blocks\n      for (i = 1, l = 0; i < n_off; ++i) {\n        if (off[l].maxv.compareTo(off[i].maxv) < 0) {\n          ++l\n          off[l].minv = off[i].minv\n          off[l].maxv = off[i].maxv\n        }\n      }\n      n_off = l + 1\n\n      return off.slice(0, n_off)\n    },\n\n    /* calculate bin given an alignment covering [beg,end) (zero-based, half-close-half-open) */\n    _reg2bin: function (beg, end, min_shift, depth) {\n      let l,\n        s = min_shift,\n        t = ((1 << (depth * 3)) - 1) / 7\n      for (--end, l = depth; l > 0; --l, s += 3, t -= 1 << (l * 3)) {\n        if (beg >> s == end >> s) {return t + (beg >> s)}\n      }\n      return 0\n    },\n\n    _reg2bins: function (beg, end, min_shift, depth) {\n      let l,\n        t,\n        s = min_shift + depth * 3,\n        n\n      let bins = []\n      for (\n        --end, l = n = t = 0;\n        l <= depth;\n        s -= 3, t += lshift(1, l * 3), ++l\n      ) {\n        let b = t + rshift(beg, s)\n        let e = t + rshift(end, s)\n        for (let i = b; i <= e; ++i) {bins[n++] = i}\n      }\n      return bins\n    },\n    _bin_limit: function (min_shift, depth = 5) {\n      return ((1 << ((depth + 1) * 3)) - 1) / 7\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/Model/DataView.js":{"size":1566,"mtime":1738905961450,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Model/DataView.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"const jDataViewOld = cjsRequire('../../jdataview-1.1-patch.X')\nconst deprecate = cjsRequire('util-deprecate')\n\n/**\n * Subclass of jDataView with a getUint64 method.\n */\ndefine([], function () {\n  var DataView = function () {\n    jDataViewOld.apply(this, arguments)\n  }\n\n  // jDataView, in the version that JBrowse is using it, does not conform to the DataView API as\n  // it was eventually settled. We need to move away from using it.\n  DataView = deprecate(\n    DataView,\n    'JBrowse/Model/DataView is deprecated, please migrate to something else',\n  )\n\n  try {\n    DataView.prototype = new jDataViewOld(new ArrayBuffer([1]), 0, 1)\n  } catch (e) {\n    console.error(e)\n  }\n\n  /**\n   * Get a 53-bit integer from 64 bits and approximate the number if it overflows.\n   */\n  DataView.prototype.getUint64Approx = function (byteOffset, littleEndian) {\n    var b = this._getBytes(8, byteOffset, littleEndian)\n    var result =\n      b[0] * Math.pow(2, 56) +\n      b[1] * Math.pow(2, 48) +\n      b[2] * Math.pow(2, 40) +\n      b[3] * Math.pow(2, 32) +\n      b[4] * Math.pow(2, 24) +\n      (b[5] << 16) +\n      (b[6] << 8) +\n      b[7]\n\n    if (b[0] || b[1] & 224) {\n      result = Number(result)\n      result.overflow = true\n    }\n\n    return result\n  }\n\n  /**\n   * Get a 53-bit integer from 64 bits and throw if it overflows.\n   */\n  DataView.prototype.getUint64 = function (byteOffset, littleEndian) {\n    var result = this.getUint64Approx(byteOffset, littleEndian)\n    if (result.overflow) {throw new Error('integer overflow')}\n    return result\n  }\n\n  return DataView\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/Model/FileBlob.js":{"size":3699,"mtime":1738905961456,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Model/FileBlob.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'dojo/_base/array',\n  'dojo/has',\n  'JBrowse/Util/TextIterator',\n], function (declare, array, has, TextIterator) {\n  var FileBlob = declare(\n    null,\n    /**\n     * @lends JBrowse.Model.FileBlob.prototype\n     */\n    {\n      /**\n       * Blob of binary data fetched from a local file (with FileReader).\n       *\n       * Adapted by Robert Buels from the BlobFetchable object in the\n       * Dalliance Genome Explorer, which is copyright Thomas Down\n       * 2006-2011.\n       * @constructs\n       */\n      constructor: function (b) {\n        this.blob = b\n        this.size = b.size\n        this.totalSize = b.size\n      },\n\n      slice: function (start, length) {\n        var sliceFunc =\n          this.blob.mozSlice || this.blob.slice || this.blob.webkitSlice\n        return new FileBlob(\n          length\n            ? sliceFunc.call(this.blob, start, start + length)\n            : sliceFunc.call(this.blob, start),\n        )\n      },\n\n      fetchLines: function (lineCallback, endCallback, failCallback) {\n        var thisB = this\n        this.fetch(function (data) {\n          data = new Uint8Array(data)\n\n          var lineIterator = new TextIterator.FromBytes({\n            bytes: data,\n            // only return a partial line at the end\n            // if we are not operating on a slice of\n            // the file\n            returnPartialRecord: !this.end,\n          })\n          var line\n          while ((line = lineIterator.getline())) {\n            lineCallback(line)\n          }\n\n          endCallback()\n        }, failCallback)\n      },\n\n      readLines: function (\n        offset = 0,\n        length,\n        lineCallback,\n        endCallback,\n        failCallback,\n      ) {\n        var start = this.start + offset,\n          end = start + length\n        var skipFirst = offset != 0\n        this.slice(offset, length).fetchLines(\n          function () {\n            // skip the first line if we have a\n            // nonzero offset, because it is probably\n            // incomplete\n            if (!skipFirst) {lineCallback()}\n            skipFirst = false\n          },\n          endCallback,\n          failCallback,\n        )\n      },\n\n      read: function (offset = 0, length, callback, failCallback) {\n        var start = this.start + offset,\n          end = start + length\n\n        // short-circuit a read of 0 bytes here, because browsers\n        // actually sometimes crash if you try to read 0 bytes from\n        // a local file!\n        if (!length) {\n          callback(new ArrayBuffer())\n          return\n        }\n\n        this.slice(offset, length).fetch(callback, failCallback)\n      },\n\n      readBufferPromise(offset, length) {\n        return new Promise((resolve, reject) => {\n          this.read(\n            offset,\n            length,\n            data => {\n              resolve(window.Buffer.from(data))\n            },\n            reject,\n          )\n        })\n      },\n\n      fetch: function (callback, failCallback) {\n        try {\n          const reader = new FileReader()\n          reader.onloadend = ev => {\n            callback(reader.result)\n          }\n          reader.onerror = failCallback\n          reader.readAsArrayBuffer(this.blob)\n        } catch (e) {\n          failCallback(e)\n        }\n      },\n\n      fetchBufferPromise() {\n        return new Promise((resolve, reject) => {\n          this.fetch(data => {\n            resolve(window.Buffer.from(data))\n          }, reject)\n        })\n      },\n\n      stat(callback, failCallback) {\n        this.statPromise().then(callback, failCallback)\n      },\n\n      async statPromise() {\n        return { size: this.blob.size }\n      },\n    },\n  )\n  return FileBlob\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/Model/Location.js":{"size":1426,"mtime":1738905961461,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Model/Location.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define(['dojo/_base/array', 'JBrowse/Util'], function (array, Util) {\n  return Util.fastDeclare({\n    constructor: function (args) {\n      if (args) {\n        if (typeof args == 'string') {args = Util.parseLocString(args)}\n\n        if (args.location) {this._populate(args.location)}\n        if (args.feature) {\n          var f = args.feature\n          this._populate({\n            start: f.get('start'),\n            end: f.get('end'),\n            ref:\n              f.get('seq_id') ||\n              (args.tracks ? args.tracks[0].browser.refSeq.name : undefined),\n            strand: f.get('strand'),\n            objectName: f.get('name') || f.get('id'),\n          })\n        }\n\n        this._populate(args)\n      }\n    },\n    _populate: function (args) {\n      array.forEach(\n        'ref,start,end,strand,tracks,objectName'.split(','),\n        function (p) {\n          if (p in args) {this[p] = args[p]}\n        },\n        this,\n      )\n    },\n\n    toString: function () {\n      var locstring = Util.assembleLocString(this)\n      if (this.objectName) {return locstring + ' (' + this.objectName + ')'}\n      else {return locstring}\n    },\n\n    fromString: function (str) {\n      var p = Util.parseLocString(str)\n      p.objectName = p.extra\n      delete p.extra\n      this._populate(p)\n    },\n\n    localeCompare: function (b) {\n      var as = this.toString()\n      var bs = b.toString()\n      return as.localeCompare(bs)\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/Model/modEncodeTrackMetadata.js":{"size":3162,"mtime":1738905961467,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Model/modEncodeTrackMetadata.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'dojo/data/util/simpleFetch',\n  'JBrowse/Util',\n], function (declare, simpleFetch, Util) {\n  var dojof = Util.dojof\n\n  var M = declare(\n    null,\n\n    /**\n     * @lends JBrowse.Model.modEncodeTrackMetadata.prototype\n     */\n    {\n      /**\n       * Track metadata datasource that understands the format of the\n       * modencode.js track metadata JSON currently (May 2012) used at\n       * data.modencode.org.\n       * @constructor\n       * @param args.url {String} URL to fetch the metadata JSON from\n       */\n      constructor: function (args) {\n        this.url = args.url\n      },\n\n      // dojo.data.api.Read support\n      getValue: function (i, attr, defaultValue) {\n        var v = i[attr]\n        return typeof v == 'undefined' ? defaultValue : v\n      },\n      getValues: function (i, attr) {\n        var a = [i[attr]]\n        return typeof a[0] == 'undefined' ? [] : a\n      },\n\n      getAttributes: function (item) {\n        return dojof.keys(item)\n      },\n\n      hasAttribute: function (item, attr) {\n        return item.hasOwnProperty(attr)\n      },\n\n      containsValue: function (item, attribute, value) {\n        return item[attribute] == value\n      },\n\n      isItem: function (item) {\n        return typeof item == 'object' && typeof item.label == 'string'\n      },\n\n      isItemLoaded: function () {\n        return true\n      },\n\n      loadItem: function (args) {},\n\n      // used by the dojo.data.util.simpleFetch mixin to implement fetch()\n      _fetchItems: function (keywordArgs, findCallback, errorCallback) {\n        dojo.xhrGet({\n          url: this.url,\n          handleAs: 'json',\n          load: dojo.hitch(this, function (data) {\n            var items = []\n            dojo.forEach(\n              data.items || [],\n              function (i) {\n                if (dojo.isArray(i.Tracks))\n                  {dojo.forEach(\n                    i.Tracks,\n                    function (trackName) {\n                      var item = dojo.clone(i)\n                      item.key = item.label\n                      item.label = trackName\n                      delete item.Tracks\n                      items.push(item)\n                    },\n                    this,\n                  )}\n              },\n              this,\n            )\n            findCallback(items, keywordArgs)\n          }),\n          error: function (e) {\n            errorCallback(e, keywordArgs)\n          },\n        })\n      },\n\n      getFeatures: function () {\n        return {\n          'dojo.data.api.Read': true,\n          'dojo.data.api.Identity': true,\n        }\n      },\n      close: function () {},\n\n      getLabel: function (i) {\n        return this.getValue(i, 'key', undefined)\n      },\n      getLabelAttributes: function (i) {\n        return ['key']\n      },\n\n      // dojo.data.api.Identity support\n      getIdentityAttributes: function () {\n        return ['label']\n      },\n      getIdentity: function (i) {\n        return this.getValue(i, 'label', undefined)\n      },\n      fetchItemByIdentity: function (id) {\n        return this.identIndex[id]\n      },\n    },\n  )\n\n  dojo.extend(M, simpleFetch)\n\n  return M\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/Model/NestedFrequencyTable.js":{"size":3033,"mtime":1738905961473,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Model/NestedFrequencyTable.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define(['JBrowse/Util'], function (Util) {\n  // A class that keeps a frequency table.  the categories in the\n  // frequency table can be other frequency tables.\n  // Note that the frequency table acts like a number (its total) when\n  // used as a number or a string.  E.g.  0+table is like table.total()\n\n  var NestedFrequencyTable = Util.fastDeclare({\n    constructor: function (initialData) {\n      this._categories = {}\n      if (initialData) {dojo.mixin(this._categories, initialData)}\n    },\n\n    // get the sum of all the category counts\n    total: function () {\n      // calculate total if necessary\n      var t = 0\n      for (var k in this._categories) {\n        var v = this._categories[k]\n        t += v.total ? v.total() : v\n      }\n      return t\n    },\n\n    // decrement the count for the given category\n    decrement: function (slotName, amount) {\n      if (!amount) {amount = 1}\n\n      if (!slotName) {slotName = 'default'}\n      else {slotName = slotName.toString()}\n\n      if (this._categories[slotName])\n        {return (this._categories[slotName] = Math.max(\n          0,\n          this._categories[slotName] - amount,\n        ))}\n      else {return 0}\n    },\n\n    // increment the count for the given category\n    increment: function (slotName, amount) {\n      if (!amount) {amount = 1}\n\n      if (!slotName) {slotName = 'default'}\n      else {slotName = slotName.toString()}\n      return (this._categories[slotName] =\n        (this._categories[slotName] || 0) + amount)\n    },\n\n    // get the value of the given category.  may be a number or a\n    // frequency table.\n    get: function (slotName) {\n      return this._categories[slotName] || 0\n    },\n\n    // get a given category as a frequency table\n    getNested: function (path) {\n      if (typeof path == 'string') {path = path.split('/')}\n\n      if (!path.length) {return this}\n\n      var slotName = path[0].toString()\n      var slot = this._categories[slotName]\n      if (!slot || !slot._categories)\n        {slot = this._categories[slotName] = new NestedFrequencyTable(\n          slot ? { default: slot + 0 } : {},\n        )}\n\n      if (path.length > 1) {\n        return slot.getNested(path.slice(1))\n      } else {return slot}\n    },\n\n    // returns array of category names that are present\n    categories: function () {\n      return Util.dojof.keys(this._categories)\n    },\n\n    toString: function () {\n      return this.total()\n        .toPrecision(6)\n        .toString()\n        .replace(/\\.?0+$/, '')\n    },\n\n    valueOf: function () {\n      return this.total()\n    },\n\n    // iterate through the categories and counts, call like:\n    //\n    //   tbl.forEach( function( count, categoryName ) {\n    //      // do something\n    //   }, this );\n    //\n    forEach: function (func, ctx) {\n      var c = this._categories\n      if (ctx) {\n        for (var slotName in c) {\n          func.call(ctx, c[slotName], slotName)\n        }\n      } else {\n        for (var slotName in c) {\n          func(c[slotName], slotName)\n        }\n      }\n    },\n  })\n\n  return NestedFrequencyTable\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/Model/Range.js":{"size":3549,"mtime":1738905961485,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Model/Range.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/src/JBrowse/Model/SimpleFeature.js":{"size":2477,"mtime":1738905961493,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Model/SimpleFeature.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"/**\n * Simple implementation of a feature object.\n */\ndefine(['JBrowse/Util'], function (Util) {\n  var counter = 0\n\n  var SimpleFeature = Util.fastDeclare({\n    /**\n     * @param args.data {Object} key-value data, must include 'start' and 'end'\n     * @param args.parent {Feature} optional parent feature\n     * @param args.id {String} optional unique identifier.  can also be in data.uniqueID.\n     *\n     * Note: args.data.subfeatures can be an array of these same args,\n     * which will be inflated to more instances of this class.\n     */\n    constructor: function (args) {\n      args = args || {}\n      this.data = args.data || {}\n      this._parent = args.parent\n      this._uniqueID =\n        args.id ||\n        this.data.uniqueID ||\n        (this._parent\n          ? this._parent.id() + '_' + counter++\n          : 'SimpleFeature_' + counter++)\n\n      // inflate any subfeatures that are not already feature objects\n      var subfeatures\n      if ((subfeatures = this.data.subfeatures)) {\n        for (var i = 0; i < subfeatures.length; i++) {\n          if (typeof subfeatures[i].get != 'function') {\n            subfeatures[i] = new SimpleFeature({\n              data: subfeatures[i],\n              parent: this,\n            })\n          }\n        }\n      }\n    },\n\n    /**\n     * Get a piece of data about the feature.  All features must have\n     * 'start' and 'end', but everything else is optional.\n     */\n    get: function (name) {\n      return this.data[name] || this.data[name.toLowerCase()]\n    },\n\n    /**\n     * Set an item of data.\n     */\n    set: function (name, val) {\n      this.data[name] = val\n    },\n\n    /**\n     * Get an array listing which data keys are present in this feature.\n     */\n    tags: function () {\n      var t = []\n      var d = this.data\n      for (var k in d) {\n        if (d.hasOwnProperty(k)) {t.push(k)}\n      }\n      return t\n    },\n\n    /**\n     * Get the unique ID of this feature.\n     */\n    id: function (newid) {\n      if (newid) {this._uniqueID = newid}\n      return this._uniqueID\n    },\n\n    /**\n     * Get this feature's parent feature, or undefined if none.\n     */\n    parent: function () {\n      return this._parent\n    },\n\n    /**\n     * Get an array of child features, or undefined if none.\n     */\n    children: function () {\n      return this.get('subfeatures')\n    },\n\n    toJSON: function () {\n      const d = Object.assign({}, this)\n      delete d._parent\n      return d\n    },\n  })\n\n  return SimpleFeature\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/Model/TabixIndex.js":{"size":9186,"mtime":1738905961510,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Model/TabixIndex.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'dojo/_base/array',\n  'dojo/_base/Deferred',\n  'JBrowse/has',\n  'JBrowse/Model/DataView',\n  'JBrowse/Util',\n  'JBrowse/Model/BGZip/VirtualOffset',\n], function (declare, array, Deferred, has, jDataView, Util, VirtualOffset) {\n  // inner class representing a chunk\n  var Chunk = Util.fastDeclare({\n    constructor: function (minv, maxv, bin) {\n      this.minv = minv\n      this.maxv = maxv\n      this.bin = bin\n    },\n    toUniqueString: function () {\n      return this.minv + '..' + this.maxv + ' (bin ' + this.bin + ')'\n    },\n    toString: function () {\n      return this.toUniqueString()\n    },\n    compareTo: function (b) {\n      return (\n        this.minv.compareTo(b.minv) ||\n        this.maxv.compareTo(b.maxv) ||\n        this.bin - b.bin\n      )\n    },\n    compare: function (b) {\n      return this.compareTo(b)\n    },\n    fetchedSize: function () {\n      return this.maxv.block + (1 << 16) - this.minv.block + 1\n    },\n  })\n\n  return declare(null, {\n    constructor: function (args) {\n      this.browser = args.browser\n      this.blob = args.blob\n      this.load()\n    },\n\n    load: function () {\n      var thisB = this\n      return (this._loaded =\n        this._loaded ||\n        function () {\n          var d = new Deferred()\n          if (!has('typed-arrays'))\n            {d.reject(\n              'This web browser lacks support for JavaScript typed arrays.',\n            )}\n          else\n            {this.blob.fetch(\n              function (data) {\n                thisB._parseIndex(data, d)\n              },\n              dojo.hitch(d, 'reject'),\n            )}\n          return d\n        }.call(this))\n    },\n\n    // fetch and parse the index\n    _parseIndex: function (bytes, deferred) {\n      this._littleEndian = true\n      var data = new jDataView(bytes, 0, undefined, this._littleEndian)\n\n      // check TBI magic numbers\n      if (data.getInt32() != 21578324 /* \"TBI\\1\" */) {\n        // try the other endianness if no magic\n        this._littleEndian = false\n        data = new jDataView(bytes, 0, undefined, this._littleEndian)\n        if (data.getInt32() != 21578324 /* \"TBI\\1\" */) {\n          console.error('Not a TBI file')\n          deferred.reject('Not a TBI file')\n          return\n        }\n      }\n\n      // number of reference sequences in the index\n      var refCount = data.getInt32()\n      this.presetType = data.getInt32()\n      this.columnNumbers = {\n        ref: data.getInt32(),\n        start: data.getInt32(),\n        end: data.getInt32(),\n      }\n      this.metaValue = data.getInt32()\n      this.metaChar = this.metaValue\n        ? String.fromCharCode(this.metaValue)\n        : null\n      this.skipLines = data.getInt32()\n\n      // read sequence dictionary\n      this._refIDToName = new Array(refCount)\n      this._refNameToID = {}\n      var nameSectionLength = data.getInt32()\n      this._parseNameBytes(data.getBytes(nameSectionLength, undefined, false))\n\n      // read the per-reference-sequence indexes\n      this._indices = new Array(refCount)\n      for (var i = 0; i < refCount; ++i) {\n        // the binning index\n        var binCount = data.getInt32()\n        var idx = (this._indices[i] = { binIndex: {} })\n        for (var j = 0; j < binCount; ++j) {\n          var bin = data.getInt32()\n          var chunkCount = data.getInt32()\n          var chunks = new Array(chunkCount)\n          for (var k = 0; k < chunkCount; ++k) {\n            var u = new VirtualOffset(data.getBytes(8))\n            var v = new VirtualOffset(data.getBytes(8))\n            this._findFirstData(u)\n            chunks[k] = new Chunk(u, v, bin)\n          }\n          idx.binIndex[bin] = chunks\n        }\n        // the linear index\n        var linearCount = data.getInt32()\n        var linear = (idx.linearIndex = new Array(linearCount))\n        for (var k = 0; k < linearCount; ++k) {\n          linear[k] = new VirtualOffset(data.getBytes(8))\n          this._findFirstData(linear[k])\n        }\n      }\n      deferred.resolve({ success: true })\n    },\n\n    _findFirstData: function (virtualOffset) {\n      var fdl = this.firstDataLine\n      this.firstDataLine = fdl\n        ? fdl.compareTo(virtualOffset) > 0\n          ? virtualOffset\n          : fdl\n        : virtualOffset\n    },\n\n    _parseNameBytes: function (namesBytes) {\n      var offset = 0\n\n      function getChar() {\n        var b = namesBytes[offset++]\n        return b ? String.fromCharCode(b) : null\n      }\n\n      function getString() {\n        var c,\n          s = ''\n        while ((c = getChar())) {s += c}\n        return s.length ? s : null\n      }\n\n      var refName,\n        refID = 0\n      for (; (refName = getString()); refID++) {\n        this._refIDToName[refID] = refName\n        this._refNameToID[this.browser.regularizeReferenceName(refName)] = refID\n      }\n    },\n\n    /**\n     * Interrogate whether a store has data for a given reference\n     * sequence.  Calls the given callback with either true or false.\n     *\n     * Implemented as a binary interrogation because some stores are\n     * smart enough to regularize reference sequence names, while\n     * others are not.\n     */\n    hasRefSeq: function (seqName, callback, errorCallback) {\n      var thisB = this\n      seqName = thisB.browser.regularizeReferenceName(seqName)\n      thisB.load().then(function () {\n        if (seqName in thisB._refNameToID) {\n          callback(true)\n          return\n        }\n        callback(false)\n      })\n    },\n\n    getRefId: function (refName) {\n      refName = this.browser.regularizeReferenceName(refName)\n      return this._refNameToID[refName]\n    },\n\n    TAD_LIDX_SHIFT: 14,\n\n    featureCount: function (refName) {\n      var tid = this.getRefId(refName)\n      var indexes = this._indices[tid]\n      if (!indexes) {return -1}\n      var ret = indexes.binIndex[this._bin_limit() + 1]\n      return ret ? ret[ret.length - 1].minv.offset : -1\n    },\n\n    blocksForRange: function (refName, beg, end) {\n      if (beg < 0) {beg = 0}\n\n      var tid = this.getRefId(refName)\n      var indexes = this._indices[tid]\n      if (!indexes) {return []}\n\n      var linearIndex = indexes.linearIndex,\n        binIndex = indexes.binIndex\n\n      var bins = this._reg2bins(beg, end)\n\n      var min_off = linearIndex.length\n        ? linearIndex[\n            beg >> this.TAD_LIDX_SHIFT >= linearIndex.length\n              ? linearIndex.length - 1\n              : beg >> this.TAD_LIDX_SHIFT\n          ]\n        : new VirtualOffset(0, 0)\n\n      var i,\n        l,\n        n_off = 0\n      for (i = 0; i < bins.length; ++i) {\n        n_off += (binIndex[bins[i]] || []).length\n      }\n\n      if (n_off == 0) {return []}\n\n      var off = []\n\n      var chunks\n      for (i = n_off = 0; i < bins.length; ++i)\n        {if ((chunks = binIndex[bins[i]]))\n          {for (var j = 0; j < chunks.length; ++j)\n            {if (min_off.compareTo(chunks[j].maxv) < 0)\n              {off[n_off++] = new Chunk(\n                chunks[j].minv,\n                chunks[j].maxv,\n                chunks[j].bin,\n              )}}}}\n\n      if (!off.length) {return []}\n\n      off = off.sort(function (a, b) {\n        return a.compareTo(b)\n      })\n\n      // resolve completely contained adjacent blocks\n      for (i = 1, l = 0; i < n_off; ++i) {\n        if (off[l].maxv.compareTo(off[i].maxv) < 0) {\n          ++l\n          off[l].minv = off[i].minv\n          off[l].maxv = off[i].maxv\n        }\n      }\n      n_off = l + 1\n\n      // resolve overlaps between adjacent blocks; this may happen due to the merge in indexing\n      for (i = 1; i < n_off; ++i)\n        {if (off[i - 1].maxv.compareTo(off[i].minv) >= 0)\n          {off[i - 1].maxv = off[i].minv}}\n      // merge adjacent blocks\n      for (i = 1, l = 0; i < n_off; ++i) {\n        if (off[l].maxv.block == off[i].minv.block) {off[l].maxv = off[i].maxv}\n        else {\n          ++l\n          off[l].minv = off[i].minv\n          off[l].maxv = off[i].maxv\n        }\n      }\n      n_off = l + 1\n\n      return off.slice(0, n_off)\n    },\n\n    /* calculate bin given an alignment covering [beg,end) (zero-based, half-close-half-open) */\n    _reg2bin: function (beg, end) {\n      --end\n      if (beg >> 14 == end >> 14) {return ((1 << 15) - 1) / 7 + (beg >> 14)}\n      if (beg >> 17 == end >> 17) {return ((1 << 12) - 1) / 7 + (beg >> 17)}\n      if (beg >> 20 == end >> 20) {return ((1 << 9) - 1) / 7 + (beg >> 20)}\n      if (beg >> 23 == end >> 23) {return ((1 << 6) - 1) / 7 + (beg >> 23)}\n      if (beg >> 26 == end >> 26) {return ((1 << 3) - 1) / 7 + (beg >> 26)}\n      return 0\n    },\n\n    /* calculate the list of bins that may overlap with region [beg,end) (zero-based) */\n    _reg2bins: function (beg, end) {\n      var k,\n        list = []\n      --end\n      list.push(0)\n      for (k = 1 + (beg >> 26); k <= 1 + (end >> 26); ++k) {list.push(k)}\n      for (k = 9 + (beg >> 23); k <= 9 + (end >> 23); ++k) {list.push(k)}\n      for (k = 73 + (beg >> 20); k <= 73 + (end >> 20); ++k) {list.push(k)}\n      for (k = 585 + (beg >> 17); k <= 585 + (end >> 17); ++k) {list.push(k)}\n      for (k = 4681 + (beg >> 14); k <= 4681 + (end >> 14); ++k) {list.push(k)}\n      return list\n    },\n    _bin_limit: function (min_shift, depth = 5) {\n      return ((1 << ((depth + 1) * 3)) - 1) / 7\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/Model/VCFFeature.js":{"size":8139,"mtime":1738905961525,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Model/VCFFeature.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"/**\n * VCF Feature creation with lazy genotpye evaluation.\n */\n\ndefine(['JBrowse/Util'], function (Util) {\n  var Feature = Util.fastDeclare({\n    constructor: function (args) {\n      this.variant = args.variant\n      this.parser = args.parser\n      this._id = args.id\n      this.data = this.dataFromVariant(this.variant)\n    },\n\n    get(field) {\n      return this._get(field) || this._get(field.toLowerCase())\n    },\n\n    // same as get(), except requires lower-case arguments.    used\n    // internally to save lots of calls to field.toLowerCase()\n    _get(field) {\n      return field in this.data\n        ? this.data[field] // have we already parsed it out?\n        : function (field) {\n            var v = (this.data[field] = this['_parse_' + field]\n              ? this['_parse_' + field]() // maybe we have a special parser for it\n              : undefined)\n            return v\n          }.call(this, field)\n    },\n\n    parent() {\n      return null\n    },\n\n    children() {\n      return null\n    },\n\n    tags() {\n      var t = []\n      var d = this.data\n      for (var k in d) {\n        if (d.hasOwnProperty(k)) {t.push(k)}\n      }\n      if (!d.genotypes) {t.push('genotypes')}\n      return t\n    },\n\n    id() {\n      return this._id\n    },\n\n    _parse_genotypes() {\n      var variant = this.variant\n      delete this.variant // TODO: remove this delete if we add other laziness\n\n      if (Object.keys(variant.SAMPLES).length) {\n        this.data.genotypes = {}\n        Object.keys(variant.SAMPLES).forEach(sample => {\n          this.data.genotypes[sample] = {}\n          Object.keys(variant.SAMPLES[sample]).forEach(field => {\n            this.data.genotypes[sample][field] = {\n              values: variant.SAMPLES[sample][field],\n            }\n          })\n        })\n        return this.data.genotypes\n      } else {\n        this.data.genotypes = null\n        return null\n      }\n    },\n\n    dataFromVariant: function (variant) {\n      const ref = variant.REF\n      const alt = variant.ALT\n      const start = variant.POS - 1\n      const end = variant.INFO['END']\n        ? Number(variant.INFO['END'][0])\n        : start + ref.length\n      const [SO_term, description] = this._getSOTermAndDescription(ref, alt)\n\n      var featureData = {\n        start: start,\n        end: end,\n        seq_id: variant.CHROM,\n        description: description,\n        type: SO_term,\n        reference_allele: ref,\n      }\n\n      if (variant.ID) {\n        featureData.name = variant.ID[0]\n        if (variant.ID > 1) {\n          featureData.aliases = variant.ID.slice(1).join(',')\n        }\n      }\n\n      if (variant.QUAL) {\n        featureData.score = variant.QUAL\n      }\n\n      if (variant.FILTER) {\n        featureData.filter = {\n          meta: {\n            description:\n              'List of filters that this site has not passed, or PASS if it has passed all filters',\n            filters: this.parser.getMetadata('FILTER'),\n          },\n          values: variant.FILTER === 'PASS' ? ['PASS'] : variant.FILTER,\n        }\n      }\n\n      if (alt) {\n        featureData.alternative_alleles = {\n          meta: {\n            description:\n              'VCF ALT field, list of alternate non-reference alleles called on at least one of the samples',\n          },\n          values: alt,\n        }\n      }\n\n      // parse the info field and store its contents as attributes in featureData\n      if (variant.INFO) {\n        this._parseInfoField(featureData, variant.INFO)\n      }\n\n      return featureData\n    },\n\n    /**\n     * parse a VCF line's INFO field, storing the contents as\n     * attributes in featureData\n     */\n    _parseInfoField: function (featureData, info) {\n      // decorate the info records with references to their descriptions\n      for (var field in info) {\n        if (info.hasOwnProperty(field)) {\n          var i = (info[field] = {\n            values: info[field],\n          })\n          var meta = this.parser.getMetadata('INFO', field)\n          if (meta) {i.meta = meta}\n          featureData[field] = i\n        }\n      }\n    },\n\n    /**\n     * Get a sequence ontology (SO) term that describes the variant type\n     */\n    _getSOTermAndDescription: function (ref, alt) {\n      // it's just a remark if there are no alternate alleles\n      if (!alt || alt === []) {\n        return ['remark', 'no alternative alleles']\n      }\n\n      const soTerms = new Set()\n      let descriptions = new Set()\n      alt.forEach(a => {\n        let [soTerm, description] = this._getSOAndDescFromAltDefs(ref, a)\n        if (!soTerm) {\n          ;[soTerm, description] = this._getSOAndDescByExamination(ref, a)\n        }\n        if (soTerm) {\n          soTerms.add(soTerm)\n          descriptions.add(description)\n        }\n      })\n      // Combine descriptions like [\"SNV G -> A\", \"SNV G -> T\"] to [\"SNV G -> A,T\"]\n      if (descriptions.size > 1) {\n        const prefixes = new Set()\n        ;[...descriptions].forEach(desc => {\n          const prefix = desc.match(/(\\w+? \\w+? -> )(?:<)\\w+(?:>)/)\n          if (prefix && prefix[1]) {prefixes.add(prefix[1])}\n          else {prefixes.add(desc)}\n        })\n        const new_descs = []\n        ;[...prefixes].forEach(prefix => {\n          const suffixes = []\n          ;[...descriptions].forEach(desc => {\n            if (desc.startsWith(prefix)) {\n              suffixes.push(desc.slice(prefix.length))\n            }\n          })\n          new_descs.push(prefix + suffixes.join(','))\n        })\n        descriptions = new_descs\n      }\n      if (soTerms.size) {\n        return [[...soTerms].join(','), [...descriptions].join(',')]\n      } else {return [null, null]}\n    },\n\n    _altTypeToSO: {\n      DEL: 'deletion',\n      INS: 'insertion',\n      DUP: 'copy_number_gain',\n      INV: 'inversion',\n      CNV: 'copy_number_variation',\n      'DUP:TANDEM': 'copy_number_gain',\n      NON_REF: 'sequence_variant',\n      '*': 'sequence_variant',\n    },\n\n    _getSOAndDescFromAltDefs: function (ref, alt) {\n      // not a symbolic ALT if doesn't begin with '<', so we'll have no definition\n      if (alt[0] != '<') {\n        return [null, null]\n      }\n\n      alt = alt.replace(/^<|>$/g, '') // trim off < and >\n\n      // look for a definition with an SO type for this\n      let soTerm = this._altTypeToSO[alt]\n      // if no SO term but ALT is in metadata, assume sequence_variant\n      if (!soTerm && this.parser.getMetadata('ALT', alt))\n        {soTerm = 'sequence_variant'}\n      if (soTerm) {\n        let description = this.parser.getMetadata('ALT', alt, 'Description')\n          ? alt + ' - ' + this.parser.getMetadata('ALT', alt, 'Description')\n          : this._makeDescriptionString(soTerm, ref, alt)\n        return [soTerm, description]\n      }\n\n      // try to look for a definition for a parent term if we can\n      alt = alt.split(':')\n      if (alt.length > 1) {\n        return this._getSOAndDescFromAltDefs(\n          ref,\n          '<' + alt.slice(0, alt.length - 1).join(':') + '>',\n        )\n      } else {\n        // no parent\n        return [null, null]\n      }\n    },\n\n    _getSOAndDescByExamination: function (ref, alt) {\n      if (ref.length == 1 && alt.length == 1) {\n        // use SNV because SO definition of SNP says abundance must be at\n        // least 1% in population, and can't be sure we meet that\n        return ['SNV', this._makeDescriptionString('SNV', ref, alt)]\n      }\n\n      if (ref.length == alt.length)\n        {if (ref.split('').reverse().join('') == alt)\n          {return [\n            'inversion',\n            this._makeDescriptionString('inversion', ref, alt),\n          ]}\n        else\n          {return [\n            'substitution',\n            this._makeDescriptionString('substitution', ref, alt),\n          ]}}\n\n      if (ref.length <= alt.length)\n        {return ['insertion', this._makeDescriptionString('insertion', ref, alt)]}\n\n      if (ref.length > alt.length)\n        {return ['deletion', this._makeDescriptionString('deletion', ref, alt)]}\n\n      return ['indel', this._makeDescriptionString('indel', ref, alt)]\n    },\n\n    _makeDescriptionString: function (soTerm, ref, alt) {\n      return soTerm + ' ' + ref + ' -> ' + alt\n    },\n  })\n\n  return Feature\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/Model/XHRBlob.js":{"size":7464,"mtime":1738905961538,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Model/XHRBlob.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"cjsRequire('whatwg-fetch')\nconst tenaciousFetch = cjsRequire('tenacious-fetch').default\n\nconst { HttpRangeFetcher } = cjsRequire('http-range-fetcher')\nconst { Buffer } = cjsRequire('buffer')\n\ndefine([\n  'dojo/_base/declare',\n  'JBrowse/Util',\n  'JBrowse/Model/FileBlob',\n], function (declare, Util, FileBlob) {\n  //throw 404 errors for plain-old-fetch xref https://github.com/github/fetch/issues/155\n  function fetchwrapper(f) {\n    return function (url, options) {\n      return f(url, options).then(function (res) {\n        if (res.status >= 200 && res.status < 300) {\n          return Promise.resolve(res)\n        } else {\n          const error = new Error(`HTTP ${res.status} when fetching ${res.url}`)\n          error.response = res\n          return Promise.reject(error)\n        }\n      })\n    }\n  }\n  function getfetch(url, opts = {}) {\n    let mfetch\n    if (Util.isElectron()) {\n      if (url.slice(0, 4) === 'http') {\n        mfetch = fetchwrapper(electronRequire('node-fetch'))\n      } else {\n        url = url.replace('%20', ' ')\n        mfetch = fetchwrapper(fetch)\n      }\n    } else {\n      mfetch = tenaciousFetch // already throws on 404\n    }\n    return mfetch(\n      url,\n      Object.assign(\n        {\n          method: 'GET',\n          credentials: 'same-origin',\n          retries: 5,\n          retryDelay: 1000, // 1 sec, 2 sec, 3 sec\n          retryStatus: [500, 404, 503],\n          onRetry: ({ retriesLeft, retryDelay }) => {\n            console.warn(\n              `${url} request failed, retrying (${retriesLeft} retries left)`,\n            )\n          },\n        },\n        opts,\n      ),\n    )\n  }\n\n  function fetchBinaryRange(url, start, end) {\n    const requestDate = new Date()\n    const headers = {\n      headers: { range: `bytes=${start}-${end}` },\n      onRetry: ({ retriesLeft, retryDelay }) => {\n        console.warn(\n          `${url} bytes ${start}-${end} request failed, retrying (${retriesLeft} retries left)`,\n        )\n      },\n    }\n\n    return getfetch(url, headers).then(\n      res => {\n        const responseDate = new Date()\n        if (res.status !== 206 && res.status !== 200)\n          {throw new Error(\n            `HTTP ${res.status} when fetching ${url} bytes ${start}-${end}`,\n          )}\n\n        // translate the Headers object into a regular key -> value object.\n        // will miss duplicate headers of course\n        const headers = {}\n        for (let entry of res.headers.entries()) {\n          headers[entry[0]] = entry[1]\n        }\n\n        if (Util.isElectron()) {\n          // electron charmingly returns HTTP 200 for byte range requests,\n          // and does not fill in content-range. so we will fill it in\n          try {\n            if (!headers['content-range']) {\n              const fs = electronRequire('fs') //Load the filesystem module\n              const stats = fs.statSync(Util.unReplacePath(url))\n              headers['content-range'] = `${start}-${end}/${stats.size}`\n            }\n          } catch (e) {\n            console.error('Could not get size of file', url, e)\n          }\n        } else if (res.status === 200) {\n          throw new Error(\n            `HTTP ${res.status} when fetching ${url} bytes ${start}-${end}`,\n          )\n        }\n\n        // return the response headers, and the data buffer\n        return res.arrayBuffer().then(arrayBuffer => ({\n          headers,\n          requestDate,\n          responseDate,\n          buffer: Buffer.from(arrayBuffer),\n        }))\n      },\n      res => {\n        throw new Error(\n          `HTTP ${res.status} when fetching ${url} bytes ${start}-${end}`,\n        )\n      },\n    )\n  }\n  const globalCache = new HttpRangeFetcher({\n    fetch: fetchBinaryRange,\n    size: 50 * 1024 * 1024, // 50MB\n    chunkSize: Math.pow(2, 18), // 256KB\n    aggregationTime: 50,\n  })\n\n  var XHRBlob = declare(\n    FileBlob,\n    /**\n     * @lends JBrowse.Model.XHRBlob.prototype\n     */\n    {\n      /**\n       * Blob of binary data fetched with an XMLHTTPRequest.\n       *\n       * Adapted by Robert Buels from the URLFetchable object in the\n       * Dalliance Genome Explorer, which was is copyright Thomas Down\n       * 2006-2011.\n       * @constructs\n       */\n      constructor(url, start, end, opts) {\n        if (!opts) {\n          if (typeof start === 'object') {\n            opts = start\n            start = undefined\n          } else {\n            opts = {}\n          }\n        }\n\n        this.url = url\n        this.start = start || 0\n        if (end) {\n          this.end = end\n        }\n        this.opts = opts\n      },\n\n      slice(s, l) {\n        var ns = this.start,\n          ne = this.end\n        if (ns && s) {\n          ns = ns + s\n        } else {\n          ns = s || ns\n        }\n        if (l && ns) {\n          ne = ns + l - 1\n        } else {\n          ne = ne || l - 1\n        }\n        return new XHRBlob(this.url, ns, ne, this.opts)\n      },\n\n      fetch(callback, failCallback) {\n        const length =\n          this.end === undefined ? undefined : this.end - this.start + 1\n        if (length < 0) {\n          throw new Error('Length less than 0 received')\n        } else if (length == undefined && this.start == 0) {\n          getfetch(this.url)\n            .then(res => res.arrayBuffer())\n            .then(callback)\n            .catch(failCallback)\n        } else {\n          globalCache\n            .getRange(this.url, this.start, length)\n            .then(\n              this._getResponseArrayBuffer.bind(this, callback),\n              failCallback,\n            )\n        }\n      },\n\n      async fetchBufferPromise() {\n        const length =\n          this.end === undefined ? undefined : this.end - this.start + 1\n        try {\n          if (length < 0) {\n            throw new Error('Length less than 0 received')\n          } else if (length == undefined && this.start == 0) {\n            const range = await getfetch(this.url)\n            if (!range.ok) {\n              throw new Error(`HTTP ${range.status} when fetching ${this.url}`)\n            }\n            return new Buffer(await range.arrayBuffer())\n          } else {\n            var range = await globalCache.getRange(this.url, this.start, length)\n            return range.buffer\n          }\n        } catch (e) {\n          if (!e.message) {\n            const bytes = length ? ` bytes ${this.start}-${this.end}` : ''\n            throw new Error(`HTTP ${e.status} when fetching ${e.url} ${bytes}`)\n          }\n          throw e\n        }\n      },\n\n      _getResponseArrayBuffer(callback, { buffer }) {\n        if (buffer.buffer) {\n          const arrayBuffer = buffer.buffer.slice(\n            buffer.byteOffset,\n            buffer.byteOffset + buffer.byteLength,\n          )\n          callback(arrayBuffer)\n        } else {throw new Error('could not convert response to ArrayBuffer')}\n      },\n\n      read(offset = 0, length, callback, failCallback) {\n        globalCache\n          .getRange(this.url, this.start + offset, length)\n          .then(this._getResponseArrayBuffer.bind(this, callback), failCallback)\n      },\n\n      async readBufferPromise(offset = 0, length) {\n        const range = await globalCache.getRange(\n          this.url,\n          this.start + offset,\n          length,\n        )\n        return range.buffer\n      },\n\n      stat(callback, failCallback) {\n        this.statPromise().then(callback, failCallback)\n      },\n\n      statPromise() {\n        return globalCache.stat(this.url)\n      },\n    },\n  )\n  return XHRBlob\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/Plugin.js":{"size":384,"mtime":1738905961546,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Plugin.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/src/JBrowse/QueryParamConfigMapper.js":{"size":5225,"mtime":1738905961559,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/QueryParamConfigMapper.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"/**\n * This library interprets options passed in via dot-notation instead of JSON in the Query URL.\n * The implementation is both for readability and security in some systems, esp. tomcat where\n * passing JSON in the Query URL is both bad-form and potentially insecure.\n *\n * This is the dot-object library: https://www.npmjs.com/package/dot-object\n *\n * Usage is depicted here:\n * http://gmod.org/wiki/JBrowse_Configuration_Guide#addFeatures\n *\n */\ndefine([\n  'dojo/_base/declare',\n  'dojo/_base/array',\n  'JBrowse/Util/dot-object',\n], function (declare, array, dotObject) {\n  return declare(null, {\n    constructor: function () {},\n\n    generateUrl: function (input) {\n      var returnObject = dotObject.dot(input)\n      var returnString\n      Object.keys(returnObject).forEach(function (key) {\n        var stringEntry = key + '=' + returnObject[key]\n        if (!returnString) {\n          returnString = stringEntry\n        } else {\n          returnString += '&' + stringEntry\n        }\n      })\n\n      return returnString\n    },\n\n    generateJsonFromKeyArray: function (inputJson, keyArray, keyDepth, value) {\n      if (!keyArray || keyArray.length == keyDepth) {return}\n\n      var firstKey = keyArray[keyDepth - 1]\n      // set value if the last one\n      if (keyArray.length == keyDepth - 1) {\n        inputJson[firstKey] = value\n        return\n      }\n\n      // more keys available, so if nothing is set, just set to null\n      if (!inputJson.hasOwnProperty(firstKey)) {\n        inputJson[firstKey] = {}\n      }\n      this.generateJsonFromKeyArray(\n        inputJson[firstKey],\n        keyArray,\n        ++keyDepth,\n        value,\n      )\n    },\n\n    mapParam: function (inputJson, queryParam) {\n      var inputQA = queryParam.split('=')\n      var query = inputQA[0]\n      var value = inputQA[1]\n      dotObject.str(query, value, inputJson)\n    },\n\n    generateJsonFromKey: function (inputJson, keyString) {\n      var allParams = keyString.split('\\&')\n      var mapParamB = this.mapParam\n      allParams.forEach(function (queryParam) {\n        mapParamB(inputJson, queryParam)\n      })\n    },\n\n    handleQueryParams: function (config, queryParams) {\n      var queryNameArray, storeName, propertyName, internalStore\n      var storeTracks = {}\n      var storeBookmarks = {}\n\n      var featuresArray = []\n      var featureIndex\n\n      Object.keys(queryParams).forEach(function (queryParam) {\n        if (queryParam.indexOf('addStores\\.') == 0) {\n          queryNameArray = queryParam.split('\\.')\n          propertyName = queryNameArray.slice(1).join('.')\n          dotObject.str(\n            'stores.' + propertyName,\n            queryParams[queryParam],\n            config,\n          )\n        } else if (queryParam.indexOf('addTracks\\.') == 0) {\n          queryNameArray = queryParam.split('\\.')\n          storeName = queryNameArray[1]\n          internalStore = storeTracks[storeName] ? storeTracks[storeName] : {}\n          propertyName = queryNameArray.slice(2).join('.')\n          if (storeName !== 'none') {\n            dotObject.str('store', storeName, internalStore)\n          }\n          dotObject.str(propertyName, queryParams[queryParam], internalStore)\n          dotObject.str(storeName, internalStore, storeTracks)\n        } else if (queryParam.indexOf('addBookmarks\\.') == 0) {\n          queryNameArray = queryParam.split('\\.')\n          storeName = queryNameArray[1]\n          internalStore = storeBookmarks[storeName]\n            ? storeBookmarks[storeName]\n            : {}\n          propertyName = queryNameArray.slice(2).join('.')\n          dotObject.str(propertyName, queryParams[queryParam], internalStore)\n          dotObject.str(storeName, internalStore, storeBookmarks)\n        } else if (queryParam.indexOf('addFeatures\\.') == 0) {\n          queryNameArray = queryParam.split('\\.')\n          featureIndex = queryNameArray[1]\n          propertyName = queryNameArray.slice(2).join('.')\n          var feature = featuresArray[featureIndex]\n          feature = feature ? feature : {}\n          dotObject.str(propertyName, queryParams[queryParam], feature)\n          featuresArray[featureIndex] = feature\n        }\n      })\n\n      // convert to an array\n      if (storeTracks) {\n        // add one for each\n        for (var track in storeTracks) {\n          if (!config.tracks) {\n            config.tracks = []\n          }\n          var storeTrack = storeTracks[track]\n          config.tracks.push(storeTrack)\n        }\n      }\n\n      if (storeBookmarks) {\n        // add one for each\n        for (var bookmark in storeBookmarks) {\n          if (!config.bookmarks) {\n            config.bookmarks = {}\n          }\n          if (!config.bookmarks.features) {\n            config.bookmarks.features = []\n          }\n          var storeBookmark = storeBookmarks[bookmark]\n          // explicitly try to handle loc strings?\n          config.bookmarks.features.push(storeBookmark)\n        }\n      }\n\n      if (featuresArray.length > 0) {\n        config.stores = config.stores ? config.stores : {}\n        config.stores.url = config.stores.url ? config.stores.url : {}\n        config.stores.url.features = array.filter(featuresArray, function (el) {\n          return el != null\n        })\n      }\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/standalone.js":{"size":309,"mtime":1738905961562,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/standalone.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/src/JBrowse/Store.js":{"size":1116,"mtime":1738905961571,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Store.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define(['dojo/_base/declare', 'JBrowse/Component'], function (\n  declare,\n  Component,\n) {\n  var uniqCounter = 0\n  return declare(\n    Component,\n\n    /**\n     * @lends JBrowse.Store.prototype\n     */\n    {\n      namePrefix: 'store-',\n\n      /**\n       * Base class for all JBrowse data stores.\n       * @constructs\n       */\n      constructor: function (args) {\n        this.refSeq = dojo.clone(args.refSeq)\n        this.name = args.name || this.namePrefix + ++uniqCounter\n        this.changeCallback = args.changeCallback || function () {}\n      },\n\n      // not really utilized.  ignore for now\n      notifyChanged: function (changeDescription) {\n        if (this.changeCallback) {this.changeCallback(changeDescription)}\n      },\n\n      /**\n       * If this store has any internal deferreds, resolves them all\n       * with the given error.\n       */\n      _failAllDeferred: function (error) {\n        var deferreds = this._deferred || {}\n        for (var dname in deferreds) {\n          if (deferreds.hasOwnProperty(dname)) {\n            deferreds[dname].reject(error)\n          }\n        }\n      },\n    },\n  )\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/Store/BigWig.js":{"size":75,"mtime":1738905961574,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Store/BigWig.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/src/JBrowse/Store/DeferredFeaturesMixin.js":{"size":1194,"mtime":1738905961577,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Store/DeferredFeaturesMixin.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"/**\n * Mixin for a store class that needs to load some remote stuff (or do\n * some other kind of asynchronous thing) before its features are\n * available through getFeatures,\n */\n\ndefine(['dojo/_base/declare', 'dojo/Deferred'], function (declare, Deferred) {\n  return declare(null, {\n    // note that dojo.declare automatically chains constructors\n    // without needing inherited()\n    constructor: function (args) {\n      this._deferFeatures()\n    },\n\n    /**\n     * sets us up to defer calls to getFeatures().  calls will be\n     * queued until the Deferred is resolved.\n     */\n    _deferFeatures: function () {\n      if (!this._deferred) {this._deferred = {}}\n      this._deferred.features = new Deferred()\n    },\n\n    /**\n     * Runs calls to getFeatures through a Deferred that will queue\n     * and aggregate feature requests until the Deferred is resolved.\n     */\n    getFeatures: function (query, featCallback, endCallback, errorCallback) {\n      this._deferred.features.then(\n        dojo.hitch(\n          this,\n          '_getFeatures',\n          query,\n          featCallback,\n          endCallback,\n          errorCallback,\n        ),\n        errorCallback,\n      )\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/Store/DeferredStatsMixin.js":{"size":1601,"mtime":1738905961581,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Store/DeferredStatsMixin.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"/**\n * Mixin for a store class that needs to load some remote stuff (or do\n * some other kind of asynchronous thing) before its stats are\n * available through getGlobalStats or getRegionStats.\n */\n\ndefine(['dojo/_base/declare', 'dojo/Deferred', 'JBrowse/Util'], function (\n  declare,\n  Deferred,\n  Util,\n) {\n  return declare(null, {\n    // note that dojo.declare automatically chains constructors\n    // without needing inherited()\n    constructor: function (args) {\n      this._deferGlobalStats()\n    },\n\n    /**\n     * sets us up to defer calls to getGlobalStats().  calls will be\n     * queued until the Deferred is resolved.\n     */\n    _deferGlobalStats: function () {\n      if (!this._deferred) {this._deferred = {}}\n      this._deferred.stats = new Deferred()\n    },\n\n    /**\n     * Runs calls to getGlobalStats through a Deferred that will queue\n     * and aggregate stats requests until the Deferred is resolved.\n     */\n    getGlobalStats: function (successCallback, errorCallback) {\n      var thisB = this\n      this._deferred.stats.then(\n        dojo.hitch(this, '_getGlobalStats', successCallback, errorCallback),\n        errorCallback,\n      )\n    },\n\n    _getGlobalStats: function (successCallback, errorCallback) {\n      successCallback(this.globalStats || {})\n    },\n\n    getRegionStats: function (query, successCallback, errorCallback) {\n      var thisB = this\n      this._deferred.stats.then(\n        dojo.hitch(\n          this,\n          '_getRegionStats',\n          query,\n          successCallback,\n          errorCallback,\n        ),\n        errorCallback,\n      )\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/Store/Hash.js":{"size":2446,"mtime":1738905961589,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Store/Hash.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'dojo/_base/array',\n  'dojo/store/JsonRest',\n  'dojo/store/util/QueryResults',\n  'JBrowse/Digest/Crc32',\n  'JBrowse/Util',\n], function (declare, array, dojoJSONRest, QueryResults, digest, Util) {\n  return declare(null, {\n    constructor: function (args) {\n      // make sure url has a trailing slash\n      var url = /\\/$/.test(args.url) ? args.url : args.url + '/'\n      this.bucketStore = new dojoJSONRest({\n        target: url,\n      })\n\n      this.meta = {}\n\n      this.browser = args.browser\n\n      // this.ready is a Deferred that will be resolved when we have\n      // read the meta.json file with the params of this hashstore\n      this.ready = this._readMeta()\n    },\n\n    _readMeta: function () {\n      var thisB = this\n      return this.bucketStore.get('meta.json').then(function (meta) {\n        dojo.mixin(thisB.meta, meta || {})\n        thisB.meta.hash_hex_characters = Math.ceil(thisB.meta.hash_bits / 4)\n      })\n    },\n\n    query: function (query, options) {\n      return this.get((query.name || '').toString()).then(function (value) {\n        return QueryResults((value || {}).exact || [])\n      })\n    },\n\n    get: function (key) {\n      return this._getBucket(key).then(function (bucket) {\n        return bucket[key]\n      })\n    },\n\n    _getBucket: function (key) {\n      var thisB = this\n      return this.ready.then(function () {\n        var bucketIdent = thisB._hash(key)\n        return thisB.bucketStore.get(thisB._hexToDirPath(bucketIdent)).then(\n          function (value) {\n            return value\n          },\n          function (err) {\n            if (Util.isElectron() || err.status == 404) {\n              // 404 is expected if the name is not in the store\n              return {}\n            }\n          },\n        )\n      })\n    },\n\n    _hexToDirPath: function (hex) {\n      // zero-pad the hex string to be 8 chars if necessary\n      while (hex.length < 8) {hex = '0' + hex}\n      hex = hex.substr(8 - this.meta.hash_hex_characters)\n      var dirpath = []\n      for (var i = 0; i < hex.length; i += 3) {\n        dirpath.push(hex.substring(i, i + 3))\n      }\n      return dirpath.join('/') + '.json' + (this.meta.compress ? 'z' : '')\n    },\n\n    _hash: function (data) {\n      return digest\n        .objectFingerprint(data)\n        .toString(16)\n        .toLowerCase()\n        .replace('-', 'n')\n    },\n\n    getIdentity: function (object) {\n      return object.id\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/Store/LazyArray.js":{"size":4719,"mtime":1738905961597,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Store/LazyArray.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define(['JBrowse/Util', 'JBrowse/Finisher', 'dojo/_base/xhr'], function (\n  Util,\n  Finisher,\n  xhr,\n) {\n  /*\n   * For a JSON array that gets too large to load in one go, this class\n   * helps break it up into chunks and provides an\n   * async API for using the information in the array.\n   */\n\n  /**\n   * Construct a new LazyArray, which partially loads large JSON arrays.\n   * @class\n   * @constructor\n   * @param lazyArrayParams {Object} as:\n   * <ul>\n   * <li><code>urlTemplate</code> - for each lazily-loaded array chunk, the chunk number will get substituted for {chunk} in this template, and the result will beused as the URL of the JSON for that array chunk</li>\n   * <li><code>length</code> - length of the overall array</li>\n   * <li><code>chunkSize</code> - the size of each array chunk</li>\n   * </ul>\n   */\n  var LazyArray = function (lazyArrayParams, baseUrl) {\n    this.urlTemplate = lazyArrayParams.urlTemplate\n    this.chunkSize = lazyArrayParams.chunkSize\n    this.length = lazyArrayParams.length\n    this.baseUrl = baseUrl === undefined ? '' : baseUrl\n    // Once a range gets loaded, it goes into the \"chunks\" array.\n    // this.chunks[n] contains data for indices in the range\n    // [n * chunkSize, Math.min(length - 1, (n * (chunkSize + 1)) - 1)]\n    this.chunks = []\n    // If a range is currently loading, this will contain a property\n    // \"chunk number\": [{start, end, callback, param}, ...]\n    this.toProcess = {}\n  }\n\n  /**\n   * call the callback on one element of the array\n   * @param i index\n   * @param callback callback, gets called with (i, value, param)\n   * @param param (optional) callback will get this as its last parameter\n   */\n  LazyArray.prototype.index = function (i, callback, param) {\n    this.range(i, i, callback, undefined, param)\n  }\n\n  /**\n   * call the callback on each element in the range [start, end]\n   * @param start index of first element to call the callback on\n   * @param end index of last element to call the callback on\n   * @param callback callback, gets called with (i, value, param)\n   * @param postFun (optional) callback that gets called when <code>callback</code> has been run on every element in the range\n   * @param param (optional) callback will get this as its last parameter\n   */\n  LazyArray.prototype.range = function (start, end, callback, postFun, param) {\n    start = Math.max(0, start)\n    end = Math.min(end, this.length - 1)\n\n    var firstChunk = Math.floor(start / this.chunkSize)\n    var lastChunk = Math.floor(end / this.chunkSize)\n\n    if (postFun === undefined) /** @inner */ {postFun = function () {}}\n    var finish = new Finisher(postFun)\n\n    for (var chunk = firstChunk; chunk <= lastChunk; chunk++) {\n      if (this.chunks[chunk]) {\n        // chunk is loaded\n        this._processChunk(start, end, chunk, callback, param)\n      } else {\n        var toProcessInfo = {\n          start: start,\n          end: end,\n          callback: callback,\n          param: param,\n          finish: finish,\n        }\n\n        finish.inc()\n        if (this.toProcess[chunk]) {\n          // chunk is currently being loaded\n          this.toProcess[chunk].push(toProcessInfo)\n        } else {\n          // start loading chunk\n          this.toProcess[chunk] = [toProcessInfo]\n          var url = this.urlTemplate.replace(/\\{Chunk\\}/gi, chunk)\n          var thisObj = this\n          dojo.xhrGet({\n            url: this.baseUrl ? Util.resolveUrl(this.baseUrl, url) : url,\n            handleAs: 'json',\n            load: this._makeLoadFun(chunk),\n            error: function () {\n              finish.dec()\n            },\n          })\n        }\n      }\n    }\n    finish.finish()\n  }\n\n  LazyArray.prototype._makeLoadFun = function (chunk) {\n    var thisObj = this\n    return function (data) {\n      thisObj.chunks[chunk] = data\n      var toProcess = thisObj.toProcess[chunk]\n      delete thisObj.toProcess[chunk]\n      for (var i = 0; i < toProcess.length; i++) {\n        thisObj._processChunk(\n          toProcess[i].start,\n          toProcess[i].end,\n          chunk,\n          toProcess[i].callback,\n          toProcess[i].param,\n        )\n        toProcess[i].finish.dec()\n      }\n    }\n  }\n\n  LazyArray.prototype._processChunk = function (\n    start,\n    end,\n    chunk,\n    callback,\n    param,\n  ) {\n    // index (in the overall lazy array) of the first position in this chunk\n    var firstIndex = chunk * this.chunkSize\n\n    var chunkStart = start - firstIndex\n    var chunkEnd = end - firstIndex\n    chunkStart = Math.max(0, chunkStart)\n    chunkEnd = Math.min(chunkEnd, this.chunkSize - 1)\n\n    for (var i = chunkStart; i <= chunkEnd; i++) {\n      callback(i + firstIndex, this.chunks[chunk][i], param)\n    }\n  }\n\n  return LazyArray\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/Store/LazyTrie.js":{"size":9226,"mtime":1738905961614,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Store/LazyTrie.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define(['dojo/_base/declare', 'dojo/request', 'JBrowse/Util'], function (\n  declare,\n  request,\n  Util,\n) {\n  return declare(\n    'JBrowse.Store.LazyTrie',\n    null,\n    /**\n     * @lends JBrowse.Store.LazyTrie.prototype\n     */\n    {\n      /**\n       * <pre>\n       * Implements a lazy PATRICIA tree.\n       *  This structure is a map where the keys are strings.  The map supports fast\n       * queries by key string prefix (\"show me all the values for keys that\n       * start with \"abc\").  It also supports lazily loading subtrees.\n       *\n       * Each edge is labeled with a substring of a key string.\n       * Each node in the tree has one or more children, each of which represents\n       *   a potential completion of the string formed by concatenating all of the\n       *   edge strings from that node up to the root.\n       *   Nodes also have zero or one data items.\n       * Leaves have zero or one data items.\n       *\n       * Each loaded node is an array.\n       *    element 0 is the edge string;\n       *    element 1 is the data item, or null if there is none;\n       *    any further elements are the child nodes, sorted lexicographically\n       *      by their edge string\n       *\n       *  Each lazy node is an array where the first element is the number of\n       *  data items in the subtree rooted at that node, and the second element\n       *  is the edge string for that node.\n       *    when the lazy node is loaded, the lazy array gets replaced with\n       *    a loaded node array; lazy nodes and loaded nodes can be distinguished by:\n       *    \"string\" == typeof loaded_node[0]\n       *    \"number\" == typeof lazy_node[0]\n       *\n       *  e.g., for the mappings:\n       *    abc   => 0\n       *    abcd  => 1\n       *    abce  => \"baz\"\n       *    abfoo => [3, 4]\n       *    abbar (subtree to be loaded lazily)\n       *\n       *  the structure is:\n       *\n       *  [, , [\"ab\", ,\n       *        [3, \"bar\"],\n       *        [\"c\", 0, [\"d\", 1],\n       *         [\"e\", \"baz\"]],\n       *        [\"foo\", [3, 4]]\n       *        ]\n       *   ]\n       *\n       *  The main goals for this structure were to minimize the JSON size on\n       *  the wire (so, no type tags in the JSON to distinguish loaded nodes,\n       *  lazy nodes, and leaves) while supporting lazy loading and reasonably\n       *  fast lookups.\n       * </pre>\n       *\n       * @constructs\n       */\n      constructor: function (rootURL, chunkTempl) {\n        this.rootURL = rootURL\n        this.chunkTempl = chunkTempl\n        var trie = this\n\n        request(rootURL, { handleAs: 'json' }).then(\n          function (o) {\n            if (!o) {\n              console.log('failed to load trie')\n              return\n            }\n            trie.root = o\n            trie.extra = o[0]\n            if (trie.deferred) {\n              trie.deferred.callee.apply(trie, trie.deferred)\n              delete trie.deferred\n            }\n          },\n          error => {\n            console.log(\n              'No name store configuration found and requesting the default root.json not found. Likely you have not run generate-names.pl yet. This is not essential for running JBrowse but will remove this message if it is run',\n            )\n            this.error = error\n          },\n        )\n      },\n\n      chunkUrl: function (prefix) {\n        var chunkUrl = this.chunkTempl.replace('\\{Chunk\\}', prefix)\n        return Util.resolveUrl(this.rootURL, chunkUrl)\n      },\n\n      pathToPrefix: function (path) {\n        var node = this.root\n        var result = ''\n        loop: for (var i = 0; i < path.length; i++) {\n          switch (typeof node[path[i]][0]) {\n            case 'string': // regular node\n              result += node[path[i]][0]\n              break\n            case 'number': // lazy node\n              result += node[path[i]][1]\n              break loop\n          }\n          node = node[path[i]]\n        }\n        return result\n      },\n\n      valuesFromPrefix: function (query, callback) {\n        var trie = this\n        this.findNode(\n          query,\n          function (prefix, node) {\n            callback(trie.valuesFromNode(node))\n          },\n          function () {\n            callback([])\n          },\n        )\n      },\n\n      mappingsFromPrefix: function (query, callback) {\n        var trie = this\n        this.findNode(\n          query,\n          function (prefix, node) {\n            callback(trie.mappingsFromNode(prefix, node))\n          },\n          function () {\n            callback([])\n          },\n        )\n      },\n\n      mappingsFromNode: function (prefix, node) {\n        var results = []\n        if (node[1] !== null) {results.push([prefix, node[1]])}\n        for (var i = 2; i < node.length; i++) {\n          if ('string' == typeof node[i][0]) {\n            results = results.concat(\n              this.mappingsFromNode(prefix + node[i][0], node[i]),\n            )\n          }\n        }\n        return results\n      },\n\n      valuesFromNode: function (node) {\n        var results = []\n        if (node[1] !== null) {results.push(node[1])}\n        for (var i = 2; i < node.length; i++)\n          {results = results.concat(this.valuesFromNode(node[i]))}\n        return results\n      },\n\n      exactMatch: function (key, callback, notfoundCallback) {\n        notfoundCallback = notfoundCallback || function () {}\n        if (this.error) {\n          notfoundCallback()\n          return\n        }\n\n        var trie = this\n        this.findNode(\n          key,\n          function (prefix, node) {\n            if (prefix.toLowerCase() == key.toLowerCase() && node[1])\n              {callback(node[1])}\n          },\n          notfoundCallback,\n        )\n      },\n\n      findNode: function (query, foundCallback, notfoundCallback) {\n        notfoundCallback = notfoundCallback || function () {}\n\n        if (this.error) {\n          notfoundCallback()\n          return\n        }\n\n        var trie = this\n        this.findPath(\n          query,\n          function (path) {\n            var node = trie.root\n            for (var i = 0; i < path.length; i++) {node = node[path[i]]}\n            var foundPrefix = trie.pathToPrefix(path)\n            foundCallback(foundPrefix, node)\n          },\n          notfoundCallback,\n        )\n      },\n\n      findPath: function (query, foundCallback, notfoundCallback) {\n        if (this.error) {\n          notfoundCallback()\n          return\n        }\n\n        notfoundCallback = notfoundCallback || function () {}\n\n        if (!this.root) {\n          notfoundCallback()\n          return\n        }\n        query = query.toLowerCase()\n        var node = this.root\n        var qStart = 0\n        var childIndex\n\n        var path = []\n\n        while (true) {\n          childIndex = this.binarySearch(node, query.charAt(qStart))\n          if (childIndex < 0) {\n            notfoundCallback()\n            return\n          }\n          path.push(childIndex)\n\n          if ('number' == typeof node[childIndex][0]) {\n            // lazy node\n            var trie = this\n            dojo.xhrGet({\n              url: this.chunkUrl(this.pathToPrefix(path)),\n              handleAs: 'json',\n              load: function (o) {\n                node[childIndex] = o\n                trie.findPath(query, foundCallback)\n              },\n              error: err => {\n                this.error = err\n              },\n            })\n            return\n          }\n\n          node = node[childIndex]\n\n          // if the current edge string doesn't match the\n          // relevant part of the query string, then there's no\n          // match\n          if (\n            query.substr(qStart, node[0].length) !=\n            node[0].substr(0, Math.min(node[0].length, query.length - qStart))\n          ) {\n            notfoundCallback()\n            return\n          }\n\n          qStart += node[0].length\n          if (qStart >= query.length) {\n            // we've reached the end of the query string, and we\n            // have some matches\n            foundCallback(path)\n            return\n          }\n        }\n      },\n\n      binarySearch: function (a, firstChar) {\n        var low = 2 // skip edge string (in 0) and data item (in 1)\n        var high = a.length - 1\n        var mid, midVal\n        while (low <= high) {\n          mid = (low + high) >>> 1\n          switch (typeof a[mid][0]) {\n            case 'string': // regular node\n              midVal = a[mid][0].charAt(0)\n              break\n            case 'number': // lazy node\n              midVal = a[mid][1].charAt(0)\n              break\n          }\n\n          if (midVal < firstChar) {\n            low = mid + 1\n          } else if (midVal > firstChar) {\n            high = mid - 1\n          } else {\n            return mid // key found\n          }\n        }\n\n        return -(low + 1) // key not found.\n      },\n    },\n  )\n})\n\n/*\n\nCopyright (c) 2007-2009 The Evolutionary Software Foundation\n\nCreated by Mitchell Skinner <mitch_skinner@berkeley.edu>\n\nThis package and its accompanying libraries are free software; you can\nredistribute it and/or modify it under the terms of the LGPL (either\nversion 2.1, or at your option, any later version) or the Artistic\nLicense 2.0.  Refer to LICENSE for the full license text.\n\n*/\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/Store/LRUCache.js":{"size":8730,"mtime":1738905961627,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Store/LRUCache.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'dojo/_base/array',\n  'JBrowse/Util',\n  'JBrowse/Digest/Crc32',\n], function (declare, array, Util, digest) {\n  return declare(\n    null,\n\n    /**\n     * @lends JBrowse.Store.LRUCache\n     */\n    {\n      /**\n       * An LRU cache.\n       *\n       * @param args.fillCallback\n       * @param args.maxSize\n       * @param args.sizeFunction\n       * @param args.keyFunction\n       * @param args.name\n       * @param args.verbose\n       * @constructs\n       */\n      constructor: function (args) {\n        this.fill = args.fillCallback\n        this.maxSize = args.maxSize || 1000000\n\n        this.verbose = args.verbose\n\n        this.name = args.name || 'LRUcache'\n\n        this._size = args.sizeFunction || this._size\n        this._keyString = args.keyFunction || this._keyString\n\n        this.itemCount = 0\n        this.size = 0\n\n        this._cacheByKey = {}\n\n        // each end of a doubly-linked list, sorted in usage order\n        this._cacheOldest = null\n        this._cacheNewest = null\n\n        // we aggregate cache fill calls that are in progress, indexed\n        // by cache key\n        this._inProgressFills = {}\n      },\n\n      get: function (inKey, callback) {\n        var keyString = this._keyString(inKey)\n        var record = this._cacheByKey[keyString]\n\n        if (!record) {\n          this._log('miss', keyString)\n\n          // call our fill callback if we can\n          this._attemptFill(inKey, keyString, callback)\n          return\n        } else {\n          this._log('hit', keyString)\n          this.touchRecord(record)\n          window.setTimeout(function () {\n            callback(record.value)\n          }, 1)\n        }\n      },\n\n      query: function (keyRegex) {\n        var results = []\n        var cache = this._cacheByKey\n        for (var k in cache) {\n          if (keyRegex.test(k) && cache.hasOwnProperty(k))\n            {results.push(cache[k])}\n        }\n        return results\n      },\n\n      forEach: function (func, context) {\n        if (!context) {context = this}\n        var i = 0\n        for (var record = this._cacheNewest; record; record = record.next) {\n          func.call(context, record, i++)\n        }\n      },\n      some: function (func, context) {\n        if (!context) {context = this}\n        var i = 0\n        for (var record = this._cacheNewest; record; record = record.next) {\n          if (func.call(context, record, i++)) {return true}\n        }\n        return false\n      },\n\n      touch: function (inKey) {\n        this.touchRecord(this._cacheByKey[this._keyString(inKey)])\n      },\n\n      touchRecord: function (record) {\n        if (!record) {return}\n\n        // already newest, nothing to do\n        if (this._cacheNewest === record) {return}\n\n        // take it out of the linked list\n        this._llRemove(record)\n\n        // add it back into the list as newest\n        this._llPush(record)\n      },\n\n      // take a record out of the LRU linked list\n      _llRemove: function (record) {\n        if (record.prev) {record.prev.next = record.next}\n        if (record.next) {record.next.prev = record.prev}\n\n        if (this._cacheNewest === record) {this._cacheNewest = record.prev}\n\n        if (this._cacheOldest === record) {this._cacheOldest = record.next}\n\n        record.prev = null\n        record.next = null\n      },\n\n      _llPush: function (record) {\n        if (this._cacheNewest) {\n          this._cacheNewest.next = record\n          record.prev = this._cacheNewest\n        }\n        this._cacheNewest = record\n        if (!this._cacheOldest) {this._cacheOldest = record}\n      },\n\n      _attemptFill: function (inKey, keyString, callback) {\n        if (this.fill) {\n          var fillRecord = (this._inProgressFills[keyString] = this\n            ._inProgressFills[keyString] || {\n            callbacks: [],\n            running: false,\n          })\n\n          fillRecord.callbacks.push(callback)\n\n          if (!fillRecord.running) {\n            fillRecord.running = true\n            this.fill(\n              inKey,\n              dojo.hitch(\n                this,\n                function (keyString, inKey, fillRecord, value, error, hints) {\n                  delete this._inProgressFills[keyString]\n                  fillRecord.running = false\n\n                  if (value && !(hints && hints.nocache)) {\n                    this._log('fill', keyString)\n                    this.set(inKey, value)\n                  }\n                  array.forEach(\n                    fillRecord.callbacks,\n                    function (cb) {\n                      try {\n                        cb.call(this, value, error)\n                      } catch (x) {\n                        console.error('' + x, x.stack, x)\n                      }\n                    },\n                    this,\n                  )\n                },\n                keyString,\n                inKey,\n                fillRecord,\n              ),\n            )\n          }\n        } else {\n          try {\n            callback(undefined)\n          } catch (x) {\n            console.error(x)\n          }\n        }\n      },\n\n      set: function (inKey, value) {\n        var keyString = this._keyString(inKey)\n        if (this._cacheByKey[keyString]) {\n          return\n        }\n\n        // make a cache record for it\n        let size\n        try {\n          size = this._size(value)\n        } catch (e) {\n          e.message = `Error calculating item size: ${e.message}`\n          console.error(e)\n          size = 1\n        }\n        var record = {\n          value: value,\n          key: inKey,\n          keyString: keyString,\n          size: size,\n        }\n\n        if (record.size > this.maxSize) {\n          this._warn(\n            'Cache cannot fit',\n            keyString,\n            '(' +\n              Util.addCommas(record.size) +\n              ' > ' +\n              Util.addCommas(this.maxSize) +\n              ')',\n          )\n          return\n        }\n\n        this._log('set', keyString, record, this.size)\n\n        // evict items if necessary\n        this._prune(record.size)\n\n        // put it in the byKey structure\n        this._cacheByKey[keyString] = record\n\n        // put it in the doubly-linked list\n        this._llPush(record)\n\n        // update our total size and item count\n        this.size += record.size\n        this.itemCount++\n\n        return\n      },\n\n      _keyString: function (inKey) {\n        var type = typeof inKey\n        if (type == 'object' && typeof inKey.toUniqueString == 'function') {\n          return inKey.toUniqueString()\n        } else {\n          return digest.objectFingerprint(inKey)\n        }\n      },\n\n      _size: function (value) {\n        var type = typeof value\n        var sum = 0\n        if (type == 'object' && type !== null) {\n          var sizeType = typeof value.size\n          if (sizeType == 'number') {\n            return sizeType\n          } else if (sizeType == 'function') {\n            return value.size()\n          } else if (value.byteLength) {\n            return value.byteLength\n          } else {\n            for (var k in value) {\n              if (value.hasOwnProperty(k)) {\n                sum += this._size(value[k])\n              }\n            }\n          }\n          return sum\n        } else if (type == 'string') {\n          return value.length\n        } else {\n          return 1\n        }\n      },\n\n      _prune: function (newItemSize) {\n        while (this.size + (newItemSize || 0) > this.maxSize) {\n          var oldest = this._cacheOldest\n          if (oldest) {\n            this._log('evict', oldest)\n\n            // // update the oldest and newest pointers\n            // if( ! oldest.next ) // if this was also the newest\n            //     this._cacheNewest = oldest.prev; // probably undef\n            // this._cacheOldest = oldest.next; // maybe undef\n\n            // take it out of the linked list\n            this._llRemove(oldest)\n\n            // delete it from the byKey structure\n            delete this._cacheByKey[oldest.keyString]\n\n            // remove its linked-list links in case that makes it\n            // easier for the GC\n            delete oldest.next\n            delete oldest.prev\n\n            // update our size and item counts\n            this.itemCount--\n            this.size -= oldest.size\n          } else {\n            // should usually not be reached\n            this._error('eviction error', this.size, newItemSize, this)\n            return\n          }\n        }\n      },\n\n      _log: function () {\n        if (this.verbose) {console.log.apply(console, arguments)}\n      },\n      _warn: function () {\n        console.warn.apply(console, arguments)\n      },\n      _error: function () {\n        console.error.apply(console, arguments)\n      },\n    },\n  )\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/Store/Names/Hash.js":{"size":5130,"mtime":1738905961639,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Store/Names/Hash.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'dojo/_base/array',\n  'dojo/store/util/QueryResults',\n  'JBrowse/Util',\n  'JBrowse/Store/Hash',\n  'JBrowse/Model/Location',\n], function (declare, array, QueryResults, Util, HashStore, Location) {\n  return declare(HashStore, {\n    constructor: function (args) {\n      this.tooManyMatchesMessage =\n        args.tooManyMatchesMessage || '(too many matches to display)'\n\n      // generate stopPrefixes\n      var stopPrefixes = (this.stopPrefixes = {})\n      // make our stopPrefixes an object as { prefix: true, ... }\n      // with all possible prefixes of our stop prefixes\n      if (args.stopPrefixes) {\n        var prefixesInput =\n          typeof args.stopPrefixes == 'string'\n            ? [args.stopPrefixes]\n            : args.stopPrefixes\n\n        dojo.forEach(prefixesInput, function (prefix) {\n          while (prefix.length) {\n            stopPrefixes[prefix] = true\n            prefix = prefix.substr(0, prefix.length - 1)\n          }\n        })\n      }\n    },\n\n    _nameRecordToItem: function (nameRecord) {\n      if (nameRecord.hitLimit) {\n        // it's a too-many-matches marker\n        return { name: this.tooManyMatchesMessage, hitLimit: true }\n      } else {\n        // it's an actual name record\n        var item = {}\n        if (typeof nameRecord == 'object') {\n          item.name = nameRecord[0]\n          var trackConfig = this._findTrackConfig(\n            ((this.meta || {}).track_names || {})[nameRecord[1]],\n          )\n          item.location = new Location({\n            ref: nameRecord[3],\n            start: parseInt(nameRecord[4]),\n            end: parseInt(nameRecord[5]),\n            tracks: trackConfig ? [trackConfig] : null,\n            objectName: nameRecord[0],\n          })\n        } else {\n          item.name = nameRecord\n        }\n        return item\n      }\n    },\n\n    // look in the browser's track configuration for the track with the given label\n    _findTrackConfig: function (trackLabel) {\n      if (!trackLabel) {return null}\n\n      var track = null\n      var i = array.some(this.browser.config.tracks, function (t) {\n        if (t.label == trackLabel) {\n          track = t\n          return true\n        }\n        return false\n      })\n\n      return track\n    },\n\n    _makeResults: function (nameRecords) {\n      // convert the name records into dojo.store-compliant data\n      // items, sort them by name and location\n      var results = array\n        .map(nameRecords, dojo.hitch(this, '_nameRecordToItem'))\n        .sort(function (a, b) {\n          return (\n            a.name.localeCompare(b.name) || a.location.localeCompare(b.location)\n          )\n        })\n\n      var last\n      var hitLimit\n\n      // aggregate them and make labels for them.  for names with\n      // multiple locations, make a multipleLocations member.\n      results = array.filter(results, function (i) {\n        if (i.hitLimit) {\n          hitLimit = i\n          if (!hitLimit.label)\n            {hitLimit.label = hitLimit.name || 'too many matches'}\n          return false\n        } else if (last && last.name == i.name) {\n          last.label =\n            last.name +\n            ' <span class=\"multipleLocations\">multiple locations</span>'\n          if (last.multipleLocations) {\n            last.multipleLocations.push(i.location)\n          } else {\n            last.multipleLocations = [last.location, i.location]\n            delete last.location\n          }\n          return false\n        }\n        last = i\n        last.label =\n          last.name +\n          (last.location\n            ? ' <span class=\"locString\">' + last.location + '</span>'\n            : '')\n        return true\n      })\n\n      if (hitLimit) {results.push(hitLimit)}\n\n      return QueryResults(results)\n    },\n\n    // case-insensitive, and supports prefix queries like 'foo*'\n    async query(query, options) {\n      // remove trailing asterisks from query.name\n      var thisB = this\n      var name = (query.name || '').toString()\n\n      // lowercase the name if the store is all-lowercase\n      // wait for the ready signal to test for lower case keys\n      await this.ready\n      if (this.meta.lowercase_keys) {name = name.toLowerCase()}\n\n      var trailingStar = /\\*$/\n      if (trailingStar.test(name)) {\n        name = name.replace(trailingStar, '')\n        return this._getEntry(name).then(function (value) {\n          value = value || {}\n          return thisB._makeResults(\n            (value.exact || []).concat(value.prefix || []),\n          )\n        })\n      } else {\n        return this._getEntry(name).then(function (value) {\n          return thisB._makeResults((value || {}).exact || [])\n        })\n      }\n    },\n\n    get: function (id) {\n      // lowercase the id if the store is all-lowercase\n      if (this.meta.lowercase_keys) {id = id.toLowerCase()}\n\n      return this._getEntry(id).then(function (bucket) {\n        var nameRec = (bucket.exact || [])[0]\n        return nameRec ? this._nameRecordToItem(nameRec) : null\n      })\n    },\n\n    _getEntry: function (key) {\n      return this._getBucket(key).then(function (bucket) {\n        return bucket[key]\n      })\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/Store/Names/LazyTrieDojoData.js":{"size":6760,"mtime":1738905961651,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Store/Names/LazyTrieDojoData.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"/**\n * dojo.data.api.Read-compatible store object that reads data from an\n * encapsulated JBrowse/Store/LazyTrie.\n */\n\ndefine([\n  'dojo/_base/declare',\n  'dojo/_base/array',\n  'JBrowse/Util',\n  'JBrowse/Model/Location',\n], function (declare, array, Util, Location) {\n  return declare(\n    null,\n    /**\n     * @lends JBrowse.Store.Autocomplete.prototype\n     */\n    {\n      /**\n       * @constructs\n       * @param args.namesTrie\n       * @param args.stopPrefixes\n       * @param args.resultLimit\n       * @param args.tooManyMatchesMessage\n       */\n      constructor: function (/**Object*/ args) {\n        if (!args.namesTrie) {throw 'must provide a namesTrie argument'}\n\n        this.namesTrie = args.namesTrie\n\n        this.resultLimit = args.resultLimit || 15\n        this.tooManyMatchesMessage =\n          args.tooManyMatchesMessage || '(too many matches to display)'\n\n        // generate stopPrefixes\n        var stopPrefixes = (this.stopPrefixes = {})\n        // make our stopPrefixes an object as { prefix: true, ... }\n        // with all possible prefixes of our stop prefixes\n        if (args.stopPrefixes) {\n          var prefixesInput =\n            typeof args.stopPrefixes == 'string'\n              ? [args.stopPrefixes]\n              : args.stopPrefixes\n\n          dojo.forEach(prefixesInput, function (prefix) {\n            while (prefix.length) {\n              stopPrefixes[prefix] = true\n              prefix = prefix.substr(0, prefix.length - 1)\n            }\n          })\n        }\n\n        // make a self-modifying method for extracting the that\n        // detects whether the name store is formatted with tools\n        // pre-1.4 or post-1.4.  for pre-1.4 formats, will just\n        // complete with the lower-case version of the name.  for\n        // post-1.4, use the original-case version that's stored in\n        // the name record.\n        this.nodeText = function (node) {\n          if (typeof node[1][0][0] == 'number') {\n            // pre-1.4, for backcompat\n            this.nodeText = function (node) {\n              return node[0]\n            }\n          } else {\n            // post-1.4\n            this.nodeText = function (node) {\n              return node[1][0][0]\n            }\n          }\n          return this.nodeText(node)\n        }\n      },\n\n      getFeatures: function () {\n        return {\n          'dojo.data.api.Read': true,\n          'dojo.data.api.Identity': true,\n        }\n      },\n\n      // dojo.data.api.Read support\n\n      fetch: function (/**Object*/ request) {\n        var start = request.start || 0\n        var matchLimit = Math.min(\n          this.resultLimit,\n          Math.max(0, request.count || Infinity),\n        )\n        var matchesRemaining = matchLimit\n        var scope = request.scope || dojo.global\n        var aborted = false\n\n        // wrap our abort function to set a flag\n        request.abort = function () {\n          var oldabort = request.abort || function () {}\n          return function () {\n            aborted = true\n            oldabort.call(scope, request)\n          }\n        }.call(this)\n\n        if (!request.store) {request.store = this}\n\n        if (request.onBegin) {request.onBegin.call(scope, 0, request)}\n\n        var prefix = (request.query.name || '').toString().replace(/\\*$/, '')\n\n        if (!this.stopPrefixes[prefix]) {\n          this.namesTrie.mappingsFromPrefix(\n            prefix,\n            dojo.hitch(this, function (tree) {\n              var matches = []\n\n              if (aborted) {return}\n\n              // are we working with a post-JBrowse 1.4 data structure?\n              var post1_4 =\n                tree[0] &&\n                tree[0][1] &&\n                tree[0][1][0] &&\n                typeof tree[0][1][0][0] == 'string'\n\n              // use dojo.some so that we can break out of the loop when we hit the limit\n              dojo.some(\n                tree,\n                function (node) {\n                  if (matchesRemaining--) {\n                    var name = this.nodeText(node)\n                    array.forEach(\n                      node[1],\n                      function (n) {\n                        var location = new Location({\n                          ref: n[post1_4 ? 3 : 2],\n                          start: parseInt(n[post1_4 ? 4 : 3]),\n                          end: parseInt(n[post1_4 ? 5 : 4]),\n                          tracks: [this.namesTrie.extra[n[post1_4 ? 1 : 0]]],\n                          objectName: name,\n                        })\n\n                        matches.push({\n                          name: name,\n                          location: location,\n                        })\n                      },\n                      this,\n                    )\n                  }\n                  return matchesRemaining < 0\n                },\n                this,\n              )\n\n              // if we found more than the match limit\n              if (matchesRemaining < 0)\n                {matches.push({\n                  name: this.tooManyMatchesMessage,\n                  hitLimit: true,\n                })}\n\n              if (request.sort)\n                {matches.sort(\n                  dojo.data.util.sorter.createSortFunction(request.sort, this),\n                )}\n              if (!aborted && request.onItem)\n                {dojo.forEach(matches, function (item) {\n                  if (!aborted) {request.onItem.call(scope, item, request)}\n                })}\n              if (!aborted && request.onComplete)\n                {request.onComplete.call(scope, matches, request)}\n            }),\n          )\n        } else if (request.onComplete) {\n          request.onComplete.call(scope, [], request)\n        }\n\n        return request\n      },\n\n      getValue: function (i, attr, defaultValue) {\n        var v = i[attr]\n        return typeof v == 'undefined' ? defaultValue : v\n      },\n      getValues: function (i, attr) {\n        var a = [i[attr]]\n        return typeof a[0] == 'undefined' ? [] : a\n      },\n\n      getAttributes: function (item) {\n        return Util.dojof.keys(item)\n      },\n\n      hasAttribute: function (item, attr) {\n        return item.hasOwnProperty(attr)\n      },\n\n      containsValue: function (item, attribute, value) {\n        return item[attribute] == value\n      },\n\n      isItem: function (item) {\n        return typeof item == 'object' && typeof item.label == 'string'\n      },\n\n      isItemLoaded: function () {\n        return true\n      },\n\n      loadItem: function (args) {},\n\n      close: function () {},\n\n      getLabel: function (i) {\n        return this.getValue(i, 'name', undefined)\n      },\n      getLabelAttributes: function (i) {\n        return ['name']\n      },\n\n      getIdentity: function (i) {\n        return this.getLabel(i)\n      },\n    },\n  )\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/Store/Names/REST.js":{"size":1569,"mtime":1738905961656,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Store/Names/REST.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/src/JBrowse/Store/NCList_v0.js":{"size":7779,"mtime":1738905961665,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Store/NCList_v0.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define(['JBrowse/Finisher', 'JBrowse/Util'], function (Finisher, Util) {\n  /**\n   * Legacy-compatible NCList for 1.2.1 backward compatibility.\n   * @lends JBrowse.Store.NCList_v0\n   * @constructs\n   */\n  function NCList_v0() {}\n\n  NCList_v0.prototype.importExisting = function (\n    nclist,\n    sublistIndex,\n    lazyIndex,\n    baseURL,\n    lazyUrlTemplate,\n  ) {\n    this.topList = nclist\n    this.sublistIndex = sublistIndex\n    this.lazyIndex = lazyIndex\n    this.baseURL = baseURL\n    this.lazyUrlTemplate = lazyUrlTemplate\n  }\n\n  NCList_v0.prototype.fill = function (intervals, sublistIndex) {\n    //intervals: array of arrays of [start, end, ...]\n    //sublistIndex: index into a [start, end] array for storing a sublist\n    //              array. this is so you can use those arrays for something\n    //              else, and keep the NCList_v0 bookkeeping from interfering.\n    //              That's hacky, but keeping a separate copy of the intervals\n    //              in the NCList_v0 seems like a waste (TODO: measure that waste).\n    //half-open?\n    this.sublistIndex = sublistIndex\n    var myIntervals = intervals //.concat();\n    //sort by OL\n    myIntervals.sort(function (a, b) {\n      if (a[0] != b[0]) {return a[0] - b[0]}\n      else {return b[1] - a[1]}\n    })\n    var sublistStack = []\n    var curList = []\n    this.topList = curList\n    curList.push(myIntervals[0])\n    var curInterval, topSublist\n    for (var i = 1, len = myIntervals.length; i < len; i++) {\n      curInterval = myIntervals[i]\n      //if this interval is contained in the previous interval,\n      if (curInterval[1] < myIntervals[i - 1][1]) {\n        //create a new sublist starting with this interval\n        sublistStack.push(curList)\n        curList = new Array(curInterval)\n        myIntervals[i - 1][sublistIndex] = curList\n      } else {\n        //find the right sublist for this interval\n        while (true) {\n          if (0 == sublistStack.length) {\n            curList.push(curInterval)\n            break\n          } else {\n            topSublist = sublistStack[sublistStack.length - 1]\n            if (topSublist[topSublist.length - 1][1] > curInterval[1]) {\n              //curList is the first (deepest) sublist that\n              //curInterval fits into\n              curList.push(curInterval)\n              break\n            } else {\n              curList = sublistStack.pop()\n            }\n          }\n        }\n      }\n    }\n  }\n\n  NCList_v0.prototype.binarySearch = function (arr, item, itemIndex) {\n    var low = -1\n    var high = arr.length\n    var mid\n\n    while (high - low > 1) {\n      mid = (low + high) >>> 1\n      if (arr[mid][itemIndex] > item) {high = mid}\n      else {low = mid}\n    }\n\n    //if we're iterating rightward, return the high index;\n    //if leftward, the low index\n    if (1 == itemIndex) {return high}\n    else {return low}\n  }\n\n  NCList_v0.prototype.iterHelper = function (\n    arr,\n    from,\n    to,\n    fun,\n    finish,\n    inc,\n    searchIndex,\n    testIndex,\n    path,\n  ) {\n    var len = arr.length\n    var i = this.binarySearch(arr, from, searchIndex)\n    while (i < len && i >= 0 && inc * arr[i][testIndex] < inc * to) {\n      if ('object' == typeof arr[i][this.lazyIndex]) {\n        var ncl = this\n        // lazy node\n        if (arr[i][this.lazyIndex].state) {\n          if ('loading' == arr[i][this.lazyIndex].state) {\n            // node is currenly loading; finish this query once it\n            // has been loaded\n            finish.inc()\n            arr[i][this.lazyIndex].callbacks.push(\n              (function (parentIndex) {\n                return function (o) {\n                  ncl.iterHelper(\n                    o,\n                    from,\n                    to,\n                    fun,\n                    finish,\n                    inc,\n                    searchIndex,\n                    testIndex,\n                    path.concat(parentIndex),\n                  )\n                  finish.dec()\n                }\n              })(i),\n            )\n          } else if ('loaded' == arr[i][this.lazyIndex].state) {\n            // just continue below\n          } else {\n            console.log('unknown lazy type: ' + arr[i])\n          }\n        } else {\n          // no \"state\" property means this node hasn't been loaded,\n          // start loading\n          arr[i][this.lazyIndex].state = 'loading'\n          arr[i][this.lazyIndex].callbacks = []\n          finish.inc()\n          dojo.xhrGet({\n            url: Util.resolveUrl(\n              this.baseURL,\n              this.lazyUrlTemplate.replace(\n                /\\{chunk\\}/g,\n                arr[i][this.lazyIndex].chunk,\n              ),\n            ),\n            headers: {\n              'X-Requested-With': null,\n            },\n            handleAs: 'json',\n            load: (function (lazyFeat, lazyObj, sublistIndex, parentIndex) {\n              return function (o) {\n                lazyObj.state = 'loaded'\n                lazyFeat[sublistIndex] = o\n                ncl.iterHelper(\n                  o,\n                  from,\n                  to,\n                  fun,\n                  finish,\n                  inc,\n                  searchIndex,\n                  testIndex,\n                  path.concat(parentIndex),\n                )\n                for (var c = 0; c < lazyObj.callbacks.length; c++)\n                  {lazyObj.callbacks[c](o)}\n                finish.dec()\n              }\n            })(arr[i], arr[i][this.lazyIndex], this.sublistIndex, i),\n            error: function () {\n              finish.dec()\n            },\n          })\n        }\n      } else {\n        fun(arr[i], path.concat(i))\n      }\n\n      if (arr[i][this.sublistIndex])\n        {this.iterHelper(\n          arr[i][this.sublistIndex],\n          from,\n          to,\n          fun,\n          finish,\n          inc,\n          searchIndex,\n          testIndex,\n          path.concat(i),\n        )}\n      i += inc\n    }\n  }\n\n  NCList_v0.prototype.iterate = function (from, to, fun, postFun) {\n    // calls the given function once for each of the\n    // intervals that overlap the given interval\n    //if from <= to, iterates left-to-right, otherwise iterates right-to-left\n\n    //inc: iterate leftward or rightward\n    var inc = from > to ? -1 : 1\n    //searchIndex: search on start or end\n    var searchIndex = from > to ? 0 : 1\n    //testIndex: test on start or end\n    var testIndex = from > to ? 1 : 0\n    var finish = new Finisher(postFun)\n    this.iterHelper(\n      this.topList,\n      from,\n      to,\n      fun,\n      finish,\n      inc,\n      searchIndex,\n      testIndex,\n      [],\n    )\n    finish.finish()\n  }\n\n  NCList_v0.prototype.histogram = function (from, to, numBins, callback) {\n    //calls callback with a histogram of the feature density\n    //in the given interval\n\n    var result = new Array(numBins)\n    var binWidth = (to - from) / numBins\n    for (var i = 0; i < numBins; i++) {result[i] = 0}\n    //this.histHelper(this.topList, from, to, result, numBins, (to - from) / numBins);\n    this.iterate(\n      from,\n      to,\n      function (feat) {\n        var firstBin = Math.max(0, ((feat[0] - from) / binWidth) | 0)\n        var lastBin = Math.min(numBins, ((feat[1] - from) / binWidth) | 0)\n        for (var bin = firstBin; bin <= lastBin; bin++) {result[bin]++}\n      },\n      function () {\n        callback(result)\n      },\n    )\n  }\n\n  /*\n\nCopyright (c) 2007-2009 The Evolutionary Software Foundation\n\nCreated by Mitchell Skinner <mitch_skinner@berkeley.edu>\n\nThis package and its accompanying libraries are free software; you can\nredistribute it and/or modify it under the terms of the LGPL (either\nversion 2.1, or at your option, any later version) or the Artistic\nLicense 2.0.  Refer to LICENSE for the full license text.\n\n*/\n\n  return NCList_v0\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/Store/NCList.js":{"size":8146,"mtime":1738905961676,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Store/NCList.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/request',\n  'dojo/promise/all',\n  'dojo/Deferred',\n  'JBrowse/Util',\n  'JBrowse/Store/LRUCache',\n], function (request, all, Deferred, Util, LRUCache) {\n  /**\n\nNested containment list.\n\n@class\n\nAfter\n<pre>\n  Alekseyenko, A., and Lee, C. (2007).\n  Nested Containment List (NCList): A new algorithm for accelerating\n     interval query of genome alignment and interval databases.\n  Bioinformatics, doi:10.1093/bioinformatics/btl647\n</pre>\n\n<a href=\"http://bioinformatics.oxfordjournals.org/cgi/content/abstract/btl647v1\">http://bioinformatics.oxfordjournals.org/cgi/content/abstract/btl647v1</a>\n\n */\n\n  function NCList() {\n    this.topList = []\n  }\n\n  NCList.prototype.importExisting = function (\n    nclist,\n    attrs,\n    baseURL,\n    lazyUrlTemplate,\n    lazyClass,\n  ) {\n    this.topList = nclist\n    this.attrs = attrs\n    this.start = attrs.makeFastGetter('Start')\n    this.end = attrs.makeFastGetter('End')\n    this.lazyClass = lazyClass\n    this.baseURL = baseURL\n    this.lazyUrlTemplate = lazyUrlTemplate\n    this.lazyChunks = {}\n  }\n\n  /**\n   *\n   *  Given an array of features, creates the nested containment list data structure\n   *  WARNING: DO NOT USE directly for adding additional intervals!\n   *  completely replaces existing nested containment structure\n   *  (erases current topList and subarrays, repopulates from intervals)\n   *  currently assumes each feature is array as described above\n   */\n  NCList.prototype.fill = function (intervals, attrs) {\n    //intervals: array of arrays of [start, end, ...]\n    //attrs: an ArrayRepr object\n    //half-open?\n    if (intervals.length == 0) {\n      this.topList = []\n      return\n    }\n\n    this.attrs = attrs\n    this.start = attrs.makeFastGetter('Start')\n    this.end = attrs.makeFastGetter('End')\n    var sublist = attrs.makeSetter('Sublist')\n    var start = this.start\n    var end = this.end\n    var myIntervals = intervals\n    //sort by OL\n    myIntervals.sort(function (a, b) {\n      if (start(a) != start(b)) {return start(a) - start(b)}\n      else {return end(b) - end(a)}\n    })\n    var sublistStack = []\n    var curList = []\n    this.topList = curList\n    curList.push(myIntervals[0])\n    if (myIntervals.length == 1) {return}\n    var curInterval, topSublist\n    for (var i = 1, len = myIntervals.length; i < len; i++) {\n      curInterval = myIntervals[i]\n      //if this interval is contained in the previous interval,\n      if (end(curInterval) < end(myIntervals[i - 1])) {\n        //create a new sublist starting with this interval\n        sublistStack.push(curList)\n        curList = new Array(curInterval)\n        sublist(myIntervals[i - 1], curList)\n      } else {\n        //find the right sublist for this interval\n        while (true) {\n          if (0 == sublistStack.length) {\n            curList.push(curInterval)\n            break\n          } else {\n            topSublist = sublistStack[sublistStack.length - 1]\n            if (end(topSublist[topSublist.length - 1]) > end(curInterval)) {\n              //curList is the first (deepest) sublist that\n              //curInterval fits into\n              curList.push(curInterval)\n              break\n            } else {\n              curList = sublistStack.pop()\n            }\n          }\n        }\n      }\n    }\n  }\n\n  NCList.prototype.binarySearch = function (arr, item, getter) {\n    var low = -1\n    var high = arr.length\n    var mid\n\n    while (high - low > 1) {\n      mid = (low + high) >>> 1\n      if (getter(arr[mid]) >= item) {high = mid}\n      else {low = mid}\n    }\n\n    //if we're iterating rightward, return the high index;\n    //if leftward, the low index\n    if (getter === this.end) {return high}\n    else {return low}\n  }\n  NCList.prototype._readChunkItems = function (chunk, callback) {\n    request\n      .get(\n        Util.resolveUrl(\n          this.baseURL,\n          this.lazyUrlTemplate.replace(/\\{Chunk\\}/gi, chunk.chunkNum),\n        ),\n        {\n          handleAs: 'json',\n          headers: {\n            'X-Requested-With': null,\n          },\n        },\n      )\n      .then(\n        function (sublist) {\n          callback(sublist)\n        },\n        function (error) {\n          if (error.response.status != 404) {callback(null, error)}\n          else {callback()}\n        },\n      )\n  }\n  NCList.prototype.iterHelper = function (\n    arr,\n    from,\n    to,\n    fun,\n    inc,\n    searchGet,\n    testGet,\n    path,\n  ) {\n    var len = arr.length\n    var i = this.binarySearch(arr, from, searchGet)\n    var getChunk = this.attrs.makeGetter('Chunk')\n    var getSublist = this.attrs.makeGetter('Sublist')\n\n    var promises = []\n\n    var cache = (this.chunkCache =\n      this.chunkCache ||\n      new LRUCache({\n        name: 'NCListCache',\n        fillCallback: dojo.hitch(this, '_readChunkItems'),\n        sizeFunction: function (chunkItems) {\n          return chunkItems.length\n        },\n        maxSize: 5000, // cache up to 100 seqchunks\n      }))\n    while (i < len && i >= 0 && inc * testGet(arr[i]) < inc * to) {\n      if (arr[i][0] == this.lazyClass) {\n        // this is a lazily-loaded chunk of the nclist\n        ;(function () {\n          var thisB = this\n          var chunkNum = getChunk(arr[i])\n          if (!(chunkNum in this.lazyChunks)) {\n            this.lazyChunks[chunkNum] = {}\n          }\n\n          var getDone = new Deferred()\n          promises.push(getDone.promise)\n\n          cache.get({ chunkNum: chunkNum }, function (item, e) {\n            if (e) {\n              getDone.reject(e)\n              return\n            }\n            if (!item) {\n              getDone.resolve()\n              return\n            }\n            return thisB\n              .iterHelper(item, from, to, fun, inc, searchGet, testGet, [\n                chunkNum,\n              ])\n              .then(function () {\n                getDone.resolve()\n              })\n          })\n        }).call(this)\n      } else {\n        // this is just a regular feature\n\n        fun(arr[i], path.concat(i))\n      }\n\n      // if this node has a contained sublist, process that too\n      var sublist = getSublist(arr[i])\n      if (sublist)\n        {promises.push(\n          this.iterHelper(\n            sublist,\n            from,\n            to,\n            fun,\n            inc,\n            searchGet,\n            testGet,\n            path.concat(i),\n          ),\n        )}\n      i += inc\n    }\n\n    return all(promises)\n  }\n\n  NCList.prototype.iterate = function (from, to, fun, postFun) {\n    // calls the given function once for each of the\n    // intervals that overlap the given interval\n    //if from <= to, iterates left-to-right, otherwise iterates right-to-left\n\n    //inc: iterate leftward or rightward\n    var inc = from > to ? -1 : 1\n    //searchGet: search on start or end\n    var searchGet = from > to ? this.start : this.end\n    //testGet: test on start or end\n    var testGet = from > to ? this.end : this.start\n\n    if (this.topList.length > 0) {\n      this.iterHelper(this.topList, from, to, fun, inc, searchGet, testGet, [\n        0,\n      ]).then(postFun)\n    }\n  }\n\n  NCList.prototype.histogram = function (from, to, numBins, callback) {\n    //calls callback with a histogram of the feature density\n    //in the given interval\n\n    var result = new Array(numBins)\n    var binWidth = (to - from) / numBins\n    var start = this.start\n    var end = this.end\n    for (var i = 0; i < numBins; i++) {result[i] = 0}\n    this.iterate(\n      from,\n      to,\n      function (feat) {\n        var firstBin = Math.max(0, ((start(feat) - from) / binWidth) | 0)\n        var lastBin = Math.min(numBins, ((end(feat) - from) / binWidth) | 0)\n        for (var bin = firstBin; bin <= lastBin; bin++) {result[bin]++}\n      },\n      function () {\n        callback(result)\n      },\n    )\n  }\n\n  /*\n\nCopyright (c) 2007-2009 The Evolutionary Software Foundation\n\nCreated by Mitchell Skinner <mitch_skinner@berkeley.edu>\n\nThis package and its accompanying libraries are free software; you can\nredistribute it and/or modify it under the terms of the LGPL (either\nversion 2.1, or at your option, any later version) or the Artistic\nLicense 2.0.  Refer to LICENSE for the full license text.\n\n*/\n  return NCList\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature.js":{"size":11792,"mtime":1738905961689,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'dojo/_base/lang',\n  'JBrowse/Util',\n  'JBrowse/Store',\n  'JBrowse/Store/LRUCache',\n], function (declare, lang, Util, Store, LRUCache) {\n  /**\n   * Base class for JBrowse data backends that hold sequences and\n   * features.\n   *\n   * @class JBrowse.SeqFeatureStore\n   * @extends JBrowse.Store\n   * @constructor\n   */\n\n  return declare(Store, {\n    constructor: function (args) {\n      this.globalStats = {}\n      this.storeTimeout = args.storeTimeout ? args.storeTimeout : 3000\n      this._featureTransforms = args.featureTransforms || []\n\n      // install general transform function if defined\n      this._configureFeaturesTransforms()\n    },\n\n    _configureFeaturesTransforms: function () {\n      let featureTransform = this.getConf('featureTransform')\n      if (typeof featureTransform === 'string') {\n        featureTransform = this.getPredefinedFeatureTransform(featureTransform)\n      }\n\n      if (featureTransform) {\n        this.addFeatureTransform(featureTransform)\n      }\n\n      // install `config.topLevelFeatures` transform if necessary\n      this._configureTopLevelFeaturesTransform()\n    },\n\n    /**\n     * get a predefined feature transform function by name, or undef if no\n     * transform by that name is defined\n     * @param {string} name\n     */\n    getPredefinedFeatureTransform(name) {},\n\n    /**\n     * Get a metadata object, if one is available, for the\n     * given feature tag name\n     * @param {string} tagName\n     * @returns {object} containing 'description' member, and optionally anything else\n     */\n    getTagMetadata(tagName) {},\n\n    /**\n     * If the `topLevelFeatures` configuration variable is set on this\n     * store, creates and installs a feature transform function to\n     * implement it.\n     */\n    _configureTopLevelFeaturesTransform: function () {\n      const confVal = this.getConf('topLevelFeatures', [this])\n      if (!confVal) {return}\n\n      if (typeof confVal === 'function') {\n        this._topLevelFeaturesTransform = confVal\n      } else {\n        let typesList\n        if (Array.isArray(confVal)) {\n          typesList = confVal\n        } else if (typeof confVal === 'string') {\n          typesList = confVal.trim().split(/\\s*,\\s*/)\n        } else {\n          throw new Error(\n            'invalid topLevelFeatures configuration value',\n            confVal,\n          )\n        }\n        if (typesList.length) {\n          this._topLevelFeatureTypes = typesList\n          this._topLevelFeaturesTransform = features => {\n            let resultFeatures = []\n            features.forEach(feature => {\n              resultFeatures.push(\n                ...this._findSubfeaturesWithTypes(typesList, feature),\n              )\n            })\n            return resultFeatures\n          }\n        }\n      }\n\n      if (this._topLevelFeaturesTransform) {\n        try {\n          this.addFeatureTransform(this._topLevelFeaturesTransform)\n        } catch (e) {\n          throw new Error(\n            `store class ${this.getConf('type')} does not support topLevelFeatures configuration`,\n          )\n        }\n      }\n    },\n\n    _isTopLevelFeatureType(featureType) {\n      if (this._topLevelFeatureTypes) {\n        return this._topLevelFeatureTypes.includes(featureType)\n      } else if (this._topLevelFeaturesTransform) {\n        throw new Error(\n          'custom top-level feature transforms not supported in this use case',\n        )\n      }\n      return true\n    },\n\n    _evalConf: function (confVal, confKey) {\n      // evaluate callbacks as functions\n      return typeof confVal == 'function' ? confVal.call(this, this) : confVal\n    },\n\n    /**\n     * Fetch global statistics the features in this store.\n     *\n     * @param {Function} successCallback(stats) callback to receive the\n     *   statistics.  called with one argument, an object containing\n     *   attributes with various statistics.\n     * @param {Function} errorCallback(error) in the event of an error, this\n     *   callback will be called with one argument, which is anything\n     *   that can stringify to an error message.\n     */\n    getGlobalStats: function (callback, errorCallback) {\n      callback(this.globalStats || {})\n    },\n\n    /**\n     * Fetch statistics about the features in a specific region.\n     *\n     * @param {String} query.ref    the name of the reference sequence\n     * @param {Number} query.start  start of the region in interbase coordinates\n     * @param {Number} query.end    end of the region in interbase coordinates\n     * @param {Function} successCallback(stats) callback to receive the\n     *   statistics.  called with one argument, an object containing\n     *   attributes with various statistics.\n     * @param {Function} errorCallback(error) in the event of an error, this\n     *   callback will be called with one argument, which is anything\n     *   that can stringify to an error message.\n     */\n    getRegionStats: function (query, successCallback, errorCallback) {\n      return this._getRegionStats.apply(this, arguments)\n    },\n\n    _getRegionStats: function (query, successCallback, errorCallback) {\n      var thisB = this\n      var cache = (thisB._regionStatsCache =\n        thisB._regionStatsCache ||\n        new LRUCache({\n          name: 'regionStatsCache',\n          maxSize: 1000, // cache stats for up to 1000 different regions\n          sizeFunction: function (stats) {\n            return 1\n          },\n          fillCallback: function (query, callback) {\n            //console.log( '_getRegionStats', query );\n            var s = {\n              scoreMax: -Infinity,\n              scoreMin: Infinity,\n              scoreSum: 0,\n              scoreSumSquares: 0,\n              basesCovered: query.end - query.start,\n              featureCount: 0,\n            }\n            thisB.getFeatures(\n              query,\n              function (feature) {\n                var score = feature.get('score') || 0\n                s.scoreMax = Math.max(score, s.scoreMax)\n                s.scoreMin = Math.min(score, s.scoreMin)\n                s.scoreSum += score\n                s.scoreSumSquares += score * score\n                s.featureCount++\n              },\n              function () {\n                s.scoreMean = s.featureCount ? s.scoreSum / s.featureCount : 0\n                s.scoreStdDev = thisB._calcStdFromSums(\n                  s.scoreSum,\n                  s.scoreSumSquares,\n                  s.featureCount,\n                )\n                s.featureDensity = s.featureCount / s.basesCovered\n                //console.log( '_getRegionStats done', s );\n                callback(s)\n              },\n              function (error) {\n                callback(null, error)\n              },\n            )\n          },\n        }))\n\n      cache.get(query, function (stats, error) {\n        if (error) {errorCallback(error)}\n        else {successCallback(stats)}\n      })\n    },\n\n    // utility method that calculates standard deviation from sum and sum of squares\n    _calcStdFromSums: function (sum, sumSquares, n) {\n      if (n == 0) {return 0}\n\n      var variance = sumSquares - (sum * sum) / n\n      if (n > 1) {\n        variance /= n - 1\n      }\n      return variance < 0 ? 0 : Math.sqrt(variance)\n    },\n\n    /**\n     * Fetch feature data from this store.\n     *\n     * @param {String} query.ref    the name of the reference sequence\n     * @param {Number} query.start  start of the region in interbase coordinates\n     * @param {Number} query.end    end of the region in interbase coordinates\n     * @param {Function} featureCallback(feature) callback that is called once\n     *   for each feature in the region of interest, with a single\n     *   argument; the feature.\n     * @param {Function} endCallback() callback that is called once\n     *   for each feature in the region of interest, with a single\n     *   argument; the feature.\n     * @param {Function} errorCallback(error) in the event of an error, this\n     *   callback will be called with one argument, which is anything\n     *   that can stringify to an error message.\n     */\n    getFeatures: function (query, featureCallback, endCallback, errorCallback) {\n      endCallback()\n    },\n\n    /**\n     * Add a transformation function to be applied to features read from the store.\n     */\n    addFeatureTransform: function (transformFunction) {\n      if (!this.supportsFeatureTransforms)\n        {throw new Error(\n          'store class ' +\n            this.getConf('type') +\n            ' does not support feature transforms',\n        )}\n      this._featureTransforms.push(transformFunction)\n    },\n\n    /**\n     * Apply all of this store's registered transform functions to the set of features\n     * @param {Array[feature]} features\n     */\n    applyFeatureTransforms: function (features) {\n      let resultFeatures = features\n      this._featureTransforms.forEach(transformFunction => {\n        resultFeatures = transformFunction.call(this, resultFeatures, this)\n      })\n      return resultFeatures\n    },\n\n    /**\n     * Apply the topLevelFeatures configuration to possibly extract\n     * subfeature from this feature, and run the given callback on\n     * each of the new top-level features.\n     *\n     * @param {Array[SimpleFeature|LazyFeature|*]} features\n     * @private\n     */\n    _applyTopLevelFeaturesTransform(features) {\n      return Util.flattenOneLevel(\n        features.map(feature => this._topLevelFeaturesTransform(feature)),\n      )\n    },\n\n    /**\n     * traverse the subfeature hierarchy of the given feature,\n     * return an array of features whose types are in the given list\n     * @param {Array[string]} types\n     * @param {SimpleFeature|LazyFeature|*} feature\n     * @private\n     */\n    _findSubfeaturesWithTypes(types, feature) {\n      if (types.includes(feature.get('type'))) {return [feature]}\n      else {\n        let children = feature.children()\n        if (children && children.length) {\n          const matchingFeatures = []\n          children.forEach(childFeature =>\n            matchingFeatures.push(\n              ...this._findSubfeaturesWithTypes(types, childFeature),\n            ),\n          )\n          return matchingFeatures\n        } else {return []}\n      }\n    },\n\n    /**\n     * Given a plain query object, call back with a single sequence\n     * string that is the naively-assembled sequence for that region,\n     * assembled from the 'residues' or 'seq' attributes of the\n     * features that come back from the store.  Add\n     * \"reference_sequences_only: true\" to the query it send to the\n     * store.\n     */\n    getReferenceSequence: function (query, seqCallback, errorCallback) {\n      // insert the `replacement` string into `str` at the given\n      // `offset`, putting in `length` characters.\n      function replaceAt(str, offset, replacement) {\n        var rOffset = 0\n        if (offset < 0) {\n          rOffset = -offset\n          offset = 0\n        }\n\n        var length = Math.min(str.length - offset, replacement.length - rOffset)\n\n        return (\n          str.substr(0, offset) +\n          replacement.substr(rOffset, length) +\n          str.substr(offset + length)\n        )\n      }\n\n      // pad with spaces at the beginning of the string if necessary\n      var len = query.end - query.start\n      var sequence = ''\n      while (sequence.length < len) {sequence += ' '}\n\n      var thisB = this\n      this.getFeatures(\n        lang.mixin({ reference_sequences_only: true }, query),\n        function (f) {\n          var seq = f.get('residues') || f.get('seq')\n          if (seq)\n            {sequence = replaceAt(sequence, f.get('start') - query.start, seq)}\n        },\n        function () {\n          seqCallback(sequence)\n        },\n        errorCallback,\n      )\n    },\n    saveStore: function () {\n      console.log('unimplemented')\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/_InsertSizeCache.js":{"size":1586,"mtime":1738905961696,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/_InsertSizeCache.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/_MismatchesMixin.js":{"size":12406,"mtime":1738905961737,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/_MismatchesMixin.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"/**\n * Functions for parsing MD and CIGAR strings.\n */\n\nexport function parseCigar(cigar) {\n  return (cigar || '').split(/([MIDNSHPX=])/)\n}\nexport function cigarToMismatches(ops, seq) {\n  let currOffset = 0\n  let seqOffset = 0\n  const mismatches = []\n  for (let i = 0; i < ops.length - 1; i += 2) {\n    const len = +ops[i]\n    const op = ops[i + 1]\n    if (op === 'M' || op === '=' || op === 'E') {\n      seqOffset += len\n    }\n    if (op === 'I') {\n      // GAH: shouldn't length of insertion really by 0, since JBrowse internally uses zero-interbase coordinates?\n      mismatches.push({\n        start: currOffset,\n        type: 'insertion',\n        base: `${len}`,\n        length: 1,\n      })\n      seqOffset += len\n    } else if (op === 'D') {\n      mismatches.push({\n        start: currOffset,\n        type: 'deletion',\n        base: '*',\n        length: len,\n      })\n    } else if (op === 'N') {\n      mismatches.push({\n        start: currOffset,\n        type: 'skip',\n        base: 'N',\n        length: len,\n      })\n    } else if (op === 'X') {\n      const r = seq.slice(seqOffset, seqOffset + len)\n      for (let j = 0; j < len; j++) {\n        mismatches.push({\n          start: currOffset + j,\n          type: 'mismatch',\n          base: r[j],\n          length: 1,\n        })\n      }\n      seqOffset += len\n    } else if (op === 'H') {\n      mismatches.push({\n        start: currOffset,\n        type: 'hardclip',\n        base: `H${len}`,\n        cliplen: len,\n        length: 1,\n      })\n    } else if (op === 'S') {\n      mismatches.push({\n        start: currOffset,\n        type: 'softclip',\n        base: `S${len}`,\n        cliplen: len,\n        length: 1,\n      })\n      seqOffset += len\n    }\n    if (op !== 'I' && op !== 'S' && op !== 'H') {\n      currOffset += len\n    }\n  }\n  return mismatches\n}\n/**\n * parse a SAM MD tag to find mismatching bases of the template versus the reference\n * @returns array of mismatches and their positions\n */\nexport function mdToMismatches(mdstring, cigarOps, cigarMismatches, seq) {\n  const mismatchRecords = []\n  let curr = { start: 0, base: '', length: 0, type: 'mismatch' }\n  const skips = cigarMismatches.filter(cigar => cigar.type === 'skip')\n  let lastCigar = 0\n  let lastTemplateOffset = 0\n  let lastRefOffset = 0\n  let lastSkipPos = 0\n\n  // convert a position on the reference sequence to a position\n  // on the template sequence, taking into account hard and soft\n  // clipping of reads\n\n  function nextRecord() {\n    mismatchRecords.push(curr)\n\n    // get a new mismatch record ready\n    curr = {\n      start: curr.start + curr.length,\n      length: 0,\n      base: '',\n      type: 'mismatch',\n    }\n  }\n\n  function getTemplateCoordLocal(refCoord) {\n    let templateOffset = lastTemplateOffset\n    let refOffset = lastRefOffset\n    for (\n      let i = lastCigar;\n      i < cigarOps.length && refOffset <= refCoord;\n      i += 2, lastCigar = i\n    ) {\n      const len = +cigarOps[i]\n      const op = cigarOps[i + 1]\n      if (op === 'S' || op === 'I') {\n        templateOffset += len\n      } else if (op === 'D' || op === 'P' || op === 'N') {\n        refOffset += len\n      } else if (op !== 'H') {\n        templateOffset += len\n        refOffset += len\n      }\n    }\n    lastTemplateOffset = templateOffset\n    lastRefOffset = refOffset\n\n    return templateOffset - (refOffset - refCoord)\n  }\n\n  // now actually parse the MD string\n  const md = mdstring.match(/(\\d+|\\^[a-z]+|[a-z])/gi) || []\n  for (let i = 0; i < md.length; i++) {\n    const token = md[i]\n    if (token.match(/^\\d/)) {\n      curr.start += parseInt(token, 10)\n    } else if (token.match(/^\\^/)) {\n      curr.length = token.length - 1\n      curr.base = '*'\n      curr.type = 'deletion'\n      curr.seq = token.substring(1)\n      nextRecord()\n    } else if (token.match(/^[a-z]/i)) {\n      // mismatch\n      for (let j = 0; j < token.length; j += 1) {\n        curr.length = 1\n\n        while (lastSkipPos < skips.length) {\n          const mismatch = skips[lastSkipPos]\n          if (curr.start >= mismatch.start) {\n            curr.start += mismatch.length\n            lastSkipPos++\n          } else {\n            break\n          }\n        }\n        curr.base = seq\n          ? seq.substr(\n              cigarOps ? getTemplateCoordLocal(curr.start) : curr.start,\n              1,\n            )\n          : 'X'\n        curr.altbase = token\n        nextRecord()\n      }\n    }\n  }\n  return mismatchRecords\n}\nexport function getTemplateCoord(refCoord, cigarOps) {\n  let templateOffset = 0\n  let refOffset = 0\n  for (let i = 0; i < cigarOps.length && refOffset <= refCoord; i += 2) {\n    const len = +cigarOps[i]\n    const op = cigarOps[i + 1]\n    if (op === 'S' || op === 'I') {\n      templateOffset += len\n    } else if (op === 'D' || op === 'P') {\n      refOffset += len\n    } else if (op !== 'H') {\n      templateOffset += len\n      refOffset += len\n    }\n  }\n  return templateOffset - (refOffset - refCoord)\n}\n\n// adapted from minimap2 code static void write_MD_core function\nexport function generateMD(target, query, cigar) {\n  let queryOffset = 0\n  let targetOffset = 0\n  let lengthMD = 0\n  if (!target) {\n    console.warn('no ref supplied to generateMD')\n    return ''\n  }\n  const cigarOps = parseCigar(cigar)\n  let str = ''\n  for (let i = 0; i < cigarOps.length; i += 2) {\n    const len = +cigarOps[i]\n    const op = cigarOps[i + 1]\n    if (op === 'M' || op === 'X' || op === '=') {\n      for (let j = 0; j < len; j++) {\n        if (\n          query[queryOffset + j].toLowerCase() !==\n          target[targetOffset + j].toLowerCase()\n        ) {\n          str += `${lengthMD}${target[targetOffset + j].toUpperCase()}`\n          lengthMD = 0\n        } else {\n          lengthMD++\n        }\n      }\n      queryOffset += len\n      targetOffset += len\n    } else if (op === 'I') {\n      queryOffset += len\n    } else if (op === 'D') {\n      let tmp = ''\n      for (let j = 0; j < len; j++) {\n        tmp += target[targetOffset + j].toUpperCase()\n      }\n      str += `${lengthMD}^${tmp}`\n      lengthMD = 0\n      targetOffset += len\n    } else if (op === 'N') {\n      targetOffset += len\n    } else if (op === 'S') {\n      queryOffset += len\n    }\n  }\n  if (lengthMD > 0) {\n    str += lengthMD\n  }\n  return str\n}\n\ndefine(['dojo/_base/declare', 'dojo/_base/array'], function (declare, array) {\n  return declare(null, {\n    constructor: function () {\n      this.cigarAttributeName = (\n        this.config.cigarAttribute || 'cigar'\n      ).toLowerCase()\n      this.mdAttributeName = (this.config.mdAttribute || 'md').toLowerCase()\n    },\n\n    _getSkipsAndDeletions: function (feature) {\n      let mismatches = []\n      // parse the CIGAR tag if it has one\n      var cigarString = feature.get(this.cigarAttributeName)\n      if (cigarString) {\n        mismatches = this._cigarToSkipsAndDeletions(\n          feature,\n          parseCigar(cigarString),\n        )\n      } else {\n        var cramReadFeatures = feature.get('cram_read_features')\n        if (\n          this.config.renderAlignment &&\n          cramReadFeatures &&\n          cramReadFeatures.length\n        ) {\n          mismatches = mismatches.filter(\n            m => !(m.type == 'deletion' || m.type == 'mismatch'),\n          )\n        }\n\n        // parse the CRAM read features if it has them\n        if (cramReadFeatures) {\n          mismatches.push(\n            ...this._cramReadFeaturesToMismatches(\n              feature,\n              cramReadFeatures,\n            ).filter(m => m.type === 'skip' || m.type === 'deletion'),\n          )\n        }\n      }\n\n      return mismatches\n    },\n\n    _getMismatches: function (feature) {\n      var mismatches = []\n      if (this.config.cacheMismatches && feature.record.mismatches) {\n        return feature.record.mismatches\n      }\n\n      // parse the CIGAR tag if it has one\n      var cigarString = feature.get(this.cigarAttributeName),\n        cigarOps\n      if (cigarString) {\n        cigarOps = parseCigar(cigarString)\n        mismatches.push.apply(\n          mismatches,\n          cigarToMismatches(cigarOps, feature.get('seq')),\n        )\n      }\n\n      // now let's look for CRAM or MD mismatches\n      var cramReadFeatures = feature.get('cram_read_features')\n      var mdString = feature.get(this.mdAttributeName)\n\n      // if there is an MD tag or CRAM mismatches, mismatches and deletions from the\n      // CIGAR string are replaced by those from MD\n      if (\n        this.config.renderAlignment &&\n        ((cramReadFeatures && cramReadFeatures.length) || mdString)\n      ) {\n        mismatches = mismatches.filter(\n          m => !(m.type == 'deletion' || m.type == 'mismatch'),\n        )\n      }\n\n      // parse the CRAM read features if it has them\n      if (cramReadFeatures) {\n        mismatches = mismatches.concat(\n          this._cramReadFeaturesToMismatches(feature, cramReadFeatures),\n        )\n      }\n\n      // parse the MD tag if it has one\n      if (mdString) {\n        mismatches = mismatches.concat(\n          mdToMismatches(mdString, cigarOps, mismatches, feature.get('seq')),\n        )\n      }\n\n      // uniqify the mismatches\n      var seen = {}\n      mismatches = array.filter(mismatches, function (m) {\n        var key = m.type + ',' + m.start + ',' + m.length\n        var s = seen[key]\n        seen[key] = true\n        return !s\n      })\n      if (this.config.cacheMismatches) {\n        feature.record.mismatches = mismatches\n      }\n\n      return mismatches\n    },\n\n    _cramReadFeaturesToMismatches(feature, readFeatures) {\n      const start = feature.get('start')\n      const mismatches = []\n      readFeatures.forEach(({ code, refPos, data, sub, ref }) => {\n        refPos = refPos - 1 - start\n        if (code === 'X') {\n          // substitution\n          mismatches.push({\n            start: refPos,\n            length: 1,\n            base: sub,\n            altbase: ref,\n            type: 'mismatch',\n          })\n        } else if (code === 'I') {\n          // insertion\n          mismatches.push({\n            start: refPos,\n            type: 'insertion',\n            base: '' + data.length,\n            length: data.length,\n          })\n        } else if (code === 'N') {\n          // reference skip\n          mismatches.push({\n            type: 'skip',\n            length: data,\n            start: refPos,\n            base: 'N',\n          })\n        } else if (code === 'S') {\n          // soft clip\n          const len = data.length\n          mismatches.push({\n            start: refPos,\n            type: 'softclip',\n            base: 'S' + len,\n            cliplen: len,\n            length: 1,\n          })\n        } else if (code === 'P') {\n          // padding\n        } else if (code === 'H') {\n          // hard clip\n          const len = data\n          mismatches.push({\n            start: refPos,\n            type: 'hardclip',\n            base: 'H' + len,\n            cliplen: len,\n            length: 1,\n          })\n        } else if (code === 'D') {\n          // deletion\n          mismatches.push({\n            type: 'deletion',\n            length: data,\n            start: refPos,\n            base: '*',\n          })\n        } else if (code === 'b') {\n          // stretch of bases\n        } else if (code === 'q') {\n          // stretch of qual scores\n        } else if (code === 'B') {\n          // a pair of [base, qual]\n        } else if (code === 'i') {\n          // single-base insertion\n          // insertion\n          mismatches.push({\n            start: refPos,\n            type: 'insertion',\n            base: data,\n            length: 1,\n          })\n        } else if (code === 'Q') {\n          // single quality value\n        }\n      })\n      return mismatches\n    },\n\n    // parse just the skips and deletions out of a CIGAR string\n    _cigarToSkipsAndDeletions: function (feature, ops) {\n      var currOffset = 0\n      var mismatches = []\n      for (let i = 0; i < ops.length; i += 2) {\n        var len = +ops[i]\n        var op = ops[i + 1]\n        if (op == 'D')\n          {mismatches.push({\n            start: currOffset,\n            type: 'deletion',\n            base: '*',\n            length: len,\n          })}\n        else if (op == 'N')\n          {mismatches.push({\n            start: currOffset,\n            type: 'skip',\n            base: 'N',\n            length: len,\n          })}\n\n        if (op != 'I' && op != 'S' && op != 'H') {currOffset += len}\n      }\n      return mismatches\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/_PairCache.js":{"size":4225,"mtime":1738905961753,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/_PairCache.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/_SpanCache.js":{"size":2210,"mtime":1738905961762,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/_SpanCache.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/BAM.js":{"size":14868,"mtime":1738905961791,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/BAM.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"const LRU = cjsRequire('quick-lru')\nconst { BamFile } = cjsRequire('@gmod/bam')\n\nconst bamIndexedFilesCache = new LRU({ maxSize: 5 })\n\nconst BlobFilehandleWrapper = cjsRequire('../../Model/BlobFilehandleWrapper')\n\nexport function parseCigar(cigar) {\n  return (cigar || '').split(/([MIDNSHPX=])/)\n}\n// adapted from minimap2 code static void write_MD_core function\nexport function generateMD(target, query, cigar) {\n  let queryOffset = 0\n  let targetOffset = 0\n  let lengthMD = 0\n  if (!target) {\n    console.warn('no ref supplied to generateMD')\n    return ''\n  }\n  const cigarOps = parseCigar(cigar)\n  let str = ''\n  for (let i = 0; i < cigarOps.length; i += 2) {\n    const len = +cigarOps[i]\n    const op = cigarOps[i + 1]\n    if (op === 'M' || op === 'X' || op === '=') {\n      for (let j = 0; j < len; j++) {\n        if (\n          query[queryOffset + j].toLowerCase() !==\n          target[targetOffset + j].toLowerCase()\n        ) {\n          str += `${lengthMD}${target[targetOffset + j].toUpperCase()}`\n          lengthMD = 0\n        } else {\n          lengthMD++\n        }\n      }\n      queryOffset += len\n      targetOffset += len\n    } else if (op === 'I') {\n      queryOffset += len\n    } else if (op === 'D') {\n      let tmp = ''\n      for (let j = 0; j < len; j++) {\n        tmp += target[targetOffset + j].toUpperCase()\n      }\n      str += `${lengthMD}^${tmp}`\n      lengthMD = 0\n      targetOffset += len\n    } else if (op === 'N') {\n      targetOffset += len\n    } else if (op === 'S') {\n      queryOffset += len\n    }\n  }\n  if (lengthMD > 0) {\n    str += lengthMD\n  }\n  return str\n}\nclass BamSlightlyLazyFeature {\n  _get_id() {\n    this.record.id()\n  }\n  _get_type() {\n    return 'match'\n  }\n  _get_score() {\n    return this.record.get('mq')\n  }\n  _get_mapping_quality() {\n    return this.record.mappingQuality\n  }\n  _get_flags() {\n    return `0x${this.record.flags.toString(16)}`\n  }\n  _get_md() {\n    const md = this.record.get('md')\n    const seq = this.get('seq')\n    if (!md && seq && this.ref) {\n      return generateMD(this.ref, this.record.getReadBases(), this.get('cigar'))\n    }\n    return md\n  }\n  _get_strand() {\n    return this.record.isReverseComplemented() ? -1 : 1\n  }\n  _get_read_group_id() {\n    return this.record.readGroupId\n  }\n  _get_seq_id() {\n    return this._store._refIdToName(this.record._refID)\n  }\n  _get_qc_failed() {\n    return this.record.isFailedQc()\n  }\n  _get_duplicate() {\n    return this.record.isDuplicate()\n  }\n  _get_secondary_alignment() {\n    return this.record.isSecondary()\n  }\n  _get_supplementary_alignment() {\n    return this.record.isSupplementary()\n  }\n  _get_multi_segment_template() {\n    return this.record.isPaired()\n  }\n  _get_multi_segment_all_correctly_aligned() {\n    return this.record.isProperlyPaired()\n  }\n  _get_multi_segment_all_aligned() {\n    return this.record.isProperlyPaired()\n  }\n  _get_multi_segment_next_segment_unmapped() {\n    return this.record.isMateUnmapped()\n  }\n  _get_multi_segment_first() {\n    return this.record.isRead1()\n  }\n  _get_multi_segment_last() {\n    return this.record.isRead2()\n  }\n  _get_multi_segment_next_segment_reversed() {\n    return this.record.isMateReverseComplemented()\n  }\n  _get_pair_orientation() {\n    return this.record.getPairOrientation()\n  }\n  _get_unmapped() {\n    return this.record.isSegmentUnmapped()\n  }\n  _get_next_seq_id() {\n    return this.record.isPaired()\n      ? this._store._refIdToName(this.record._next_refid())\n      : undefined\n  }\n  _get_is_paired() {\n    return this.record.isPaired()\n  }\n  _get_next_pos() {\n    return this.record.isPaired() ? this.record._next_pos() : undefined\n  }\n  _get_next_segment_position() {\n    return this.record.isPaired()\n      ? this._store._refIdToName(this.record._next_refid()) +\n          ':' +\n          (this.record._next_pos() + 1)\n      : undefined\n  }\n  _get_tags() {\n    return this.record._tags()\n  }\n  _get_seq() {\n    return this.record.getReadBases()\n  }\n\n  constructor(record, store, ref) {\n    this.record = record\n    this._store = store\n    this.ref = ref\n  }\n\n  tags() {\n    return this._get_tags()\n  }\n\n  id() {\n    return this.record.id()\n  }\n\n  _get(field) {\n    const methodName = `_get_${field}`\n    if (this[methodName]) {return this[methodName]()}\n    else {return this.record.get(field)}\n  }\n  get(field) {\n    const methodName = `_get_${field.toLowerCase()}`\n    if (this[methodName]) {return this[methodName]()}\n    else {return this.record.get(field)}\n  }\n\n  getCaseSensitive(field) {\n    const methodName = `_get_${field}`\n    if (this[methodName]) {return this[methodName]()}\n    else {return this.record._get(field)}\n  }\n\n  parent() {}\n\n  children() {}\n\n  pairedFeature() {\n    return false\n  }\n}\n\ndefine([\n  'dojo/_base/declare',\n  'JBrowse/Util',\n  'JBrowse/Errors',\n  'JBrowse/Store/SeqFeature',\n  'JBrowse/Store/DeferredStatsMixin',\n  'JBrowse/Store/DeferredFeaturesMixin',\n  'JBrowse/Store/SeqFeature/IndexedStatsEstimationMixin',\n  'JBrowse/Store/SeqFeature/_PairCache',\n  'JBrowse/Store/SeqFeature/_SpanCache',\n  'JBrowse/Store/SeqFeature/_InsertSizeCache',\n  'JBrowse/Model/XHRBlob',\n  'JBrowse/Model/SimpleFeature',\n], function (\n  declare,\n  Util,\n  Errors,\n  SeqFeatureStore,\n  DeferredStatsMixin,\n  DeferredFeaturesMixin,\n  IndexedStatsEstimationMixin,\n  PairCache,\n  SpanCache,\n  InsertSizeCache,\n  XHRBlob,\n  SimpleFeature,\n) {\n  return declare(\n    [\n      SeqFeatureStore,\n      DeferredStatsMixin,\n      DeferredFeaturesMixin,\n      IndexedStatsEstimationMixin,\n    ],\n    {\n      constructor(args) {\n        let dataBlob\n        if (args.bam) {dataBlob = new BlobFilehandleWrapper(args.bam)}\n        else if (args.urlTemplate)\n          {dataBlob = new BlobFilehandleWrapper(\n            new XHRBlob(this.resolveUrl(args.urlTemplate || 'data.bam'), {\n              expectRanges: true,\n            }),\n          )}\n        else {throw new Error('must provide either `bam` or `urlTemplate`')}\n\n        let baiBlob, csiBlob\n        if (args.bai) {baiBlob = new BlobFilehandleWrapper(args.bai)}\n        else if (args.csi) {csiBlob = new BlobFilehandleWrapper(args.csi)}\n        else if (args.baiUrlTemplate)\n          {baiBlob = new BlobFilehandleWrapper(\n            new XHRBlob(this.resolveUrl(args.baiUrlTemplate)),\n          )}\n        else if (args.csiUrlTemplate)\n          {csiBlob = new BlobFilehandleWrapper(\n            new XHRBlob(this.resolveUrl(args.csiUrlTemplate)),\n          )}\n        else if (args.urlTemplate)\n          {baiBlob = new BlobFilehandleWrapper(\n            new XHRBlob(this.resolveUrl(args.urlTemplate + '.bai')),\n          )}\n        else\n          {throw new Error('no index provided, must provide a BAI or CSI index')}\n\n        this.source = dataBlob.toString()\n\n        // LRU-cache the BAM object so we don't have to re-download the\n        // index when we switch chromosomes\n        const cacheKey = `data: ${dataBlob}, index: ${csiBlob || baiBlob}`\n        this.bam = bamIndexedFilesCache.get(cacheKey)\n        if (!this.bam) {\n          this.bam = new BamFile({\n            bamFilehandle: dataBlob,\n            baiFilehandle: baiBlob,\n            csiFilehandle: csiBlob,\n            renameRefSeqs: n => this.browser.regularizeReferenceName(n),\n            fetchSizeLimit: args.fetchSizeLimit || 100000000,\n            chunkSizeLimit: args.chunkSizeLimit || 20000000,\n          })\n\n          bamIndexedFilesCache.set(cacheKey, this.bam)\n        }\n\n        // pre-download the index before running the statistics estimation so that the stats\n        // estimation doesn't time out\n        this.bam\n          .hasRefSeq(0)\n          .then(() => this.bam.getHeader())\n          .then(header => this._setSamHeader(header))\n          .then(res => {\n            this._deferred.features.resolve({ success: true })\n          })\n          .then(() => this._estimateGlobalStats())\n          .then(stats => {\n            this.globalStats = stats\n            this._deferred.stats.resolve({ success: true })\n          })\n          .catch(err => {\n            this._deferred.features.reject(err)\n            this._deferred.stats.reject(err)\n          })\n\n        this.insertSizeCache = new InsertSizeCache(args)\n        this.pairCache = new PairCache(args)\n        this.spanCache = new SpanCache(args)\n      },\n\n      _getRefSeqStore() {\n        return new Promise((resolve, reject) => {\n          this.browser.getStore('refseqs', resolve, reject)\n        })\n      },\n\n      // used by the CRAM backend to fetch a region of the underlying reference\n      // sequence.  needed for some of its calculations\n      async seqFetch(refName, start, end) {\n        const refSeqStore = await this._getRefSeqStore()\n        if (!refSeqStore) {return undefined}\n\n        const seqChunks = await new Promise((resolve, reject) => {\n          let features = []\n          refSeqStore.getFeatures(\n            { ref: refName, start: start - 1, end },\n            f => features.push(f),\n            () => resolve(features),\n            reject,\n          )\n        })\n\n        const trimmed = []\n        seqChunks\n          .sort((a, b) => a.get('start') - b.get('start'))\n          .forEach((chunk, i) => {\n            let chunkStart = chunk.get('start')\n            let chunkEnd = chunk.get('end')\n            let trimStart = Math.max(start - chunkStart, 0)\n            let trimEnd = Math.min(end - chunkStart, chunkEnd - chunkStart)\n            let trimLength = trimEnd - trimStart\n            let chunkSeq = chunk.get('seq') || chunk.get('residues')\n            trimmed.push(chunkSeq.substr(trimStart, trimLength))\n          })\n\n        const sequence = trimmed.join('')\n        if (sequence.length !== end - start)\n          {throw new Error(\n            `sequence fetch failed: fetching ${(\n              start - 1\n            ).toLocaleString()}-${end.toLocaleString()} only returned ${sequence.length.toLocaleString()} bases, but should have returned ${(\n              end - start\n            ).toLocaleString()}`,\n          )}\n        return sequence\n      },\n\n      // process the parsed SAM header from the bam file\n      _setSamHeader(samHeader) {\n        this._samHeader = {}\n\n        // use the @SQ lines in the header to figure out the\n        // mapping between ref seq ID numbers and names\n        const refSeqIdToName = []\n        const refSeqNameToId = {}\n        const sqLines = samHeader.filter(l => l.tag === 'SQ')\n        sqLines.forEach((sqLine, seqId) => {\n          sqLine.data.forEach(item => {\n            if (item.tag === 'SN') {\n              // this is the seq name\n              const seqName = item.value\n              refSeqNameToId[seqName] = seqId\n              refSeqIdToName[seqId] = seqName\n            }\n          })\n        })\n        if (refSeqIdToName.length) {\n          this._samHeader.refSeqIdToName = refSeqIdToName\n          this._samHeader.refSeqNameToId = refSeqNameToId\n        }\n      },\n\n      _refNameToId(refName) {\n        // use info from the SAM header if possible, but fall back to using\n        // the ref seq order from when the browser's refseqs were loaded\n        if (this._samHeader.refSeqNameToId)\n          {return this._samHeader.refSeqNameToId[refName]}\n        else {return this.browser.getRefSeqNumber(refName)}\n      },\n\n      _refIdToName(refId) {\n        // use info from the SAM header if possible, but fall back to using\n        // the ref seq order from when the browser's refseqs were loaded\n        if (this._samHeader.refSeqIdToName) {\n          return this._samHeader.refSeqIdToName[refId]\n        } else {\n          let ref = this.browser.getRefSeqById(refId)\n          return ref ? ref.name : undefined\n        }\n      },\n\n      /**\n       * Interrogate whether a store has data for a given reference\n       * sequence.  Calls the given callback with either true or false.\n       */\n      hasRefSeq(seqName, callback, errorCallback) {\n        seqName = this.browser.regularizeReferenceName(seqName)\n\n        this._deferred.stats\n          .then(() => this.bam.hasRefSeq(this._refNameToId(seqName)))\n          .then(callback, errorCallback)\n      },\n\n      // called by getFeatures from the DeferredFeaturesMixin\n      _getFeatures(query, featCallback, endCallback, errorCallback) {\n        let seqName = query.ref || this.refSeq.name\n        seqName = this.browser.regularizeReferenceName(seqName)\n        const pairCache = {}\n        query.maxInsertSize = query.maxInsertSize || 50000\n\n        this.bam\n          .getRecordsForRange(seqName, query.start, query.end, {\n            viewAsPairs: query.viewAsPairs,\n            viewAsSpans: query.viewAsSpans,\n            maxInsertSize: query.maxInsertSize,\n          })\n          .then(async records => {\n            if (query.viewAsPairs) {\n              let recs = []\n              for (const record of records) {\n                recs.push(await this._bamRecordToFeature(record, seqName))\n              }\n              recs.forEach(r => this.insertSizeCache.insertFeat(r))\n              this.pairCache.pairFeatures(\n                query,\n                recs,\n                featCallback,\n                endCallback,\n                errorCallback,\n              )\n            } else if (query.viewAsSpans) {\n              let recs = []\n              for (const record of records) {\n                recs.push(await this._bamRecordToFeature(record, seqName))\n              }\n              recs.forEach(r => this.insertSizeCache.insertFeat(r))\n              this.spanCache.pairFeatures(\n                query,\n                recs,\n                featCallback,\n                endCallback,\n                errorCallback,\n              )\n            } else {\n              let recs = []\n              for (const record of records) {\n                recs.push(await this._bamRecordToFeature(record, seqName))\n              }\n              for (let i = 0; i < recs.length; i++) {\n                this.insertSizeCache.insertFeat(recs[i])\n                featCallback(recs[i])\n              }\n            }\n            endCallback()\n          })\n          .catch(errorCallback)\n      },\n\n      getInsertSizeStats() {\n        return this.insertSizeCache.getInsertSizeStats()\n      },\n\n      cleanFeatureCache(query) {\n        this.pairCache.cleanFeatureCache(query)\n        this.spanCache.cleanFeatureCache(query)\n      },\n\n      cleanStatsCache() {\n        this.insertSizeCache.cleanStatsCache()\n      },\n      async _bamRecordToFeature(record, refName) {\n        let ref\n        if (!record.get('md')) {\n          ref = await this.seqFetch(\n            refName,\n            record.get('start'),\n            record.get('end'),\n          )\n        }\n        return new BamSlightlyLazyFeature(record, this, ref)\n      },\n\n      saveStore() {\n        return {\n          urlTemplate: this.config.bam.url,\n          baiUrlTemplate: (this.config.bai || {}).url,\n          csiUrlTemplate: (this.config.csi || {}).url,\n        }\n      },\n    },\n  )\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/BAMCombination.js":{"size":1454,"mtime":1738905961795,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/BAMCombination.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/BED.js":{"size":6149,"mtime":1738905961804,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/BED.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'dojo/_base/lang',\n  'dojo/_base/array',\n  'dojo/Deferred',\n  'JBrowse/Model/SimpleFeature',\n  'JBrowse/Store/SeqFeature',\n  'JBrowse/Store/DeferredFeaturesMixin',\n  'JBrowse/Store/DeferredStatsMixin',\n  'JBrowse/Store/SeqFeature/GlobalStatsEstimationMixin',\n  'JBrowse/Store/SeqFeature/RegionStatsMixin',\n  'JBrowse/Model/XHRBlob',\n  './BED/Parser',\n], function (\n  declare,\n  lang,\n  array,\n  Deferred,\n  SimpleFeature,\n  SeqFeatureStore,\n  DeferredFeatures,\n  DeferredStats,\n  GlobalStatsEstimationMixin,\n  RegionStatsMixin,\n  XHRBlob,\n  Parser,\n) {\n  return declare(\n    [\n      SeqFeatureStore,\n      DeferredFeatures,\n      DeferredStats,\n      GlobalStatsEstimationMixin,\n      RegionStatsMixin,\n    ],\n\n    /**\n     * @lends JBrowse.Store.SeqFeature.BED\n     */\n    {\n      constructor: function (args) {\n        this.data =\n          args.blob ||\n          new XHRBlob(this.resolveUrl(this._evalConf(args.urlTemplate)))\n        this.features = []\n        this._loadFeatures()\n      },\n\n      _loadFeatures: function () {\n        var thisB = this\n        var features = (this.bareFeatures = [])\n\n        var featuresSorted = true\n        var seenRefs = (this.refSeqs = {})\n        var parser = new Parser({\n          featureCallback: function (fs) {\n            array.forEach(fs, function (feature) {\n              var prevFeature = features[features.length - 1]\n              var regRefName = thisB.browser.regularizeReferenceName(\n                feature.seq_id,\n              )\n              if (\n                regRefName in seenRefs &&\n                prevFeature &&\n                prevFeature.seq_id != feature.seq_id\n              )\n                {featuresSorted = false}\n              if (\n                prevFeature &&\n                prevFeature.seq_id == feature.seq_id &&\n                feature.start < prevFeature.start\n              )\n                {featuresSorted = false}\n\n              if (!(regRefName in seenRefs))\n                {seenRefs[regRefName] = features.length}\n\n              if (thisB.config.featureCallback) {\n                features.push(thisB.config.featureCallback(feature, thisB))\n              } else {\n                features.push(feature)\n              }\n            })\n          },\n          endCallback: function () {\n            if (!featuresSorted) {\n              features.sort(thisB._compareFeatureData)\n              // need to rebuild the refseq index if changing the sort order\n              thisB._rebuildRefSeqs(features)\n            }\n\n            thisB._estimateGlobalStats().then(function (stats) {\n              thisB.globalStats = stats\n              thisB._deferred.stats.resolve()\n            })\n\n            thisB._deferred.features.resolve(features)\n          },\n          commentCallback: this.config.commentCallback || function (i) {},\n          store: this,\n        })\n\n        var fail = lang.hitch(this, '_failAllDeferred')\n        // parse the whole file and store it\n        this.data.fetchLines(\n          function (line) {\n            try {\n              parser.addLine(line)\n            } catch (e) {\n              fail('Error parsing BED.')\n              throw e\n            }\n          },\n          lang.hitch(parser, 'finish'),\n          fail,\n        )\n      },\n\n      _rebuildRefSeqs: function (features) {\n        var refs = {}\n        for (var i = 0; i < features.length; i++) {\n          var regRefName = this.browser.regularizeReferenceName(\n            features[i].seq_id,\n          )\n\n          if (!(regRefName in refs)) {refs[regRefName] = i}\n        }\n        this.refSeqs = refs\n      },\n\n      _compareFeatureData: function (a, b) {\n        if (a.seq_id < b.seq_id) {return -1}\n        else if (a.seq_id > b.seq_id) {return 1}\n\n        return a.start - b.start\n      },\n\n      _getFeatures: function (\n        query,\n        featureCallback,\n        finishedCallback,\n        errorCallback,\n      ) {\n        var thisB = this\n        thisB._deferred.features.then(function () {\n          thisB._search(query, featureCallback, finishedCallback, errorCallback)\n        })\n      },\n\n      _search: function (\n        query,\n        featureCallback,\n        finishCallback,\n        errorCallback,\n      ) {\n        // search in this.features, which are sorted\n        // by ref and start coordinate, to find the beginning of the\n        // relevant range\n        var bare = this.bareFeatures\n        var converted = this.features\n\n        var refName = this.browser.regularizeReferenceName(query.ref)\n\n        var i = this.refSeqs[refName]\n        if (!(i >= 0)) {\n          finishCallback()\n          return\n        }\n\n        var checkEnd =\n          'start' in query\n            ? function (f) {\n                return f.get('end') >= query.start\n              }\n            : function () {\n                return true\n              }\n\n        for (; i < bare.length; i++) {\n          // lazily convert the bare feature data to JBrowse features\n          var f =\n            converted[i] ||\n            (converted[i] = function (b, i) {\n              bare[i] = false\n              return this._formatFeature(b, i)\n            }.call(this, bare[i], i))\n          // features are sorted by ref seq and start coord, so we\n          // can stop if we are past the ref seq or the end of the\n          // query region\n          if (f._reg_seq_id != refName || f.get('start') > query.end) {break}\n\n          if (checkEnd(f)) {\n            this.applyFeatureTransforms([f]).forEach(featureCallback)\n          }\n        }\n\n        finishCallback()\n      },\n\n      supportsFeatureTransforms: true,\n\n      _formatFeature: function (data, i) {\n        var f = new SimpleFeature({\n          data: data,\n          id:\n            data.seq_id +\n            '_' +\n            data.start +\n            '_' +\n            data.end +\n            '_' +\n            data.name +\n            '_' +\n            i,\n        })\n        f._reg_seq_id = this.browser.regularizeReferenceName(data.seq_id)\n        return f\n      },\n\n      saveStore: function () {\n        return {\n          urlTemplate: this.config.blob.url,\n        }\n      },\n    },\n  )\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/BED/Parser.js":{"size":4071,"mtime":1738905961812,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/BED/Parser.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"/* The function to parse the bed files. The standard BED file format (BED-6) is \"chr\\tstart(0based)\\tEnd(1based)\\tname\\tscore\\tstrand\n\nBED-3 is the minimal parsed line by this parser (i.e. includes only first three fields)\nOptional header lines start with '#'\n*/\ndefine([\n  'dojo/_base/declare',\n  'dojo/_base/array',\n  'dojo/_base/lang',\n  'JBrowse/Util/TextIterator',\n], function (declare, array, lang, TextIterator) {\n  var bed_feature_names = 'seq_id start end name score strand'.split(' ')\n\n  return declare(null, {\n    constructor: function (args) {\n      lang.mixin(this, {\n        featureCallback: args.featureCallback || function () {},\n        endCallback: args.endCallback || function () {},\n        commentCallback: args.commentCallback || function () {},\n        errorCallback:\n          args.errorCallback ||\n          function (e) {\n            console.error(e)\n          },\n        store: args.store,\n        // if this is true, the parser ignores the\n        // rest of the lines in the file.  currently\n        // set when the file switches over to FASTA\n        eof: false,\n      })\n    },\n\n    /**\n     * Parse the bytes that contain the BED header, storing the parsed\n     * data in this.header.\n     */\n    parseHeader: function (headerBytes) {\n      // parse the header lines\n      var headData = {}\n      var lineIterator = new TextIterator.FromBytes({\n        bytes: headerBytes,\n      })\n      var line\n      while ((line = lineIterator.getline())) {\n        // only interested in meta and header lines\n        if (line[0] != '#') {continue}\n\n        // parse meta line using the parseHeader configuration callback function\n        var metaData = (this.config.parseHeader || function () {})(line)\n        var key = metaData.key\n        headData[key] = metaData.value\n      }\n\n      this.header = headData\n      return headData\n    },\n    finish: function () {\n      this.endCallback()\n    },\n    addLine: function (line) {\n      var match\n      if (this.eof) {\n        // do nothing\n      } else if (/^\\s*[^#\\s>]/.test(line)) {\n        //< feature line, most common case\n        line = line.replace(/\\r?\\n?$/g, '')\n        var f = this.parse_feature(line)\n        this.featureCallback(this._return_item([f]))\n      }\n      // directive or comment\n      else if ((match = /^\\s*(\\#+)(.*)/.exec(line))) {\n        var hashsigns = match[1],\n          contents = match[2]\n        contents = contents.replace(/\\s*/, '')\n        this._return_item({ comment: contents })\n      } else if (/^\\s*$/.test(line)) {\n        // blank line, do nothing\n      } else if (/^\\s*>/.test(line)) {\n        // implicit beginning of a FASTA section.  just stop\n        // parsing, since we don't currently handle sequences\n        this._return_all_under_construction_features()\n        this.eof = true\n      } else {\n        // it's a parse error\n        line = line.replace(/\\r?\\n?$/g, '')\n        throw \"GFF3 parse error.  Cannot parse '\" + line + \"'.\"\n      }\n    },\n\n    unescape(s) {\n      if (s === null) {return null}\n\n      return s.replace(/%([0-9A-Fa-f]{2})/g, function (match, seq) {\n        return String.fromCharCode(parseInt(seq, 16))\n      })\n    },\n\n    parse_feature: function (line) {\n      var f = array.map(line.split('\\t'), function (a) {\n        if (a == '.') {\n          return null\n        }\n        return a\n      })\n\n      // unescape only the ref and source columns\n      f[0] = this.unescape(f[0])\n\n      var parsed = {}\n      for (var i = 0; i < bed_feature_names.length; i++) {\n        if (f[i]) {\n          parsed[bed_feature_names[i]] = f[i] == '.' ? null : f[i]\n        }\n      }\n      if (parsed.start !== null) {parsed.start = parseInt(parsed.start, 10)}\n      if (parsed.end !== null) {parsed.end = parseInt(parsed.end, 10)}\n      if (parsed.score != null) {parsed.score = parseFloat(parsed.score, 10)}\n\n      parsed.strand = { '+': 1, '-': -1 }[parsed.strand] || 0\n\n      return parsed\n    },\n\n    _return_item: function (i) {\n      if (i[0]) {this.featureCallback(i)}\n      else if (i.comment) {this.commentCallback(i, this.store)}\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/BEDTabix.js":{"size":6571,"mtime":1738905961824,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/BEDTabix.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"const { TabixIndexedFile } = cjsRequire('@gmod/tabix')\n\ndefine([\n  'dojo/_base/declare',\n  'dojo/_base/lang',\n  'JBrowse/Errors',\n  'JBrowse/Store/SeqFeature',\n  'JBrowse/Store/DeferredStatsMixin',\n  'JBrowse/Store/DeferredFeaturesMixin',\n  'JBrowse/Store/SeqFeature/IndexedStatsEstimationMixin',\n  'JBrowse/Store/SeqFeature/RegionStatsMixin',\n  'JBrowse/Model/BlobFilehandleWrapper',\n  'JBrowse/Model/XHRBlob',\n  'JBrowse/Model/SimpleFeature',\n  './BED/Parser',\n], function (\n  declare,\n  lang,\n  Errors,\n  SeqFeatureStore,\n  DeferredStatsMixin,\n  DeferredFeaturesMixin,\n  IndexedStatsEstimationMixin,\n  RegionStatsMixin,\n  BlobFilehandleWrapper,\n  XHRBlob,\n  SimpleFeature,\n  Parser,\n) {\n  return declare(\n    [\n      SeqFeatureStore,\n      DeferredStatsMixin,\n      DeferredFeaturesMixin,\n      IndexedStatsEstimationMixin,\n      RegionStatsMixin,\n    ],\n    {\n      constructor: function (args) {\n        var thisB = this\n        var csiBlob, tbiBlob\n\n        if (args.csi || this.config.csiUrlTemplate) {\n          csiBlob =\n            args.csi ||\n            new XHRBlob(this.resolveUrl(this.getConf('csiUrlTemplate', [])))\n        } else {\n          tbiBlob =\n            args.tbi ||\n            new XHRBlob(\n              this.resolveUrl(\n                this.getConf('tbiUrlTemplate', []) ||\n                  this.getConf('urlTemplate', []) + '.tbi',\n              ),\n            )\n        }\n\n        var fileBlob =\n          args.file ||\n          new XHRBlob(this.resolveUrl(this.getConf('urlTemplate', [])), {\n            expectRanges: true,\n          })\n\n        this.indexedData = new TabixIndexedFile({\n          filehandle: new BlobFilehandleWrapper(fileBlob),\n          tbiFilehandle: tbiBlob && new BlobFilehandleWrapper(tbiBlob),\n          csiFilehandle: csiBlob && new BlobFilehandleWrapper(csiBlob),\n          chunkSizeLimit: args.chunkSizeLimit || 1000000,\n          renameRefSeqs: n => this.browser.regularizeReferenceName(n),\n        })\n\n        this.parser = new Parser({\n          commentCallback: this.config.commentCallback || function (i) {},\n          store: this,\n        })\n\n        this.getHeader().then(\n          function (header) {\n            thisB._deferred.features.resolve({ success: true })\n            thisB._estimateGlobalStats().then(\n              function (stats) {\n                thisB.globalStats = stats\n                thisB._deferred.stats.resolve(stats)\n              },\n              lang.hitch(thisB, '_failAllDeferred'),\n            )\n          },\n          lang.hitch(thisB, '_failAllDeferred'),\n        )\n      },\n\n      /**fetch and parse the Header line */\n      getHeader: function () {\n        if (!this._parsedHeader) {\n          this._parsedHeader = this.indexedData\n            .lineCount('nonexistent')\n            .then(() => this.indexedData.getHeader())\n            .then(bytes => this.parser.parseHeader(bytes))\n        }\n        return this._parsedHeader\n      },\n\n      _getFeatures: function (\n        query,\n        featureCallback,\n        finishCallback,\n        errorCallback,\n      ) {\n        this.getHeader().then(() => {\n          this.indexedData\n            .getMetadata()\n            .then(metadata => {\n              const regularizedReferenceName =\n                this.browser.regularizeReferenceName(query.ref)\n              return this.indexedData.getLines(\n                regularizedReferenceName || this.refSeq.name,\n                query.start,\n                query.end,\n                line => {\n                  this.applyFeatureTransforms([\n                    this.lineToFeature(metadata.columnNumbers, line),\n                  ]).forEach(f => {\n                    if (this.config.featureCallback)\n                      {f = this.config.featureCallback(f)}\n                    featureCallback(f)\n                  })\n                },\n              )\n            })\n            .then(finishCallback, error => {\n              if (errorCallback) {\n                if (\n                  error.message &&\n                  error.message.indexOf('Too much data') >= 0\n                ) {\n                  error = new Errors.DataOverflow(error.message)\n                }\n                errorCallback(error)\n              } else {console.error(error)}\n            })\n        }, errorCallback)\n      },\n\n      supportsFeatureTransforms: true,\n\n      _featureData: function (data) {\n        var f = lang.mixin({}, data)\n        for (var a in data.matrix) {\n          f[a.toLowerCase()] = data.attributes[a].join(',')\n        }\n\n        return f\n      },\n      _formatFeature: function (data) {\n        var f = new SimpleFeature({\n          data: this._featureData(data),\n          id: data.seq_id + '_' + data.start + '_' + data.end + '_' + data.name,\n        })\n        f._reg_seq_id = this.browser.regularizeReferenceName(data.seq_id)\n        return f\n      },\n      //read the line\n      lineToFeature: function (columnNumbers, line) {\n        const fields = line.split('\\t')\n\n        for (var i = 0; i < fields.length; i++) {\n          if (fields[i] == '.') {\n            fields[i] = null\n          }\n        }\n\n        var featureData = {\n          start: parseInt(fields[columnNumbers.start - 1]),\n          end: parseInt(fields[columnNumbers.end - 1]),\n          seq_id: fields[columnNumbers.ref - 1],\n          name: fields[3],\n          score: fields[4] || null,\n          strand: { '+': 1, '-': -1 }[fields[5]] || 0,\n          thick_start: fields[6],\n          thick_end: fields[7],\n          itemrgb: fields[8],\n          block_count: fields[9],\n          block_sizes: fields[10],\n          chrom_starts: fields[11],\n        }\n\n        var f = new SimpleFeature({\n          id: fields.slice(0, 5).join('/'),\n          data: featureData,\n          fields: fields,\n        })\n\n        return f\n      },\n\n      /**\n       * Interrogate whether a store has data for a given reference\n       * sequence.  Calls the given callback with either true or false.\n       *\n       * Implemented as a binary interrogation because some stores are\n       * smart enough to regularize reference sequence names, while\n       * others are not.\n       */\n      hasRefSeq: function (seqName, callback, errorCallback) {\n        return this.indexedData.index.hasRefSeq(\n          seqName,\n          callback,\n          errorCallback,\n        )\n      },\n\n      saveStore: function () {\n        return {\n          urlTemplate: this.config.file.url,\n          tbiUrlTemplate: (this.config.tbi || {}).url,\n          csiUrlTemplate: (this.config.csi || {}).url,\n        }\n      },\n    },\n  )\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/BgzipIndexedFasta.js":{"size":2963,"mtime":1738905961830,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/BgzipIndexedFasta.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"const LRU = cjsRequire('quick-lru')\nconst { BgzipIndexedFasta } = cjsRequire('@gmod/indexedfasta')\nconst { Buffer } = cjsRequire('buffer')\n\nconst fastaIndexedFilesCache = new LRU({ maxSize: 5 })\n\nconst BlobFilehandleWrapper = cjsRequire('../../Model/BlobFilehandleWrapper')\n\ndefine([\n  'dojo/_base/declare',\n  'dojo/_base/lang',\n  'JBrowse/Model/XHRBlob',\n  'JBrowse/Store/SeqFeature/IndexedFasta',\n], function (declare, lang, XHRBlob, IndexedFasta) {\n  return declare(IndexedFasta, {\n    /**\n     * Storage backend for sequences in indexed fasta files\n     * served as static text files.\n     * @constructs\n     */\n    constructor: function (args) {\n      let dataBlob\n      if (args.bgzfa) {dataBlob = new BlobFilehandleWrapper(args.bgzfa)}\n      else if (args.urlTemplate)\n        {dataBlob = new BlobFilehandleWrapper(\n          new XHRBlob(this.resolveUrl(args.urlTemplate), {\n            expectRanges: true,\n          }),\n        )}\n      else\n        {dataBlob = new BlobFilehandleWrapper(\n          new XHRBlob('data.fa', { expectRanges: true }),\n        )}\n\n      let indexBlob\n      if (args.fai) {indexBlob = new BlobFilehandleWrapper(args.fai)}\n      else if (args.faiUrlTemplate)\n        {indexBlob = new BlobFilehandleWrapper(\n          new XHRBlob(this.resolveUrl(args.faiUrlTemplate)),\n        )}\n      else if (args.urlTemplate)\n        {indexBlob = new BlobFilehandleWrapper(\n          new XHRBlob(this.resolveUrl(args.urlTemplate + '.fai')),\n        )}\n      else {throw new Error('no index provided, must provide a FASTA index')}\n\n      let gziBlob\n      if (args.gzi) {gziBlob = new BlobFilehandleWrapper(args.gzi)}\n      else if (args.gziUrlTemplate)\n        {gziBlob = new BlobFilehandleWrapper(\n          new XHRBlob(this.resolveUrl(args.gziUrlTemplate)),\n        )}\n      else if (args.urlTemplate)\n        {gziBlob = new BlobFilehandleWrapper(\n          new XHRBlob(this.resolveUrl(args.urlTemplate + '.gzi')),\n        )}\n      else {throw new Error('no gzi index provided, must provide a GZI index')}\n\n      this.source = dataBlob.toString()\n\n      // LRU-cache the CRAM object so we don't have to re-download the\n      // index when we switch chromosomes\n      const cacheKey = `data: ${dataBlob}, index: ${indexBlob}, gzi: ${gziBlob}`\n      this.fasta = fastaIndexedFilesCache.get(cacheKey)\n      if (!this.fasta) {\n        this.fasta = new BgzipIndexedFasta({\n          fasta: dataBlob,\n          fai: indexBlob,\n          gzi: gziBlob,\n          chunkSizeLimit: args.chunkSizeLimit || 1000000,\n        })\n\n        fastaIndexedFilesCache.set(cacheKey, this.fasta)\n      }\n      this.fasta.getSequenceList().then(\n        () => this._deferred.features.resolve({ success: true }),\n        () => this._failAllDeferred(),\n      )\n    },\n    saveStore: function () {\n      return {\n        urlTemplate: (this.config.file || this.config.blob).url,\n        faiUrlTemplate: this.config.fai.url,\n        gziUrlTemplate: this.config.gzi.url,\n      }\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/BigBed.js":{"size":1294,"mtime":1738905961834,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/BigBed.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/BigWig.js":{"size":14958,"mtime":1738905961852,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/BigWig.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'dojo/_base/lang',\n  'dojo/_base/array',\n  'dojo/_base/url',\n  'JBrowse/Model/DataView',\n  'JBrowse/has',\n  'JBrowse/Errors',\n  'JBrowse/Store/SeqFeature',\n  'JBrowse/Store/DeferredStatsMixin',\n  'JBrowse/Store/DeferredFeaturesMixin',\n  './BigWig/Window',\n  'JBrowse/Util',\n  'JBrowse/Model/XHRBlob',\n], function (\n  declare,\n  lang,\n  array,\n  urlObj,\n  jDataView,\n  has,\n  JBrowseErrors,\n  SeqFeatureStore,\n  DeferredFeaturesMixin,\n  DeferredStatsMixin,\n  Window,\n  Util,\n  XHRBlob,\n) {\n  return declare(\n    [SeqFeatureStore, DeferredFeaturesMixin, DeferredStatsMixin],\n\n    /**\n     * @lends JBrowse.Store.SeqFeature.BigWig\n     */\n    {\n      BIG_WIG_MAGIC: -2003829722,\n      BIG_BED_MAGIC: -2021002517,\n\n      BIG_WIG_TYPE_GRAPH: 1,\n      BIG_WIG_TYPE_VSTEP: 2,\n      BIG_WIG_TYPE_FSTEP: 3,\n\n      _littleEndian: true,\n\n      /**\n       * Data backend for reading wiggle data from BigWig or BigBed files.\n       *\n       * Adapted by Robert Buels from bigwig.js in the Dalliance Genome\n       * Explorer which is copyright Thomas Down 2006-2010\n       * @constructs\n       */\n      constructor: function (args) {\n        this.data =\n          args.blob ||\n          new XHRBlob(this.resolveUrl(args.urlTemplate || 'data.bigwig'), {\n            expectRanges: true,\n          })\n\n        this.name =\n          args.name ||\n          (this.data.url &&\n            new urlObj(this.data.url).path.replace(/^.+\\//, '')) ||\n          'anonymous'\n\n        this._load()\n      },\n\n      _defaultConfig: function () {\n        return Util.deepUpdate(dojo.clone(this.inherited(arguments)), {\n          chunkSizeLimit: 30000000, // 30mb\n        })\n      },\n\n      _getGlobalStats: function (successCallback, errorCallback) {\n        var s = this._globalStats || {}\n\n        // calc mean and standard deviation if necessary\n        if (!('scoreMean' in s))\n          {s.scoreMean = s.basesCovered ? s.scoreSum / s.basesCovered : 0}\n        if (!('scoreStdDev' in s))\n          {s.scoreStdDev = this._calcStdFromSums(\n            s.scoreSum,\n            s.scoreSumSquares,\n            s.basesCovered,\n          )}\n\n        successCallback(s)\n      },\n\n      /**\n       * Read from the bbi file, respecting the configured chunkSizeLimit.\n       */\n      _read: function (start, size, callback, errorcallback) {\n        if (size > this.config.chunkSizeLimit)\n          {errorcallback(\n            new JBrowseErrors.DataOverflow(\n              'Too much data. Chunk size ' +\n                Util.commifyNumber(size) +\n                ' bytes exceeds chunkSizeLimit of ' +\n                Util.commifyNumber(this.config.chunkSizeLimit) +\n                '.',\n            ),\n          )}\n        else {this.data.read.apply(this.data, arguments)}\n      },\n\n      _load: function (headerLen = 2000) {\n        this._read(\n          0,\n          headerLen,\n          async bytes => {\n            try {\n              const res = await this.data.statPromise()\n              if (!bytes) {\n                this._failAllDeferred('BBI header not readable')\n                return\n              }\n\n              var data = this.newDataView(bytes)\n\n              // check magic numbers\n              var magic = data.getInt32()\n              if (magic != this.BIG_WIG_MAGIC && magic != this.BIG_BED_MAGIC) {\n                // try the other endianness if no magic\n                this._littleEndian = false\n                data = this.newDataView(bytes)\n                if (\n                  data.getInt32() != this.BIG_WIG_MAGIC &&\n                  magic != this.BIG_BED_MAGIC\n                ) {\n                  console.error('Not a BigWig or BigBed file')\n                  this._failAllDeferred('Not a BigWig or BigBed file')\n                  return\n                }\n              }\n              this.type = magic == this.BIG_BED_MAGIC ? 'bigbed' : 'bigwig'\n\n              this.fileSize = (res || {}).size\n              if (!this.fileSize)\n                {console.warn(\n                  'cannot get size of BigWig/BigBed file, widest zoom level not available',\n                )}\n\n              this.version = data.getUint16()\n              this.numZoomLevels = data.getUint16()\n              this.chromTreeOffset = data.getUint64()\n              this.unzoomedDataOffset = data.getUint64()\n              this.unzoomedIndexOffset = data.getUint64()\n              this.fieldCount = data.getUint16()\n              this.definedFieldCount = data.getUint16()\n              this.asOffset = data.getUint64()\n              this.totalSummaryOffset = data.getUint64()\n              this.uncompressBufSize = data.getUint32()\n              if (\n                this.asOffset > headerLen ||\n                this.totalSummaryOffset > headerLen\n              ) {\n                return this._load(headerLen * 2)\n              }\n\n              // dlog('bigType: ' + this.type);\n              // dlog('chromTree at: ' + this.chromTreeOffset);\n              // dlog('uncompress: ' + this.uncompressBufSize);\n              // dlog('data at: ' + this.unzoomedDataOffset);\n              // dlog('index at: ' + this.unzoomedIndexOffset);\n              // dlog('field count: ' + this.fieldCount);\n              // dlog('defined count: ' + this.definedFieldCount);\n\n              this.zoomLevels = []\n              for (var zl = 0; zl < this.numZoomLevels; ++zl) {\n                var zlReduction = data.getUint32(4 * (zl * 6 + 16))\n                var zlData = data.getUint64(4 * (zl * 6 + 18))\n                var zlIndex = data.getUint64(4 * (zl * 6 + 20))\n\n                //          dlog('zoom(' + zl + '): reduction=' + zlReduction + '; data=' + zlData + '; index=' + zlIndex);\n                this.zoomLevels.push({\n                  reductionLevel: zlReduction,\n                  dataOffset: zlData,\n                  indexOffset: zlIndex,\n                })\n              }\n\n              // parse the autoSql if present (bigbed)\n              if (this.asOffset) {\n                ;(function () {\n                  var d = this.newDataView(bytes, this.asOffset)\n                  var string = ''\n                  var c\n                  while ((c = d.getChar()) && c.charCodeAt() != 0) {\n                    string += c\n                  }\n                  this.parseAutoSql(string)\n                }).call(this)\n              }\n\n              // parse the totalSummary if present (summary of all data in the file)\n              if (this.totalSummaryOffset) {\n                ;(function () {\n                  var d = this.newDataView(bytes, this.totalSummaryOffset)\n                  var s = {\n                    basesCovered: d.getUint64(),\n                    scoreMin: d.getFloat64(),\n                    scoreMax: d.getFloat64(),\n                    scoreSum: d.getFloat64(),\n                    scoreSumSquares: d.getFloat64(),\n                  }\n                  this._globalStats = s\n                  // rest of stats will be calculated on demand in getGlobalStats\n                }).call(this)\n              } else {\n                console.warn(\n                  'BigWig ' + this.data.url + ' has no total summary data.',\n                )\n              }\n\n              this._readChromTree(\n                function () {\n                  this._deferred.features.resolve({\n                    success: true,\n                  })\n                  this._deferred.stats.resolve({\n                    success: true,\n                  })\n                },\n                lang.hitch(this, '_failAllDeferred'),\n              )\n            } catch (e) {\n              this._failAllDeferred(e)\n            }\n          },\n          lang.hitch(this, '_failAllDeferred'),\n        )\n      },\n\n      newDataView: function (bytes, offset, length) {\n        return new jDataView(bytes, offset, length, this._littleEndian)\n      },\n\n      /**\n       * @private\n       */\n      _readChromTree: function (callback, errorCallback) {\n        var thisB = this\n        this.refsByNumber = {}\n        this.refsByName = {}\n\n        var udo = this.unzoomedDataOffset\n        while (udo % 4 != 0) {\n          ++udo\n        }\n\n        this._read(\n          this.chromTreeOffset,\n          udo - this.chromTreeOffset,\n          function (bpt) {\n            if (!has('typed-arrays')) {\n              thisB._failAllDeferred(\n                'Web browser does not support typed arrays',\n              )\n              return\n            }\n            var data = thisB.newDataView(bpt)\n\n            if (data.getUint32() !== 2026540177)\n              {throw 'parse error: not a Kent bPlusTree'}\n            var blockSize = data.getUint32()\n            var keySize = data.getUint32()\n            var valSize = data.getUint32()\n            var itemCount = data.getUint64()\n            var rootNodeOffset = 32\n\n            //dlog('blockSize=' + blockSize + '    keySize=' + keySize + '   valSize=' + valSize + '    itemCount=' + itemCount);\n\n            var bptReadNode = function (offset) {\n              if (offset >= bpt.length) {throw 'reading beyond end of buffer'}\n              var isLeafNode = data.getUint8(offset)\n              var cnt = data.getUint16(offset + 2)\n              //dlog('ReadNode: ' + offset + '     type=' + isLeafNode + '   count=' + cnt);\n              offset += 4\n              for (var n = 0; n < cnt; ++n) {\n                if (isLeafNode) {\n                  // parse leaf node\n                  var key = ''\n                  for (var ki = 0; ki < keySize; ++ki) {\n                    var charCode = data.getUint8(offset++)\n                    if (charCode != 0) {\n                      key += String.fromCharCode(charCode)\n                    }\n                  }\n                  var refId = data.getUint32(offset)\n                  var refSize = data.getUint32(offset + 4)\n                  offset += 8\n\n                  var refRec = {\n                    name: key,\n                    id: refId,\n                    length: refSize,\n                  }\n\n                  //dlog(key + ':' + refId + ',' + refSize);\n                  thisB.refsByName[thisB.browser.regularizeReferenceName(key)] =\n                    refRec\n                  thisB.refsByNumber[refId] = refRec\n                } else {\n                  // parse index node\n                  offset += keySize\n                  var childOffset = data.getUint64(offset)\n                  offset += 8\n                  childOffset -= thisB.chromTreeOffset\n                  bptReadNode(childOffset)\n                }\n              }\n            }\n            bptReadNode(rootNodeOffset)\n\n            callback.call(thisB, thisB)\n          },\n          errorCallback,\n        )\n      },\n\n      /**\n       * Interrogate whether a store has data for a given reference\n       * sequence.  Calls the given callback with either true or false.\n       *\n       * Implemented as a binary interrogation because some stores are\n       * smart enough to regularize reference sequence names, while\n       * others are not.\n       */\n      hasRefSeq: function (seqName, callback, errorCallback) {\n        var thisB = this\n        seqName = thisB.browser.regularizeReferenceName(seqName)\n        this._deferred.features.then(function () {\n          callback(seqName in thisB.refsByName)\n        }, errorCallback)\n      },\n\n      _getFeatures: function (\n        query,\n        featureCallback,\n        endCallback,\n        errorCallback,\n      ) {\n        var chrName = this.browser.regularizeReferenceName(query.ref)\n        var min = query.start\n        var max = query.end\n\n        var v = query.basesPerSpan\n          ? this.getView(1 / query.basesPerSpan)\n          : query.scale\n            ? this.getView(query.scale)\n            : this.getView(1)\n\n        if (!v) {\n          endCallback()\n          return\n        }\n\n        v.readWigData(\n          chrName,\n          min,\n          max,\n          dojo.hitch(this, function (features) {\n            array.forEach(features || [], featureCallback)\n            endCallback()\n          }),\n          errorCallback,\n        )\n      },\n\n      getUnzoomedView: function () {\n        if (!this.unzoomedView) {\n          var cirLen = 4000\n          var nzl = this.zoomLevels[0]\n          if (nzl) {\n            cirLen = this.zoomLevels[0].dataOffset - this.unzoomedIndexOffset\n          }\n          this.unzoomedView = new Window(\n            this,\n            this.unzoomedIndexOffset,\n            cirLen,\n            false,\n            this.autoSql,\n          )\n        }\n        return this.unzoomedView\n      },\n\n      getView: function (scale) {\n        if (!this.zoomLevels || !this.zoomLevels.length) {return null}\n\n        if (!this._viewCache || this._viewCache.scale != scale) {\n          this._viewCache = {\n            scale: scale,\n            view: this._getView(scale),\n          }\n        }\n        return this._viewCache.view\n      },\n\n      _getView: function (scale) {\n        var basesPerPx = 1 / scale\n        //console.log('getting view for '+basesPerSpan+' bases per span');\n        var maxLevel = this.zoomLevels.length\n        if (!this.fileSize)\n          // if we don't know the file size, we can't fetch the highest zoom level :-(\n          {maxLevel--}\n        for (var i = maxLevel; i >= 0; i--) {\n          var zh = this.zoomLevels[i]\n          if (zh && zh.reductionLevel <= 2 * basesPerPx) {\n            var indexLength =\n              i < this.zoomLevels.length - 1\n                ? this.zoomLevels[i + 1].dataOffset - zh.indexOffset\n                : this.fileSize - 4 - zh.indexOffset\n            //console.log( 'using zoom level '+i);\n            return new Window(this, zh.indexOffset, indexLength, true)\n          }\n        }\n        //console.log( 'using unzoomed level');\n        return this.getUnzoomedView()\n      },\n\n      getTagMetadata(tagName) {\n        if (this.autoSql) {\n          const lcTagName = tagName.replace(/_/g, '').toLowerCase()\n          const fieldDefinition = this.autoSql.fields.find(\n            field => field.name.toLowerCase() === lcTagName,\n          )\n          if (fieldDefinition) {return fieldDefinition}\n        }\n      },\n\n      parseAutoSql: function (string) {\n        string = string.trim()\n        var res = string.split('\\n')\n        this.autoSql = {\n          name: /table\\s+(\\w+)/.exec(res[0])[1],\n          description: /\"(.*)\"/.exec(res[1])[1],\n          fields: [],\n        }\n        var i = 3\n        var field\n        while (res[i].trim() != ')') {\n          if (\n            (field = /([\\w\\[\\]0-9]+)\\s*(\\w+)\\s*;\\s*\"(.*)\"/.exec(res[i].trim()))\n          ) {\n            this.autoSql.fields.push({\n              type: field[1],\n              name: field[2],\n              description: field[3],\n            })\n          } else {\n            console.warn('autosql line not parsed', res[i])\n          }\n          i++\n        }\n      },\n\n      saveStore: function () {\n        return {\n          urlTemplate: this.config.blob.url,\n        }\n      },\n    },\n  )\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/BigWig/RequestWorker.js":{"size":16367,"mtime":1738905961881,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/BigWig/RequestWorker.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"const snakeCase = cjsRequire('snake-case')\n\ndefine([\n  'dojo/_base/declare',\n  'dojo/_base/lang',\n  'dojo/_base/array',\n  'JBrowse/Util',\n  'JBrowse/Util/RejectableFastPromise',\n  'dojo/promise/all',\n  'JBrowse/Model/Range',\n  'JBrowse/Model/SimpleFeature',\n  'JBrowse/Util/jszlib',\n  'JBrowse/Util/arrayCopy',\n], function (\n  declare,\n  dlang,\n  array,\n  Util,\n  RejectableFastPromise,\n  all,\n  Range,\n  SimpleFeature,\n  inflate,\n  arrayCopy,\n) {\n  var dlog = function () {\n    console.log.apply(console, arguments)\n  }\n\n  const defaultAutoSql = {\n    name: 'BigBED file',\n    description: 'this file has no associated autoSQL',\n    fields: [\n      {\n        type: 'string',\n        name: 'chrom',\n        description: 'Name of chromosome ',\n      },\n      {\n        type: 'uint',\n        name: 'chromStart',\n        description: 'Start position (first base is 0).',\n      },\n      {\n        type: 'uint',\n        name: 'chromEnd',\n        description: 'End position plus one (chromEnd – chromStart = size).',\n      },\n      {\n        type: 'string',\n        name: 'name',\n        description: 'Name of feature.',\n      },\n      {\n        type: 'float',\n        name: 'score',\n        description:\n          'A number between 0 and 1000 that controls shading of item (0 if unused).',\n      },\n      {\n        type: 'string',\n        name: 'strand',\n        description: '+ or – (or . for unknown).',\n      },\n      {\n        type: 'uint',\n        name: 'thickStart',\n        description:\n          'Start position where feature is drawn as thicker line; used for CDS start for genes.',\n      },\n      {\n        type: 'uint',\n        name: 'thickEnd',\n        description: 'Position where thicker part of feature ends.',\n      },\n      {\n        type: 'string',\n        name: 'itemRgb',\n        description:\n          'Comma-separated list of red, green, blue values from 0-255 (0 if unused).',\n      },\n      {\n        type: 'uint',\n        name: 'blockCount',\n        description:\n          'For multipart items, the number of blocks; corresponds to exons for genes.',\n      },\n      {\n        type: 'string',\n        name: 'blockSizes',\n        description: 'Comma-separated list of block sizes.',\n      },\n      {\n        type: 'string',\n        name: 'chromStarts',\n        description:\n          'Comma-separated list of block starts relative to chromStart.',\n      },\n    ],\n  }\n\n  var RequestWorker = declare(\n    null,\n    /**\n     * @lends JBrowse.Store.BigWig.Window.RequestWorker.prototype\n     */\n    {\n      BIG_WIG_TYPE_GRAPH: 1,\n      BIG_WIG_TYPE_VSTEP: 2,\n      BIG_WIG_TYPE_FSTEP: 3,\n\n      /**\n       * Worker object for reading data from a bigwig or bigbed file.\n       * Manages the state necessary for traversing the index trees and\n       * so forth.\n       *\n       * Adapted by Robert Buels from bigwig.js in the Dalliance Genome\n       * Explorer by Thomas Down.\n       * @constructs\n       */\n      constructor: function (window, chr, min, max, callback, errorCallback) {\n        this.window = window\n        this.source = window.bwg.name || undefined\n\n        this.blocksToFetch = []\n        this.outstanding = 0\n\n        this.chr = chr\n        this.min = min\n        this.max = max\n        this.callback = callback\n        this.errorCallback =\n          errorCallback ||\n          function (e) {\n            console.error(e, e.stack, arguments.caller)\n          }\n      },\n\n      cirFobRecur: function (offset, level) {\n        this.outstanding += offset.length\n\n        var maxCirBlockSpan = 4 + this.window.cirBlockSize * 32 // Upper bound on size, based on a completely full leaf node.\n        var spans\n        for (var i = 0; i < offset.length; ++i) {\n          var blockSpan = new Range(offset[i], offset[i] + maxCirBlockSpan)\n          spans = spans ? spans.union(blockSpan) : blockSpan\n        }\n\n        var fetchRanges = spans.ranges()\n        //dlog('fetchRanges: ' + fetchRanges);\n        for (var r = 0; r < fetchRanges.length; ++r) {\n          var fr = fetchRanges[r]\n          this.cirFobStartFetch(offset, fr, level)\n        }\n      },\n\n      cirFobStartFetch: function (offset, fr, level, attempts) {\n        var length = fr.max() - fr.min()\n        // dlog('fetching ' + fr.min() + '-' + fr.max() + ' (' + Util.humanReadableNumber(length) + ')');\n        //console.log('cirfobstartfetch');\n        this.window.bwg._read(\n          fr.min(),\n          length,\n          dlang.hitch(this, function (resultBuffer) {\n            for (var i = 0; i < offset.length; ++i) {\n              if (fr.contains(offset[i])) {\n                this.cirFobRecur2(resultBuffer, offset[i] - fr.min(), level)\n                --this.outstanding\n                if (this.outstanding == 0) {\n                  this.cirCompleted()\n                }\n              }\n            }\n          }),\n          this.errorCallback,\n        )\n      },\n\n      cirFobRecur2: function (cirBlockData, offset, level) {\n        var data = this.window.bwg.newDataView(cirBlockData, offset)\n\n        var isLeaf = data.getUint8()\n        var cnt = data.getUint16(2)\n        //dlog('cir level=' + level + '; cnt=' + cnt);\n\n        if (isLeaf != 0) {\n          for (var i = 0; i < cnt; ++i) {\n            var startChrom = data.getUint32()\n            var startBase = data.getUint32()\n            var endChrom = data.getUint32()\n            var endBase = data.getUint32()\n            var blockOffset = data.getUint64()\n            var blockSize = data.getUint64()\n            if (\n              (startChrom < this.chr ||\n                (startChrom == this.chr && startBase <= this.max)) &&\n              (endChrom > this.chr ||\n                (endChrom == this.chr && endBase >= this.min))\n            ) {\n              // dlog('Got an interesting block: startBase=' + startBase + '; endBase=' + endBase + '; offset=' + blockOffset + '; size=' + blockSize);\n              this.blocksToFetch.push({\n                offset: blockOffset,\n                size: blockSize,\n              })\n            }\n          }\n        } else {\n          var recurOffsets = []\n          for (var i = 0; i < cnt; ++i) {\n            var startChrom = data.getUint32()\n            var startBase = data.getUint32()\n            var endChrom = data.getUint32()\n            var endBase = data.getUint32()\n            var blockOffset = data.getUint64()\n            if (\n              (startChrom < this.chr ||\n                (startChrom == this.chr && startBase <= this.max)) &&\n              (endChrom > this.chr ||\n                (endChrom == this.chr && endBase >= this.min))\n            ) {\n              recurOffsets.push(blockOffset)\n            }\n          }\n          if (recurOffsets.length > 0) {\n            this.cirFobRecur(recurOffsets, level + 1)\n          }\n        }\n      },\n\n      cirCompleted: function () {\n        // merge contiguous blocks\n        this.blockGroupsToFetch = this.groupBlocks(this.blocksToFetch)\n\n        if (this.blockGroupsToFetch.length == 0) {\n          this.callback([])\n        } else {\n          this.features = []\n          this.readFeatures()\n        }\n      },\n\n      groupBlocks: function (blocks) {\n        // sort the blocks by file offset\n        blocks.sort(function (b0, b1) {\n          return (b0.offset | 0) - (b1.offset | 0)\n        })\n\n        // group blocks that are within 2KB of eachother\n        var blockGroups = []\n        var lastBlock\n        var lastBlockEnd\n        for (var i = 0; i < blocks.length; i++) {\n          if (lastBlock && blocks[i].offset - lastBlockEnd <= 2000) {\n            lastBlock.size += blocks[i].size - lastBlockEnd + blocks[i].offset\n            lastBlock.blocks.push(blocks[i])\n          } else {\n            blockGroups.push(\n              (lastBlock = {\n                blocks: [blocks[i]],\n                size: blocks[i].size,\n                offset: blocks[i].offset,\n              }),\n            )\n          }\n          lastBlockEnd = lastBlock.offset + lastBlock.size\n        }\n\n        return blockGroups\n      },\n\n      createFeature: function (fmin, fmax, opts) {\n        // dlog('createFeature(' + fmin +', ' + fmax + ', '+opts.score+')');\n\n        var data = {\n          start: fmin,\n          end: fmax,\n        }\n\n        for (var k in opts) {data[k] = opts[k]}\n\n        var id = data.id\n        delete data.id\n\n        var f = new SimpleFeature({\n          data: data,\n          id: id ? id : data.start + '_' + data.end + '_' + data.score,\n        })\n\n        this.features.push(f)\n      },\n\n      maybeCreateFeature: function (fmin, fmax, opts) {\n        if (fmin <= this.max && fmax >= this.min) {\n          this.createFeature(fmin, fmax, opts)\n        }\n      },\n\n      parseSummaryBlock: function (bytes, startOffset) {\n        var data = this.window.bwg.newDataView(bytes, startOffset)\n\n        var itemCount = bytes.byteLength / 32\n        for (var i = 0; i < itemCount; ++i) {\n          var chromId = data.getInt32()\n          var start = data.getInt32()\n          var end = data.getInt32()\n          var validCnt = data.getInt32() || 1\n          var minVal = data.getFloat32()\n          var maxVal = data.getFloat32()\n          var sumData = data.getFloat32()\n          var sumSqData = data.getFloat32()\n\n          if (chromId == this.chr) {\n            var summaryOpts = {\n              score: sumData / validCnt,\n              maxScore: maxVal,\n              minScore: minVal,\n            }\n            if (this.window.bwg.type == 'bigbed') {\n              summaryOpts.type = 'density'\n            }\n            this.maybeCreateFeature(start, end, summaryOpts)\n          }\n        }\n      },\n\n      parseBigWigBlock: function (bytes, startOffset) {\n        var data = this.window.bwg.newDataView(bytes, startOffset)\n\n        var itemSpan = data.getUint32(16)\n        var blockType = data.getUint8(20)\n        var itemCount = data.getUint16(22)\n\n        // dlog('processing bigwig block, type=' + blockType + '; count=' + itemCount);\n\n        if (blockType == this.BIG_WIG_TYPE_FSTEP) {\n          var blockStart = data.getInt32(4)\n          var itemStep = data.getUint32(12)\n          for (var i = 0; i < itemCount; ++i) {\n            var score = data.getFloat32(4 * i + 24)\n            this.maybeCreateFeature(\n              blockStart + i * itemStep,\n              blockStart + i * itemStep + itemSpan,\n              { score: score },\n            )\n          }\n        } else if (blockType == this.BIG_WIG_TYPE_VSTEP) {\n          for (var i = 0; i < itemCount; ++i) {\n            var start = data.getInt32(8 * i + 24)\n            var score = data.getFloat32()\n            this.maybeCreateFeature(start, start + itemSpan, {\n              score: score,\n            })\n          }\n        } else if (blockType == this.BIG_WIG_TYPE_GRAPH) {\n          for (var i = 0; i < itemCount; ++i) {\n            var start = data.getInt32(12 * i + 24)\n            var end = data.getInt32()\n            var score = data.getFloat32()\n            if (start > end) {\n              start = end\n            }\n            this.maybeCreateFeature(start, end, { score: score })\n          }\n        } else {\n          dlog('Currently not handling bwgType=' + blockType)\n        }\n      },\n\n      parseBigBedBlock: function (bytes, startOffset) {\n        var data = this.window.bwg.newDataView(bytes, startOffset)\n\n        var offset = 0\n        while (offset < bytes.byteLength) {\n          const chromId = data.getUint32(offset)\n          const start = data.getInt32(offset + 4)\n          const end = data.getInt32(offset + 8)\n          offset += 12\n          if (chromId !== this.chr) {\n            console.warn('BigBed block is out of current range')\n            return\n          }\n\n          let rest = ''\n          while (offset < bytes.byteLength) {\n            let ch = data.getUint8(offset++)\n            if (ch !== 0) {\n              rest += String.fromCharCode(ch)\n            } else {\n              break\n            }\n          }\n\n          const featureData = this.parseBedText(start, end, rest)\n          featureData.id = `bb-${startOffset + offset}`\n          this.maybeCreateFeature(start, end, featureData)\n        }\n      },\n\n      /**\n       * parse the `rest` field of a binary bed data section, using\n       * the autosql schema defined for this file\n       *\n       * @returns {Object} feature data with native BED field names\n       */\n      parseBedText: function (start, end, rest) {\n        // include ucsc-style names as well as jbrowse-style names\n        const featureData = {\n          start: start,\n          end: end,\n        }\n\n        const bedColumns = rest.split('\\t')\n        const asql = this.window.autoSql || defaultAutoSql\n        const numericTypes = ['uint', 'int', 'float', 'long']\n        // first three columns (chrom,start,end) are not included in bigBed\n        for (let i = 3; i < asql.fields.length; i++) {\n          if (bedColumns[i - 3] !== '.' && bedColumns[i - 3] !== '') {\n            const autoField = asql.fields[i]\n            let columnVal = bedColumns[i - 3]\n\n            // for speed, cache some of the tests we need inside the autofield definition\n            if (!autoField._requestWorkerCache) {\n              const match = /^(\\w+)\\[/.exec(autoField.type)\n              autoField._requestWorkerCache = {\n                isNumeric: numericTypes.includes(autoField.type),\n                isArray: !!match,\n                arrayIsNumeric: match && numericTypes.includes(match[1]),\n              }\n            }\n\n            if (autoField._requestWorkerCache.isNumeric) {\n              let num = Number(columnVal)\n              // if the number parse results in NaN, somebody probably\n              // listed the type erroneously as numeric, so don't use\n              // the parsed number\n              columnVal = isNaN(num) ? columnVal : num\n            } else if (autoField._requestWorkerCache.isArray) {\n              // parse array values\n              columnVal = columnVal.split(',')\n              if (columnVal[columnVal.length - 1] === '') {columnVal.pop()}\n              if (autoField._requestWorkerCache.arrayIsNumeric)\n                {columnVal = columnVal.map(str => Number(str))}\n            }\n\n            featureData[snakeCase(autoField.name)] = columnVal\n          }\n        }\n\n        if (featureData.strand) {\n          featureData.strand = { '-': -1, '+': 1 }[featureData.strand]\n        }\n\n        return featureData\n      },\n\n      readFeatures: function () {\n        var thisB = this\n        var blockFetches = array.map(\n          thisB.blockGroupsToFetch,\n          function (blockGroup) {\n            //console.log( 'fetching blockgroup with '+blockGroup.blocks.length+' blocks: '+blockGroup );\n            var d = new RejectableFastPromise()\n            thisB.window.bwg._read(\n              blockGroup.offset,\n              blockGroup.size,\n              function (data) {\n                blockGroup.data = data\n                d.resolve(blockGroup)\n              },\n              dlang.hitch(d, 'reject'),\n            )\n            return d\n          },\n          thisB,\n        )\n\n        all(blockFetches).then(function (blockGroups) {\n          array.forEach(blockGroups, function (blockGroup) {\n            array.forEach(blockGroup.blocks, function (block) {\n              var data\n              var offset = block.offset - blockGroup.offset\n              if (thisB.window.bwg.uncompressBufSize > 0) {\n                // var beforeInf = new Date();\n                data = inflate(blockGroup.data, offset + 2, block.size - 2)\n                offset = 0\n                //console.log( 'inflate', 2, block.size - 2);\n                // var afterInf = new Date();\n                // dlog('inflate: ' + (afterInf - beforeInf) + 'ms');\n              } else {\n                data = blockGroup.data\n              }\n\n              if (thisB.window.isSummary) {\n                thisB.parseSummaryBlock(data, offset)\n              } else if (thisB.window.bwg.type == 'bigwig') {\n                thisB.parseBigWigBlock(data, offset)\n              } else if (thisB.window.bwg.type == 'bigbed') {\n                thisB.parseBigBedBlock(data, offset)\n              } else {\n                dlog(\"Don't know what to do with \" + thisB.window.bwg.type)\n              }\n            })\n          })\n\n          thisB.callback(thisB.features)\n        }, thisB.errorCallback)\n      },\n    },\n  )\n\n  return RequestWorker\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/BigWig/Window.js":{"size":3938,"mtime":1738905961888,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/BigWig/Window.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'dojo/_base/lang',\n  'dojo/_base/array',\n  'JBrowse/Store/LRUCache',\n  './RequestWorker',\n], function (declare, lang, array, LRUCache, RequestWorker) {\n  var dlog = function () {\n    console.log.apply(console, arguments)\n  }\n\n  return declare(\n    null,\n    /**\n     * @lends JBrowse.Store.BigWig.Window.prototype\n     */\n    {\n      /**\n       * View into a subset of the data in a BigWig file.\n       *\n       * Adapted by Robert Buels from bigwig.js in the Dalliance Genome\n       * Explorer by Thomas Down.\n       * @constructs\n       */\n      constructor: function (\n        bwg,\n        cirTreeOffset,\n        cirTreeLength,\n        isSummary,\n        autoSql,\n      ) {\n        this.bwg = bwg\n        this.autoSql = autoSql\n        if (!(cirTreeOffset >= 0)) {throw 'invalid cirTreeOffset!'}\n        if (!(cirTreeLength > 0)) {throw 'invalid cirTreeLength!'}\n\n        this.cirTreeOffset = cirTreeOffset\n        this.cirTreeLength = cirTreeLength\n        this.isSummary = isSummary\n\n        function countFeatures(features) {\n          if (!features) {return 0}\n          let total = features.length\n          features.forEach(feature => {\n            total += countFeatures(feature.children())\n          })\n          return total\n        }\n        this.featureCache = new LRUCache({\n          name: 'feature cache',\n          fillCallback: (query, callback) => {\n            this.readWigDataById(...query, callback, err => {\n              console.error(err)\n            })\n          },\n          sizeFunction: countFeatures,\n          maxSize: 500000, // cache up to 50000 features and subfeatures\n        })\n      },\n\n      BED_COLOR_REGEXP: /^[0-9]+,[0-9]+,[0-9]+/,\n\n      readWigData: function (chrName, min, max, callback, errorCallback) {\n        // console.log( 'reading wig data from '+chrName+':'+min+'..'+max);\n        var chr = this.bwg.refsByName[chrName]\n        if (!chr) {\n          // Not an error because some .bwgs won't have data for all chromosomes.\n\n          // dlog(\"Couldn't find chr \" + chrName);\n          // dlog('Chroms=' + miniJSONify(this.bwg.refsByName));\n          callback([])\n        } else {\n          this.readWigDataByIdWithCache(\n            chr.id,\n            min,\n            max,\n            callback,\n            errorCallback,\n          )\n        }\n      },\n\n      readWigDataByIdWithCache(chr, min, max, callback, errorCallback) {\n        this.featureCache.get([chr, min, max], (result, error) => {\n          if (error) {errorCallback(error)}\n          else {callback(result)}\n        })\n      },\n\n      readWigDataById: function (chr, min, max, callback, errorCallback) {\n        if (!this.cirHeader) {\n          var readCallback = lang.hitch(\n            this,\n            'readWigDataById',\n            chr,\n            min,\n            max,\n            callback,\n            errorCallback,\n          )\n          if (this.cirHeaderLoading) {\n            this.cirHeaderLoading.push(readCallback)\n          } else {\n            this.cirHeaderLoading = [readCallback]\n            // dlog('No CIR yet, fetching');\n            this.bwg.data.read(\n              this.cirTreeOffset,\n              48,\n              lang.hitch(this, function (result) {\n                this.cirHeader = result\n                this.cirBlockSize = this.bwg\n                  .newDataView(result, 4, 4)\n                  .getUint32()\n                array.forEach(this.cirHeaderLoading, function (c) {\n                  c()\n                })\n                delete this.cirHeaderLoading\n              }),\n              errorCallback,\n            )\n          }\n          return\n        }\n\n        //dlog('_readWigDataById', chr, min, max, callback);\n\n        var worker = new RequestWorker(\n          this,\n          chr,\n          min,\n          max,\n          callback,\n          errorCallback,\n        )\n        worker.cirFobRecur([this.cirTreeOffset + 48], 1)\n      },\n    },\n  )\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/ChromSizes.js":{"size":2687,"mtime":1738905961895,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/ChromSizes.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"const BlobFilehandleWrapper = cjsRequire('../../Model/BlobFilehandleWrapper')\n\ndefine([\n  'dojo/_base/declare',\n  'dojo/_base/lang',\n  'dojo/Deferred',\n  'JBrowse/Store/SeqFeature',\n  'JBrowse/Model/XHRBlob',\n  'JBrowse/Store/DeferredFeaturesMixin',\n], function (\n  declare,\n  lang,\n  Deferred,\n  SeqFeatureStore,\n  XHRBlob,\n  DeferredFeaturesMixin,\n) {\n  return declare([SeqFeatureStore, DeferredFeaturesMixin], {\n    /**\n     * Storage backend for sequences in chrom.sizes files\n     * served as static text files.\n     * @constructs\n     */\n    constructor: function (args) {\n      let dataBlob\n      if (args.blob) {dataBlob = new BlobFilehandleWrapper(args.blob)}\n      else if (args.urlTemplate)\n        {dataBlob = new BlobFilehandleWrapper(\n          new XHRBlob(this.resolveUrl(args.urlTemplate)),\n        )}\n\n      this.source = dataBlob.toString()\n      this.data = dataBlob\n      this.refSeqs = {}\n\n      this.init({\n        success: () => this._deferred.features.resolve({ success: true }),\n        failure: this._failAllDeferred.bind(this),\n      })\n    },\n\n    hasRefSeq: function (seqName, callback, errorCallback) {\n      this.getSequenceSize(seqName).then(size => {\n        callback(size !== undefined)\n      }, errorCallback)\n    },\n    getRefSeqs: function (callback, errorCallback) {\n      this.getSequenceSizes()\n        .then(sizes =>\n          Object.entries(this.refSeqs).map(([name, length]) => {\n            return {\n              name,\n              length,\n              end: length,\n              start: 0,\n            }\n          }),\n        )\n        .then(callback, errorCallback)\n    },\n    getSequenceSize: function (refSeq) {\n      return this._deferred.features.then(() => {\n        return this.refSeqs[refSeq]\n      })\n    },\n    getSequenceSizes: function () {\n      return this._deferred.features.then(() => {\n        return this.refSeqs\n      })\n    },\n    init: function (args) {\n      var fasta = this.data\n      var successCallback = args.success || function () {}\n      var failCallback =\n        args.failure ||\n        function (e) {\n          console.error(e, e.stack)\n        }\n      this.data.readFile().then(data => {\n        if (!data.length) {\n          failCallback('Could not read file ' + this.source)\n        }\n        const chroms = data.toString('utf8')\n        chroms.split('\\n').forEach(line => {\n          if (line.length) {\n            const [name, length] = line.split('\\t')\n            this.refSeqs[name] = length\n          }\n        })\n        successCallback()\n      }, failCallback)\n    },\n\n    saveStore: function () {\n      return {\n        urlTemplate: (this.config.file || this.config.blob).url,\n      }\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/Combination.js":{"size":8873,"mtime":1738905961907,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/Combination.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'dojo/_base/array',\n  'dojo/Deferred',\n  'JBrowse/Model/SimpleFeature',\n  'JBrowse/Store/SeqFeature/CombinationBase',\n], function (declare, array, Deferred, SimpleFeature, CombinationBaseStore) {\n  return declare([CombinationBaseStore], {\n    // An implementation of CombinationBase that deals with set-type features (without score, as in HTMLFeatures tracks).\n    // Usual operations are things like intersection, union, set subtraction and XOR.\n\n    // Creates features from spans.  Essentially copies the basic span information and adds a feature id.\n    createFeatures: function (spans) {\n      var features = []\n      //Validate this next time...\n      for (var span in spans) {\n        var id =\n          'comfeat_' +\n          spans[span].start +\n          '.' +\n          spans[span].end +\n          '.' +\n          spans[span].strand\n        features.push(\n          new SimpleFeature({\n            data: {\n              start: spans[span].start,\n              end: spans[span].end,\n              strand: spans[span].strand,\n            },\n            id: id,\n          }),\n        )\n      }\n      return features\n    },\n\n    // Defines the various set-theoretic operations that may occur and assigns each to a span-making function.\n    // Passes the two sets of spans to the appropriate operator function.\n    opSpan: function (op, span1, span2, query) {\n      switch (op) {\n        case '&':\n          return this.andSpan(span1, span2)\n        case 'U':\n          return this.orSpan(span1, span2)\n        case 'X':\n          return this.andSpan(\n            this.orSpan(span1, span2),\n            this.notSpan(this.andSpan(span1, span2), query),\n          )\n        case 'S':\n          return this.andSpan(span1, this.notSpan(span2, query))\n        default:\n          console.error('Invalid boolean operation: ' + op)\n      }\n      return undefined\n    },\n\n    // given a set of features, takes the \"union\" of them and outputs a single set of nonoverlapping spans\n    toSpan: function (features, query) {\n      // strip away extra stuff and keep only the relevant feature data\n      var rawSpans = this._rawToSpan(features, query)\n\n      // Splits the spans based on which strand they're on, and remove overlap from each strand's spans, recombining at the end.\n      return this._removeOverlap(this._strandFilter(rawSpans, +1)).concat(\n        this._removeOverlap(this._strandFilter(rawSpans, -1)),\n      )\n    },\n\n    _rawToSpan: function (features, query) {\n      // given a set of features, makes a set of spans with the\n      // same start and end points (a.k.a. pseudo-features)\n      var spans = []\n      for (var feature in features) {\n        if (features.hasOwnProperty(feature)) {\n          spans.push({\n            start: features[feature].get('start'), //Math.max( features[feature].get('start'), query.start ),\n            end: features[feature].get('end'), //Math.min( features[feature].get('end'),   query.end   ),\n            strand: features[feature].get('strand'),\n          })\n        }\n      }\n      return spans\n    },\n\n    // Filters an array of spans based on which strand of the reference sequence they are attached to\n    _strandFilter: function (spans, strand) {\n      return array\n        .filter(spans, function (item) {\n          return item.strand == strand || !item.strand\n        })\n        .map(function (item) {\n          if (!item.strand)\n            {return {\n              start: item.start,\n              end: item.end,\n              strand: strand,\n            }}\n          // Adds strand to strandless spans\n          else {return item}\n        })\n    },\n\n    // converts overlapping spans into their union.  Assumes the spans are all on the same strand.\n    _removeOverlap: function (spans) {\n      if (!spans.length) {\n        return []\n      }\n      spans.sort(function (a, b) {\n        return a.start - b.start\n      })\n      return this._removeOverlapSorted(spans)\n    },\n\n    // Given an array of spans sorted by their start bp, converts them into a single non-overlapping set (ie takes their union).\n    _removeOverlapSorted: function (spans) {\n      var retSpans = []\n      var i = 0\n      var strand = spans[0].strand\n      while (i < spans.length) {\n        var start = spans[i].start\n        var end = spans[i].end\n        while (i < spans.length && spans[i].start <= end) {\n          end = Math.max(end, spans[i].end)\n          i++\n        }\n        retSpans.push({ start: start, end: end, strand: strand })\n      }\n      return retSpans\n    },\n\n    // given two sets of spans without internal overlap, outputs a set corresponding to their union.\n    orSpan: function (span1, span2) {\n      return this._computeUnion(\n        this._strandFilter(span1, 1),\n        this._strandFilter(span2, 1),\n      ).concat(\n        this._computeUnion(\n          this._strandFilter(span1, -1),\n          this._strandFilter(span2, -1),\n        ),\n      )\n    },\n\n    // given two sets of spans without internal overlap, outputs a set corresponding to their intersection\n    andSpan: function (span1, span2) {\n      return this._computeIntersection(\n        this._strandFilter(span1, 1),\n        this._strandFilter(span2, 1),\n      ).concat(\n        this._computeIntersection(\n          this._strandFilter(span1, -1),\n          this._strandFilter(span2, -1),\n        ),\n      )\n    },\n\n    // This method should merge two sorted span arrays in O(n) time, which is better\n    // then using span1.concat(span2) and then array.sort(), which takes O(n*log(n)) time.\n    _sortedArrayMerge: function (span1, span2) {\n      var newArray = []\n      var i = 0\n      var j = 0\n      while (i < span1.length && j < span2.length) {\n        if (span1[i].start <= span2[j].start) {\n          newArray.push(span1[i])\n          i++\n        } else {\n          newArray.push(span2[j])\n          j++\n        }\n      }\n      if (i < span1.length) {\n        newArray = newArray.concat(span1.slice(i, span1.length))\n      } else if (j < span2.length) {\n        newArray = newArray.concat(span2.slice(j, span2.length))\n      }\n      return newArray\n    },\n\n    // A helper method for computing the union of two arrays of spans.\n    _computeUnion: function (span1, span2) {\n      if (!span1.length && !span2.length) {\n        return []\n      }\n      return this._removeOverlapSorted(this._sortedArrayMerge(span1, span2))\n    },\n\n    // A helper method for computing the intersection of two arrays of spans.\n    _computeIntersection: function (span1, span2) {\n      if (!span1.length || !span2.length) {\n        return []\n      }\n\n      var allSpans = this._sortedArrayMerge(span1, span2)\n      var retSpans = []\n\n      var maxEnd = allSpans[0].end\n      var strand = span1[0].strand // Assumes both span sets contain only features for one specific strand\n      var i = 1\n      while (i < allSpans.length) {\n        var start = allSpans[i].start\n        var end = Math.min(allSpans[i].end, maxEnd)\n        if (start < end) {\n          retSpans.push({ start: start, end: end, strand: strand })\n        }\n        maxEnd = Math.max(allSpans[i].end, maxEnd)\n        i++\n      }\n\n      return retSpans\n    },\n\n    // Filters span set by strand, inverts the sets represented on each strand, and recombines.\n    notSpan: function (spans, query) {\n      return this._rawNotSpan(this._strandFilter(spans, +1), query, +1).concat(\n        this._rawNotSpan(this._strandFilter(spans, -1), query, -1),\n      )\n    },\n\n    // Converts a set of spans into its complement in the reference sequence.\n    _rawNotSpan: function (spans, query, strand) {\n      var invSpan = []\n      invSpan[0] = { start: query.start }\n      var i = 0\n      for (var span in spans) {\n        if (spans.hasOwnProperty(span)) {\n          span = spans[span]\n          invSpan[i].strand = strand\n          invSpan[i].end = span.start\n          i++\n          invSpan[i] = { start: span.end }\n        }\n      }\n      invSpan[i].strand = strand\n      invSpan[i].end = query.end\n      if (invSpan[i].end <= invSpan[i].start) {\n        invSpan.splice(i, 1)\n      }\n      if (invSpan[0].end <= invSpan[0].start) {\n        invSpan.splice(0, 1)\n      }\n      return invSpan\n    },\n\n    loadRegion: function (region) {\n      var d = new Deferred()\n\n      if (this.stores.length == 1) {\n        d.resolve(this, true)\n        return d.promise\n      }\n      var thisB = this\n      var regionLoaded = region\n      regionLoaded.spans = []\n\n      delete this.regionLoaded\n\n      this._getFeatures(\n        region,\n        function () {},\n        function (results) {\n          if (results && results.spans) {\n            regionLoaded.spans = results.spans\n            thisB.regionLoaded = regionLoaded\n          }\n          d.resolve(thisB, true)\n        },\n        function () {\n          d.reject('cannot load region')\n        },\n      )\n      return d.promise\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/CombinationBase.js":{"size":7054,"mtime":1738905961920,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/CombinationBase.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/Coverage.js":{"size":2887,"mtime":1738905961925,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/Coverage.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/CRAM.js":{"size":13992,"mtime":1738905961944,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/CRAM.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"const LRU = cjsRequire('quick-lru')\nconst { IndexedCramFile, CraiIndex } = cjsRequire('@gmod/cram')\nconst { CramSizeLimitError } = cjsRequire('@gmod/cram/errors')\n\nconst cramIndexedFilesCache = new LRU({ maxSize: 5 })\n\nconst BlobFilehandleWrapper = cjsRequire('../../Model/BlobFilehandleWrapper')\n\nclass CramSlightlyLazyFeature {\n  _get_id() {\n    return this.id()\n  }\n  _get_name() {\n    return this.record.readName\n  }\n  _get_start() {\n    return this.record.alignmentStart - 1\n  }\n  _get_end() {\n    return this.record.alignmentStart + this.record.lengthOnRef - 1\n  }\n  _get_cram_read_features() {\n    return this.record.readFeatures\n  }\n  _get_type() {\n    return 'match'\n  }\n  _get_score() {\n    return this.record.mappingQuality\n  }\n  _get_mapping_quality() {\n    return this.record.mappingQuality\n  }\n  _get_flags() {\n    return `0x${this.record.flags.toString(16)}`\n  }\n  _get_cramFlags() {\n    return `0x${this.record.cramFlags.toString(16)}`\n  }\n  _get_strand() {\n    return this.record.isReverseComplemented() ? -1 : 1\n  }\n  _get_read_group_id() {\n    return this.record.readGroupId\n  }\n  _get_qual() {\n    return (this.record.qualityScores || []).map(q => q + 33).join(' ')\n  }\n  _get_seq_id() {\n    return this._store._refIdToName(this.record.sequenceId)\n  }\n  _get_qc_failed() {\n    return this.record.isFailedQc()\n  }\n  _get_secondary_alignment() {\n    return this.record.isSecondary()\n  }\n  _get_duplicate() {\n    return this.record.isDuplicate()\n  }\n  _get_supplementary_alignment() {\n    return this.record.isSupplementary()\n  }\n  _get_pair_orientation() {\n    return this.record.getPairOrientation()\n  }\n  _get_multi_segment_template() {\n    return this.record.isPaired()\n  }\n  _get_multi_segment_all_correctly_aligned() {\n    return this.record.isProperlyPaired()\n  }\n  _get_multi_segment_all_aligned() {\n    return this.record.isProperlyPaired()\n  }\n  _get_multi_segment_next_segment_unmapped() {\n    return this.record.isMateUnmapped()\n  }\n  _get_multi_segment_first() {\n    return this.record.isRead1()\n  }\n  _get_multi_segment_last() {\n    return this.record.isRead2()\n  }\n  _get_multi_segment_next_segment_reversed() {\n    return this.record.isMateReverseComplemented()\n  }\n  _get_is_paired() {\n    return !!this.record.mate\n  }\n  _get_unmapped() {\n    return this.record.isSegmentUnmapped()\n  }\n  _get_template_length() {\n    return this.record.templateLength || this.record.templateSize\n  }\n  _get_next_seq_id() {\n    return this.record.mate\n      ? this._store._refIdToName(this.record.mate.sequenceId)\n      : undefined\n  }\n  _get_next_pos() {\n    return this.record.mate ? this.record.mate.alignmentStart : undefined\n  }\n  _get_next_segment_position() {\n    return this.record.mate\n      ? this._store._refIdToName(this.record.mate.sequenceId) +\n          ':' +\n          this.record.mate.alignmentStart\n      : undefined\n  }\n  _get_tags() {\n    return this.record.tags\n  }\n  _get_seq() {\n    return this.record.getReadBases()\n  }\n\n  constructor(record, store) {\n    this.record = record\n    this._store = store\n  }\n\n  tags() {\n    const properties = Object.getOwnPropertyNames(\n      CramSlightlyLazyFeature.prototype,\n    )\n    return properties\n      .filter(prop => /^_get_/.test(prop))\n      .map(methodName => methodName.replace('_get_', ''))\n  }\n\n  id() {\n    return this.record.uniqueId + 1\n  }\n\n  _get(field) {\n    const methodName = `_get_${field}`\n    if (this[methodName]) {return this[methodName]()}\n    return undefined\n  }\n  get(field) {\n    const methodName = `_get_${field.toLowerCase()}`\n    if (this[methodName]) {return this[methodName]()}\n    return undefined\n  }\n\n  parent() {}\n\n  children() {}\n\n  pairedFeature() {\n    return false\n  }\n}\n\ndefine([\n  'dojo/_base/declare',\n  'JBrowse/Util',\n  'JBrowse/Errors',\n  'JBrowse/Store/SeqFeature',\n  'JBrowse/Store/DeferredStatsMixin',\n  'JBrowse/Store/DeferredFeaturesMixin',\n  'JBrowse/Store/SeqFeature/GlobalStatsEstimationMixin',\n  'JBrowse/Store/SeqFeature/_PairCache',\n  'JBrowse/Store/SeqFeature/_SpanCache',\n  'JBrowse/Store/SeqFeature/_InsertSizeCache',\n  'JBrowse/Model/XHRBlob',\n  'JBrowse/Model/SimpleFeature',\n], function (\n  declare,\n  Util,\n  Errors,\n  SeqFeatureStore,\n  DeferredStatsMixin,\n  DeferredFeaturesMixin,\n  GlobalStatsEstimationMixin,\n  PairCache,\n  SpanCache,\n  InsertSizeCache,\n  XHRBlob,\n  SimpleFeature,\n) {\n  return declare(\n    [\n      SeqFeatureStore,\n      DeferredStatsMixin,\n      DeferredFeaturesMixin,\n      GlobalStatsEstimationMixin,\n    ],\n\n    /**\n     * @lends JBrowse.Store.SeqFeature.CRAM\n     */\n    {\n      /**\n       * Data backend for reading feature data directly from a\n       * web-accessible CRAM file.\n       *\n       * @constructs\n       */\n      constructor: function (args) {\n        let dataBlob\n        if (args.cram) {dataBlob = new BlobFilehandleWrapper(args.cram)}\n        else if (args.urlTemplate)\n          {dataBlob = new BlobFilehandleWrapper(\n            new XHRBlob(this.resolveUrl(args.urlTemplate || 'data.cram'), {\n              expectRanges: true,\n            }),\n          )}\n        else {throw new Error('must provide either `cram` or `urlTemplate`')}\n\n        let indexBlob\n        if (args.crai) {indexBlob = new BlobFilehandleWrapper(args.crai)}\n        else if (args.craiUrlTemplate)\n          {indexBlob = new BlobFilehandleWrapper(\n            new XHRBlob(this.resolveUrl(args.craiUrlTemplate)),\n          )}\n        else if (args.urlTemplate)\n          {indexBlob = new BlobFilehandleWrapper(\n            new XHRBlob(this.resolveUrl(args.urlTemplate + '.crai')),\n          )}\n        else {throw new Error('no index provided, must provide a CRAM index')}\n\n        this.source = dataBlob.toString()\n\n        // LRU-cache the CRAM object so we don't have to re-download the\n        // index when we switch chromosomes\n        const cacheKey = `data: ${dataBlob}, index: ${indexBlob}`\n        this.cram = cramIndexedFilesCache.get(cacheKey)\n        if (!this.cram) {\n          this.cram = new IndexedCramFile({\n            cramFilehandle: dataBlob,\n            index: new CraiIndex({ filehandle: indexBlob }),\n            seqFetch: this._seqFetch.bind(this),\n            checkSequenceMD5: false,\n            fetchSizeLimit: args.fetchSizeLimit || 60000000,\n          })\n\n          cramIndexedFilesCache.set(cacheKey, this.cram)\n        }\n\n        // pre-download the index before running the statistics estimation so that the stats\n        // estimation doesn't time out\n        this.cram\n          .hasDataForReferenceSequence(0)\n          .then(() => this.cram.cram.getSamHeader())\n          .then(samHeader => {\n            this._setSamHeader(samHeader)\n          })\n          .then(() => {\n            this._deferred.features.resolve({ success: true })\n          })\n          .then(() => this._estimateGlobalStats())\n          .then(stats => {\n            this.globalStats = stats\n            this._deferred.stats.resolve({ success: true })\n          })\n          .catch(err => {\n            this._deferred.features.reject(err)\n            this._deferred.stats.reject(err)\n          })\n\n        this.insertSizeCache = new InsertSizeCache(args)\n        this.pairCache = new PairCache(args)\n        this.spanCache = new SpanCache(args)\n      },\n\n      // process the parsed SAM header from the cram file\n      _setSamHeader(samHeader) {\n        this._samHeader = {}\n\n        // use the @SQ lines in the header to figure out the\n        // mapping between ref seq ID numbers and names\n        const refSeqIdToName = []\n        const refSeqNameToId = {}\n        const sqLines = samHeader.filter(l => l.tag === 'SQ')\n        sqLines.forEach((sqLine, seqId) => {\n          sqLine.data.forEach(item => {\n            if (item.tag === 'SN') {\n              // this is the seq name\n              const seqName = this.browser.regularizeReferenceName(item.value)\n              refSeqNameToId[seqName] = seqId\n              refSeqIdToName[seqId] = seqName\n            }\n          })\n        })\n        if (refSeqIdToName.length) {\n          this._samHeader.refSeqIdToName = refSeqIdToName\n          this._samHeader.refSeqNameToId = refSeqNameToId\n        }\n      },\n\n      _refNameToId(refName) {\n        // use info from the SAM header if possible, but fall back to using\n        // the ref seq order from when the browser's refseqs were loaded\n        if (this._samHeader.refSeqNameToId)\n          {return this._samHeader.refSeqNameToId[refName]}\n        else {return this.browser.getRefSeqNumber(refName)}\n      },\n\n      _refIdToName(refId) {\n        // use info from the SAM header if possible, but fall back to using\n        // the ref seq order from when the browser's refseqs were loaded\n        if (this._samHeader.refSeqIdToName) {\n          return this._samHeader.refSeqIdToName[refId]\n        } else {\n          let ref = this.browser.getRefSeqById(refId)\n          return ref ? ref.name : undefined\n        }\n      },\n\n      _getRefSeqStore() {\n        return new Promise((resolve, reject) => {\n          this.browser.getStore('refseqs', resolve, reject)\n        })\n      },\n\n      // used by the CRAM backend to fetch a region of the underlying reference\n      // sequence.  needed for some of its calculations\n      async _seqFetch(seqId, start, end) {\n        start -= 1 // convert from 1-based closed to interbase\n\n        const refSeqStore = await this._getRefSeqStore()\n        if (!refSeqStore) {return undefined}\n        const refName = this._refIdToName(seqId)\n        if (!refName) {return undefined}\n\n        const seqChunks = await new Promise((resolve, reject) => {\n          let features = []\n          refSeqStore.getFeatures(\n            { ref: refName, start: start - 1, end },\n            f => features.push(f),\n            () => resolve(features),\n            reject,\n          )\n        })\n\n        const trimmed = []\n        seqChunks\n          .sort((a, b) => a.get('start') - b.get('start'))\n          .forEach((chunk, i) => {\n            let chunkStart = chunk.get('start')\n            let chunkEnd = chunk.get('end')\n            let trimStart = Math.max(start - chunkStart, 0)\n            let trimEnd = Math.min(end - chunkStart, chunkEnd - chunkStart)\n            let trimLength = trimEnd - trimStart\n            let chunkSeq = chunk.get('seq') || chunk.get('residues')\n            trimmed.push(chunkSeq.substr(trimStart, trimLength))\n          })\n\n        const sequence = trimmed.join('')\n        if (sequence.length !== end - start)\n          {throw new Error(\n            `sequence fetch failed: fetching ${(\n              start - 1\n            ).toLocaleString()}-${end.toLocaleString()} only returned ${sequence.length.toLocaleString()} bases, but should have returned ${(\n              end - start\n            ).toLocaleString()}`,\n          )}\n        return sequence\n      },\n\n      /**\n       * Interrogate whether a store has data for a given reference\n       * sequence.  Calls the given callback with either true or false.\n       */\n      hasRefSeq: function (seqName, callback, errorCallback) {\n        seqName = this.browser.regularizeReferenceName(seqName)\n        const refSeqNumber = this._refNameToId(seqName)\n        if (refSeqNumber === undefined) {callback(false)}\n\n        this._deferred.stats\n          .then(() => this.cram.hasDataForReferenceSequence(refSeqNumber))\n          .then(callback, errorCallback)\n      },\n\n      // called by getFeatures from the DeferredFeaturesMixin\n      _getFeatures: function (query, featCallback, endCallback, errorCallback) {\n        const pairCache = {}\n        const seqName = query.ref || this.refSeq.name\n        const refSeqNumber = this._refNameToId(\n          this.browser.regularizeReferenceName(seqName),\n        )\n        query.maxInsertSize = query.maxInsertSize || 50000\n        if (refSeqNumber === undefined) {\n          endCallback()\n          return\n        }\n        this.cram\n          .getRecordsForRange(refSeqNumber, query.start + 1, query.end, {\n            viewAsPairs: query.viewAsPairs,\n            viewAsSpans: query.viewAsSpans,\n            maxInsertSize: query.maxInsertSize,\n          })\n          .then(records => {\n            if (query.viewAsPairs) {\n              const recs = records.map(f => this._cramRecordToFeature(f))\n              recs.forEach(r => this.insertSizeCache.insertFeat(r))\n              this.pairCache.pairFeatures(\n                query,\n                recs,\n                featCallback,\n                endCallback,\n                errorCallback,\n              )\n            } else if (query.viewAsSpans) {\n              const recs = records.map(f => this._cramRecordToFeature(f))\n              recs.forEach(r => this.insertSizeCache.insertFeat(r))\n              this.spanCache.pairFeatures(\n                query,\n                recs,\n                featCallback,\n                endCallback,\n                errorCallback,\n              )\n            } else {\n              for (let i = 0; i < records.length; i++) {\n                let feat = this._cramRecordToFeature(records[i])\n                this.insertSizeCache.insertFeat(feat)\n                featCallback(feat)\n              }\n            }\n            endCallback()\n          })\n          .catch(err => {\n            // map the CramSizeLimitError to JBrowse Errors.DataOverflow\n            if (err instanceof CramSizeLimitError) {\n              err = new Errors.DataOverflow(err)\n            }\n\n            errorCallback(err)\n          })\n      },\n\n      getInsertSizeStats() {\n        return this.insertSizeCache.getInsertSizeStats()\n      },\n\n      cleanFeatureCache(query) {\n        this.pairCache.cleanFeatureCache(query)\n        this.spanCache.cleanFeatureCache(query)\n      },\n\n      cleanStatsCache() {\n        this.insertSizeCache.cleanStatsCache()\n      },\n\n      _cramRecordToFeature(record) {\n        return new CramSlightlyLazyFeature(record, this)\n      },\n\n      saveStore() {\n        return {\n          urlTemplate: this.config.cram.url,\n          craiUrlTemplate: this.config.crai.url,\n        }\n      },\n    },\n  )\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/FromConfig.js":{"size":2211,"mtime":1738905961950,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/FromConfig.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"/**\n * Store that shows features defined in its `features` configuration\n * key, like:\n *   \"features\": [ { \"seq_id\": \"ctgA\", \"start\":1, \"end\":20 },\n *                 ...\n *               ]\n */\n\ndefine([\n  'dojo/_base/declare',\n  'dojo/_base/array',\n  'JBrowse/Store/SeqFeature',\n  'JBrowse/Model/SimpleFeature',\n], function (declare, array, SeqFeatureStore, SimpleFeature) {\n  return declare(SeqFeatureStore, {\n    constructor: function (args) {\n      this.features = this._makeFeatures(this.config.features || [])\n    },\n\n    _makeFeatures: function (fdata) {\n      var features = {}\n      for (var i = 0; i < fdata.length; i++) {\n        if (fdata[i]) {\n          var f = this._makeFeature(fdata[i])\n          var refName = this.browser.regularizeReferenceName(f.get('seq_id'))\n          var refFeatures =\n            features[refName] ||\n            function () {\n              return (features[refName] = [])\n            }.call()\n          refFeatures.push(f)\n        }\n      }\n      return features\n    },\n\n    _parseInt: function (data) {\n      array.forEach(['start', 'end', 'strand'], function (field) {\n        if (field in data) {data[field] = parseInt(data[field])}\n      })\n      if ('score' in data) {data.score = parseFloat(data.score)}\n      if ('subfeatures' in data)\n        {for (var i = 0; i < data.subfeatures.length; i++)\n          {this._parseInt(data.subfeatures[i])}}\n    },\n\n    _makeFeature: function (data, parent) {\n      this._parseInt(data)\n      return new SimpleFeature({ data: data, parent: parent })\n    },\n\n    getGlobalStats: function (cb, errorCb) {\n      this.getRegionStats(\n        {\n          ref: this.refSeq.name,\n          start: this.refSeq.start,\n          end: this.refSeq.end,\n        },\n        cb,\n        errorCb,\n      )\n    },\n\n    getFeatures: function (query, featCallback, endCallback, errorCallback) {\n      var start = query.start\n      var end = query.end\n      var features =\n        this.features[this.browser.regularizeReferenceName(query.ref)] || {}\n      for (var id in features) {\n        var f = features[id]\n        if (!(f.get('end') < start || f.get('start') > end)) {\n          featCallback(f)\n        }\n      }\n      endCallback()\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/GFF3.js":{"size":7207,"mtime":1738905961962,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/GFF3.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"import gff from '@gmod/gff'\n\ndefine([\n  'dojo/_base/declare',\n  'dojo/_base/lang',\n  'dojo/_base/array',\n  'dojo/Deferred',\n  'JBrowse/Util',\n  'JBrowse/Model/SimpleFeature',\n  'JBrowse/Store/SeqFeature',\n  'JBrowse/Store/DeferredFeaturesMixin',\n  'JBrowse/Store/DeferredStatsMixin',\n  'JBrowse/Store/SeqFeature/GlobalStatsEstimationMixin',\n  'JBrowse/Store/SeqFeature/RegionStatsMixin',\n  'JBrowse/Model/XHRBlob',\n], function (\n  declare,\n  lang,\n  array,\n  Deferred,\n  Util,\n  SimpleFeature,\n  SeqFeatureStore,\n  DeferredFeatures,\n  DeferredStats,\n  GlobalStatsEstimationMixin,\n  RegionStatsMixin,\n  XHRBlob,\n) {\n  return declare(\n    [\n      SeqFeatureStore,\n      DeferredFeatures,\n      DeferredStats,\n      GlobalStatsEstimationMixin,\n      RegionStatsMixin,\n    ],\n\n    /**\n     * @lends JBrowse.Store.SeqFeature.GFF3\n     */\n    {\n      constructor: function (args) {\n        this.data =\n          args.blob ||\n          new XHRBlob(this.resolveUrl(this._evalConf(args.urlTemplate)))\n        this.features = []\n        this._loadFeatures()\n      },\n\n      _loadFeatures() {\n        const features = (this.bareFeatures = [])\n\n        let featuresSorted = true\n        const seenRefs = (this.refSeqs = {})\n\n        let addFeature = fs => {\n          fs.forEach(feature => {\n            var prevFeature = features[features.length - 1]\n            var regRefName = this.browser.regularizeReferenceName(\n              feature.seq_id,\n            )\n            if (\n              regRefName in seenRefs &&\n              prevFeature &&\n              prevFeature.seq_id != feature.seq_id\n            )\n              {featuresSorted = false}\n            if (\n              prevFeature &&\n              prevFeature.seq_id == feature.seq_id &&\n              feature.start < prevFeature.start\n            )\n              {featuresSorted = false}\n\n            if (!(regRefName in seenRefs))\n              {seenRefs[regRefName] = features.length}\n\n            features.push(feature)\n          })\n        }\n\n        let endFeatures = () => {\n          if (!featuresSorted) {\n            features.sort(this._compareFeatureData)\n            // need to rebuild the refseq index if changing the sort order\n            this._rebuildRefSeqs(features)\n          }\n\n          this._estimateGlobalStats().then(stats => {\n            this.globalStats = stats\n            this._deferred.stats.resolve()\n          })\n\n          this._deferred.features.resolve(features)\n        }\n\n        const fail = this._failAllDeferred.bind(this)\n\n        const parseStream = gff\n          .parseStream({\n            parseFeatures: true,\n            parseSequences: false,\n          })\n          .on('data', addFeature)\n          .on('end', endFeatures)\n          .on('error', fail)\n\n        // parse the whole file and store it\n        this.data.fetchLines(\n          line => parseStream.write(line),\n          () => parseStream.end(),\n          fail,\n        )\n      },\n\n      _rebuildRefSeqs: function (features) {\n        var refs = {}\n        for (var i = 0; i < features.length; i++) {\n          var regRefName = this.browser.regularizeReferenceName(\n            features[i].seq_id,\n          )\n\n          if (!(regRefName in refs)) {refs[regRefName] = i}\n        }\n        this.refSeqs = refs\n      },\n\n      _compareFeatureData: function (a, b) {\n        if (a.seq_id < b.seq_id) {return -1}\n        else if (a.seq_id > b.seq_id) {return 1}\n\n        return a.start - b.start\n      },\n\n      _getFeatures: function (\n        query,\n        featureCallback,\n        finishedCallback,\n        errorCallback,\n      ) {\n        var thisB = this\n        thisB._deferred.features.then(function () {\n          thisB._search(query, featureCallback, finishedCallback, errorCallback)\n        })\n      },\n\n      _search: function (\n        query,\n        featureCallback,\n        finishCallback,\n        errorCallback,\n      ) {\n        // search in this.features, which are sorted\n        // by ref and start coordinate, to find the beginning of the\n        // relevant range\n        var bare = this.bareFeatures\n        var converted = this.features\n\n        var refName = this.browser.regularizeReferenceName(query.ref)\n\n        var i = this.refSeqs[refName]\n        if (!(i >= 0)) {\n          finishCallback()\n          return\n        }\n\n        var checkEnd =\n          'start' in query\n            ? function (f) {\n                return f.get('end') >= query.start\n              }\n            : function () {\n                return true\n              }\n\n        for (; i < bare.length; i++) {\n          // lazily convert the bare feature data to JBrowse features\n          var f =\n            converted[i] ||\n            (converted[i] = function (b, i) {\n              bare[i] = false\n              return this._formatFeature(b)\n            }.call(this, bare[i], i))\n          // features are sorted by ref seq and start coord, so we\n          // can stop if we are past the ref seq or the end of the\n          // query region\n          if (f._reg_seq_id != refName || f.get('start') > query.end) {break}\n\n          if (checkEnd(f)) {\n            this.applyFeatureTransforms([f]).forEach(featureCallback)\n          }\n        }\n\n        finishCallback()\n      },\n\n      supportsFeatureTransforms: true,\n\n      _formatFeature: function (data) {\n        var f = new SimpleFeature({\n          data: this._featureData(data),\n          id: (data.attributes.ID || [])[0],\n        })\n        f._reg_seq_id = this.browser.regularizeReferenceName(data.seq_id)\n        return f\n      },\n\n      _featureData: function (data) {\n        const f = lang.mixin({}, data)\n        delete f.child_features\n        delete f.derived_features\n        delete f.attributes\n        f.start -= 1 // convert to interbase\n        f.strand = { '+': 1, '-': -1, '.': 0, '?': undefined }[data.strand]\n        const defaultFields = [\n          'start',\n          'end',\n          'seq_id',\n          'score',\n          'type',\n          'source',\n          'phase',\n          'strand',\n        ]\n        for (var a in data.attributes) {\n          let b = a.toLowerCase()\n          if (defaultFields.includes(b)) {b += '2'} //reproduce behavior of NCList\n          f[b] = data.attributes[a]\n          if (f[b].length == 1) {f[b] = f[b][0]}\n        }\n        var sub = array.map(\n          Util.flattenOneLevel(data.child_features),\n          this._featureData,\n          this,\n        )\n        if (sub.length) {f.subfeatures = sub}\n\n        return f\n      },\n\n      /**\n       * Interrogate whether a store has data for a given reference\n       * sequence.  Calls the given callback with either true or false.\n       *\n       * Implemented as a binary interrogation because some stores are\n       * smart enough to regularize reference sequence names, while\n       * others are not.\n       */\n      hasRefSeq: function (seqName, callback, errorCallback) {\n        var thisB = this\n        this._deferred.features.then(function () {\n          callback(\n            thisB.browser.regularizeReferenceName(seqName) in thisB.refSeqs,\n          )\n        })\n      },\n\n      saveStore: function () {\n        return {\n          urlTemplate: this.config.blob.url,\n        }\n      },\n    },\n  )\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/GFF3Tabix.js":{"size":10860,"mtime":1738905961974,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/GFF3Tabix.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"const gff = cjsRequire('@gmod/gff').default\nconst { TabixIndexedFile } = cjsRequire('@gmod/tabix')\n\ndefine([\n  'dojo/_base/declare',\n  'JBrowse/Util',\n  'JBrowse/Errors',\n  'JBrowse/Model/SimpleFeature',\n  'JBrowse/Store/SeqFeature',\n  'JBrowse/Store/DeferredStatsMixin',\n  'JBrowse/Store/DeferredFeaturesMixin',\n  'JBrowse/Store/SeqFeature/IndexedStatsEstimationMixin',\n  'JBrowse/Store/SeqFeature/RegionStatsMixin',\n  'JBrowse/Model/BlobFilehandleWrapper',\n  'JBrowse/Model/XHRBlob',\n], function (\n  declare,\n  Util,\n  Errors,\n  SimpleFeature,\n  SeqFeatureStore,\n  DeferredStatsMixin,\n  DeferredFeaturesMixin,\n  IndexedStatsEstimationMixin,\n  RegionStatsMixin,\n  BlobFilehandleWrapper,\n  XHRBlob,\n) {\n  return declare(\n    [\n      SeqFeatureStore,\n      DeferredStatsMixin,\n      DeferredFeaturesMixin,\n      IndexedStatsEstimationMixin,\n      RegionStatsMixin,\n    ],\n    {\n      supportsFeatureTransforms: true,\n\n      constructor(args) {\n        this.dontRedispatch = (\n          args.dontRedispatch || 'chromosome,region'\n        ).split(/\\s*,\\s*/)\n        var csiBlob, tbiBlob\n\n        if (args.csi || this.config.csiUrlTemplate) {\n          csiBlob =\n            args.csi ||\n            new XHRBlob(this.resolveUrl(this.getConf('csiUrlTemplate', [])))\n        } else {\n          tbiBlob =\n            args.tbi ||\n            new XHRBlob(\n              this.resolveUrl(\n                this.getConf('tbiUrlTemplate', []) ||\n                  this.getConf('urlTemplate', []) + '.tbi',\n              ),\n            )\n        }\n\n        var fileBlob =\n          args.file ||\n          new XHRBlob(this.resolveUrl(this.getConf('urlTemplate', [])), {\n            expectRanges: true,\n          })\n\n        this.indexedData = new TabixIndexedFile({\n          filehandle: new BlobFilehandleWrapper(fileBlob),\n          tbiFilehandle: tbiBlob && new BlobFilehandleWrapper(tbiBlob),\n          csiFilehandle: csiBlob && new BlobFilehandleWrapper(csiBlob),\n          chunkSizeLimit: args.chunkSizeLimit || 50000000,\n          renameRefSeqs: n => this.browser.regularizeReferenceName(n),\n        })\n\n        // start our global stats estimation\n        this.indexedData.lineCount('nonexistent').then(\n          () => {\n            this._deferred.features.resolve({ success: true })\n            this._estimateGlobalStats().then(\n              stats => {\n                this.globalStats = stats\n                this._deferred.stats.resolve(stats)\n              },\n              err => this._failAllDeferred(err),\n            )\n          },\n          err => this._failAllDeferred(err),\n        )\n      },\n\n      _parseLine(columnNumbers, line, fileOffset) {\n        const fields = line.split('\\t')\n\n        return {\n          // note: index column numbers are 1-based\n          start: parseInt(fields[columnNumbers.start - 1]),\n          end: parseInt(fields[columnNumbers.end - 1]),\n          lineHash: fileOffset,\n          fields,\n        }\n      },\n\n      _getFeatures(\n        query,\n        featureCallback,\n        finishedCallback,\n        errorCallback,\n        allowRedispatch = true,\n      ) {\n        this.indexedData.getMetadata().then(metadata => {\n          const regularizedReferenceName = this.browser.regularizeReferenceName(\n            query.ref,\n          )\n          const lines = []\n          this.indexedData\n            .getLines(\n              regularizedReferenceName || this.refSeq.name,\n              query.start,\n              query.end,\n              (line, fileOffset) => {\n                lines.push(\n                  this._parseLine(metadata.columnNumbers, line, fileOffset),\n                )\n              },\n            )\n            .then(\n              () => {\n                // If this is the first fetch (allowRedispatch is true), check whether\n                // any of the features protrude out of the queried range.\n                // If it is, redo the fetch to fetch the max span of the features, so\n                // that we will get all of the child features of the top-level features.\n                // This assumes that child features will always fall within the span\n                // of the parent feature, which isn't true in the general case, but\n                // this should work for most use cases\n                if (allowRedispatch && lines.length) {\n                  let minStart = Infinity\n                  let maxEnd = -Infinity\n                  lines.forEach(line => {\n                    const featureType = line.fields[2]\n                    // only expand redispatch range if the feature is not in dontRedispatch,\n                    // and is a top-level feature\n                    if (\n                      !this.dontRedispatch.includes(featureType) &&\n                      this._isTopLevelFeatureType(featureType)\n                    ) {\n                      let start = line.start - 1 // gff is 1-based\n                      if (start < minStart) {minStart = start}\n                      if (line.end > maxEnd) {maxEnd = line.end}\n                    }\n                  })\n                  if (maxEnd > query.end || minStart < query.start) {\n                    // console.log(`redispatching ${query.start}-${query.end} => ${minStart}-${maxEnd}`)\n                    let newQuery = Object.assign({}, query, {\n                      start: minStart,\n                      end: maxEnd,\n                    })\n                    // make a new feature callback to only return top-level features\n                    // in the original query range\n                    const newFeatureCallback = feature => {\n                      if (\n                        feature.get('start') < query.end &&\n                        feature.get('end') > query.start\n                      ) {\n                        featureCallback(feature)\n                      }\n                    }\n                    this._getFeatures(\n                      newQuery,\n                      newFeatureCallback,\n                      finishedCallback,\n                      errorCallback,\n                      false,\n                    )\n                    return\n                  }\n                }\n\n                // decorate each of the lines with a _lineHash attribute\n                const gff3 = lines\n                  .map(lineRecord => {\n                    // add a lineHash attr to each gff3 line sayings its offset in\n                    // the file, we can use this later to synthesize a unique ID for\n                    // features that don't have one\n                    if (lineRecord.fields[8] && lineRecord.fields[8] !== '.') {\n                      if (!lineRecord.fields[8].includes('_lineHash'))\n                        {lineRecord.fields[8] += `;_lineHash=${lineRecord.lineHash}`}\n                    } else {\n                      lineRecord.fields[8] = `_lineHash=${lineRecord.lineHash}`\n                    }\n                    return lineRecord.fields.join('\\t')\n                  })\n                  .join('\\n')\n                const features = gff.parseStringSync(gff3, {\n                  parseFeatures: true,\n                  parseComments: false,\n                  parseDirectives: false,\n                  parseSequences: false,\n                })\n\n                features.forEach(feature =>\n                  this.applyFeatureTransforms(\n                    this._formatFeatures(feature),\n                  ).forEach(featureCallback),\n                )\n                finishedCallback()\n              },\n              error => {\n                if (errorCallback) {\n                  if (\n                    error.message &&\n                    error.message.indexOf('Too much data') >= 0\n                  ) {\n                    error = new Errors.DataOverflow(error.message)\n                  }\n                  errorCallback(error)\n                } else {console.error(error)}\n              },\n            )\n            .catch(errorCallback)\n        }, errorCallback)\n      },\n\n      _featureData(data) {\n        const f = Object.assign({}, data)\n        delete f.child_features\n        delete f.data\n        delete f.derived_features\n        f.start -= 1 // convert to interbase\n        f.strand = { '+': 1, '-': -1, '.': 0, '?': undefined }[f.strand] // convert strand\n        const defaultFields = [\n          'start',\n          'end',\n          'seq_id',\n          'score',\n          'type',\n          'source',\n          'phase',\n          'strand',\n        ]\n        for (var a in data.attributes) {\n          let b = a.toLowerCase()\n          if (defaultFields.includes(b)) {b += '2'} //reproduce behavior of NCList\n          f[b] = data.attributes[a]\n          if (f[b].length == 1) {f[b] = f[b][0]}\n        }\n        f.uniqueID = `offset-${f._linehash}`\n\n        delete f._linehash\n        delete f.attributes\n        // the SimpleFeature constructor takes care of recursively inflating subfeatures\n        if (data.child_features && data.child_features.length) {\n          f.subfeatures = Util.flattenOneLevel(\n            data.child_features.map(childLocs =>\n              childLocs.map(childLoc => this._featureData(childLoc)),\n            ),\n          )\n        }\n\n        return f\n      },\n\n      /**\n       * A GFF3 feature is an arrayref of that feature's locations. Because a single feature could be\n       * in multiple locations. To match that with the JBrowse feature model, we treat each of those\n       * locations as a separate feature, and disambiguate them by appending an index to their ID\n       */\n      _formatFeatures(featureLocs) {\n        const features = []\n        featureLocs.forEach((featureLoc, locIndex) => {\n          let ids = featureLoc.attributes.ID || [\n            `offset-${featureLoc.attributes._lineHash[0]}`,\n          ]\n          ids.forEach((id, idIndex) => {\n            var f = new SimpleFeature({\n              data: this._featureData(featureLoc),\n              id: idIndex === 0 ? id : `${id}-${idIndex + 1}`,\n            })\n            f._reg_seq_id = this.browser.regularizeReferenceName(\n              featureLoc.seq_id,\n            )\n            features.push(f)\n          })\n        })\n        return features\n      },\n\n      /**\n       * Interrogate whether a store has data for a given reference\n       * sequence.  Calls the given callback with either true or false.\n       *\n       * Implemented as a binary interrogation because some stores are\n       * smart enough to regularize reference sequence names, while\n       * others are not.\n       */\n      hasRefSeq(seqName, callback, errorCallback) {\n        return this.indexedData.hasRefSeq(seqName, callback, errorCallback)\n      },\n\n      saveStore() {\n        return {\n          urlTemplate: this.config.file.url,\n          tbiUrlTemplate: (this.config.tbi || {}).url,\n          csiUrlTemplate: (this.config.csi || {}).url,\n        }\n      },\n    },\n  )\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/GlobalStatsEstimationMixin.js":{"size":3705,"mtime":1738905961984,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/GlobalStatsEstimationMixin.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/GTF.js":{"size":6777,"mtime":1738905961992,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/GTF.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'dojo/_base/lang',\n  'dojo/_base/array',\n  'dojo/Deferred',\n  'JBrowse/Util',\n  'JBrowse/Model/SimpleFeature',\n  'JBrowse/Store/SeqFeature',\n  'JBrowse/Store/DeferredFeaturesMixin',\n  'JBrowse/Store/DeferredStatsMixin',\n  'JBrowse/Store/SeqFeature/GlobalStatsEstimationMixin',\n  'JBrowse/Model/XHRBlob',\n  './GTF/Parser',\n], function (\n  declare,\n  lang,\n  array,\n  Deferred,\n  Util,\n  SimpleFeature,\n  SeqFeatureStore,\n  DeferredFeatures,\n  DeferredStats,\n  GlobalStatsEstimationMixin,\n  XHRBlob,\n  Parser,\n) {\n  return declare(\n    [\n      SeqFeatureStore,\n      DeferredFeatures,\n      DeferredStats,\n      GlobalStatsEstimationMixin,\n    ],\n\n    /**\n     * @lends JBrowse.Store.SeqFeature.GTF\n     */\n    {\n      constructor: function (args) {\n        this.data = args.blob || new XHRBlob(this.resolveUrl(args.urlTemplate))\n        this.features = []\n        this._loadFeatures()\n      },\n\n      _loadFeatures: function () {\n        var thisB = this\n        var features = (this.bareFeatures = [])\n\n        var featuresSorted = true\n        var seenRefs = (this.refSeqs = {})\n        var parser = new Parser({\n          featureCallback: function (fs) {\n            array.forEach(fs, function (feature) {\n              var prevFeature = features[features.length - 1]\n              var regRefName = thisB.browser.regularizeReferenceName(\n                feature.seq_id,\n              )\n              if (\n                regRefName in seenRefs &&\n                prevFeature &&\n                prevFeature.seq_id != feature.seq_id\n              )\n                {featuresSorted = false}\n              if (\n                prevFeature &&\n                prevFeature.seq_id == feature.seq_id &&\n                feature.start < prevFeature.start\n              )\n                {featuresSorted = false}\n\n              if (!(regRefName in seenRefs))\n                {seenRefs[regRefName] = features.length}\n\n              features.push(feature)\n            })\n          },\n          endCallback: function () {\n            if (!featuresSorted) {\n              features.sort(thisB._compareFeatureData)\n              // need to rebuild the refseq index if changing the sort order\n              thisB._rebuildRefSeqs(features)\n            }\n\n            thisB._estimateGlobalStats().then(function (stats) {\n              thisB.globalStats = stats\n              thisB._deferred.stats.resolve()\n            })\n\n            thisB._deferred.features.resolve(features)\n          },\n        })\n        var fail = lang.hitch(this, '_failAllDeferred')\n        // parse the whole file and store it\n        this.data.fetchLines(\n          function (line) {\n            try {\n              parser.addLine(line)\n            } catch (e) {\n              fail('Error parsing GTF.')\n              throw e\n            }\n          },\n          lang.hitch(parser, 'finish'),\n          fail,\n        )\n      },\n\n      _rebuildRefSeqs: function (features) {\n        var refs = {}\n        for (var i = 0; i < features.length; i++) {\n          var regRefName = this.browser.regularizeReferenceName(\n            features[i].seq_id,\n          )\n\n          if (!(regRefName in refs)) {refs[regRefName] = i}\n        }\n        this.refSeqs = refs\n      },\n\n      _compareFeatureData: function (a, b) {\n        if (a.seq_id < b.seq_id) {return -1}\n        else if (a.seq_id > b.seq_id) {return 1}\n\n        return a.start - b.start\n      },\n\n      _getFeatures: function (\n        query,\n        featureCallback,\n        finishedCallback,\n        errorCallback,\n      ) {\n        var thisB = this\n        thisB._deferred.features.then(function () {\n          thisB._search(query, featureCallback, finishedCallback, errorCallback)\n        })\n      },\n\n      _search: function (\n        query,\n        featureCallback,\n        finishCallback,\n        errorCallback,\n      ) {\n        // search in this.features, which are sorted\n        // by ref and start coordinate, to find the beginning of the\n        // relevant range\n        var bare = this.bareFeatures\n        var converted = this.features\n\n        var refName = this.browser.regularizeReferenceName(query.ref)\n\n        var i = this.refSeqs[refName]\n        if (!(i >= 0)) {\n          finishCallback()\n          return\n        }\n\n        var checkEnd =\n          'start' in query\n            ? function (f) {\n                return f.get('end') >= query.start\n              }\n            : function () {\n                return true\n              }\n\n        for (; i < bare.length; i++) {\n          // lazily convert the bare feature data to JBrowse features\n          var f =\n            converted[i] ||\n            (converted[i] = function (b, i) {\n              bare[i] = false\n              return this._formatFeature(b)\n            }.call(this, bare[i], i))\n          // features are sorted by ref seq and start coord, so we\n          // can stop if we are past the ref seq or the end of the\n          // query region\n          if (f._reg_seq_id != refName || f.get('start') > query.end) {break}\n\n          if (checkEnd(f)) {\n            this.applyFeatureTransforms([f]).forEach(featureCallback)\n          }\n        }\n\n        finishCallback()\n      },\n\n      supportsFeatureTransforms: true,\n\n      _formatFeature: function (data) {\n        var f = new SimpleFeature({\n          data: this._featureData(data),\n          id: (data.attributes.ID || [])[0],\n        })\n        f._reg_seq_id = this.browser.regularizeReferenceName(data.seq_id)\n        return f\n      },\n\n      _featureData: function (data) {\n        var f = lang.mixin({}, data)\n        delete f.child_features\n        delete f.derived_features\n        delete f.attributes\n        f.start -= 1 // convert to interbase\n        for (var a in data.attributes) {\n          f[a.toLowerCase()] = data.attributes[a].join(',')\n        }\n        var sub = array.map(\n          Util.flattenOneLevel(data.child_features),\n          this._featureData,\n          this,\n        )\n        if (sub.length) {f.subfeatures = sub}\n\n        return f\n      },\n\n      /**\n       * Interrogate whether a store has data for a given reference\n       * sequence.  Calls the given callback with either true or false.\n       *\n       * Implemented as a binary interrogation because some stores are\n       * smart enough to regularize reference sequence names, while\n       * others are not.\n       */\n      hasRefSeq: function (seqName, callback, errorCallback) {\n        var thisB = this\n        this._deferred.features.then(function () {\n          callback(\n            thisB.browser.regularizeReferenceName(seqName) in thisB.refSeqs,\n          )\n        })\n      },\n\n      saveStore: function () {\n        return {\n          urlTemplate: this.config.blob.url,\n        }\n      },\n    },\n  )\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/GTF/Parser.js":{"size":9414,"mtime":1738905962003,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/GTF/Parser.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"// the challenge with GTF is that there is no parent relationship\n// every feature line has a gene_id and a transcript_id but there are no ids that uniquely id each feature\n// in eukaryotes a gene can have multiple transcripts\n// in prokaryotes a transcript can have multiple genes\n// here we just create transcript features with children features and let 'gene_ids' simply be attributes not a feature in themselves\n\ndefine([\n  'dojo/_base/declare',\n  'dojo/_base/array',\n  'dojo/_base/lang',\n  'dojo/json',\n  'JBrowse/Util/GTF',\n], function (declare, array, lang, JSON, GTF) {\n  return declare(null, {\n    constructor: function (args) {\n      lang.mixin(this, {\n        featureCallback: args.featureCallback || function () {},\n        endCallback: args.endCallback || function () {},\n        commentCallback: args.commentCallback || function () {},\n        errorCallback:\n          args.errorCallback ||\n          function (e) {\n            console.error(e)\n          },\n        directiveCallback: args.directiveCallback || function () {},\n\n        // features that we have to keep on hand for now because they\n        // might be referenced by something else\n        under_construction_top_level: [],\n        // index of the above by ID\n        under_construction_by_id: {},\n\n        completed_references: {},\n\n        // features that reference something we have not seen yet\n        // structured as:\n        // {  'some_id' : {\n        //     'Parent' : [ orphans that have a Parent attr referencing it ],\n        //     'Derives_from' : [ orphans that have a Derives_from attr referencing it ],\n        // }\n        under_construction_orphans: {},\n\n        // if this is true, the parser ignores the\n        // rest of the lines in the file.  currently\n        // set when the file switches over to FASTA\n        eof: false,\n      })\n    },\n\n    addLine: function (line) {\n      var match\n      if (this.eof) {\n        // do nothing\n      } else if (/^\\s*[^#\\s>]/.test(line)) {\n        //< feature line, most common case\n        var f = GTF.parse_feature(line)\n        this._buffer_feature(f)\n      }\n      // directive or comment\n      else if ((match = /^\\s*(\\#+)(.*)/.exec(line))) {\n        var hashsigns = match[1],\n          contents = match[2]\n        if (hashsigns.length == 3) {\n          //< sync directive, all forward-references are resolved.\n          this._return_all_under_construction_features()\n        } else if (hashsigns.length == 2) {\n          var directive = GTF.parse_directive(line)\n          if (directive.directive == 'FASTA') {\n            this._return_all_under_construction_features()\n            this.eof = true\n          } else {\n            this._return_item(directive)\n          }\n        } else {\n          contents = contents.replace(/\\s*/, '')\n          this._return_item({ comment: contents })\n        }\n      } else if (/^\\s*$/.test(line)) {\n        // blank line, do nothing\n      } else if (/^\\s*>/.test(line)) {\n        // implicit beginning of a FASTA section.  just stop\n        // parsing, since we don't currently handle sequences\n        this._return_all_under_construction_features()\n        this.eof = true\n      } else {\n        // it's a parse error\n        line = line.replace(/\\r?\\n?$/g, '')\n        throw \"GTF parse error.  Cannot parse '\" + line + \"'.\"\n      }\n    },\n\n    _return_item: function (i) {\n      if (i[0]) {this.featureCallback(i)}\n      else if (i.directive) {this.directiveCallback(i)}\n      else if (i.comment) {this.commentCallback(i)}\n    },\n\n    finish: function () {\n      this._return_all_under_construction_features()\n      this.endCallback()\n    },\n\n    /**\n     * return all under-construction features, called when we know\n     * there will be no additional data to attach to them\n     */\n    _return_all_under_construction_features: function () {\n      // since the under_construction_top_level buffer is likely to be\n      // much larger than the item_buffer, we swap them and unshift the\n      // existing buffer onto it to avoid a big copy.\n      array.forEach(this.under_construction_top_level, this._return_item, this)\n\n      this.under_construction_top_level = []\n      this.under_construction_by_id = {}\n      this.completed_references = {}\n\n      // if we have any orphans hanging around still, this is a\n      // problem. die with a parse error\n      for (var o in this.under_construction_orphans) {\n        for (var orphan in o) {\n          throw (\n            'parse error: orphans ' +\n            JSON.stringify(this.under_construction_orphans)\n          )\n        }\n      }\n    },\n\n    container_attributes: {\n      Parent: 'child_features',\n      Derives_from: 'derived_features',\n    },\n    line_number: 0,\n\n    // do the right thing with a newly-parsed feature line\n    _buffer_feature: function (feature_line) {\n      feature_line.child_features = []\n      feature_line.derived_features = []\n\n      // NOTE: a feature is an arrayref of one or more feature lines.\n      this.line_number = this.line_number + 1\n      var feature_number = this.line_number // no such thing as unique ID in GTF. make one up.\n      var is_transcript = feature_line.type == 'transcript' //trying to support the Cufflinks convention of adding a transcript line\n      var ids = is_transcript\n        ? feature_line.attributes.transcript_id || []\n        : [feature_number]\n      var parents = is_transcript\n        ? []\n        : feature_line.attributes.transcript_id || []\n      var derives = feature_line.attributes.Derives_from || []\n\n      if (!ids.length && !parents.length && !derives.length) {\n        // if it has no IDs and does not refer to anything, we can just\n        // output it\n        this._return_item([feature_line])\n        return\n      }\n      array.forEach(\n        parents,\n        function (id) {\n          if (!this.under_construction_by_id[id]) {\n            this._buffer_feature(this._create_transcript(feature_line))\n          }\n        },\n        this,\n      )\n\n      var feature\n      array.forEach(\n        ids,\n        function (id) {\n          var existing\n          if ((existing = this.under_construction_by_id[id])) {\n            // another location of the same feature\n            existing.push(feature_line)\n            feature = existing\n          } else {\n            // haven't seen it yet\n            feature = [feature_line]\n            if (!parents.length && !derives.length) {\n              this.under_construction_top_level.push(feature)\n            }\n            this.under_construction_by_id[id] = feature\n\n            // see if we have anything buffered that refers to it\n            this._resolve_references_to(feature, id)\n          }\n        },\n        this,\n      )\n\n      // try to resolve all its references\n      this._resolve_references_from(\n        feature || [feature_line],\n        { Parent: parents, Derives_from: derives },\n        ids,\n      )\n    },\n\n    _create_transcript: function (feature) {\n      var result = JSON.parse(JSON.stringify(feature))\n      result.type = 'transcript'\n      //result.attributes={'transcript_id':result.attributes.transcript_id, 'gene_id':result.attributes.gene_id};\n      return result\n    },\n\n    //there are no unique ids so no chance for collision just use first elements\n    _expand_feature: function (parent_feature, child_feature) {\n      parent_feature[0].start = Math.min(\n        parent_feature[0].start,\n        child_feature[0].start,\n      )\n      parent_feature[0].end = Math.max(\n        parent_feature[0].end,\n        child_feature[0].end,\n      )\n    },\n\n    _resolve_references_to: function (feature, id) {\n      var references = this.under_construction_orphans[id]\n      if (!references) {return}\n\n      for (var attrname in references) {\n        var pname =\n          this.container_attributes[attrname] || attrname.toLowerCase()\n        array.forEach(feature, function (loc) {\n          loc[pname].push(references[attrname])\n          delete references[attrname]\n        })\n      }\n    },\n    _resolve_references_from: function (feature, references, ids) {\n      // go through our references\n      //  if we have the feature under construction, put this feature in the right place\n      //  otherwise, put this feature in the right slot in the orphans\n\n      var pname\n      for (var attrname in references) {\n        array.forEach(\n          references[attrname],\n          function (to_id) {\n            var other_feature\n            if ((other_feature = this.under_construction_by_id[to_id])) {\n              this._expand_feature(other_feature, feature)\n              if (!pname)\n                {pname =\n                  this.container_attributes[attrname] || attrname.toLowerCase()}\n              if (\n                !array.some(\n                  ids,\n                  function (i) {\n                    return this.completed_references[\n                      i + ',' + attrname + ',' + to_id\n                    ]++\n                  },\n                  this,\n                )\n              ) {\n                array.forEach(other_feature, function (loc) {\n                  loc[pname].push(feature)\n                })\n              }\n            } else {\n              ;(this.under_construction_orphans[to_id][attrname] =\n                this.under_construction_orphans[to_id][attrname] || []).push(\n                feature,\n              )\n            }\n          },\n          this,\n        )\n      }\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/IndexedFasta.js":{"size":3783,"mtime":1738905962009,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/IndexedFasta.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"const LRU = cjsRequire('quick-lru')\nconst { IndexedFasta } = cjsRequire('@gmod/indexedfasta')\nconst { Buffer } = cjsRequire('buffer')\n\nconst fastaIndexedFilesCache = new LRU({ maxSize: 5 })\n\nconst BlobFilehandleWrapper = cjsRequire('../../Model/BlobFilehandleWrapper')\n\ndefine([\n  'dojo/_base/declare',\n  'JBrowse/Store/SeqFeature',\n  'JBrowse/Model/XHRBlob',\n  'JBrowse/Model/SimpleFeature',\n  'JBrowse/Store/DeferredFeaturesMixin',\n], function (\n  declare,\n  SeqFeatureStore,\n  XHRBlob,\n  SimpleFeature,\n  DeferredFeaturesMixin,\n) {\n  return declare([SeqFeatureStore, DeferredFeaturesMixin], {\n    /**\n     * Storage backend for sequences in indexed fasta files\n     * served as static text files.\n     * @constructs\n     */\n    constructor: function (args) {\n      let dataBlob\n      if (args.fasta) {dataBlob = new BlobFilehandleWrapper(args.fasta)}\n      else if (args.urlTemplate)\n        {dataBlob = new BlobFilehandleWrapper(\n          new XHRBlob(this.resolveUrl(args.urlTemplate), {\n            expectRanges: true,\n          }),\n        )}\n      else\n        {dataBlob = new BlobFilehandleWrapper(\n          new XHRBlob('data.fa', { expectRanges: true }),\n        )}\n\n      let indexBlob\n      if (args.fai) {indexBlob = new BlobFilehandleWrapper(args.fai)}\n      else if (args.faiUrlTemplate)\n        {indexBlob = new BlobFilehandleWrapper(\n          new XHRBlob(this.resolveUrl(args.faiUrlTemplate)),\n        )}\n      else if (args.urlTemplate)\n        {indexBlob = new BlobFilehandleWrapper(\n          new XHRBlob(this.resolveUrl(args.urlTemplate + '.fai')),\n        )}\n      else {throw new Error('no index provided, must provide a FASTA index')}\n\n      this.source = dataBlob.toString()\n\n      // LRU-cache the FASTA object so we don't have to re-download the\n      // index when we switch chromosomes\n      const cacheKey = `data: ${dataBlob}, index: ${indexBlob}`\n      this.fasta = fastaIndexedFilesCache.get(cacheKey)\n      if (!this.fasta) {\n        this.fasta = new IndexedFasta({\n          fasta: dataBlob,\n          fai: indexBlob,\n          chunkSizeLimit: args.chunkSizeLimit || 1000000,\n        })\n\n        fastaIndexedFilesCache.set(cacheKey, this.fasta)\n      }\n      this.fasta.getSequenceList().then(() => {\n        this._deferred.features.resolve({ success: true })\n      }, this._failAllDeferred.bind(this))\n    },\n\n    _getFeatures: function (query, featCallback, endCallback, errorCallback) {\n      if (query.start < 0) {\n        query.start = 0\n      }\n      var refname = query.ref\n      // if they both regularize to the same thing, use this.refSeq.name since that is guaranteed to be from refseq store\n      if (!this.browser.compareReferenceNames(this.refSeq.name, refname))\n        {refname = this.refSeq.name}\n\n      this.fasta\n        .getResiduesByName(refname, query.start, query.end)\n        .then(seq => {\n          featCallback(\n            new SimpleFeature({\n              data: { seq, start: query.start, end: query.end },\n            }),\n          )\n          endCallback()\n        }, errorCallback)\n    },\n    hasRefSeq: function (seqName, callback, errorCallback) {\n      this.fasta.getSequenceSize(seqName).then(size => {\n        callback(size !== undefined)\n      }, errorCallback)\n    },\n    getRefSeqs: function (callback, errorCallback) {\n      this.fasta\n        .getSequenceSizes()\n        .then(sizes =>\n          Object.entries(sizes).map(([name, length]) => {\n            return {\n              name,\n              length,\n              end: length,\n              start: 0,\n            }\n          }),\n        )\n        .then(callback, errorCallback)\n    },\n\n    saveStore: function () {\n      return {\n        urlTemplate: (this.config.file || this.config.blob).url,\n        faiUrlTemplate: this.config.fai.url,\n      }\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/IndexedStatsEstimationMixin.js":{"size":1232,"mtime":1738905962014,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/IndexedStatsEstimationMixin.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/Mask.js":{"size":8036,"mtime":1738905962024,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/Mask.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'dojo/_base/array',\n  'dojo/Deferred',\n  'dojo/when',\n  'dojo/promise/all',\n  'JBrowse/Store/SeqFeature',\n  'JBrowse/Model/SimpleFeature',\n  'JBrowse/Model/BinaryTreeNode',\n  'JBrowse/Util',\n], function (\n  declare,\n  array,\n  Deferred,\n  when,\n  all,\n  SeqFeatureStore,\n  SimpleFeature,\n  TreeNode,\n  Util,\n) {\n  return declare([SeqFeatureStore], {\n    // A store that takes in two feature stores (one of them set-based e.g. NCList) and uses the data from one store as a mask\n    // for the other.  Although the design resembles those of combinationStores, differences are substantial enough that\n    // this class does not derive from CombinationBase.\n\n    constructor: function (args) {\n      this.isCombinationStore = true\n      this.inverse = args.inverse || false\n      this.stores = {}\n\n      if (args.mask && args.display) {\n        this.reload(args.mask, args.display)\n      }\n    },\n\n    // Loads an opTree (optionally), and a mask and display store.  Ensure all stores exist,\n    // and build an operation tree for the benefit of combination tracks.\n    reload: function (opTree, mask, display) {\n      var inverse\n\n      this.gotAllStores = new Deferred()\n      if (opTree) {\n        this.opTree = opTree\n        this.inverse = inverse === undefined ? opTree.get() == 'N' : inverse\n        this.stores.mask =\n          opTree.leftChild && !mask ? opTree.leftChild.get() : mask\n        this.stores.display =\n          opTree.rightChild && !display ? opTree.rightChild.get() : display\n        this.gotAllStores.resolve(true)\n      } else {\n        if (inverse !== undefined) {\n          this.inverse = inverse\n        }\n        this.opTree = new TreeNode({ Value: this.inverse ? 'N' : 'M' })\n        this.stores.mask = mask\n        this.stores.display = display\n        var thisB = this\n\n        var grabStore = function (store) {\n          var haveStore = new Deferred()\n          if (typeof store == 'string') {\n            thisB.browser.getStore(store, function (result) {\n              if (result) {\n                haveStore.resolve(result, true)\n              } else {\n                haveStore.reject('store ' + store + ' not found')\n              }\n            })\n          } else {\n            haveStore.resolve(store, true)\n          }\n          return haveStore.promise\n        }\n\n        var haveMaskStore = grabStore(this.stores.mask).then(function (store) {\n          thisB.stores.mask = store\n        })\n        var haveDisplayStore = grabStore(this.stores.display).then(\n          function (store) {\n            thisB.stores.display = store\n          },\n        )\n        this.gotAllStores = all([haveMaskStore, haveDisplayStore])\n        this.gotAllStores.then(function () {\n          thisB.opTree.leftChild = thisB.stores.mask.isCombinationStore\n            ? thisB.stores.mask.opTree\n            : new TreeNode({ Value: thisB.stores.mask })\n          thisB.opTree.rightChild = thisB.stores.display.isCombinationStore\n            ? thisB.stores.display.opTree\n            : new TreeNode({ Value: thisB.stores.display })\n        })\n      }\n    },\n\n    // The global stats of this store should be the same as those for the display data.\n    getGlobalStats: function (callback, errorCallback) {\n      this.stores.display.getGlobalStats(callback, errorCallback)\n    },\n\n    // The regional stats of this store should be the same as those for the display data.\n    getRegionStats: function (query, callback, errorCallback) {\n      this.stores.display.getRegionStats(query, callback, errorCallback)\n    },\n\n    // Gets the features from the mask and display stores, and then returns the display store features with the mask store features\n    // added as masks\n    getFeatures: function (query, featCallback, doneCallback, errorCallback) {\n      var thisB = this\n\n      this.gotAllStores.then(function () {\n        var featureArray = {}\n\n        // Get features from one particular store\n        var grabFeats = function (key) {\n          var d = new Deferred()\n          featureArray[key] = []\n\n          thisB.stores[key].getFeatures(\n            query,\n            function (feature) {\n              featureArray[key].push(feature)\n            },\n            function () {\n              d.resolve(true)\n            },\n            function () {\n              d.reject('failed to load features for ' + key + ' store')\n            },\n          )\n          return d.promise\n        }\n\n        when(\n          all([grabFeats('mask'), grabFeats('display')]),\n          function () {\n            // Convert mask features into simplified spans\n            var spans = thisB.toSpans(featureArray.mask, query)\n            // invert masking spans if necessary\n            spans = thisB.inverse ? thisB.notSpan(spans, query) : spans\n            var features = featureArray.display\n\n            thisB.maskFeatures(features, spans, featCallback, doneCallback)\n          },\n          errorCallback,\n        )\n      }, errorCallback)\n    },\n\n    // given a feature or pseudo-feature, returns true if the feature\n    // overlaps the span. False otherwise.\n    inSpan: function (feature, span) {\n      if (!feature || !span) {\n        console.error('invalid arguments to inSpan function')\n      }\n      return feature.get\n        ? !(\n            feature.get('start') >= span.end || feature.get('end') <= span.start\n          )\n        : !(feature.start >= span.end || feature.end <= span.start)\n    },\n\n    maskFeatures: function (features, spans, featCallback, doneCallback) {\n      /* Pass features to the track's original featCallback, and pass spans to the doneCallback.\n       * If the track has boolean support, the DoneCallback will use the spans to mask the features.\n       * For glyph based tracks, the masks passed to each feature will be used to do masking.\n       */\n      for (var key in features) {\n        if (features.hasOwnProperty(key)) {\n          var feat = features[key]\n          delete feat.masks\n          for (var span in spans) {\n            if (spans.hasOwnProperty(span) && this.inSpan(feat, spans[span])) {\n              // add masks to the feature. Used by Glyphs to do masking.\n              feat.masks = feat.masks\n                ? feat.masks.concat([spans[span]])\n                : [spans[span]]\n            }\n          }\n          featCallback(features[key])\n        }\n      }\n      doneCallback({ maskingSpans: spans })\n    },\n\n    notSpan: function (spans, query) {\n      // creates the complement spans of the input spans\n      var invSpan = []\n      invSpan[0] = { start: query.start }\n      var i = 0\n      for (var span in spans) {\n        if (spans.hasOwnProperty(span)) {\n          span = spans[span]\n          invSpan[i].end = span.start\n          i++\n          invSpan[i] = { start: span.end }\n        }\n      }\n      invSpan[i].end = query.end\n      if (invSpan[i].end <= invSpan[i].start) {\n        invSpan.splice(i, 1)\n      }\n      if (invSpan[0].end <= invSpan[0].start) {\n        invSpan.splice(0, 1)\n      }\n      return invSpan\n    },\n\n    toSpans: function (features, query) {\n      // given a set of features, takes the \"union\" of them and outputs a single set of nonoverlapping spans\n      var spans = []\n      for (var feature in features) {\n        if (features.hasOwnProperty(feature)) {\n          spans.push({\n            start: features[feature].get('start'), //Math.max( features[feature].get('start'), query.start ),\n            end: features[feature].get('end'), //Math.min( features[feature].get('end'),   query.end   )\n          })\n        }\n      }\n\n      if (!spans.length) {return []}\n      spans.sort(function (a, b) {\n        return a.start - b.start\n      })\n\n      var retSpans = []\n      var i = 0\n      while (i < spans.length) {\n        var start = spans[i].start\n        var end = spans[i].end\n        while (i < spans.length && spans[i].start <= end) {\n          end = Math.max(end, spans[i].end)\n          i++\n        }\n        retSpans.push({ start: start, end: end })\n      }\n      return retSpans\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/NCList_v0.js":{"size":5958,"mtime":1738905962032,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/NCList_v0.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'dojo/Deferred',\n  'JBrowse/Store/SeqFeature/NCList',\n  'JBrowse/Store/NCList_v0',\n  'JBrowse/Store/LazyArray',\n], function (declare, Deferred, SFNCList, GenericNCList, LazyArray) {\n  return declare(\n    SFNCList,\n\n    /**\n     * @lends JBrowse.Store.SeqFeature.NCList_v0\n     */\n    {\n      /**\n       * Feature storage backend for backward-compatibility with JBrowse 1.2.1 stores.\n       * @extends SeqFeatureStore.NCList\n       * @constructs\n       */\n      constructor: function (args) {\n        this.fields = {}\n        this.track = new Deferred()\n        if (args.track) {this.track.resolve(args.track)}\n      },\n\n      setTrack: function (t) {\n        if (!this.track.isFulfilled()) {this.track.resolve(t)}\n      },\n\n      /**\n       * Delete an object member and return the deleted value.\n       * @private\n       */\n      _del: function (obj, old) {\n        var x = obj[old]\n        delete obj[old]\n        return x\n      },\n\n      _handleTrackInfo: function (refData, trackInfo, url) {\n        if (trackInfo) {\n          // munge the trackInfo to make the histogram stuff work with v1 code\n          dojo.forEach(trackInfo.histogramMeta, function (m) {\n            m.arrayParams.urlTemplate = m.arrayParams.urlTemplate.replace(\n              /\\{chunk\\}/,\n              '{Chunk}',\n            )\n          })\n          trackInfo.histograms = {\n            meta: this._del(trackInfo, 'histogramMeta'),\n            stats: this._del(trackInfo, 'histStats'),\n          }\n          // rename stats.bases to stats.basesPerBin\n          dojo.forEach(\n            trackInfo.histograms.stats,\n            function (s) {\n              s.basesPerBin = this._del(s, 'bases')\n            },\n            this,\n          )\n\n          // since the old format had style information inside the\n          // trackdata file, yuckily push it up to the track's config.style\n          var renameVar = {\n            urlTemplate: 'linkTemplate',\n          }\n\n          this.track.then(function (track) {\n            dojo.forEach(\n              [\n                'className',\n                'arrowheadClass',\n                'subfeatureClasses',\n                'urlTemplate',\n                'clientConfig',\n              ],\n              function (varname) {\n                if (!track.config.style) {track.config.style = {}}\n                var dest_varname = renameVar[varname] || varname\n                if (varname in trackInfo)\n                  {track.config.style[dest_varname] = trackInfo[varname]}\n              },\n              this,\n            )\n\n            // also need to merge Ye Olde clientConfig values into the style object\n            if (track.config.style.clientConfig) {\n              track.config.style = dojo.mixin(\n                track.config.style,\n                track.config.style.clientConfig,\n              )\n              delete track.config.style.clientConfig\n            }\n          })\n\n          // remember the field offsets from the old-style trackinfo headers\n          refData.fields = {}\n          refData.fieldOrder = []\n          var i\n          for (i = 0; i < trackInfo.headers.length; i++) {\n            refData.fieldOrder.push(trackInfo.headers[i])\n            refData.fields[trackInfo.headers[i]] = i\n          }\n          refData.subFields = {}\n          refData.subFieldOrder = []\n          if (trackInfo.subfeatureHeaders) {\n            for (i = 0; i < trackInfo.subfeatureHeaders.length; i++) {\n              refData.subFieldOrder.push(trackInfo.subfeatureHeaders[i])\n              refData.subFields[trackInfo.subfeatureHeaders[i]] = i\n            }\n          }\n\n          refData.stats = {\n            featureCount: trackInfo.featureCount,\n            featureDensity: trackInfo.featureCount / this.refSeq.length,\n          }\n\n          this.loadNCList(refData, trackInfo, url)\n\n          var histograms = trackInfo.histograms\n          if (histograms && histograms.meta) {\n            for (var i = 0; i < histograms.meta.length; i++) {\n              histograms.meta[i].lazyArray = new LazyArray(\n                histograms.meta[i].arrayParams,\n                url,\n              )\n            }\n            refData._histograms = histograms\n          }\n\n          this._deferred.root.resolve(refData)\n        }\n      },\n\n      makeNCList: function () {\n        return new GenericNCList()\n      },\n\n      loadNCList: function (refData, trackInfo, url) {\n        refData.nclist.importExisting(\n          trackInfo.featureNCList,\n          trackInfo.sublistIndex,\n          trackInfo.lazyIndex,\n          url,\n          trackInfo.lazyfeatureUrlTemplate,\n        )\n      },\n\n      _getFeatures: function (\n        data,\n        query,\n        origFeatCallback,\n        finishCallback,\n        errorCallback,\n      ) {\n        var that = this,\n          startBase = query.start,\n          endBase = query.end,\n          fields = data.fields,\n          fieldOrder = data.fieldOrder,\n          subFields = data.subFields,\n          subfieldOrder = data.subfieldOrder,\n          get = function (fieldname) {\n            var f = fields[fieldname]\n            if (f >= 0) {return this[f]}\n            else {return undefined}\n          },\n          subget = function (fieldname) {\n            var f = subFields[fieldname]\n            if (f >= 0) {return this[f]}\n            else {return undefined}\n          },\n          tags = function () {\n            return fieldOrder\n          },\n          subTags = function () {\n            return subfieldOrder\n          },\n          featCallBack = function (feature, path) {\n            that._decorate_feature(\n              { get: get, tags: tags },\n              feature,\n              path.join(','),\n            )\n            return origFeatCallback(feature, path)\n          }\n\n        return data.nclist.iterate.call(\n          data.nclist,\n          startBase,\n          endBase,\n          featCallBack,\n          finishCallback,\n        )\n      },\n    },\n  )\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/NCList.js":{"size":10067,"mtime":1738905962046,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/NCList.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'dojo/_base/lang',\n  'dojo/Deferred',\n  'dojo/request/xhr',\n  'JBrowse/Store/SeqFeature',\n  'JBrowse/Store/DeferredFeaturesMixin',\n  'JBrowse/Store/DeferredStatsMixin',\n  'JBrowse/Util',\n  'JBrowse/Model/ArrayRepr',\n  'JBrowse/Store/NCList',\n  'JBrowse/Store/LazyArray',\n], function (\n  declare,\n  lang,\n  Deferred,\n  xhr,\n  SeqFeatureStore,\n  DeferredFeaturesMixin,\n  DeferredStatsMixin,\n  Util,\n  ArrayRepr,\n  GenericNCList,\n  LazyArray,\n) {\n  /**\n   * Implementation of SeqFeatureStore using nested containment\n   * lists held in static files that are lazily fetched from the web\n   * server.\n   *\n   * @class JBrowse.Store.SeqFeature.NCList\n   * @extends SeqFeatureStore\n   */\n\n  var idfunc = function () {\n    return this._uniqueID\n  }\n  var parentfunc = function () {\n    return this._parent\n  }\n  var childrenfunc = function () {\n    return this.get('subfeatures')\n  }\n\n  return declare(SeqFeatureStore, {\n    constructor: function (args) {\n      this.args = args\n\n      this.baseUrl = args.baseUrl\n      this.urlTemplates = { root: args.urlTemplate }\n\n      this._deferred = {}\n    },\n\n    makeNCList: function () {\n      return new GenericNCList()\n    },\n\n    loadNCList: function (refData, trackInfo, url) {\n      refData.nclist.importExisting(\n        trackInfo.intervals.nclist,\n        refData.attrs,\n        url,\n        trackInfo.intervals.urlTemplate,\n        trackInfo.intervals.lazyClass,\n      )\n    },\n\n    getDataRoot: function (refName) {\n      if (!this._deferred.root || this.curRefName != refName) {\n        var d = (this._deferred.root = new Deferred())\n        this.curRefName = refName\n\n        var refData = {\n          nclist: this.makeNCList(),\n        }\n\n        var url = this.resolveUrl(this._evalConf(this.urlTemplates.root), {\n          refseq: refName,\n        })\n\n        // fetch the trackdata\n        var thisB = this\n        xhr\n          .get(url, {\n            handleAs: 'json',\n            failOk: true,\n            headers: {\n              'X-Requested-With': null,\n            },\n          })\n          .then(\n            function (trackInfo, request) {\n              //trackInfo = JSON.parse( trackInfo );\n              thisB._handleTrackInfo(refData, trackInfo, url)\n            },\n            function (error) {\n              if (Util.isElectron() || error.response.status == 404) {\n                thisB._handleTrackInfo(refData, {}, url)\n              } else if (error.response.status != 200) {\n                thisB._failAllDeferred(\n                  'Server returned an HTTP ' + error.response.status + ' error',\n                )\n              } else {thisB._failAllDeferred(error)}\n            },\n          )\n      }\n      return this._deferred.root\n    },\n\n    _handleTrackInfo: function (refData, trackInfo, url) {\n      refData.stats = {\n        featureCount: trackInfo.featureCount || 0,\n        featureDensity: (trackInfo.featureCount || 0) / this.refSeq.length,\n      }\n\n      this.empty = !trackInfo.featureCount\n\n      if (trackInfo.intervals) {\n        refData.attrs = new ArrayRepr(trackInfo.intervals.classes)\n        this.loadNCList(refData, trackInfo, url)\n      }\n\n      var histograms = trackInfo.histograms\n      if (histograms && histograms.meta) {\n        for (var i = 0; i < histograms.meta.length; i++) {\n          histograms.meta[i].lazyArray = new LazyArray(\n            histograms.meta[i].arrayParams,\n            url,\n          )\n        }\n        refData._histograms = histograms\n      }\n\n      this._deferred.root.resolve(refData)\n    },\n\n    getGlobalStats: function (successCallback, errorCallback) {\n      return (\n        this._deferred.root || this.getDataRoot(this.browser.refSeq.name)\n      ).then(function (data) {\n        successCallback(data.stats)\n      }, errorCallback)\n    },\n\n    getRegionStats: function (query, successCallback, errorCallback) {\n      this.getDataRoot(query.ref).then(function (data) {\n        successCallback(data.stats)\n      }, errorCallback)\n    },\n\n    getRegionFeatureDensities: function (\n      query,\n      successCallback,\n      errorCallback,\n    ) {\n      this.getDataRoot(query.ref)\n        .then(function (data) {\n          var numBins, basesPerBin\n          if (query.numBins) {\n            numBins = query.numBins\n            basesPerBin = (query.end - query.start) / numBins\n          } else if (query.basesPerBin) {\n            basesPerBin = query.basesPerBin\n            numBins = Math.ceil((query.end - query.start) / basesPerBin)\n          } else {\n            throw new Error(\n              'numBins or basesPerBin arg required for getRegionFeatureDensities',\n            )\n          }\n\n          // pick the relevant entry in our pre-calculated stats\n          var statEntry = (function (basesPerBin, stats) {\n            for (var i = 0; i < stats.length; i++) {\n              if (stats[i].basesPerBin >= basesPerBin) {\n                return stats[i]\n              }\n            }\n            return undefined\n          })(basesPerBin, data._histograms.stats || [])\n\n          // The histogramMeta array describes multiple levels of histogram detail,\n          // going from the finest (smallest number of bases per bin) to the\n          // coarsest (largest number of bases per bin).\n          // We want to use coarsest histogramMeta that's at least as fine as the\n          // one we're currently rendering.\n          // TODO: take into account that the histogramMeta chosen here might not\n          // fit neatly into the current histogram (e.g., if the current histogram\n          // is at 50,000 bases/bin, and we have server histograms at 20,000\n          // and 2,000 bases/bin, then we should choose the 2,000 histogramMeta\n          // rather than the 20,000)\n          var histogramMeta = data._histograms.meta[0]\n          for (var i = 0; i < data._histograms.meta.length; i++) {\n            if (basesPerBin >= data._histograms.meta[i].basesPerBin)\n              {histogramMeta = data._histograms.meta[i]}\n          }\n\n          // number of bins in the server-supplied histogram for each current bin\n          var binRatio = basesPerBin / ((histogramMeta || {}).basesPerBin || 1)\n\n          // if the server-supplied histogram fits neatly into our requested\n          if (\n            binRatio > 0.9 &&\n            Math.abs(binRatio - Math.round(binRatio)) < 0.0001\n          ) {\n            //console.log('server-supplied',query);\n            // we can use the server-supplied counts\n            var firstServerBin = Math.floor(\n              query.start / histogramMeta.basesPerBin,\n            )\n            binRatio = Math.round(binRatio)\n            var histogram = []\n            for (var bin = 0; bin < numBins; bin++) {histogram[bin] = 0}\n\n            histogramMeta.lazyArray.range(\n              firstServerBin,\n              firstServerBin + binRatio * numBins,\n              function (i, val) {\n                // this will count features that span the boundaries of\n                // the original histogram multiple times, so it's not\n                // perfectly quantitative.  Hopefully it's still useful, though.\n                histogram[Math.floor((i - firstServerBin) / binRatio)] += val\n              },\n              function () {\n                successCallback({\n                  bins: histogram,\n                  stats: statEntry,\n                })\n              },\n            )\n          } else {\n            //console.log('make own',query);\n            // make our own counts\n            data.nclist.histogram.call(\n              data.nclist,\n              query.start,\n              query.end,\n              numBins,\n              function (hist) {\n                successCallback({\n                  bins: hist,\n                  stats: statEntry,\n                })\n              },\n            )\n          }\n        })\n        .catch(errorCallback)\n    },\n\n    getFeatures: function (\n      query,\n      origFeatCallback,\n      finishCallback,\n      errorCallback,\n    ) {\n      if (this.empty) {\n        finishCallback()\n        return\n      }\n\n      var thisB = this\n      this.getDataRoot(query.ref).then(function (data) {\n        thisB._getFeatures(\n          data,\n          query,\n          origFeatCallback,\n          finishCallback,\n          errorCallback,\n        )\n      }, errorCallback)\n    },\n\n    _getFeatures: function (\n      data,\n      query,\n      origFeatCallback,\n      finishCallback,\n      errorCallback,\n    ) {\n      var thisB = this\n      var startBase = query.start\n      var endBase = query.end\n      var accessors = data.attrs.accessors(),\n        /** @inner */\n        featCallBack = function (feature, path) {\n          // the unique ID is a stringification of the path in the\n          // NCList where the feature lives; it's unique across the\n          // top-level NCList (the top-level NCList covers a\n          // track/chromosome combination)\n\n          // only need to decorate a feature once\n          if (!feature.decorated) {\n            var uniqueID = path.join(',')\n            thisB._decorate_feature(accessors, feature, uniqueID)\n          }\n          return origFeatCallback(feature)\n        }\n\n      data.nclist.iterate.call(\n        data.nclist,\n        startBase,\n        endBase,\n        featCallBack,\n        finishCallback,\n        errorCallback,\n      )\n    },\n\n    // helper method to recursively add .get and .tags methods to a feature and its\n    // subfeatures\n    _decorate_feature: function (accessors, feature, id, parent) {\n      feature.get = accessors.get\n      // possibly include set method in decorations? not currently\n      //    feature.set = accessors.set;\n      feature.tags = accessors.tags\n      feature._uniqueID = id\n      feature.id = idfunc\n      feature._parent = parent\n      feature.parent = parentfunc\n      feature.children = childrenfunc\n      dojo.forEach(\n        feature.get('subfeatures'),\n        function (f, i) {\n          this._decorate_feature(accessors, f, id + '-' + i, feature)\n        },\n        this,\n      )\n      feature.decorated = true\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/QuantitativeCombination.js":{"size":6280,"mtime":1738905962060,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/QuantitativeCombination.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'dojo/_base/array',\n  'JBrowse/Store/SeqFeature/CombinationBase',\n], function (declare, array, CombinationBaseStore) {\n  // Plagiarized from Store/SeqFeature/Bigwig/RequestWorker to create BigWig features\n  var gettable = declare(null, {\n    get: function (name) {\n      return this[\n        { start: 'start', end: 'end', seq_id: 'segment' }[name] || name\n      ]\n    },\n    tags: function () {\n      return ['start', 'end', 'seq_id', 'score', 'type', 'source']\n    },\n  })\n  var Feature = declare(gettable, {})\n\n  return declare([CombinationBaseStore], {\n    // An implementation of CombinationBase that deals with quantitative features (with score, as with BigWig features).\n    // Usual operations are things like addition, subtraction, multiplication, and division.\n\n    // Applies a given operation on two scores.\n    applyOp: function (scoreA, scoreB, op) {\n      var retValue\n      switch (op) {\n        case '+':\n          retValue = scoreA + scoreB\n          break\n        case '-':\n          retValue = scoreA - scoreB\n          break\n        case '*':\n          retValue = scoreA * scoreB\n          break\n        case '/':\n          retValue = scoreB == 0 ? undefined : scoreA / scoreB\n          break\n        default:\n          console.error('invalid operation ' + op)\n          return undefined\n      }\n      return retValue\n    },\n\n    // Converts a list of spans to a list of features.\n    createFeatures: function (spans) {\n      var features = []\n      for (var span in spans) {\n        var f = new Feature()\n        f.start = spans[span].start\n        f.end = spans[span].end\n        f.score = spans[span].score\n        if (spans[span].segment) {f.segment = spans[span].segment}\n        if (spans[span].type) {f.type = spans[span].type}\n        f.source = this.name\n\n        features.push(f)\n      }\n      return features\n    },\n\n    // Loops through two sets of pseudo-features (spans).  At any region for which both sets have features defined,\n    // applies the given operation on those features.  Otherwise, uses whichever one is defined.\n    opSpan: function (op, pseudosA, pseudosB, query) {\n      var retPseudos = []\n      var i = 0\n      var j = 0\n\n      if (!pseudosA.length && !pseudosB.length) {return retPseudos}\n\n      // Critical values are the starts and ends of features for either set of spans.\n      // nextCritical will iterate through all critical values.\n      var nextCritical = pseudosA[i]\n        ? pseudosB[j]\n          ? Math.min(pseudosA[i].start, pseudosB[j].start)\n          : pseudosA[i].start\n        : pseudosB[j].start\n\n      var inA\n      var inB\n\n      while (i < pseudosA.length && j < pseudosB.length) {\n        // Decide whether to add a span to the list at all - we don't add spans if the gap from this critical point to the\n        // next critical point is not inside any feature.\n        if (nextCritical == pseudosA[i].start) {inA = true}\n        if (nextCritical == pseudosB[j].start) {inB = true}\n        var addPseudo = inA || inB\n        var newPseudo\n        // If we're inside at least one pseudo-feature, adds data for the current feature.\n        if (addPseudo) {\n          newPseudo = {\n            start: nextCritical,\n            score: this.applyOp(\n              inA ? pseudosA[i].score : 0,\n              inB ? pseudosB[j].score : 0,\n              op,\n            ),\n          }\n          if (inA != inB || pseudosA[i].segment == pseudosB[j].segment) {\n            newPseudo.segment = inA ? pseudosA[i].segment : pseudosB[j].segment\n          }\n          if (inA != inB || pseudosA[i].type == pseudosB[j].type) {\n            newPseudo.type = inA ? pseudosA[i].type : pseudosB[j].type\n          }\n        }\n        // Dividing by zero or other invalid operation being performed, don't add the feature\n        if (newPseudo.score === undefined) {addPseudo = false}\n\n        // Fetches the next critical point (the next base pair greater than the current nextCritical value\n        //    that is either the beginning or the end of a pseudo)\n        var _possibleCriticals = [\n          pseudosA[i].start,\n          pseudosA[i].end,\n          pseudosB[j].start,\n          pseudosB[j].end,\n        ]\n\n        _possibleCriticals = array\n          .filter(_possibleCriticals, function (item) {\n            return item > nextCritical\n          })\n          .sort(function (a, b) {\n            return a - b\n          })\n\n        nextCritical = _possibleCriticals[0]\n        if (!nextCritical) {break}\n\n        // Determines whether the next pseudo to be created will use data from pseudosA or pseudosB or both\n        if (nextCritical == pseudosA[i].end) {\n          inA = false\n          i++\n        }\n        if (nextCritical == pseudosB[j].end) {\n          inB = false\n          j++\n        }\n\n        // If there is currently a pseudo-feature being built, adds it\n        if (addPseudo) {\n          newPseudo.end = nextCritical\n\n          retPseudos.push(newPseudo)\n        }\n      }\n\n      // If some pseudofeatures remain in either pseudo set, they are pushed as is into the return pseudo set.\n      for (; i < pseudosA.length; i++) {\n        retPseudos.push({\n          start: Math.max(nextCritical, pseudosA[i].start),\n          end: pseudosA[i].end,\n          score: this.applyOp(pseudosA[i].score, 0, op),\n          segment: pseudosA[i].segment,\n          type: pseudosA[i].type,\n        })\n      }\n      for (; j < pseudosB.length; j++) {\n        retPseudos.push({\n          start: Math.max(nextCritical, pseudosB[j].start),\n          end: pseudosB[j].end,\n          score: this.applyOp(0, pseudosB[j].score, op),\n          segment: pseudosB[j].segment,\n          type: pseudosB[j].type,\n        })\n      }\n      return retPseudos\n    },\n\n    toSpan: function (features, query) {\n      // given a set of features, creates a set of pseudo-features with similar properties.\n      var pseudos = []\n      for (var feature in features) {\n        var pseudo = {\n          start: features[feature].get('start'),\n          end: features[feature].get('end'),\n          score: features[feature].get('score'),\n          segment: features[feature].get('segment'),\n          type: features[feature].get('type'),\n        }\n        pseudos.push(pseudo)\n      }\n      return pseudos\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/RegionStatsMixin.js":{"size":2200,"mtime":1738905962065,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/RegionStatsMixin.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/REST.js":{"size":11471,"mtime":1738905962078,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/REST.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"/**\n * Store that gets data from any set of web services that implement\n * the JBrowse REST API.\n */\ndefine([\n  'dojo/_base/declare',\n  'dojo/_base/lang',\n  'dojo/_base/array',\n  'dojo/io-query',\n  'dojo/request',\n  'dojo/Deferred',\n  'JBrowse/Store/LRUCache',\n  'JBrowse/Store/SeqFeature',\n  'JBrowse/Store/DeferredFeaturesMixin',\n  'JBrowse/Store/DeferredStatsMixin',\n  'JBrowse/Util',\n  'JBrowse/Model/SimpleFeature',\n], function (\n  declare,\n  lang,\n  array,\n  ioquery,\n  dojoRequest,\n  Deferred,\n  LRUCache,\n  SeqFeatureStore,\n  DeferredFeaturesMixin,\n  DeferredStatsMixin,\n  Util,\n  SimpleFeature,\n) {\n  return declare(SeqFeatureStore, {\n    constructor: function (args) {\n      this.region_cache_hits = 0 //< stats mostly for unit tests\n\n      // make sure the baseUrl has a trailing slash\n      this.baseUrl = args.baseUrl || this.config.baseUrl\n      if (this.baseUrl.charAt(this.baseUrl.length - 1) != '/')\n        {this.baseUrl = this.baseUrl + '/'}\n\n      // enable feature density bin fetching if turned on\n      if (\n        this.config.region_feature_densities &&\n        !this.getRegionFeatureDensities\n      ) {\n        this.getRegionFeatureDensities = this._getRegionFeatureDensities\n      }\n    },\n\n    _defaultConfig: function () {\n      return {\n        noCache: false,\n      }\n    },\n\n    getGlobalStats: function (callback, errorCallback) {\n      var url = this._makeURL('stats/global')\n      this._get({ url: url, type: 'globalStats' }, callback, errorCallback)\n    },\n\n    getRegionStats: function (query, successCallback, errorCallback) {\n      if (!this.config.region_stats) {\n        this._getRegionStats.apply(this, arguments)\n        return\n      }\n\n      query = this._assembleQuery(query)\n      var url = this._makeURL('stats/region', query)\n      this._get(\n        { url: url, query: query, type: 'regionStats' },\n        successCallback,\n        errorCallback,\n      )\n    },\n\n    getFeatures: function (query, featureCallback, endCallback, errorCallback) {\n      var thisB = this\n      query = this._assembleQuery(query)\n      var url = this._makeURL('features', query)\n\n      // look for cached feature regions if configured to do so\n      var cachedFeatureRegions\n      if (\n        this.config.feature_range_cache &&\n        !this.config.noCache &&\n        (cachedFeatureRegions = this._getCachedFeatureRegions(query))\n      ) {\n        this.region_cache_hits++\n        this._makeFeaturesFromCachedRegions(\n          cachedFeatureRegions,\n          query,\n          featureCallback,\n          endCallback,\n          errorCallback,\n        )\n      }\n      // otherwise just fetch and cache like all the other requests\n      else {\n        this._get(\n          { url: url, query: query, type: 'features' },\n          dojo.hitch(\n            this,\n            '_makeFeatures',\n            featureCallback,\n            endCallback,\n            errorCallback,\n          ),\n          errorCallback,\n        )\n      }\n    },\n\n    // look in the REST backend's cache for cached feature requests\n    // that are relevant to the given query params (overlap the\n    // start/end region, and match other params).  return an array\n    // like [ {features: [...], start: 123, end: 456 }, ... ]\n    _getCachedFeatureRegions: function (query) {\n      var cache = this._getCache()\n\n      function tilingIsComplete(regions, start, end) {\n        regions.sort(function (a, b) {\n          return a.start - b.start\n        })\n        var coverStart = regions[0].start,\n          coverEnd\n        var i\n        var tilingComplete\n        for (i = 0; !tilingComplete && i < regions.length; i++) {\n          if (\n            coverEnd === undefined ||\n            (regions[i].start <= coverEnd && regions[i].end > coverEnd)\n          ) {\n            coverEnd = regions[i].end\n            tilingComplete = coverStart <= start && coverEnd >= end\n          }\n        }\n\n        if (tilingComplete) {\n          // touch all of the regions we processed in the cache,\n          // cause we are going to use them\n          for (i--; i >= 0; i--) {cache.touchRecord(regions[i].cacheRecord)}\n\n          return true\n        }\n\n        return false\n      }\n\n      function queriesMatch(q1, q2) {\n        var keys = Util.dojof.keys(q1).concat(Util.dojof.keys(q2))\n        for (var k in q1) {\n          if (k == 'start' || k == 'end') {continue}\n          if (q1[k] != q2[k]) {return false}\n        }\n        for (var k in q2) {\n          if (k == 'start' || k == 'end') {continue}\n          if (q1[k] != q2[k]) {return false}\n        }\n        return true\n      }\n\n      var relevantRegions = []\n      if (\n        cache.some(function (cacheRecord) {\n          var cachedRequest = cacheRecord.value.request\n          var cachedResponse = cacheRecord.value.response\n          if (cachedRequest.type != 'features' || !cachedResponse) {return false}\n          if (!queriesMatch(cachedRequest.query, query)) {return false}\n          if (\n            !(\n              cachedRequest.query.end < query.start ||\n              cachedRequest.query.start > query.end\n            )\n          ) {\n            relevantRegions.push({\n              features: cachedResponse.features,\n              start: cachedRequest.query.start,\n              end: cachedRequest.query.end,\n              cacheRecord: cacheRecord,\n            })\n            if (tilingIsComplete(relevantRegions, query.start, query.end))\n              {return true}\n          }\n          return false\n        }, this)\n      ) {\n        return relevantRegions\n      }\n      return null\n    },\n\n    // given an array of records of cached feature data like that\n    // returned by _getCachedFeatureRegions, make feature objects from\n    // them and emit them via the callbacks\n    _makeFeaturesFromCachedRegions: function (\n      cachedFeatureRegions,\n      query,\n      featureCallback,\n      endCallback,\n      errorCallback,\n    ) {\n      // gather and uniqify all the relevant feature data objects from the cached regions\n      var seen = {}\n      var featureData = []\n      array.forEach(cachedFeatureRegions, function (region) {\n        if (region && region.features) {\n          array.forEach(region.features, function (feature) {\n            if (!seen[feature.uniqueID]) {\n              seen[feature.uniqueID] = true\n              if (!(feature.start > query.end || feature.end < query.start))\n                {featureData.push(feature)}\n            }\n          })\n        }\n      })\n\n      // iterate over them and make feature objects from them\n      this._makeFeatures(featureCallback, endCallback, errorCallback, {\n        features: featureData,\n      })\n    },\n\n    // this method is copied to getRegionFeatureDensities in the\n    // constructor if config.region_feature_densities is true\n    _getRegionFeatureDensities: function (\n      query,\n      histDataCallback,\n      errorCallback,\n    ) {\n      var url = this._makeURL(\n        'stats/regionFeatureDensities',\n        this._assembleQuery(query),\n      )\n      this._get({ url: url }, histDataCallback, errorCallback)\n\n      // query like:\n      //    { ref: 'ctgA, start: 123, end: 456, basesPerBin: 200 }\n\n      // callback like:\n      //   histDataCallback({\n      //     \"bins\":  [ 51,50,58,63,57,57,65,66,63,61,56,49,50,47,39,38,54,41,50,71,61,44,64,60,42 ],\n      //     \"stats\": { \"basesPerBin\":\"200\",\"max\":88,\"mean\":57.772 } //< `max` used to set the Y scale\n      //   });\n\n      // or error like:\n      //   errorCallback( 'aieeee i died' );\n    },\n    // STUB method to satisfy requirements when setting the REST track to a VCF type\n    getVCFHeader: function (query, filterFunctionCallback, errorCallback) {\n      return new Deferred(function () {\n        /* console.log(\"REST store getVCFHeader\"); */\n      })\n    },\n\n    clearCache: function () {\n      delete this._cache\n    },\n\n    // HELPER METHODS\n    _get: function (request, callback, errorCallback) {\n      var thisB = this\n      if (this.config.noCache)\n        {dojoRequest(request.url, {\n          method: 'GET',\n          handleAs: 'json',\n        }).then(callback, this._errorHandler(errorCallback))}\n      else\n        {this._getCache().get(request, function (record, error) {\n          if (error) {thisB._errorHandler(errorCallback)(error)}\n          else {callback(record.response)}\n        })}\n    },\n\n    _getCache: function () {\n      var thisB = this\n      return (\n        this._cache ||\n        (this._cache = new LRUCache({\n          name: 'REST data cache ' + this.name,\n          maxSize: 25000, // cache up to about 5MB of data (assuming about 200B per feature)\n          sizeFunction: function (data) {\n            return data.length || 1\n          },\n          fillCallback: function (request, callback) {\n            var get = dojoRequest(\n              request.url,\n              { method: 'GET', handleAs: 'json' },\n              true, // work around dojo/request bug\n            )\n            get.then(\n              function (data) {\n                var nocacheResponse =\n                  /no-cache/.test(get.response.getHeader('Cache-Control')) ||\n                  /no-cache/.test(get.response.getHeader('Pragma'))\n                callback({ response: data, request: request }, null, {\n                  nocache: nocacheResponse,\n                })\n              },\n              thisB._errorHandler(lang.partial(callback, null)),\n            )\n          },\n        }))\n      )\n    },\n\n    _errorHandler: function (handler) {\n      handler =\n        handler ||\n        function (e) {\n          console.error(e, e.stack)\n          throw e\n        }\n      return dojo.hitch(this, function (error) {\n        var httpStatus = ((error || {}).response || {}).status\n        if (httpStatus >= 400) {\n          handler(\n            'HTTP ' +\n              httpStatus +\n              ' fetching ' +\n              error.response.url +\n              ' : ' +\n              error.response.text,\n          )\n        } else {\n          handler(error)\n        }\n      })\n    },\n\n    _assembleQuery: function (query) {\n      return lang.mixin(\n        { ref: (this.refSeq || {}).name },\n        this.config.query || {},\n        query || {},\n      )\n    },\n\n    _makeURL: function (subpath, query) {\n      var url = this.baseUrl + subpath\n\n      if (query) {\n        if (query.ref) {\n          url += '/' + query.ref\n          query = lang.mixin({}, query)\n          delete query.ref\n        }\n\n        query = ioquery.objectToQuery(query)\n        if (query) {url += '?' + query}\n      }\n\n      return url\n    },\n\n    _makeFeatures: function (\n      featureCallback,\n      endCallback,\n      errorCallback,\n      featureData,\n    ) {\n      let features\n      if (featureData && (features = featureData.features)) {\n        for (let i = 0; i < features.length; i++) {\n          let f = this._makeFeature(features[i])\n          this.applyFeatureTransforms([f]).forEach(featureCallback)\n        }\n      }\n\n      endCallback()\n    },\n\n    supportsFeatureTransforms: true,\n\n    _parseInt: function (data) {\n      array.forEach(['start', 'end', 'strand'], function (field) {\n        if (field in data) {data[field] = parseInt(data[field])}\n      })\n      if ('score' in data) {data.score = parseFloat(data.score)}\n      if ('subfeatures' in data)\n        {for (var i = 0; i < data.subfeatures.length; i++)\n          {this._parseInt(data.subfeatures[i])}}\n    },\n\n    _makeFeature: function (data, parent) {\n      this._parseInt(data)\n      return new SimpleFeature({ data: data, parent: parent })\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/SequenceChunks.js":{"size":4463,"mtime":1738905962087,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/SequenceChunks.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'dojo/_base/lang',\n  'dojo/_base/array',\n  'dojo/request',\n  'dojo/promise/all',\n  'dojo/Deferred',\n  'JBrowse/Store/SeqFeature',\n  'JBrowse/Store/LRUCache',\n  'JBrowse/Util',\n  'JBrowse/Model/SimpleFeature',\n  'JBrowse/Digest/Crc32',\n], function (\n  declare,\n  lang,\n  array,\n  request,\n  all,\n  Deferred,\n  SeqFeatureStore,\n  LRUCache,\n  Util,\n  SimpleFeature,\n  Crc32,\n) {\n  return declare(SeqFeatureStore, {\n    /**\n     * Storage backend for sequences broken up into chunks, stored and\n     * served as static text files.\n     * @constructs\n     */\n    constructor: function (args) {\n      this.compress = args.compress\n      this.urlTemplate = this.getConf('urlTemplate', [])\n      if (!this.urlTemplate) {\n        throw 'no urlTemplate provided, cannot open sequence store'\n      }\n\n      this.baseUrl = args.baseUrl\n      this.seqChunkSize = args.seqChunkSize\n    },\n\n    getFeatures: function (query, featureCallback, endCallback, errorCallback) {\n      errorCallback =\n        errorCallback ||\n        function (e) {\n          console.error(e)\n        }\n\n      var refname = query.ref\n      // if they both regularize to the same thing, use this.refSeq.name since that is guaranteed to be from refseq store\n      if (!this.browser.compareReferenceNames(this.refSeq.name, refname))\n        {refname = this.refSeq.name}\n\n      var chunkSize =\n        (refname == this.refSeq.name && this.refSeq.seqChunkSize) ||\n        this.seqChunkSize ||\n        (this.compress ? 80000 : 20000)\n\n      var chunksProcessed = 0\n\n      var cache = (this.chunkCache =\n        this.chunkCache ||\n        new LRUCache({\n          name: 'SequenceCache',\n          fillCallback: dojo.hitch(this, '_readChunkItems'),\n          sizeFunction: function (chunkItems) {\n            return chunkItems.length\n          },\n          maxSize: 100, // cache up to 100 seqchunks\n        }))\n      var firstChunk = Math.floor(Math.max(0, query.start) / chunkSize)\n      var lastChunk = Math.floor((query.end - 1) / chunkSize)\n\n      var chunks = []\n      for (var i = firstChunk; i <= lastChunk; i++) {\n        chunks.push({\n          refname: refname,\n          chunkNum: i,\n          chunkSize: chunkSize,\n        })\n      }\n\n      var haveError\n      array.forEach(chunks, function (c) {\n        cache.get(c, function (item, e) {\n          if (e && !haveError) {errorCallback(e)}\n          if ((haveError = haveError || e)) {\n            return\n          }\n\n          featureCallback(item)\n          if (++chunksProcessed == chunks.length) {\n            endCallback()\n          }\n        })\n      })\n    },\n    _readChunkItems: function (chunk, callback) {\n      var thisB = this\n      var d = new Deferred() // need to have our own deferred that is resolved to '' on 404\n\n      var sequrl = this.resolveUrl(this.urlTemplate, {\n        refseq: chunk.refname,\n        refseq_dirpath: function () {\n          var hex = Crc32.crc32(chunk.refname)\n            .toString(16)\n            .toLowerCase()\n            .replace('-', 'n')\n          // zero-pad the hex string to be 8 chars if necessary\n          while (hex.length < 8) {hex = '0' + hex}\n          var dirpath = []\n          for (var i = 0; i < hex.length; i += 3) {\n            dirpath.push(hex.substring(i, i + 3))\n          }\n          return dirpath.join('/')\n        },\n      })\n      this._fetchChunk(sequrl, chunk.chunkNum).then(\n        lang.hitch(d, 'resolve'),\n        function (e) {\n          if (e.response.status == 404) {d.resolve('')}\n          else {d.reject(e)}\n        },\n      )\n      d.then(\n        function (sequenceString) {\n          callback(\n            thisB._makeFeature(\n              chunk.refname,\n              chunk.chunkNum,\n              chunk.chunkSize,\n              sequenceString,\n            ),\n          )\n        },\n        function (e) {\n          callback(null, e)\n        },\n      )\n    },\n\n    _fetchChunk: function (sequrl, chunkNum) {\n      return request.get(\n        sequrl + chunkNum + '.txt' + (this.compress ? 'z' : ''),\n        { handleAs: 'text', headers: { 'X-Requested-With': null } },\n      )\n    },\n\n    _makeFeature: function (refname, chunkNum, chunkSize, sequenceString) {\n      return new SimpleFeature({\n        data: {\n          start: chunkNum * chunkSize,\n          end: chunkNum * chunkSize + sequenceString.length,\n          residues: sequenceString,\n          seq_id: refname,\n          name: refname,\n        },\n      })\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/SNPCoverage.js":{"size":6286,"mtime":1738905962096,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/SNPCoverage.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"/**\n * Store that encapsulates another store, which is expected to have\n * features in it that have CIGAR and MD attributes.  Produces\n * features that include SNP allele frequencies.\n */\n\ndefine([\n  'dojo/_base/declare',\n  'dojo/_base/array',\n\n  'JBrowse/Util',\n  'JBrowse/Store/SeqFeature',\n  'JBrowse/Model/NestedFrequencyTable',\n  'JBrowse/Model/CoverageFeature',\n  './_MismatchesMixin',\n], function (\n  declare,\n  array,\n\n  Util,\n  SeqFeatureStore,\n  NestedFrequencyTable,\n  CoverageFeature,\n  MismatchesMixin,\n) {\n  return declare([SeqFeatureStore, MismatchesMixin], {\n    constructor: function (args) {\n      this.store = args.store\n      this.filter =\n        args.filter ||\n        function () {\n          return true\n        }\n    },\n\n    getGlobalStats: function (callback, errorCallback) {\n      callback({})\n    },\n\n    _defaultConfig: function () {\n      return Util.deepUpdate(dojo.clone(this.inherited(arguments)), {\n        mismatchScale: 1 / 10,\n      })\n    },\n\n    getFeatures: function (\n      query,\n      featureCallback,\n      finishCallback,\n      errorCallback,\n    ) {\n      var thisB = this\n      var leftBase = query.start\n      var rightBase = query.end\n      var scale =\n        query.scale || (query.basesPerSpan && 1 / query.basesPerSpan) || 10 // px/bp\n      var widthBp = rightBase - leftBase\n      var widthPx = widthBp * scale\n\n      var binWidth = (function () {\n        var bpPerPixel = 1 / scale\n        if (bpPerPixel <= 1 / thisB.config.mismatchScale) {\n          return 1\n        } else {\n          return Math.ceil(bpPerPixel)\n        }\n      })()\n\n      function binNumber(bp) {\n        return Math.floor((bp - leftBase) / binWidth)\n      }\n\n      // init coverage bins\n      var binMax = Math.ceil((rightBase - leftBase) / binWidth)\n      var coverageBins = new Array(binMax)\n      for (var i = 0; i < binMax; i++) {\n        coverageBins[i] = new NestedFrequencyTable()\n        if (binWidth == 1) {coverageBins[i].snpsCounted = true}\n      }\n\n      function forEachBin(start, end, callback) {\n        var s = (start - leftBase) / binWidth\n        var e = (end - 1 - leftBase) / binWidth\n        var sb = Math.floor(s),\n          eb = Math.floor(e)\n\n        if (sb >= binMax || eb < 0) {return} // does not overlap this block\n\n        // enforce 0 <= bin < binMax\n        if (sb < 0) {s = sb = 0}\n        if (eb >= binMax) {\n          eb = binMax - 1\n          e = binMax\n        }\n\n        // now iterate\n        if (sb == eb)\n          // if in the same bin, just one call\n          {callback(sb, e - s)}\n        else {\n          // if in different bins, two or more calls\n          callback(sb, sb + 1 - s)\n          for (var i = sb + 1; i < eb; i++) {callback(i, 1)}\n          callback(eb, e - eb)\n        }\n      }\n\n      thisB.store.getFeatures(\n        query,\n        function (feature) {\n          if (!thisB.filter(feature)) {return}\n\n          var strand =\n            { '-1': '-', 1: '+' }['' + feature.get('strand')] || 'unstranded'\n\n          // increment start and end partial-overlap bins by proportion of overlap\n          forEachBin(\n            feature.get('start'),\n            feature.get('end'),\n            function (bin, overlap) {\n              coverageBins[bin]\n                .getNested('reference')\n                .increment(strand, overlap)\n            },\n          )\n\n          // Calculate SNP coverage\n          if (binWidth == 1) {\n            var mismatches = thisB._getMismatches(feature)\n            // loops through mismatches and updates coverage variables accordingly.\n            for (var i = 0; i < mismatches.length; i++) {\n              var mismatch = mismatches[i]\n              forEachBin(\n                feature.get('start') + mismatch.start,\n                feature.get('start') + mismatch.start + mismatch.length,\n                function (binNumber, overlap) {\n                  // Note: we decrement 'reference' so that total of the score is the total coverage\n                  var bin = coverageBins[binNumber]\n                  bin.getNested('reference').decrement(strand, overlap)\n                  var base = mismatch.base\n                  if (mismatch.type == 'insertion') {base = 'ins ' + base}\n                  else if (mismatch.type == 'skip') {base = 'skip'}\n                  bin.getNested(base).increment(strand, overlap)\n                },\n              )\n            }\n          }\n        },\n        function (args) {\n          var makeFeatures = function () {\n            // make fake features from the coverage\n            for (var i = 0; i < coverageBins.length; i++) {\n              var bpOffset = leftBase + binWidth * i\n              featureCallback(\n                new CoverageFeature({\n                  start: bpOffset,\n                  end: bpOffset + binWidth,\n                  score: coverageBins[i],\n                }),\n              )\n            }\n            finishCallback(args) // optional arguments may change callback behaviour (e.g. add masking)\n          }\n\n          // if we are zoomed to base level, try to fetch the\n          // reference sequence for this region and record each\n          // of the bases in the coverage bins\n          if (binWidth == 1) {\n            var sequence\n            thisB.browser.getStore('refseqs', function (refSeqStore) {\n              if (refSeqStore) {\n                refSeqStore.getFeatures(\n                  query,\n                  function (f) {\n                    sequence = f.get('seq')\n                  },\n                  function () {\n                    if (sequence) {\n                      for (var base = leftBase; base <= rightBase; base++) {\n                        var bin = binNumber(base)\n                        if (coverageBins[bin])\n                          {coverageBins[bin].refBase = sequence[bin]}\n                      }\n                    }\n                    makeFeatures()\n                  },\n                  makeFeatures,\n                )\n              } else {\n                makeFeatures()\n              }\n            })\n          } else {\n            makeFeatures()\n          }\n        },\n        errorCallback,\n      )\n    },\n\n    saveStore: function () {\n      return {\n        urlTemplate: this.config.bam.url,\n        baiUrlTemplate: this.config.bai.url,\n      }\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/SPARQL.js":{"size":5174,"mtime":1738905962103,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/SPARQL.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'dojo/_base/lang',\n  'dojo/_base/array',\n  'dojo/request/xhr',\n  'JBrowse/Store/SeqFeature',\n  'JBrowse/Store/DeferredStatsMixin',\n  'JBrowse/Store/SeqFeature/GlobalStatsEstimationMixin',\n  'JBrowse/Util',\n  'JBrowse/Model/SimpleFeature',\n  'dojo/io-query',\n], function (\n  declare,\n  lang,\n  array,\n  xhr,\n  SeqFeatureStore,\n  DeferredStatsMixin,\n  GlobalStatsEstimationMixin,\n  Util,\n  SimpleFeature,\n  ioQuery,\n) {\n  return declare(\n    [SeqFeatureStore, DeferredStatsMixin, GlobalStatsEstimationMixin],\n\n    /**\n     * @lends JBrowse.Store.SeqFeature.SPARQL\n     */\n    {\n      /**\n       * JBrowse feature backend to retrieve features from a SPARQL endpoint.\n       * @constructs\n       */\n      constructor: function (args) {\n        this.url = this.urlTemplate\n        this.refSeq = args.refSeq\n        this.baseUrl = args.baseUrl\n        this.density = 0\n        this.url = Util.resolveUrl(\n          this.baseUrl,\n          Util.fillTemplate(args.urlTemplate, {\n            refseq: this.refSeq.name,\n          }),\n        )\n        this.queryTemplate = args.queryTemplate\n        if (!this.queryTemplate) {\n          console.error(\n            'No queryTemplate set for SPARQL backend, no data will be displayed',\n          )\n        }\n\n        var thisB = this\n        this._estimateGlobalStats().then(\n          function (stats) {\n            thisB.globalStats = stats\n            thisB._deferred.stats.resolve(stats)\n          },\n          lang.hitch(this, '_failAllDeferred'),\n        )\n      },\n\n      // load: function() {\n      //     // ping the endpoint to see if it's there\n      //     dojo.xhrGet({ url: this.url+'?'+ioQuery.objectToQuery({ query: 'SELECT ?s WHERE { ?s ?p ?o } LIMIT 1' }),\n      //                   handleAs: \"text\",\n      //                   failOk: false,\n      //                   load:  Util.debugHandler( this, function(o) { this.loadSuccess(o); }),\n      //                   error: dojo.hitch( this, function(error) { this.loadFail(error, this.url); } )\n      //     });\n      // },\n\n      _makeQuery: function (query) {\n        if (this.config.variables)\n          {query = dojo.mixin(dojo.mixin({}, this.config.variables), query)}\n\n        return Util.fillTemplate(this.queryTemplate, query)\n      },\n\n      _getFeatures: function () {\n        this.getFeatures.apply(this, arguments)\n      },\n\n      getFeatures: function (\n        query,\n        featCallback,\n        finishCallback,\n        errorCallback,\n      ) {\n        if (this.queryTemplate) {\n          var thisB = this\n          var headers = { Accept: 'application/json' }\n          if (this.config.disablePreflight) {\n            // https://www.sitepen.com/blog/2014/01/15/faq-cors-with-dojo/\n            headers['X-Requested-With'] = null\n          }\n\n          xhr\n            .get(\n              this.url +\n                '?' +\n                ioQuery.objectToQuery({\n                  query: this._makeQuery(query),\n                }),\n              {\n                headers: headers,\n                handleAs: 'json',\n                failOk: true,\n              },\n            )\n            .then(\n              function (o) {\n                thisB._resultsToFeatures(o, featCallback)\n                finishCallback()\n              },\n              lang.hitch(this, '_failAllDeferred'),\n            )\n        } else {\n          finishCallback()\n        }\n      },\n\n      _resultsToFeatures: function (results, featCallback) {\n        var rows = ((results || {}).results || {}).bindings || []\n        if (!rows.length) {return}\n        var fields = results.head.vars\n        var requiredFields = ['start', 'end', 'strand', 'uniqueID']\n        for (var i = 0; i < requiredFields.length; i++) {\n          if (fields.indexOf(requiredFields[i]) == -1) {\n            console.error(\n              'Required field ' +\n                requiredFields[i] +\n                ' missing from feature data',\n            )\n            return\n          }\n        }\n        var seenFeatures = {}\n        array.forEach(\n          rows,\n          function (row) {\n            var f = { data: { subfeatures: [] } }\n\n            var data = f.data\n            array.forEach(fields, function (field) {\n              if (field in row) {data[field] = row[field].value}\n            })\n            data.start = parseInt(data.start)\n            data.end = parseInt(data.end)\n            data.strand = parseInt(data.strand)\n\n            var id = data.uniqueID\n            delete data.uniqueID\n            f.id = id\n            seenFeatures[id] = f\n          },\n          this,\n        )\n\n        // resolve subfeatures, keeping only top-level features in seenFeatures\n        for (var id in seenFeatures) {\n          var f = seenFeatures[id]\n          var pid = f.data.parentUniqueID\n          delete f.data.parentUniqueID\n          if (pid) {\n            var p = seenFeatures[pid]\n            if (p) {\n              p.data.subfeatures.push(f.data)\n              delete seenFeatures[id]\n            }\n          }\n        }\n\n        for (var id in seenFeatures) {\n          featCallback(new SimpleFeature(seenFeatures[id]))\n        }\n      },\n    },\n  )\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/TwoBit.js":{"size":2936,"mtime":1738905962109,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/TwoBit.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"const { TwoBitFile } = cjsRequire('@gmod/twobit')\n\nconst BlobFilehandleWrapper = cjsRequire('../../Model/BlobFilehandleWrapper')\n\ndefine([\n  'dojo/_base/declare',\n  'JBrowse/Model/XHRBlob',\n  'JBrowse/Store/SeqFeature',\n  'JBrowse/Store/DeferredFeaturesMixin',\n  'JBrowse/Model/SimpleFeature',\n], function (\n  declare,\n  XHRBlob,\n  SeqFeatureStore,\n  DeferredFeaturesMixin,\n  SimpleFeature,\n) {\n  return declare([SeqFeatureStore, DeferredFeaturesMixin], {\n    /**\n     * Data backend for reading feature data directly from a\n     * web-accessible .2bit file.\n     *\n     * @constructs\n     */\n    constructor: function (args) {\n      var blob =\n        args.blob ||\n        new XHRBlob(this.resolveUrl(args.urlTemplate || 'data.2bit'), {\n          expectRanges: true,\n        })\n\n      this.twoBit = new TwoBitFile({\n        filehandle: new BlobFilehandleWrapper(blob),\n      })\n\n      this.twoBit.getIndex().then(() => {\n        this._deferred.features.resolve({ success: true })\n      }, this._failAllDeferred.bind(this))\n    },\n\n    /**\n     * Interrogate whether a store has data for a given reference\n     * sequence.  Calls the given callback with either true or false.\n     *\n     * Implemented as a binary interrogation because some stores are\n     * smart enough to regularize reference sequence names, while\n     * others are not.\n     */\n    hasRefSeq: function (seqName, callback, errorCallback) {\n      this.twoBit.getSequenceSize(seqName).then(size => {\n        callback(size !== undefined)\n      }, errorCallback)\n    },\n    getRefSeqs: function (callback, errorCallback) {\n      this.twoBit\n        .getSequenceSizes()\n        .then(sizes =>\n          Object.entries(sizes).map(([name, length]) => {\n            return {\n              name,\n              length,\n              end: length,\n              start: 0,\n            }\n          }),\n        )\n        .then(callback, errorCallback)\n    },\n\n    // called by getFeatures from the DeferredFeaturesMixin\n    _getFeatures: function (query, featCallback, endCallback, errorCallback) {\n      let start = query.start\n      if (start < 0) {\n        start = 0\n      }\n      var refname = query.ref\n      // if they both regularize to the same thing, use this.refSeq.name since that is guaranteed to be from refseq store\n      if (!this.browser.compareReferenceNames(this.refSeq.name, refname))\n        {refname = this.refSeq.name}\n\n      this.twoBit.getSequence(refname, start, query.end).then(seq => {\n        if (seq !== undefined) {\n          featCallback(\n            new SimpleFeature({\n              data: {\n                seq_id: query.ref,\n                start: start,\n                end: query.end,\n                seq,\n              },\n            }),\n          )\n        }\n        endCallback()\n      }, errorCallback)\n    },\n\n    saveStore: function () {\n      return {\n        urlTemplate: (this.config.file || this.config.blob).url,\n      }\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/UnindexedFasta.js":{"size":1567,"mtime":1738905962113,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/UnindexedFasta.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/UnindexedFasta/File.js":{"size":3373,"mtime":1738905962121,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/UnindexedFasta/File.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'dojo/_base/array',\n  'dojo/Deferred',\n  'JBrowse/has',\n  'JBrowse/Util',\n  'JBrowse/Errors',\n  'JBrowse/Model/SimpleFeature',\n], function (declare, array, Deferred, has, Util, Errors, SimpleFeature) {\n  return declare(null, {\n    constructor: function (args) {\n      this.store = args.store\n      this.data = args.data\n      this.features = {}\n      this.refseqs = []\n    },\n\n    init: function (args) {\n      var fasta = this.data\n      var thisB = this\n      var successCallback = args.success || function () {}\n      var failCallback =\n        args.failure ||\n        function (e) {\n          console.error(e, e.stack)\n        }\n      this.parseFile(\n        fasta,\n        function (data) {\n          array.forEach(data, function (rs) {\n            thisB.features[rs.name] = {\n              seq_id: rs.name,\n              name: rs.name,\n              start: 0,\n              end: rs.seq.length,\n              seq: rs.seq,\n            }\n            thisB.refseqs.push({\n              name: rs.name,\n              start: 0,\n              end: rs.seq.length,\n              length: rs.seq.length,\n            })\n          })\n\n          successCallback()\n        },\n        failCallback,\n      )\n    },\n\n    fetch: function (chr, min, max, featCallback, endCallback, errorCallback) {\n      errorCallback =\n        errorCallback ||\n        function (e) {\n          console.error(e)\n        }\n      var refname = chr\n      if (!this.store.browser.compareReferenceNames(chr, refname)) {\n        refname = chr\n      }\n      featCallback(\n        new SimpleFeature({\n          data: {\n            start: this.features[refname].start,\n            end: this.features[refname].end,\n            residues: this.features[refname].seq,\n            seq_id: refname,\n            name: refname,\n          },\n        }),\n      )\n\n      endCallback()\n    },\n\n    parseFile: function (fastaFile, successCallback, failCallback) {\n      this.data.fetch(\n        dojo.hitch(this, function (text) {\n          var fastaString = ''\n          var bytes = new Uint8Array(text)\n          var length = bytes.length\n          for (var i = 0; i < length; i++) {\n            fastaString += String.fromCharCode(bytes[i])\n          }\n\n          if (!(fastaString && fastaString.length))\n            {failCallback('Could not read file: ' + fastaFile.name)}\n          else {\n            var data = this.parseString(fastaString)\n            if (!data.length)\n              {failCallback('File contained no (FASTA) sequences')}\n            else {successCallback(data)}\n          }\n        }),\n        failCallback,\n      )\n    },\n\n    parseString: function (fastaString) {\n      var data = []\n      var addSeq = function (s) {\n        if ('name' in s && s.seq.length)\n          // ignore empty sequences\n          {data.push(s)}\n      }\n      var current = { seq: '' }\n      var lines = fastaString.match(/^.*((\\r\\n|\\n|\\r)|$)/gm) // this is wasteful, maybe try to avoid storing split lines separately later\n\n      for (var i = 0; i < lines.length; i++) {\n        var m\n        if ((m = /^>(\\S*)/.exec(lines[i]))) {\n          addSeq(current)\n          current = { seq: '' }\n          if (m[1].length) {current.name = m[1]}\n        } else if ((m = /^\\s*(\\S+)\\s*$/.exec(lines[i]))) {\n          current.seq += m[1]\n        }\n      }\n      addSeq(current)\n\n      return data\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/VCFTabix.js":{"size":4631,"mtime":1738905962131,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/VCFTabix.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"const { TabixIndexedFile } = cjsRequire('@gmod/tabix')\nconst VCF = cjsRequire('@gmod/vcf')\n\ndefine([\n  'dojo/_base/declare',\n  'JBrowse/Errors',\n  'dojo/_base/lang',\n  'JBrowse/Store/SeqFeature',\n  'JBrowse/Store/DeferredStatsMixin',\n  'JBrowse/Store/DeferredFeaturesMixin',\n  'JBrowse/Store/SeqFeature/IndexedStatsEstimationMixin',\n  'JBrowse/Model/XHRBlob',\n  'JBrowse/Model/BlobFilehandleWrapper',\n  'JBrowse/Model/VCFFeature',\n], function (\n  declare,\n  Errors,\n  lang,\n  SeqFeatureStore,\n  DeferredStatsMixin,\n  DeferredFeaturesMixin,\n  IndexedStatsEstimationMixin,\n  XHRBlob,\n  BlobFilehandleWrapper,\n  VCFFeature,\n) {\n  return declare(\n    [\n      SeqFeatureStore,\n      DeferredStatsMixin,\n      DeferredFeaturesMixin,\n      IndexedStatsEstimationMixin,\n    ],\n    {\n      constructor(args) {\n        var thisB = this\n        var csiBlob, tbiBlob\n\n        if (args.csi || this.config.csiUrlTemplate) {\n          csiBlob = new BlobFilehandleWrapper(\n            args.csi ||\n              new XHRBlob(this.resolveUrl(this.getConf('csiUrlTemplate', []))),\n          )\n        } else {\n          tbiBlob = new BlobFilehandleWrapper(\n            args.tbi ||\n              new XHRBlob(\n                this.resolveUrl(\n                  this.getConf('tbiUrlTemplate', []) ||\n                    this.getConf('urlTemplate', []) + '.tbi',\n                ),\n              ),\n          )\n        }\n\n        var fileBlob = new BlobFilehandleWrapper(\n          args.file ||\n            new XHRBlob(this.resolveUrl(this.getConf('urlTemplate', [])), {\n              expectRanges: true,\n            }),\n        )\n\n        this.fileBlob = fileBlob\n\n        this.indexedData = new TabixIndexedFile({\n          tbiFilehandle: tbiBlob,\n          csiFilehandle: csiBlob,\n          filehandle: fileBlob,\n          chunkSizeLimit: args.chunkSizeLimit || 1000000,\n          renameRefSeqs: n => this.browser.regularizeReferenceName(n),\n        })\n\n        this.getParser().then(\n          function (parser) {\n            thisB._deferred.features.resolve({ success: true })\n            thisB._estimateGlobalStats().then(\n              function (stats) {\n                thisB.globalStats = stats\n                thisB._deferred.stats.resolve(stats)\n              },\n              lang.hitch(thisB, '_failAllDeferred'),\n            )\n          },\n          lang.hitch(thisB, '_failAllDeferred'),\n        )\n      },\n\n      getParser() {\n        if (!this._parser) {\n          this._parser = this.indexedData\n            .getHeader()\n            .then(header => new VCF({ header: header }))\n        }\n        return this._parser\n      },\n\n      _getFeatures(query, featureCallback, finishedCallback, errorCallback) {\n        var thisB = this\n        thisB\n          .getParser()\n          .then(parser => {\n            const regularizedReferenceName =\n              this.browser.regularizeReferenceName(query.ref)\n            thisB.indexedData\n              .getLines(\n                regularizedReferenceName,\n                query.start,\n                query.end,\n                (line, fileOffset) => {\n                  const variant = parser.parseLine(line)\n                  const feature = new VCFFeature({\n                    variant: variant,\n                    parser: parser,\n                    id: 'vcf-' + fileOffset,\n                  })\n                  featureCallback(feature)\n                },\n              )\n              .then(finishedCallback, error => {\n                if (errorCallback) {\n                  if (\n                    error.message &&\n                    error.message.indexOf('Too much data') >= 0\n                  ) {\n                    error = new Errors.DataOverflow(error.message)\n                  }\n                  errorCallback(error)\n                } else {console.error(error)}\n              })\n          })\n          .catch(errorCallback)\n      },\n\n      /**\n       * Interrogate whether a store has data for a given reference\n       * sequence.  Calls the given callback with either true or false.\n       *\n       * Implemented as a binary interrogation because some stores are\n       * smart enough to regularize reference sequence names, while\n       * others are not.\n       */\n      hasRefSeq(seqName, callback, errorCallback) {\n        return this.indexedData.index.hasRefSeq(\n          seqName,\n          callback,\n          errorCallback,\n        )\n      },\n\n      saveStore() {\n        return {\n          urlTemplate: this.config.file.url,\n          tbiUrlTemplate: (this.config.tbi || {}).url,\n          csiUrlTemplate: (this.config.csi || {}).url,\n        }\n      },\n    },\n  )\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/VCFTribble.js":{"size":4426,"mtime":1738905962138,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Store/SeqFeature/VCFTribble.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"const { TribbleIndexedFile } = cjsRequire('@gmod/tribble-index')\nconst VCF = cjsRequire('@gmod/vcf')\n\ndefine([\n  'dojo/_base/declare',\n  'JBrowse/Errors',\n  'dojo/_base/lang',\n  'JBrowse/Store/SeqFeature',\n  'JBrowse/Store/DeferredStatsMixin',\n  'JBrowse/Store/DeferredFeaturesMixin',\n  'JBrowse/Store/SeqFeature/GlobalStatsEstimationMixin',\n  'JBrowse/Model/XHRBlob',\n  'JBrowse/Model/BlobFilehandleWrapper',\n  'JBrowse/Model/VCFFeature',\n], function (\n  declare,\n  Errors,\n  lang,\n  SeqFeatureStore,\n  DeferredStatsMixin,\n  DeferredFeaturesMixin,\n  GlobalStatsEstimationMixin,\n  XHRBlob,\n  BlobFilehandleWrapper,\n  VCFFeature,\n) {\n  return declare(\n    [\n      SeqFeatureStore,\n      DeferredStatsMixin,\n      DeferredFeaturesMixin,\n      GlobalStatsEstimationMixin,\n    ],\n    {\n      constructor(args) {\n        var thisB = this\n\n        var idxBlob =\n          args.idx ||\n          new BlobFilehandleWrapper(\n            new XHRBlob(\n              this.resolveUrl(\n                this.getConf('idxUrlTemplate', []) ||\n                  this.getConf('urlTemplate', []) + '.idx',\n              ),\n            ),\n          )\n\n        var fileBlob =\n          args.file ||\n          new BlobFilehandleWrapper(\n            new XHRBlob(this.resolveUrl(this.getConf('urlTemplate', [])), {\n              expectRanges: true,\n            }),\n          )\n\n        this.indexedData = new TribbleIndexedFile({\n          filehandle: fileBlob,\n          tribbleFilehandle: idxBlob,\n          oneBasedClosed: true,\n          chunkSizeLimit: args.chunkSizeLimit || 2000000,\n          renameRefSeqs: n => this.browser.regularizeReferenceName(n),\n        })\n\n        this.getParser().then(\n          function (parser) {\n            thisB._deferred.features.resolve({ success: true })\n            thisB._estimateGlobalStats().then(\n              function (stats) {\n                thisB.globalStats = stats\n                thisB._deferred.stats.resolve(stats)\n              },\n              lang.hitch(thisB, '_failAllDeferred'),\n            )\n          },\n          lang.hitch(thisB, '_failAllDeferred'),\n        )\n      },\n\n      getParser() {\n        if (!this._parser) {\n          this._parser = this.indexedData\n            .getHeader()\n            .then(header => new VCF({ header: header }))\n        }\n        return this._parser\n      },\n\n      _getFeatures(query, featureCallback, finishedCallback, errorCallback) {\n        var thisB = this\n        thisB\n          .getParser()\n          .then(parser => {\n            const regularizedReferenceName =\n              this.browser.regularizeReferenceName(query.ref)\n            thisB.indexedData\n              .getLines(\n                regularizedReferenceName,\n                query.start,\n                query.end,\n                line => {\n                  const variant = parser.parseLine(line)\n                  const feature = new VCFFeature({\n                    variant: variant,\n                    parser: parser,\n                    id: variant.ID.length\n                      ? variant.ID[0]\n                      : `chr${variant.CHROM}_pos${variant.POS}_ref${variant.REF}_alt${variant.ALT}`,\n                  })\n                  featureCallback(feature)\n                },\n              )\n              .then(finishedCallback, error => {\n                if (errorCallback) {\n                  if (\n                    error.message &&\n                    error.message.indexOf('Too much data') >= 0\n                  ) {\n                    error = new Errors.DataOverflow(error.message)\n                  }\n                  errorCallback(error)\n                } else {console.error(error)}\n              })\n          })\n          .catch(errorCallback)\n      },\n\n      /**\n       * Interrogate whether a store has data for a given reference\n       * sequence.  Calls the given callback with either true or false.\n       *\n       * Implemented as a binary interrogation because some stores are\n       * smart enough to regularize reference sequence names, while\n       * others are not.\n       */\n      hasRefSeq: function (seqName, callback, errorCallback) {\n        return this.indexedData.index.hasRefSeq(\n          seqName,\n          callback,\n          errorCallback,\n        )\n      },\n\n      saveStore: function () {\n        return {\n          urlTemplate: this.config.file.url,\n          idxUrlTemplate: this.config.idx.url,\n        }\n      },\n    },\n  )\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/Store/Sequence/IndexedFasta.js":{"size":90,"mtime":1738905962142,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Store/Sequence/IndexedFasta.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/src/JBrowse/Store/Sequence/StaticChunked.js":{"size":92,"mtime":1738905962143,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Store/Sequence/StaticChunked.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/src/JBrowse/Store/Sequence/TwoBit.js":{"size":84,"mtime":1738905962145,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Store/Sequence/TwoBit.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/src/JBrowse/Store/TiledImage/Fixed_v0.js":{"size":606,"mtime":1738905962150,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Store/TiledImage/Fixed_v0.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/src/JBrowse/Store/TiledImage/Fixed.js":{"size":4017,"mtime":1738905962157,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Store/TiledImage/Fixed.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'dojo/_base/Deferred',\n  'JBrowse/Store',\n  'JBrowse/Store/DeferredStatsMixin',\n  'JBrowse/Util',\n], function (declare, Deferred, Store, DeferredStatsMixin, Util) {\n  return declare(\n    [Store, DeferredStatsMixin],\n\n    /**\n     * Implements a store for image tiles that are only available at a\n     * fixed set of sizes and zoom levels.  Most often used with\n     * pre-generated image tiles served statically.\n     * @lends JBrowse.Store.TiledImage.Fixed\n     * @class\n     * @extends Store\n     */\n    {\n      constructor: function (args) {\n        this.tileToImage = {}\n        this.zoomCache = {}\n\n        this.baseUrl = args.baseUrl\n\n        this.url = this.resolveUrl(args.urlTemplate)\n\n        this._deferred.images = new Deferred()\n\n        dojo.xhrGet({\n          url: this.url,\n          handleAs: 'json',\n          failOk: true,\n          load: dojo.hitch(this, function (o) {\n            this.loadSuccess(o)\n          }),\n          error: dojo.hitch(this, '_failAllDeferred'),\n        })\n      },\n\n      loadSuccess: function (o) {\n        this.globalStats = o.stats || {}\n        //backcompat\n        if (!('scoreMin' in this.globalStats))\n          {this.globalStats.scoreMin = this.globalStats.global_min}\n        if (!('scoreMax' in this.globalStats))\n          {this.globalStats.scoreMax = this.globalStats.global_max}\n\n        //tileWidth: width, in pixels, of the tiles\n        this.tileWidth = o.tileWidth\n        this.align = o.align\n        //zoomLevels: array of {basesPerTile, urlPrefix} hashes\n        this.zoomLevels = o.zoomLevels\n\n        this._deferred.stats.resolve({ success: true })\n        this._deferred.images.resolve({ success: true })\n      },\n\n      /**\n       * @private\n       */\n      _getZoom: function (scale) {\n        var result = this.zoomCache[scale]\n        if (result) {return result}\n\n        result = this.zoomLevels[0]\n        var desiredBases = this.tileWidth / scale\n        for (var i = 1; i < this.zoomLevels.length; i++) {\n          if (\n            Math.abs(this.zoomLevels[i].basesPerTile - desiredBases) <\n            Math.abs(result.basesPerTile - desiredBases)\n          )\n            {result = this.zoomLevels[i]}\n        }\n\n        this.zoomCache[scale] = result\n        return result\n      },\n\n      getImages: function (query, callback, errorCallback) {\n        var thisB = this\n        this._deferred.images.then(function (result) {\n          if (result.success) {thisB._getImages(query, callback, errorCallback)}\n          else {\n            thisB.error = result.error\n            errorCallback(result.error || result)\n          }\n        }, errorCallback)\n      },\n\n      /**\n       * Fetch an array of <code>&lt;img&gt;</code> elements for the image\n       * tiles that should be displayed for a certain magnification scale\n       * and section of the reference.\n       */\n      _getImages: function (query, callback, errorCallback) {\n        var scale = query.scale || 1\n        var startBase = query.start\n        var endBase = query.end\n\n        var zoom = this._getZoom(scale)\n\n        var startTile = Math.max(startBase / zoom.basesPerTile, 0) | 0\n        var endTile = (endBase / zoom.basesPerTile) | 0\n\n        var result = []\n        var im\n        for (var i = startTile; i <= endTile; i++) {\n          im = document.createElement('img')\n          dojo.connect(im, 'onerror', this.handleImageError)\n          im.src = this._imageSource(zoom, i)\n          //TODO: need image coord systems that don't start at 0?\n          im.startBase = i * zoom.basesPerTile // + this.refSeq.start;\n          im.baseWidth = zoom.basesPerTile\n          im.tileNum = i\n\n          result.push(im)\n        }\n        callback(result)\n      },\n\n      /**\n       * Gives the image source for a given zoom (as returned by _getZoom())\n       * and tileIndex.\n       * @private\n       */\n      _imageSource: function (zoom, tileIndex) {\n        return Util.resolveUrl(this.url, zoom.urlPrefix + tileIndex + '.png')\n      },\n    },\n  )\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/Store/TrackMetaData.js":{"size":30553,"mtime":1738905962187,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Store/TrackMetaData.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'dojo/_base/array',\n  'dojo/data/util/simpleFetch',\n  'JBrowse/Util',\n  'JBrowse/Digest/Crc32',\n], function (declare, array, simpleFetch, Util, Crc32) {\n  var dojof = Util.dojof\n  var Meta = declare(\n    null,\n\n    /**\n     * @lends JBrowse.Store.TrackMetaData.prototype\n     */\n    {\n      _noDataValue: '(no data)',\n\n      /**\n       * Data store for track metadata, supporting faceted\n       * (parameterized) searching.  Keeps all of the track metadata,\n       * and the indexes thereof, in memory.\n       * @constructs\n       * @param args.trackConfigs {Array} array of track configuration\n       * @param args.indexFacets {Function|Array|String}\n       * @param args.onReady {Function}\n       * @param args.metadataStores {Array[dojox.data]}\n       */\n      constructor: function (args) {\n        this.sortFacets = args.sortFacets !== undefined ? args.sortFacets : true\n        // set up our facet name discrimination: what facets we will\n        // actually provide search on\n        var non_facet_attrs = ['conf']\n        this._filterFacet = function () {\n          var filter =\n            args.indexFacets ||\n            function () {\n              return true\n            }\n          // if we have a non-function filter, coerce to an array,\n          // then convert that array to a function\n          if (typeof filter == 'string') {filter = [filter]}\n          if (dojo.isArray(filter)) {\n            var oldfilter = filter\n            filter = function (facetName) {\n              return dojo.some(oldfilter, function (fn) {\n                return facetName == fn.toLowerCase()\n              })\n            }\n          }\n          var ident_facets = this.getIdentityAttributes()\n          return function (facetName) {\n            return (\n              // always index ident facets\n              dojo.some(ident_facets, function (n) {\n                return n == facetName\n              }) ||\n              // otherwise, must pass the user filter AND not be one of our explicitly-blocked attrs\n              (filter(facetName) &&\n                !dojo.some(non_facet_attrs, function (a) {\n                  return a == facetName\n                }))\n            )\n          }\n        }.call(this)\n\n        // set up our onReady callbacks to fire once the data is\n        // loaded\n        if (!dojo.isArray(args.onReady)) {\n          this.onReadyFuncs = args.onReady ? [args.onReady] : []\n        } else {\n          this.onReadyFuncs = dojo.clone(args.onReady)\n        }\n\n        // interpret the track configurations themselves as a metadata store\n        this._indexItems({\n          store: this,\n          items: dojo.map(\n            args.trackConfigs,\n            dojo.hitch(this, '_trackConfigToItem'),\n          ),\n        })\n\n        // fetch and index all the items from each of the stores\n        var stores_fetched_count = 0\n        // filter out empty metadata store entries\n        args.metadataStores = dojo.filter(args.metadataStores, function (s) {\n          return s\n        })\n        if (!args.metadataStores || !args.metadataStores.length) {\n          // if we don't actually have any stores besides the track\n          // confs, we're ready now.\n          this._finishLoad()\n        } else {\n          // index the track metadata from each of the stores\n\n          var storeFetchFinished = dojo.hitch(this, function () {\n            if (++stores_fetched_count == args.metadataStores.length)\n              {this._finishLoad()}\n          })\n          dojo.forEach(\n            args.metadataStores,\n            function (store) {\n              store.fetch({\n                scope: this,\n                onComplete: dojo.hitch(this, function (items) {\n                  // build our indexes\n                  this._indexItems({\n                    store: store,\n                    items: items,\n                    supplementalOnly: true,\n                  })\n\n                  // if this is the last store to be fetched, call\n                  // our onReady callbacks\n                  storeFetchFinished()\n                }),\n                onError: function (e) {\n                  console.error(e, e.stack)\n                  storeFetchFinished()\n                },\n              })\n            },\n            this,\n          )\n        }\n\n        // listen for track-editing commands and update our track metadata accordingly\n        args.browser.subscribe(\n          '/jbrowse/v1/c/tracks/new',\n          dojo.hitch(this, 'addTracks'),\n        )\n        args.browser.subscribe(\n          '/jbrowse/v1/c/tracks/replace',\n          dojo.hitch(this, function (trackConfigs) {\n            this.deleteTracks(trackConfigs, 'no events')\n            this.addTracks(trackConfigs, 'no events')\n          }),\n        )\n        args.browser.subscribe(\n          '/jbrowse/v1/c/tracks/delete',\n          dojo.hitch(this, 'deleteTracks'),\n        )\n      },\n\n      /**\n       * Convert a track config object into a data store item.\n       */\n      _trackConfigToItem: function (conf) {\n        var metarecord = dojo.clone(conf.metadata || {})\n        metarecord.label = conf.label\n        metarecord.key = conf.key\n        metarecord.conf = conf\n        metarecord['track type'] = conf.type\n        if (conf.category) {metarecord.category = conf.category}\n        return metarecord\n      },\n\n      // map of special comparator functions for certain metadata items\n      comparatorMap: {\n        // for category metadata, split on \"/\" and compare\n        category: function (a, b) {\n          var acs = (a || 'Uncategorized').split(/\\s*\\/\\s*/)\n          var bcs = (b || 'Uncategorized').split(/\\s*\\/\\s*/)\n          var ac, bc, compresult\n          while ((ac = acs.shift()) && (bc = bcs.shift())) {\n            if ((compresult = ac.localeCompare(bc))) {return compresult}\n          }\n          return 0\n        },\n      },\n\n      addTracks: function (trackConfigs, suppressEvents) {\n        if (trackConfigs.length) {\n          // clear the query cache\n          delete this.previousQueryFingerprint\n          delete this.previousResults\n        }\n\n        array.forEach(\n          trackConfigs,\n          function (conf) {\n            // insert in the indexes\n            this._indexItems({\n              store: this,\n              items: [this._trackConfigToItem(conf)],\n            })\n\n            var name = conf.label\n            var item = this.fetchItemByIdentity(name)\n            if (!item)\n              {console.error(\n                'failed to add ' + name + ' track to track metadata store',\n                conf,\n              )}\n            else if (!suppressEvents) {this.onNew(item)}\n          },\n          this,\n        )\n      },\n\n      deleteTracks: function (trackConfigs, suppressEvents) {\n        if (trackConfigs.length) {\n          // clear the query cache\n          delete this.previousQueryFingerprint\n          delete this.previousResults\n        }\n\n        // we don't actually delete things, we just mark them as\n        // deleted and filter out deleted ones when returning results.\n        array.forEach(\n          trackConfigs,\n          function (conf) {\n            var name = conf.label\n            var item = this.fetchItemByIdentity(name)\n            if (item) {\n              item.DELETED = true\n              if (!suppressEvents) {this.onDelete(item)}\n            }\n          },\n          this,\n        )\n      },\n\n      /**\n       * Set the store's state to be ready (i.e. loaded), and calls all\n       * our onReady callbacks.\n       * @private\n       */\n      _finishLoad: function () {\n        // sort the facet names\n        if (this.sortFacets) {\n          this.facets.sort()\n        }\n\n        // calculate the average bucket size for each facet index\n        dojo.forEach(dojof.values(this.facetIndexes.byName), function (bucket) {\n          bucket.avgBucketSize = bucket.itemCount / bucket.bucketCount\n        })\n        // calculate the rank of the facets: make an array of\n        // facet names sorted by bucket size, descending\n        this.facetIndexes.facetRank = dojo.clone(this.facets).sort(\n          dojo.hitch(this, function (a, b) {\n            return (\n              this.facetIndexes.byName[a].avgBucketSize -\n              this.facetIndexes.byName[b].avgBucketSize\n            )\n          }),\n        )\n\n        // sort the facet indexes by ident, so that we can do our\n        // kind-of-efficient N-way merging when querying.  also,\n        // uniqify them by identity.\n        var itemSortFunction = dojo.hitch(this, '_itemSortFunc')\n        dojo.forEach(\n          dojof.values(this.facetIndexes.byName),\n          function (facetIndex) {\n            dojo.forEach(\n              dojof.values(facetIndex.byValue),\n              function (valueIndex) {\n                var uniqueItems = []\n                var seen = {}\n                //NOTE: the first record loaded with a given identity always wins\n                array.forEach(\n                  valueIndex.items,\n                  function (item) {\n                    var id = this.getIdentity(item)\n                    if (!seen[id]) {\n                      seen[id] = true\n                      uniqueItems.push(item)\n                    }\n                  },\n                  this,\n                )\n                valueIndex.items = uniqueItems.sort(itemSortFunction)\n              },\n              this,\n            )\n          },\n          this,\n        )\n\n        this.ready = true\n        this._onReady()\n      },\n\n      _itemSortFunc: function (a, b) {\n        var ai = this.getIdentity(a),\n          bi = this.getIdentity(b)\n        return ai == bi ? 0 : ai > bi ? 1 : ai < bi ? -1 : 0\n      },\n\n      _indexItems: function (args) {\n        // get our (filtered) list of facets we will index for\n        var store = args.store,\n          items = args.items\n\n        var storeAttributes = {}\n\n        // convert the items to a uniform format\n        items = dojo.map(\n          items,\n          function (item) {\n            var itemattrs = store.getAttributes(item)\n\n            //convert the item into a uniform data format of plain objects\n            var newitem = {}\n            dojo.forEach(itemattrs, function (attr) {\n              // stores sometimes emit undef attributes  >:-{\n              if (!attr) {return}\n\n              var lcattr = attr.toLowerCase()\n              storeAttributes[lcattr] = true\n              newitem[lcattr] = store.getValue(item, attr)\n            })\n            return newitem\n          },\n          this,\n        )\n\n        // merge them with any existing records, filtering out ones\n        // that should be ignored if we were passed\n        // 'supplementalOnly', and update the identity index\n        this.identIndex = this.identIndex || {}\n        items = function () {\n          var seenInThisStore = {}\n          return dojo.map(\n            items,\n            function (item) {\n              // merge the new item attributes with any existing\n              // record for this item\n              var ident = this.getIdentity(item)\n              var existingItem = this.identIndex[ident]\n              if (existingItem && existingItem.DELETED)\n                {delete existingItem.DELETED}\n\n              // skip this item if we have already\n              // seen it from this store, or if we\n              // are supplementalOnly and it\n              // does not already exist\n              if (\n                seenInThisStore[ident] ||\n                (args.supplementalOnly && !existingItem)\n              ) {\n                return null\n              }\n              seenInThisStore[ident] = true\n\n              return (this.identIndex[ident] = dojo.mixin(\n                existingItem || {},\n                item,\n              ))\n            },\n            this,\n          )\n        }.call(this)\n\n        // filter out nulls\n        items = dojo.filter(items, function (i) {\n          return i\n        })\n\n        // update our facet list to include any new attrs these\n        // items have\n        var store_facets = dojof.keys(storeAttributes)\n        var new_facets = this._addFacets(dojof.keys(storeAttributes))\n        var use_facets = array.filter(this.facets, function (f) {\n          return f in storeAttributes\n        })\n\n        // initialize indexes for any new facets\n        this.facetIndexes = this.facetIndexes || {\n          itemCount: 0,\n          bucketCount: 0,\n          byName: {},\n        }\n        dojo.forEach(\n          new_facets,\n          function (facet) {\n            if (!this.facetIndexes.byName[facet]) {\n              this.facetIndexes.bucketCount++\n              this.facetIndexes.byName[facet] = {\n                itemCount: 0,\n                bucketCount: 0,\n                byValue: {},\n              }\n            }\n          },\n          this,\n        )\n\n        // now update the indexes with the new data\n        if (use_facets.length) {\n          var gotDataForItem = {}\n          dojo.forEach(use_facets, function (f) {\n            gotDataForItem[f] = {}\n          })\n\n          dojo.forEach(\n            items,\n            function (item) {\n              this.facetIndexes.itemCount++\n              dojo.forEach(\n                use_facets,\n                function (facet) {\n                  var value = this.getValue(item, facet, undefined)\n                  if (typeof value == 'undefined') {return}\n                  gotDataForItem[facet][this.getIdentity(item)] = 1\n                  this._indexItem(facet, value, item)\n                },\n                this,\n              )\n            },\n            this,\n          )\n\n          // index the items that do not have data for this facet\n          dojo.forEach(\n            use_facets,\n            function (facet) {\n              dojo.forEach(\n                dojof.values(this.identIndex),\n                function (item) {\n                  if (!gotDataForItem[facet][this.getIdentity(item)]) {\n                    this._indexItem(facet, this._noDataValue, item)\n                  }\n                },\n                this,\n              )\n            },\n            this,\n          )\n        }\n      },\n\n      /**\n       * Add an item to the indexes for the given facet name and value.\n       * @private\n       */\n      _indexItem: function (facet, value, item) {\n        var facetValues = this.facetIndexes.byName[facet]\n        var bucket = facetValues.byValue[value]\n        if (!bucket) {\n          bucket = facetValues.byValue[value] = {\n            itemCount: 0,\n            items: [],\n          }\n          facetValues.bucketCount++\n        }\n        bucket.itemCount++\n        facetValues.itemCount++\n        bucket.items.push(item)\n      },\n\n      /**\n       * Given an array of string facet names, add records for them,\n       * initializing the necessary data structures.\n       * @private\n       * @returns {Array[String]} facet names that did not already exist\n       */\n      _addFacets: function (facetNames) {\n        var old_facets = this.facets || []\n        var seen = {}\n        this.facets = dojo.filter(\n          old_facets.concat(facetNames),\n          function (facetName) {\n            var take = this._filterFacet(facetName) && !seen[facetName]\n            seen[facetName] = true\n            return take\n          },\n          this,\n        )\n        return this.facets.slice(old_facets.length)\n      },\n\n      /**\n       * Get the number of items that matched the most recent query.\n       * @returns {Number} the item count, or undefined if there has not\n       * been any query so far.\n       */\n      getCount: function () {\n        return this._fetchCount\n      },\n\n      /**\n       * @param facetName {String} facet name\n       * @returns {Object}\n       */\n      getFacetCounts: function (facetName) {\n        var context =\n          this._fetchFacetCounts[facetName] ||\n          this._fetchFacetCounts['__other__']\n        return context ? context[facetName] : undefined\n      },\n\n      /**\n       * Get an array of the text names of the facets that are defined\n       * in this track metadata.\n       * @param callback {Function} called as callback( [facet,facet,...] )\n       */\n      getFacetNames: function (callback) {\n        return this.facets\n      },\n\n      /**\n       * Get an Array of the distinct values for a given facet name.\n       * @param facetName {String} the facet name\n       * @returns {Array} distinct values for that facet\n       */\n      getFacetValues: function (facetName) {\n        var index = this.facetIndexes.byName[facetName]\n        if (!index) {return []}\n\n        return dojof.keys(index.byValue)\n      },\n\n      /**\n       * Get statistics about the facet with the given name.\n       * @returns {Object} as: <code>{ itemCount: ##, bucketCount: ##, avgBucketSize: ## }</code>\n       */\n      getFacetStats: function (facetName) {\n        var index = this.facetIndexes.byName[facetName]\n        if (!index) {return {}}\n\n        var stats = {}\n        dojo.forEach(\n          ['itemCount', 'bucketCount', 'avgBucketSize'],\n          function (attr) {\n            stats[attr] = index[attr]\n          },\n        )\n        return stats\n      },\n\n      // dojo.data.api.Read support\n\n      getValue: function (i, attr, defaultValue) {\n        var v = i[attr]\n        return typeof v == 'undefined' ? defaultValue : v\n      },\n      getValues: function (i, attr) {\n        var a = [i[attr]]\n        return typeof a[0] == 'undefined' ? [] : a\n      },\n\n      getAttributes: function (item) {\n        return dojof.keys(item)\n      },\n\n      hasAttribute: function (item, attr) {\n        return item.hasOwnProperty(attr)\n      },\n\n      containsValue: function (item, attribute, value) {\n        return item[attribute] == value\n      },\n\n      isItem: function (item) {\n        return typeof item == 'object' && typeof item.label == 'string'\n      },\n\n      isItemLoaded: function () {\n        return this.ready\n      },\n\n      loadItem: function (args) {},\n\n      getItem: function (label) {\n        if (this.ready) {return this.identIndex[label]}\n        else {return null}\n      },\n\n      // used by the dojo.data.util.simpleFetch mixin to implement fetch()\n      _fetchItems: function (keywordArgs, findCallback, errorCallback) {\n        if (!this.ready) {\n          this.onReady(\n            dojo.hitch(\n              this,\n              '_fetchItems',\n              keywordArgs,\n              findCallback,\n              errorCallback,\n            ),\n          )\n          return\n        }\n\n        var query = dojo.clone(keywordArgs.query || {})\n        // coerce query arguments to arrays if they are not already arrays\n        dojo.forEach(\n          dojof.keys(query),\n          function (qattr) {\n            if (!dojo.isArray(query[qattr])) {\n              query[qattr] = [query[qattr]]\n            }\n          },\n          this,\n        )\n\n        var results\n        var queryFingerprint = Crc32.objectFingerprint(query)\n        if (queryFingerprint == this.previousQueryFingerprint) {\n          results = this.previousResults\n        } else {\n          this.previousQueryFingerprint = queryFingerprint\n          this.previousResults = results = this._doQuery(query)\n        }\n\n        // and finally, hand them to the finding callback\n        findCallback(results, keywordArgs)\n        this.onFetchSuccess()\n      },\n\n      /**\n       * @private\n       */\n      _doQuery: function (/**Object*/ query) {\n        var textFilter = this._compileTextFilter(query.text)\n        delete query.text\n\n        // algorithm pseudocode:\n        //\n        //    * for each individual facet, get a set of tracks that\n        //      matches its selected values.  sort each set by the\n        //      track's unique identifier.\n        //    * while still need to go through all the items in the filtered sets:\n        //          - if all the facets have the same track first in their sorted set:\n        //                 add it to the core result set.\n        //                 count it in the global counts\n        //          - if all the facets *but one* have the same track first:\n        //                 this track will need to be counted in the\n        //                 'leave-out' counts for the odd facet out.  count it.\n        //          - shift the lowest-labeled track off of whatever facets have it at the front\n\n        var results = [] // array of items that completely match the query\n\n        // construct the filtered sets (arrays of items) for each of\n        // our search criteria\n        var filteredSets = []\n        if (textFilter) {\n          filteredSets.push(\n            this._filterDeleted(\n              array.filter(dojof.values(this.identIndex), textFilter),\n            ).sort(dojo.hitch(this, '_itemSortFunc')),\n          )\n          filteredSets[0].facetName = 'Contains text'\n        }\n        filteredSets.push.apply(\n          filteredSets,\n          dojo.map(\n            dojof.keys(query),\n            function (facetName) {\n              var values = query[facetName]\n              var items = []\n              if (!this.facetIndexes.byName[facetName]) {\n                console.error(\"No facet defined with name '\" + facetName + \"'.\")\n                throw (\n                  \"No facet defined with name '\" +\n                  facetName +\n                  \"', faceted search failed.\"\n                )\n              }\n              dojo.forEach(\n                values,\n                function (value) {\n                  var idx =\n                    this.facetIndexes.byName[facetName].byValue[value] || {}\n                  items.push.apply(items, this._filterDeleted(idx.items || []))\n                },\n                this,\n              )\n              items.facetName = facetName\n              items.sort(dojo.hitch(this, '_itemSortFunc'))\n              return items\n            },\n            this,\n          ),\n        )\n        dojo.forEach(filteredSets, function (s) {\n          s.myOffset = 0\n          s.topItem = function () {\n            return this[this.myOffset]\n          }\n          s.shift = function () {\n            this.myOffset++\n          }\n        })\n\n        // init counts\n        var facetMatchCounts = {}\n\n        if (!filteredSets.length) {\n          results = this._filterDeleted(dojof.values(this.identIndex))\n        } else {\n          // calculate how many item records total we need to go through\n          var leftToProcess = 0\n          dojo.forEach(filteredSets, function (s) {\n            leftToProcess += s.length\n          })\n\n          // do a sort of N-way merge of the filtered sets\n          while (leftToProcess) {\n            // look at the top of each of our sets, seeing what items\n            // we have there.  group the sets by the identity of their\n            // topmost item.\n            var setsByTopIdent = {},\n              uniqueIdents = [],\n              ident,\n              item\n            dojo.forEach(\n              filteredSets,\n              function (set, i) {\n                item = set.topItem()\n                ident = item ? this.getIdentity(item) : '(at end of set)'\n                if (setsByTopIdent[ident]) {\n                  setsByTopIdent[ident].push(set)\n                } else {\n                  setsByTopIdent[ident] = [set]\n                  uniqueIdents.push(ident)\n                }\n              },\n              this,\n            )\n            if (uniqueIdents.length == 1) {\n              // each of our matched sets has the same item at the\n              // top.  this means it is part of the core result set.\n              results.push(item)\n            } else {\n              // ident we are operating on is always the\n              // lexically-first one that is not the end-of-set\n              // marker\n              uniqueIdents.sort()\n              var leftOutIndex\n              if (uniqueIdents[0] == '(at end of set)') {\n                ident = uniqueIdents[1]\n                leftOutIndex = 0\n              } else {\n                ident = uniqueIdents[0]\n                leftOutIndex = 1\n              }\n              ident =\n                uniqueIdents[0] == '(at end of set)'\n                  ? uniqueIdents[1]\n                  : uniqueIdents[0]\n\n              if (\n                uniqueIdents.length == 2 &&\n                setsByTopIdent[ident].length == filteredSets.length - 1\n              ) {\n                // all of the matched sets except one has the same\n                // item on top, and it is the lowest-labeled item\n\n                var leftOutSet = setsByTopIdent[uniqueIdents[leftOutIndex]][0]\n                this._countItem(\n                  facetMatchCounts,\n                  setsByTopIdent[ident][0].topItem(),\n                  leftOutSet.facetName,\n                )\n              }\n            }\n\n            dojo.forEach(setsByTopIdent[ident], function (s) {\n              s.shift()\n              leftToProcess--\n            })\n          }\n        }\n\n        // each of the leave-one-out count sets needs to also have the\n        // core result set counted in it, and also make a counting set\n        // for the core result set (used by __other__ facets not\n        // involved in the query)\n        dojo.forEach(\n          dojof.keys(facetMatchCounts).concat(['__other__']),\n          function (category) {\n            dojo.forEach(\n              results,\n              function (item) {\n                this._countItem(facetMatchCounts, item, category)\n              },\n              this,\n            )\n          },\n          this,\n        )\n\n        // in the case of just one filtered set, the 'leave-one-out'\n        // count for it is actually the count of all results, so we\n        // need to make a special little count of that attribute for\n        // the global result set.\n        if (filteredSets.length == 1) {\n          dojo.forEach(\n            dojof.values(this.identIndex),\n            function (item) {\n              this._countItem(facetMatchCounts, item, filteredSets[0].facetName)\n            },\n            this,\n          )\n        }\n\n        this._fetchFacetCounts = facetMatchCounts\n        this._fetchCount = results.length\n        return results\n      },\n\n      _countItem: function (facetMatchCounts, item, facetName) {\n        var facetEntry = facetMatchCounts[facetName]\n        if (!facetEntry) {facetEntry = facetMatchCounts[facetName] = {}}\n        var facets = facetName == '__other__' ? this.facets : [facetName]\n        dojo.forEach(\n          facets,\n          function (attrName) {\n            var value = this.getValue(item, attrName, this._noDataValue)\n            var attrEntry = facetEntry[attrName]\n            if (!attrEntry) {\n              attrEntry = facetEntry[attrName] = {}\n              attrEntry[value] = 0\n            }\n            attrEntry[value] = (attrEntry[value] || 0) + 1\n          },\n          this,\n        )\n      },\n\n      onReady: function (scope, func) {\n        scope = scope || dojo.global\n        func = dojo.hitch(scope, func)\n        if (!this.ready) {\n          this.onReadyFuncs.push(func)\n          return\n        } else {\n          func()\n        }\n      },\n\n      /**\n       * Event hook called once when the store is initialized and has\n       * an initial set of data loaded.\n       */\n      _onReady: function () {\n        dojo.forEach(this.onReadyFuncs || [], function (func) {\n          func.call()\n        })\n      },\n\n      /**\n       * Event hook called after a fetch has been successfully completed\n       * on this store.\n       */\n      onFetchSuccess: function () {},\n\n      /**\n       * Event hook called when there are new items in the store.\n       */\n      onNew: function (item) {},\n      /**\n       * Event hook called when something is deleted from the store.\n       */\n      onDelete: function (item) {},\n      /**\n       * Event hook called when one or more items in the store have changed their values.\n       */\n      onSet: function (item, attribute, oldvalue, newvalue) {},\n\n      _filterDeleted: function (items) {\n        return array.filter(items, function (i) {\n          return !i.DELETED\n        })\n      },\n\n      /**\n       * Compile a text search string into a function that tests whether\n       * a given piece of text matches that search string.\n       * @private\n       */\n      _compileTextFilter: function (textString) {\n        if (textString === undefined) {return null}\n\n        // parse out words and quoted words, and convert each into a regexp\n        var rQuotedWord = /\\s*[\"']([^\"']+)[\"']\\s*/g\n        var rWord = /(\\S+)/g\n        var parseWord = function () {\n          var word = rQuotedWord.exec(textString) || rWord.exec(textString)\n          if (word) {\n            word = word[1]\n            var lastIndex = Math.max(rQuotedWord.lastIndex, rWord.lastIndex)\n            rWord.lastIndex = rQuotedWord.lastIndex = lastIndex\n          }\n          return word\n        }\n        var wordREs = []\n        var currentWord\n        while ((currentWord = parseWord())) {\n          // escape regex control chars, and convert glob-like chars to\n          // their regex equivalents\n          currentWord = dojo.regexp\n            .escapeString(currentWord, '*?')\n            .replace(/\\*/g, '.+')\n            .replace(/ /g, '\\\\s+')\n            .replace(/\\?/g, '.')\n          wordREs.push(new RegExp(currentWord, 'i'))\n        }\n\n        // return a function that takes on item and returns true if it\n        // matches the text filter\n        return dojo.hitch(this, function (item) {\n          return dojo.some(\n            this.facets,\n            function (facetName) {\n              var text = this.getValue(item, facetName)\n              return array.every(wordREs, function (re) {\n                return re.test(text)\n              })\n            },\n            this,\n          )\n        })\n      },\n\n      getFeatures: function () {\n        return {\n          'dojo.data.api.Read': true,\n          'dojo.data.api.Identity': true,\n          'dojo.data.api.Notification': true,\n        }\n      },\n      close: function () {},\n\n      getLabel: function (i) {\n        return this.getValue(i, 'key', undefined)\n      },\n      getLabelAttributes: function (i) {\n        return ['key']\n      },\n\n      // dojo.data.api.Identity support\n      getIdentityAttributes: function () {\n        return ['label']\n      },\n      getIdentity: function (i) {\n        return this.getValue(i, 'label', undefined)\n      },\n      fetchItemByIdentity: function (id) {\n        return this.identIndex[id]\n      },\n    },\n  )\n  dojo.extend(Meta, simpleFetch)\n  return Meta\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/TouchScreenSupport.js":{"size":8902,"mtime":1738905962201,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/TouchScreenSupport.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([], function () {\n  var startX\n  var initialPane\n\n  /**\n   * Utility functions for touch-screen device (smartphone and tablet) support.\n   *\n   * @lends JBrowse.TouchScreenSupport\n   */\n  var Touch\n  Touch = {\n    CompareObjPos: function (nodes, touch) {\n      var samePos = 0,\n        j = 0,\n        top = touch.pageY\n\n      for (var i = 0; i < nodes.length; i++) {\n        samePos = j++\n        var position = Touch.findPos(nodes[i])\n        if (position.top > top) {\n          break\n        }\n      }\n      return samePos\n    },\n\n    checkAvatarPosition: function (first) {\n      var leftPane = document.getElementById('tracksAvail'),\n        rightPane = document.getElementById('container')\n\n      if (!leftPane) {return rightPane}\n\n      if (first.pageX < leftPane.offsetLeft + leftPane.offsetWidth) {\n        return leftPane\n      } else {\n        return rightPane\n      }\n    },\n\n    removeTouchEvents: function () {\n      startX = null\n    },\n\n    touchSimulated: function (event) {\n      if (event.touches.length <= 1) {\n        var touches = event.changedTouches,\n          first = touches[0],\n          type1 = '',\n          type2 = 'mouseover',\n          objAvatar = document.getElementsByClassName('dojoDndAvatar'),\n          obj = {},\n          pane = Touch.checkAvatarPosition(first),\n          nodes = pane.getElementsByClassName('dojoDndItem'),\n          element = {},\n          simulatedEvent_1 = document.createEvent('MouseEvent'),\n          simulatedEvent_2 = document.createEvent('MouseEvent')\n\n        switch (event.type) {\n          case 'touchstart':\n            startX = first.pageX\n            type1 = 'mousedown'\n            break\n          case 'touchmove':\n            event.preventDefault()\n            type1 = 'mousemove'\n            break\n          default:\n            return\n        }\n\n        simulatedEvent_1.initMouseEvent(\n          type1,\n          true,\n          true,\n          window,\n          1,\n          first.pageX,\n          first.pageY,\n          first.clientX,\n          first.clientY,\n          false,\n          false,\n          false,\n          false,\n          0,\n          null,\n        )\n\n        simulatedEvent_2.initMouseEvent(\n          type2,\n          true,\n          true,\n          window,\n          1,\n          first.pageX,\n          first.pageY,\n          first.clientX,\n          first.clientY,\n          false,\n          false,\n          false,\n          false,\n          0,\n          null,\n        )\n\n        switch (event.type) {\n          case 'touchstart':\n            first.target.dispatchEvent(simulatedEvent_1)\n            first.target.dispatchEvent(simulatedEvent_2)\n            initialPane = pane\n            break\n          case 'touchmove':\n            if (objAvatar.length > 0) {\n              if (nodes.length > 0) {\n                element = Touch.CompareObjPos(nodes, first)\n                obj = nodes[element]\n              }\n              try {\n                if (initialPane != pane) {\n                  var simulatedEvent_3 = document.createEvent('MouseEvent')\n                  var type3 = 'mouseout'\n                  simulatedEvent_3.initMouseEvent(\n                    type3,\n                    true,\n                    true,\n                    window,\n                    1,\n                    first.pageX,\n                    first.pageY,\n                    first.clientX,\n                    first.clientY,\n                    false,\n                    false,\n                    false,\n                    false,\n                    0,\n                    null,\n                  )\n                  initialPane.dispatchEvent(simulatedEvent_3)\n                }\n                obj.dispatchEvent(simulatedEvent_2)\n                obj.dispatchEvent(simulatedEvent_1)\n              } catch (err) {\n                //No Elements in the pane\n                pane.dispatchEvent(simulatedEvent_2)\n                pane.dispatchEvent(simulatedEvent_1)\n              }\n            }\n            break\n          default:\n            return\n        }\n      } else {\n        Touch.removeTouchEvents()\n      }\n    },\n\n    touchEnd: function (event) {\n      var touches = event.changedTouches,\n        first = touches[0],\n        type1 = 'mouseup',\n        type2 = 'mouseover',\n        objAvatar = document.getElementsByClassName('dojoDndAvatar'),\n        obj = {},\n        pane = Touch.checkAvatarPosition(first),\n        nodes = pane.getElementsByClassName('dojoDndItem'),\n        element = {},\n        simulatedEvent_1 = document.createEvent('MouseEvent'),\n        simulatedEvent_2 = document.createEvent('MouseEvent')\n\n      if (startX !== first.pageX) {\n        //slide ocurrs\n        event.preventDefault()\n      }\n\n      var test = Touch.findPos(first.target)\n\n      simulatedEvent_1.initMouseEvent(\n        type1,\n        true,\n        true,\n        window,\n        1,\n        first.pageX,\n        first.pageY,\n        first.clientX,\n        first.clientY,\n        false,\n        false,\n        false,\n        false,\n        0,\n        null,\n      )\n\n      simulatedEvent_2.initMouseEvent(\n        type2,\n        true,\n        true,\n        window,\n        1,\n        first.pageX,\n        first.pageY,\n        first.clientX,\n        first.clientY,\n        false,\n        false,\n        false,\n        false,\n        0,\n        null,\n      )\n\n      if (objAvatar.length > 0) {\n        if (nodes.length > 0) {\n          element = Touch.CompareObjPos(nodes, first)\n          obj = nodes[element]\n        }\n        try {\n          obj.dispatchEvent(simulatedEvent_2)\n          obj.dispatchEvent(simulatedEvent_1)\n        } catch (error) {\n          first.target.dispatchEvent(simulatedEvent_2)\n          pane.dispatchEvent(simulatedEvent_2)\n        }\n      } else {\n        first.target.dispatchEvent(simulatedEvent_1)\n        first.target.dispatchEvent(simulatedEvent_2)\n      }\n\n      Touch.removeTouchEvents()\n    },\n\n    touchHandle: function (event) {\n      dojo\n        .query('.dojoDndItemAnchor')\n        .connect('touchstart', Touch.touchSimulated)\n      dojo\n        .query('.dojoDndItemAnchor')\n        .connect('touchmove', Touch.touchSimulated)\n      dojo.query('.dojoDndItemAnchor').connect('touchend', Touch.touchEnd)\n      dojo.query('.dojoDndItemAnchor').connect('click', function () {\n        void 0\n      })\n\n      if (event.touches.length <= 1) {\n        var touches = event.changedTouches,\n          first = touches[0],\n          type = ''\n\n        switch (event.type) {\n          case 'touchstart':\n            startX = first.pageX\n            type = 'mousedown'\n            break\n\n          case 'touchmove':\n            event.preventDefault()\n            type = 'mousemove'\n            break\n\n          case 'touchend':\n            if (startX !== first.pageX) {\n              //slide ocurrs\n              event.preventDefault()\n            }\n            type = 'mouseup'\n            break\n\n          default:\n            return\n        }\n\n        var simulatedEvent = document.createEvent('MouseEvent')\n\n        simulatedEvent.initMouseEvent(\n          type,\n          true,\n          true,\n          window,\n          1,\n          first.screenX,\n          first.screenY,\n          first.clientX,\n          first.clientY,\n          false,\n          false,\n          false,\n          false,\n          0 /*left*/,\n          null,\n        )\n\n        first.target.dispatchEvent(simulatedEvent)\n      } else {\n        Touch.removeTouchEvents()\n      }\n    },\n\n    touchinit: function () {\n      dojo.query('.dojoDndItem').connect('touchstart', Touch.touchSimulated)\n      dojo.query('.dojoDndItem').connect('touchmove', Touch.touchSimulated)\n      dojo.query('.dojoDndItem').connect('touchend', Touch.touchEnd)\n\n      dojo.query('.locationThumb').connect('touchstart', Touch.touchHandle)\n      dojo.query('.locationThumb').connect('touchmove', Touch.touchHandle)\n      dojo.query('.locationThumb').connect('touchend', Touch.touchHandle)\n\n      dojo.query('.dojoDndItem').connect('click', function () {\n        void 0\n      })\n\n      dojo.query('.dojoDndTarget').connect('touchstart', Touch.touchHandle)\n      dojo.query('.dojoDndTarget').connect('touchmove', Touch.touchHandle)\n      dojo.query('.dojoDndTarget').connect('touchend', Touch.touchHandle)\n\n      dojo.query('.dijitSplitter').connect('touchstart', Touch.touchHandle)\n      dojo.query('.dijitSplitter').connect('touchmove', Touch.touchHandle)\n      dojo.query('.dijitSplitter').connect('touchend', Touch.touchHandle)\n    },\n\n    loadTouch: function () {\n      Touch.touchinit()\n      document.documentElement.style.webkitTouchCallout = 'none'\n    },\n\n    findPos: function (obj) {\n      var curtop = 0,\n        objP = {}\n\n      if (obj.offsetParent) {\n        do {\n          curtop += obj.offsetTop\n        } while ((obj = obj.offsetParent))\n      }\n\n      objP.top = curtop\n\n      return objP\n    },\n  }\n\n  return Touch\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/Track.js":{"size":1151,"mtime":1738905962204,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Track.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/src/JBrowse/Util.js":{"size":20106,"mtime":1738905962227,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Util.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"const url = cjsRequire('url')\n\n/**\n * Miscellaneous utility functions.\n */\ndefine([\n  'dojo/_base/array',\n  'dojo/_base/lang',\n  'dojo/Deferred',\n\n  'dojox/lang/functional/object',\n  'dojox/lang/functional/fold',\n], function (array, lang, Deferred) {\n  var Util\n  Util = {\n    dojof: dojox.lang.functional,\n    is_ie: navigator.appVersion.indexOf('MSIE') >= 0,\n    is_ie6: navigator.appVersion.indexOf('MSIE 6') >= 0,\n    addCommas: function (nStr) {\n      nStr += ''\n      var x = nStr.split('.')\n      var x1 = x[0]\n      var x2 = x.length > 1 ? '.' + x[1] : ''\n      var rgx = /(\\d+)(\\d{3})/\n      while (rgx.test(x1)) {\n        x1 = x1.replace(rgx, '$1' + ',' + '$2')\n      }\n      return x1 + x2\n    },\n\n    commifyNumber: function () {\n      return this.addCommas.apply(this, arguments)\n    },\n\n    escapeHTML: function (str) {\n      if (str === null || str === undefined) {\n        return str\n      }\n      return str\n        .toString()\n        .replace(/&/g, '&amp;')\n        .replace(/</g, '&lt;')\n        .replace(/>/g, '&gt;')\n    },\n\n    unescapeHTML: function (str) {\n      return str\n        .toString()\n        .replace(/&amp;/g, '&')\n        .replace(/&lt;/g, '<')\n        .replace(/&gt;/g, '>')\n    },\n\n    /**\n     * Fast, simple class-maker, used for classes that need speed more\n     * than they need dojo.declare's nice features.\n     */\n    fastDeclare: function (members, className) {\n      var constructor = members.constructor\n      var fastDeclareClass = function () {\n        constructor.apply(this, arguments)\n      }\n      dojo.mixin(fastDeclareClass.prototype, members)\n      return fastDeclareClass\n    },\n\n    isRightButton: function (e) {\n      if (!e) {var e = window.event}\n      if (e.which) {return e.which == 3}\n      else if (e.button) {return e.button == 2}\n      else {return false}\n    },\n\n    getViewportWidth: function () {\n      var width = 0\n      if (document.documentElement && document.documentElement.clientWidth) {\n        width = document.documentElement.clientWidth\n      } else if (document.body && document.body.clientWidth) {\n        width = document.body.clientWidth\n      } else if (window.innerWidth) {\n        width = window.innerWidth - 18\n      }\n      return width\n    },\n\n    getViewportHeight: function () {\n      var height = 0\n      if (document.documentElement && document.documentElement.clientHeight) {\n        height = document.documentElement.clientHeight\n      } else if (document.body && document.body.clientHeight) {\n        height = document.body.clientHeight\n      } else if (window.innerHeight) {\n        height = window.innerHeight - 18\n      }\n      return height\n    },\n\n    findNearest: function (numArray, num) {\n      var minIndex = 0\n      var min = Math.abs(num - numArray[0])\n      for (var i = 1; i < numArray.length; i++) {\n        if (Math.abs(num - numArray[i]) < min) {\n          minIndex = i\n          min = Math.abs(num - numArray[i])\n        }\n      }\n      return minIndex\n    },\n\n    /**\n     * replace variables in a template string with values\n     * @param template String with variable names in curly brackets\n     *                 e.g., \"http://foo/{bar}?arg={baz.foo}\n     * @param fillWith object with attribute-value mappings\n     *                 e.g., { 'bar': 'someurl', 'baz': { 'foo': 42 } }\n     * @returns the template string with variables in fillWith replaced\n     *                 e.g., 'htp://foo/someurl?arg=valueforbaz'\n     *\n     */\n\n    fillTemplate: function (template, fillWith) {\n      return template.replace(/\\{([\\w\\s\\.]+)\\}/g, function (match, varname) {\n        varname = varname.replace(/\\s+/g, '') // remove all whitespace\n        var fill = lang.getObject(varname, false, fillWith)\n        if (fill !== undefined) {\n          if (typeof fill == 'function') {return fill(varname)}\n          else {return fill}\n        } else if (fillWith.callback) {\n          var v = fillWith.callback.call(this, varname)\n          if (v !== undefined) {return v}\n        }\n        return match\n      })\n    },\n\n    /**\n     * function to load a specified resource only once\n     * @param {Object}   dojoXhrArgs object containing arguments for dojo.xhrGet,\n     *                               like <code>url</code> and <code>handleAs</code>\n     * @param {Object}   stateObj object that stores the state of the load\n     * @param {Function} successCallback function to call on a successful load\n     * @param {Function} errorCallback function to call on an unsuccessful load\n     */\n    maybeLoad: function (\n      dojoXhrArgs,\n      stateObj,\n      successCallback,\n      errorCallback,\n    ) {\n      if (stateObj.state) {\n        if ('loaded' == stateObj.state) {\n          successCallback(stateObj.data)\n        } else if ('error' == stateObj.state) {\n          errorCallback()\n        } else if ('loading' == stateObj.state) {\n          stateObj.successCallbacks.push(successCallback)\n          if (errorCallback) {stateObj.errorCallbacks.push(errorCallback)}\n        }\n      } else {\n        stateObj.state = 'loading'\n        stateObj.successCallbacks = [successCallback]\n        stateObj.errorCallbacks = [errorCallback]\n\n        var args = dojo.clone(dojoXhrArgs)\n        args.load = function (o) {\n          stateObj.state = 'loaded'\n          stateObj.data = o\n          var cbs = stateObj.successCallbacks\n          for (var c = 0; c < cbs.length; c++) {cbs[c](o)}\n        }\n        args.error = function (error) {\n          console.error('' + error)\n          stateObj.state = 'error'\n          var cbs = stateObj.errorCallbacks\n          for (var c = 0; c < cbs.length; c++) {cbs[c]()}\n        }\n\n        dojo.xhrGet(args)\n      }\n    },\n\n    /**\n     * updates a with values from b, recursively\n     */\n    deepUpdate: function (a, b) {\n      for (var prop in b) {\n        if (\n          prop in a &&\n          'object' == typeof b[prop] &&\n          'object' == typeof a[prop]\n        ) {\n          Util.deepUpdate(a[prop], b[prop])\n        } else if (\n          typeof a[prop] == 'undefined' ||\n          typeof b[prop] != 'undefined'\n        ) {\n          a[prop] = b[prop]\n        }\n      }\n      return a\n    },\n\n    humanReadableNumber: function (num) {\n      num = parseInt(num)\n      var suffix = ''\n      if (num >= 1e12) {\n        num /= 1e12\n        suffix = 'T'\n      } else if (num >= 1e9) {\n        num /= 1e9\n        suffix = 'G'\n      } else if (num >= 1e6) {\n        num /= 1e6\n        suffix = 'M'\n      } else if (num >= 1000) {\n        num /= 1000\n        suffix = 'K'\n      }\n\n      return (num.toFixed(2) + ' ' + suffix)\n        .replace(/0+ /, ' ')\n        .replace(/\\. /, ' ')\n    },\n\n    resolved: function (val) {\n      var d = new Deferred()\n      d.resolve(val)\n      return d\n    },\n\n    resolveUrl: function (baseUrl, relativeUrl) {\n      if (this.isElectron()) {\n        // url.resolve does not correctly resolve absolute file urls\n        if (relativeUrl.substr(0, 8) === 'file:///') {return relativeUrl}\n      }\n      return url.resolve(baseUrl, relativeUrl)\n    },\n\n    loadJS: function (paths) {\n      var d = new Deferred()\n      dojo.global.require(paths, function () {\n        var modules = Array.prototype.slice.call(arguments)\n\n        // check the loaded modules for success\n        for (var i = 0; i < modules.length; i++) {\n          if (!{ object: true, function: true }[typeof modules[i]]) {\n            d.reject('could not load ' + paths[i] + ': ' + modules[i])\n            return\n          }\n        }\n\n        d.resolve(modules)\n      })\n      return d\n    },\n\n    isElectron: function () {\n      var process = window.process\n      return !!(process && process.versions && process.versions.electron)\n    },\n\n    parseLocString: function (locstring) {\n      if (typeof locstring != 'string') {return null}\n      locstring = locstring.trim()\n\n      var location = {}\n\n      // Strip out any extra info in parentheses?\n      var extraRegex = new RegExp(\n        [\n          /^\\s*/, // optional whitespace at start of locstring\n          /(.+?)/, // capture remaining characters, non-greedily, as the locstring without the \"extra\" info\n          /(\\((.+?)\\))?/, // capture the contents of the perentheses, if they exist, as the \"extra\" info\n          /\\s*$/, // optional whitespace at end locstring\n        ]\n          .map(function (r) {\n            return r.source\n          })\n          .join(''),\n      )\n\n      var tokens_extra = locstring.match(extraRegex)\n\n      locstring = tokens_extra[1]\n\n      if (tokens_extra[3]) {\n        location.extra = tokens_extra[3]\n      }\n\n      // Regex to match coordinate ranges, with or without a ref seq id\n      var rangeRegex = new RegExp(\n        [\n          /^((.+):)?/, // ref seq id\n          /\\s*/, // optional whitespace preceeding range\n          /-?([\\d,]+(\\.\\d+)?)/, // extract positive integer part of first number - thousand separator (\",\") safe\n          /\\s*/, // optional whitespace\n          /(\\.{2,}|-+)/, // range separator of 2 or more dots OR 1 or more hyphen\n          /\\s*/, // optional whitespace\n          /-?([\\d,]+(\\.\\d+)?)/, // extract positive integer part of second number - thousand separator (\",\") safe\n          /\\s*$/, // optional whitespace\n        ]\n          .map(function (r) {\n            return r.source\n          })\n          .join(''),\n      )\n\n      var rangeTokens = locstring.match(rangeRegex)\n\n      if (rangeTokens) {\n        // locstring specified a range\n        location.ref = rangeTokens[2]\n        location.start = Number(rangeTokens[3].replace(/\\,/g, ''))\n        location.end = Number(rangeTokens[6].replace(/\\,/g, ''))\n\n        // reverse the numbers if necessary\n        if (location.start > location.end) {\n          var t = location.start\n          location.start = location.end\n          location.end = t\n        }\n      } else {\n        // locstring comprises a single point location coordinate, with or without a ref seq id\n        var pointRegex = new RegExp(\n          [\n            /^((.+):)?/, // ref\n            /\\s*/, // optional whitespace\n            /-?([\\d,]+(\\.\\d+)?)?/, // extract positive integer part of first number - thousand separator (\",\") safe\n            /\\s*$/, // optional whitespace\n          ]\n            .map(function (r) {\n              return r.source\n            })\n            .join(''),\n        )\n\n        var pointTokens = locstring.match(pointRegex)\n\n        if (pointTokens) {\n          if (pointTokens[2]) {\n            location.ref = pointTokens[2]\n          }\n          if (pointTokens[3]) {\n            location.start = Number(pointTokens[3].replace(/\\,/g, ''))\n            location.end = location.start\n          } else {\n            return null\n          }\n        } else {\n          return null\n        }\n      }\n\n      // Make coordinates 0-start, half-open (like BED cordinates)\n      location.start = location.start - 1\n\n      return location\n    },\n\n    basename: function (str, suffixList) {\n      if (!str || !str.match) {return undefined}\n      var m = str.match(/[\\/\\\\]([^\\/\\\\]+)[\\/\\/\\/]*$/)\n      var bn = m ? m[1] || undefined : str\n      if (bn && suffixList) {\n        if (!(suffixList instanceof Array)) {suffixList = [suffixList]}\n        suffixList = array.map(suffixList, function (s) {\n          return s.replace(/([\\.\\?\\+])/g, '\\\\$1')\n        })\n        bn = bn.replace(new RegExp(suffixList.join('|') + '$', 'i'), '')\n      }\n      return bn\n    },\n\n    assembleLocString: function (loc_in, useExtra = true) {\n      var s = '',\n        types = {\n          start: 'number',\n          end: 'number',\n          ref: 'string',\n          strand: 'number',\n        },\n        location = {}\n      // filter the incoming loc_in to only pay attention to slots that we\n      // know how to handle\n      for (var slot in types) {\n        if (\n          types[slot] == typeof loc_in[slot] &&\n          (types[slot] != 'number' || !isNaN(loc_in[slot])) //filter any NaNs\n        ) {\n          location[slot] = loc_in[slot]\n        }\n      }\n\n      //finally assemble our string\n      if ('ref' in location) {\n        s += location.ref\n        if (location.start || location.end) {s += ':'}\n      }\n      if ('start' in location) {\n        s += (Math.round(location.start) + 1).toFixed(0).toLocaleString()\n        if ('end' in location) {s += '..'}\n      }\n      if ('end' in location)\n        {s += Math.round(location.end).toFixed(0).toLocaleString()}\n\n      if ('strand' in location)\n        {s +=\n          {\n            1: ' (+ strand)',\n            '-1': ' (- strand)',\n            0: ' (no strand)',\n          }[location.strand || ''] || ''}\n\n      // add on any extra stuff if it was passed in\n      if (useExtra && 'extra' in loc_in) {s += loc_in.extra}\n\n      return s\n    },\n\n    /**\n     * Complement a sequence (without reversing).\n     * @param {String} seqString sequence\n     * @returns {String} complemented sequence\n     */\n    complement: (function () {\n      var compl_rx = /[ACGT]/gi\n\n      // from bioperl: tr/acgtrymkswhbvdnxACGTRYMKSWHBVDNX/tgcayrkmswdvbhnxTGCAYRKMSWDVBHNX/\n      // generated with:\n      // perl -MJSON -E '@l = split \"\",\"acgtrymkswhbvdnxACGTRYMKSWHBVDNX\"; print to_json({ map { my $in = $_; tr/acgtrymkswhbvdnxACGTRYMKSWHBVDNX/tgcayrkmswdvbhnxTGCAYRKMSWDVBHNX/; $in => $_ } @l})'\n      var compl_tbl = {\n        S: 'S',\n        w: 'w',\n        T: 'A',\n        r: 'y',\n        a: 't',\n        N: 'N',\n        K: 'M',\n        x: 'x',\n        d: 'h',\n        Y: 'R',\n        V: 'B',\n        y: 'r',\n        M: 'K',\n        h: 'd',\n        k: 'm',\n        C: 'G',\n        g: 'c',\n        t: 'a',\n        A: 'T',\n        n: 'n',\n        W: 'W',\n        X: 'X',\n        m: 'k',\n        v: 'b',\n        B: 'V',\n        s: 's',\n        H: 'D',\n        c: 'g',\n        D: 'H',\n        b: 'v',\n        R: 'Y',\n        G: 'C',\n      }\n\n      var nbsp = String.fromCharCode(160)\n      var compl_func = function (m) {\n        return compl_tbl[m] || nbsp\n      }\n      return function (seqString) {\n        return seqString.replace(compl_rx, compl_func)\n      }\n    })(),\n\n    /**\n     * Reverse-complement a sequence string.\n     * @param {String} seqString\n     * @returns {String} reverse-complemented sequence\n     */\n    revcom: function (seqString) {\n      return Util.complement(seqString).split('').reverse().join('')\n    },\n\n    assembleLocStringWithLength: function (def) {\n      var locString = Util.assembleLocString(def)\n      var length = def.length || def.end - def.start\n      return locString + ' (' + Util.humanReadableNumber(length) + 'b)'\n    },\n\n    // given a possible reference sequence name and an object as { 'foo':\n    // <refseq foo>, ... }, try to match that reference sequence name\n    // against the actual name of one of the reference sequences.  returns\n    // the reference sequence record, or null\n    // if none matched.\n    matchRefSeqName: function (name, refseqs) {\n      for (var ref in refseqs) {\n        if (!refseqs.hasOwnProperty(ref)) {continue}\n\n        var ucname = name.toUpperCase()\n        var ucref = ref.toUpperCase()\n\n        if (\n          ucname == ucref ||\n          'CHR' + ucname == ucref ||\n          ucname == 'CHR' + ucref\n        ) {\n          return refseqs[ref]\n        }\n      }\n      return null\n    },\n\n    /**\n     * Wrap a handler function to be called 1ms later in a window timeout.\n     * This will usually give a better stack trace for figuring out where\n     * errors are happening.\n     */\n    debugHandler: function (context, func) {\n      return function () {\n        var args = arguments\n        window.setTimeout(function () {\n          var f = func\n          if (typeof f == 'string') {f = context[f]}\n          f.apply(context, args)\n        }, 1)\n      }\n    },\n\n    ucFirst: function (str) {\n      if (typeof str != 'string') {return undefined}\n      return str.charAt(0).toUpperCase() + str.slice(1)\n    },\n\n    /**\n     * Uniqify an array.\n     * @param stuff {Array} array of stuff\n     * @param normalizer {Function} optional function to be called on\n     * each element to convert them to a comparable string.  By\n     * default, just does default stringification.\n     */\n    uniq: function (stuff, normalizer) {\n      normalizer =\n        normalizer ||\n        function (t) {\n          return '' + t\n        }\n      var result = [],\n        seen = {}\n      dojo.forEach(stuff, function (thing) {\n        var norm = normalizer(thing)\n        if (!seen[normalizer(thing)]) {result.push(thing)}\n        seen[norm] = true\n      })\n      return result\n    },\n\n    /**\n     * Replace windows file path, e.g. C:\\ to use file:/// prefixes\n     */\n    replacePath: function (path) {\n      return path.replace(/^(\\w):/, 'file:///$1:').replace(/\\\\/g, '/')\n    },\n    unReplacePath: function (path) {\n      path = path.replace(/^file:\\/\\//, '')\n      var process = window.process\n      return process.platform === 'win32' && path[0] == '/'\n        ? path.substr(1)\n        : path\n    },\n\n    // back-compatible way to remove properties/attributes from DOM\n    // nodes.  IE 7 and older do not support the `delete` operator on\n    // DOM nodes.\n    removeAttribute: function (domNode, attrName) {\n      try {\n        delete domNode[attrName]\n      } catch (e) {\n        if (domNode.removeAttribute) {domNode.removeAttribute(attrName)}\n      }\n    },\n    // Return resolution, accounting for config possibly specifying that highres is disabled\n    getResolution: function (ctx, highResolutionMode) {\n      var ratio\n      if (highResolutionMode == 'auto') {\n        // finally query the various pixel ratios\n        var devicePixelRatio = window.devicePixelRatio || 1\n        var backingStoreRatio =\n          ctx.webkitBackingStorePixelRatio ||\n          ctx.mozBackingStorePixelRatio ||\n          ctx.msBackingStorePixelRatio ||\n          ctx.oBackingStorePixelRatio ||\n          ctx.backingStorePixelRatio ||\n          1\n        ratio = Math.ceil(devicePixelRatio / backingStoreRatio)\n      } else if (highResolutionMode == 'disabled') {\n        ratio = 1\n      } else {\n        ratio = highResolutionMode\n      }\n      return ratio >= 1 ? ratio : 1\n    },\n\n    /**\n     * flatten array like [ [1,2], [3,4] ] to [ 1,2,3,4 ]\n     * @param {Array} ar\n     */\n    flattenOneLevel(ar) {\n      const r = []\n      for (let i = 0; i < ar.length; i += 1) {\n        r.push(...ar[i])\n      }\n      return r\n    },\n\n    /**\n     * Coerce a value of unknown type to a boolean, treating string 'true'\n     * and 'false' as the values they indicate, and string numbers as\n     * numbers.\n     * @private\n     */\n    coerceBoolean: function (val) {\n      if (typeof val == 'string') {\n        val = val.toLowerCase()\n        if (val == 'true') {\n          return true\n        } else if (val == 'false') {return false}\n        else {return parseInt(val)}\n      } else if (typeof val == 'boolean') {\n        return val\n      } else if (typeof val == 'number') {\n        return !!val\n      } else {\n        return true\n      }\n    },\n\n    intersect(x1, x2, y1, y2) {\n      return x2 >= y1 && y2 >= x1\n    },\n\n    // orientation definitions from igv.js, see also https://software.broadinstitute.org/software/igv/interpreting_pair_orientations\n    orientationTypes: {\n      fr: {\n        F1R2: 'LR',\n        F2R1: 'LR',\n\n        F1F2: 'LL',\n        F2F1: 'LL',\n\n        R1R2: 'RR',\n        R2R1: 'RR',\n\n        R1F2: 'RL',\n        R2F1: 'RL',\n      },\n\n      rf: {\n        R1F2: 'LR',\n        R2F1: 'LR',\n\n        R1R2: 'LL',\n        R2R1: 'LL',\n\n        F1F2: 'RR',\n        F2F1: 'RR',\n\n        F1R2: 'RL',\n        F2R1: 'RL',\n      },\n\n      ff: {\n        F2F1: 'LR',\n        R1R2: 'LR',\n\n        F2R1: 'LL',\n        R1F2: 'LL',\n\n        R2F1: 'RR',\n        F1R2: 'RR',\n\n        R2R1: 'RL',\n        F1F2: 'RL',\n      },\n    },\n  }\n\n  return Util\n})\n\n/*\n\nCopyright (c) 2007-2018 The Evolutionary Software Foundation\n\nCreated by Mitchell Skinner <mitch_skinner@berkeley.edu>\n\nThis package and its accompanying libraries are free software; you can\nredistribute it and/or modify it under the terms of the LGPL (either\nversion 2.1, or at your option, any later version) or the Artistic\nLicense 2.0.  Refer to LICENSE for the full license text.\n\n*/\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/Util/arrayCopy.js":{"size":1347,"mtime":1738905962233,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Util/arrayCopy.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/src/JBrowse/Util/dot-object.js":{"size":12560,"mtime":1738905962251,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Util/dot-object.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"// from: https://unpkg.com/dot-object@1.7.0/dist/dot-object.js\n;(function (global, exportName) {\n  'use strict'\n\n  function _process(v, mod) {\n    var i\n    var r\n\n    if (typeof mod === 'function') {\n      r = mod(v)\n      if (r !== undefined) {\n        v = r\n      }\n    } else if (Array.isArray(mod)) {\n      for (i = 0; i < mod.length; i++) {\n        r = mod[i](v)\n        if (r !== undefined) {\n          v = r\n        }\n      }\n    }\n\n    return v\n  }\n\n  function parseKey(key, val) {\n    // detect negative index notation\n    if (key[0] === '-' && Array.isArray(val) && /^-\\d+$/.test(key)) {\n      return val.length + parseInt(key, 10)\n    }\n    return key\n  }\n\n  function isIndex(k) {\n    return /^\\d+/.test(k)\n  }\n\n  function isObject(val) {\n    return Object.prototype.toString.call(val) === '[object Object]'\n  }\n\n  function isArrayOrObject(val) {\n    return Object(val) === val\n  }\n\n  function isEmptyObject(val) {\n    return Object.keys(val).length === 0\n  }\n\n  function parsePath(path, sep) {\n    if (path.indexOf('[') >= 0) {\n      path = path.replace(/\\[/g, '.').replace(/]/g, '')\n    }\n    return path.split(sep)\n  }\n\n  function DotObject(seperator, override, useArray) {\n    if (!(this instanceof DotObject)) {\n      return new DotObject(seperator, override, useArray)\n    }\n\n    if (typeof override === 'undefined') {override = false}\n    if (typeof useArray === 'undefined') {useArray = true}\n    this.seperator = seperator || '.'\n    this.override = override\n    this.useArray = useArray\n    this.keepArray = false\n\n    // contains touched arrays\n    this.cleanup = []\n  }\n\n  var dotDefault = new DotObject('.', false, true)\n\n  function wrap(method) {\n    return function () {\n      return dotDefault[method].apply(dotDefault, arguments)\n    }\n  }\n\n  DotObject.prototype._fill = function (a, obj, v, mod) {\n    var k = a.shift()\n\n    if (a.length > 0) {\n      obj[k] = obj[k] || (this.useArray && isIndex(a[0]) ? [] : {})\n\n      if (!isArrayOrObject(obj[k])) {\n        if (this.override) {\n          obj[k] = {}\n        } else {\n          if (!(isArrayOrObject(v) && isEmptyObject(v))) {\n            throw new Error(\n              'Trying to redefine `' + k + '` which is a ' + typeof obj[k],\n            )\n          }\n\n          return\n        }\n      }\n\n      this._fill(a, obj[k], v, mod)\n    } else {\n      if (!this.override && isArrayOrObject(obj[k]) && !isEmptyObject(obj[k])) {\n        if (!(isArrayOrObject(v) && isEmptyObject(v))) {\n          throw new Error(\"Trying to redefine non-empty obj['\" + k + \"']\")\n        }\n\n        return\n      }\n\n      obj[k] = _process(v, mod)\n    }\n  }\n\n  /**\n   *\n   * Converts an object with dotted-key/value pairs to it's expanded version\n   *\n   * Optionally transformed by a set of modifiers.\n   *\n   * Usage:\n   *\n   *   var row = {\n   *     'nr': 200,\n   *     'doc.name': '  My Document  '\n   *   }\n   *\n   *   var mods = {\n   *     'doc.name': [_s.trim, _s.underscored]\n   *   }\n   *\n   *   dot.object(row, mods)\n   *\n   * @param {Object} obj\n   * @param {Object} mods\n   */\n  DotObject.prototype.object = function (obj, mods) {\n    var self = this\n\n    Object.keys(obj).forEach(function (k) {\n      var mod = mods === undefined ? null : mods[k]\n      // normalize array notation.\n      var ok = parsePath(k, self.seperator).join(self.seperator)\n\n      if (ok.indexOf(self.seperator) !== -1) {\n        self._fill(ok.split(self.seperator), obj, obj[k], mod)\n        delete obj[k]\n      } else if (self.override) {\n        obj[k] = _process(obj[k], mod)\n      }\n    })\n\n    return obj\n  }\n\n  /**\n   * @param {String} path dotted path\n   * @param {String} v value to be set\n   * @param {Object} obj object to be modified\n   * @param {Function|Array} mod optional modifier\n   */\n  DotObject.prototype.str = function (path, v, obj, mod) {\n    if (path.indexOf(this.seperator) !== -1) {\n      this._fill(path.split(this.seperator), obj, v, mod)\n    } else if (!obj.hasOwnProperty(path) || this.override) {\n      obj[path] = _process(v, mod)\n    }\n\n    return obj\n  }\n\n  /**\n   *\n   * Pick a value from an object using dot notation.\n   *\n   * Optionally remove the value\n   *\n   * @param {String} path\n   * @param {Object} obj\n   * @param {Boolean} remove\n   */\n  DotObject.prototype.pick = function (path, obj, remove) {\n    var i\n    var keys\n    var val\n    var key\n    var cp\n\n    keys = parsePath(path, this.seperator)\n    for (i = 0; i < keys.length; i++) {\n      key = parseKey(keys[i], obj)\n      if (obj && typeof obj === 'object' && key in obj) {\n        if (i === keys.length - 1) {\n          if (remove) {\n            val = obj[key]\n            delete obj[key]\n            if (Array.isArray(obj)) {\n              cp = keys.slice(0, -1).join('.')\n              if (this.cleanup.indexOf(cp) === -1) {\n                this.cleanup.push(cp)\n              }\n            }\n            return val\n          } else {\n            return obj[key]\n          }\n        } else {\n          obj = obj[key]\n        }\n      } else {\n        return undefined\n      }\n    }\n    if (remove && Array.isArray(obj)) {\n      obj = obj.filter(function (n) {\n        return n !== undefined\n      })\n    }\n    return obj\n  }\n\n  /**\n   *\n   * Remove value from an object using dot notation.\n   *\n   * @param {String} path\n   * @param {Object} obj\n   * @return {Mixed} The removed value\n   */\n  DotObject.prototype.remove = function (path, obj) {\n    var i\n\n    this.cleanup = []\n    if (Array.isArray(path)) {\n      for (i = 0; i < path.length; i++) {\n        this.pick(path[i], obj, true)\n      }\n      this._cleanup(obj)\n      return obj\n    } else {\n      return this.pick(path, obj, true)\n    }\n  }\n\n  DotObject.prototype._cleanup = function (obj) {\n    var ret\n    var i\n    var keys\n    var root\n    if (this.cleanup.length) {\n      for (i = 0; i < this.cleanup.length; i++) {\n        keys = this.cleanup[i].split('.')\n        root = keys.splice(0, -1).join('.')\n        ret = root ? this.pick(root, obj) : obj\n        ret = ret[keys[0]].filter(function (v) {\n          return v !== undefined\n        })\n        this.set(this.cleanup[i], ret, obj)\n      }\n      this.cleanup = []\n    }\n  }\n\n  // alias method\n  DotObject.prototype.del = DotObject.prototype.remove\n\n  /**\n   *\n   * Move a property from one place to the other.\n   *\n   * If the source path does not exist (undefined)\n   * the target property will not be set.\n   *\n   * @param {String} source\n   * @param {String} target\n   * @param {Object} obj\n   * @param {Function|Array} mods\n   * @param {Boolean} merge\n   */\n  DotObject.prototype.move = function (source, target, obj, mods, merge) {\n    if (typeof mods === 'function' || Array.isArray(mods)) {\n      this.set(target, _process(this.pick(source, obj, true), mods), obj, merge)\n    } else {\n      merge = mods\n      this.set(target, this.pick(source, obj, true), obj, merge)\n    }\n\n    return obj\n  }\n\n  /**\n   *\n   * Transfer a property from one object to another object.\n   *\n   * If the source path does not exist (undefined)\n   * the property on the other object will not be set.\n   *\n   * @param {String} source\n   * @param {String} target\n   * @param {Object} obj1\n   * @param {Object} obj2\n   * @param {Function|Array} mods\n   * @param {Boolean} merge\n   */\n  DotObject.prototype.transfer = function (\n    source,\n    target,\n    obj1,\n    obj2,\n    mods,\n    merge,\n  ) {\n    if (typeof mods === 'function' || Array.isArray(mods)) {\n      this.set(\n        target,\n        _process(this.pick(source, obj1, true), mods),\n        obj2,\n        merge,\n      )\n    } else {\n      merge = mods\n      this.set(target, this.pick(source, obj1, true), obj2, merge)\n    }\n\n    return obj2\n  }\n\n  /**\n   *\n   * Copy a property from one object to another object.\n   *\n   * If the source path does not exist (undefined)\n   * the property on the other object will not be set.\n   *\n   * @param {String} source\n   * @param {String} target\n   * @param {Object} obj1\n   * @param {Object} obj2\n   * @param {Function|Array} mods\n   * @param {Boolean} merge\n   */\n  DotObject.prototype.copy = function (\n    source,\n    target,\n    obj1,\n    obj2,\n    mods,\n    merge,\n  ) {\n    if (typeof mods === 'function' || Array.isArray(mods)) {\n      this.set(\n        target,\n        _process(\n          // clone what is picked\n          JSON.parse(JSON.stringify(this.pick(source, obj1, false))),\n          mods,\n        ),\n        obj2,\n        merge,\n      )\n    } else {\n      merge = mods\n      this.set(target, this.pick(source, obj1, false), obj2, merge)\n    }\n\n    return obj2\n  }\n\n  /**\n   *\n   * Set a property on an object using dot notation.\n   *\n   * @param {String} path\n   * @param {Mixed} val\n   * @param {Object} obj\n   * @param {Boolean} merge\n   */\n  DotObject.prototype.set = function (path, val, obj, merge) {\n    var i\n    var k\n    var keys\n    var key\n\n    // Do not operate if the value is undefined.\n    if (typeof val === 'undefined') {\n      return obj\n    }\n    keys = parsePath(path, this.seperator)\n\n    for (i = 0; i < keys.length; i++) {\n      key = keys[i]\n      if (i === keys.length - 1) {\n        if (merge && isObject(val) && isObject(obj[key])) {\n          for (k in val) {\n            if (val.hasOwnProperty(k)) {\n              obj[key][k] = val[k]\n            }\n          }\n        } else if (merge && Array.isArray(obj[key]) && Array.isArray(val)) {\n          for (var j = 0; j < val.length; j++) {\n            obj[keys[i]].push(val[j])\n          }\n        } else {\n          obj[key] = val\n        }\n      } else if (\n        // force the value to be an object\n        !obj.hasOwnProperty(key) ||\n        (!isObject(obj[key]) && !Array.isArray(obj[key]))\n      ) {\n        // initialize as array if next key is numeric\n        if (/^\\d+$/.test(keys[i + 1])) {\n          obj[key] = []\n        } else {\n          obj[key] = {}\n        }\n      }\n      obj = obj[key]\n    }\n    return obj\n  }\n\n  /**\n   *\n   * Transform an object\n   *\n   * Usage:\n   *\n   *   var obj = {\n   *     \"id\": 1,\n   *    \"some\": {\n   *      \"thing\": \"else\"\n   *    }\n   *   }\n   *\n   *   var transform = {\n   *     \"id\": \"nr\",\n   *    \"some.thing\": \"name\"\n   *   }\n   *\n   *   var tgt = dot.transform(transform, obj)\n   *\n   * @param {Object} recipe Transform recipe\n   * @param {Object} obj Object to be transformed\n   * @param {Array} mods modifiers for the target\n   */\n  DotObject.prototype.transform = function (recipe, obj, tgt) {\n    obj = obj || {}\n    tgt = tgt || {}\n    Object.keys(recipe).forEach(\n      function (key) {\n        this.set(recipe[key], this.pick(key, obj), tgt)\n      }.bind(this),\n    )\n    return tgt\n  }\n\n  /**\n   *\n   * Convert object to dotted-key/value pair\n   *\n   * Usage:\n   *\n   *   var tgt = dot.dot(obj)\n   *\n   *   or\n   *\n   *   var tgt = {}\n   *   dot.dot(obj, tgt)\n   *\n   * @param {Object} obj source object\n   * @param {Object} tgt target object\n   * @param {Array} path path array (internal)\n   */\n  DotObject.prototype.dot = function (obj, tgt, path) {\n    tgt = tgt || {}\n    path = path || []\n    Object.keys(obj).forEach(\n      function (key) {\n        if (\n          isArrayOrObject(obj[key]) &&\n          ((isObject(obj[key]) && !isEmptyObject(obj[key])) ||\n            (Array.isArray(obj[key]) &&\n              !this.keepArray &&\n              obj[key].length !== 0))\n        ) {\n          return this.dot(obj[key], tgt, path.concat(key))\n        } else {\n          tgt[path.concat(key).join(this.seperator)] = obj[key]\n        }\n      }.bind(this),\n    )\n    return tgt\n  }\n\n  DotObject.pick = wrap('pick')\n  DotObject.move = wrap('move')\n  DotObject.transfer = wrap('transfer')\n  DotObject.transform = wrap('transform')\n  DotObject.copy = wrap('copy')\n  DotObject.object = wrap('object')\n  DotObject.str = wrap('str')\n  DotObject.set = wrap('set')\n  DotObject.del = DotObject.remove = wrap('remove')\n  DotObject.dot = wrap('dot')\n  ;['override', 'overwrite'].forEach(function (prop) {\n    Object.defineProperty(DotObject, prop, {\n      get: function () {\n        return dotDefault.override\n      },\n      set: function (val) {\n        dotDefault.override = !!val\n      },\n    })\n  })\n  ;['useArray', 'keepArray'].forEach(function (prop) {\n    Object.defineProperty(DotObject, prop, {\n      get: function () {\n        return dotDefault[prop]\n      },\n      set: function (val) {\n        dotDefault[prop] = val\n      },\n    })\n  })\n\n  DotObject._process = _process\n\n  if (typeof define === 'function' && define.amd) {\n    define(function () {\n      return DotObject\n    })\n  } else {\n    global[exportName] = DotObject\n  }\n})(this, 'DotObject')\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/Util/FastPromise.js":{"size":592,"mtime":1738905962254,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Util/FastPromise.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"/**\n * Very minimal and fast implementation of a promise, used in\n * performance-critical code.  Dojo Deferred is too heavy for some\n * uses.\n */\n\ndefine([], function () {\n  var fastpromise = function () {\n    this.callbacks = []\n  }\n\n  fastpromise.prototype.then = function (callback) {\n    if ('value' in this) {callback(this.value)}\n    else {this.callbacks.push(callback)}\n  }\n\n  fastpromise.prototype.resolve = function (value) {\n    this.value = value\n    var c = this.callbacks\n    delete this.callbacks\n    for (var i = 0; i < c.length; i++) {c[i](this.value)}\n  }\n\n  return fastpromise\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/Util/FeatureFilters.js":{"size":614,"mtime":1738905962257,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Util/FeatureFilters.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/src/JBrowse/Util/GTF.js":{"size":4618,"mtime":1738905962267,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Util/GTF.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"/**\n * Fast, low-level functions for parsing and formatting GFF3.\n * JavaScript port of Robert Buels's Bio::GFF3::LowLevel Perl module.\n */\n\ndefine(['dojo/_base/array'], function (array) {\n  var gff3_field_names =\n    'seq_id source type start end score strand phase attributes'.split(' ')\n\n  return {\n    parse_feature: function (line) {\n      var f = array.map(line.split('\\t'), function (a) {\n        if (a == '.') {\n          return null\n        }\n        return a\n      })\n\n      // unescape only the ref and source columns\n      f[0] = this.unescape(f[0])\n      f[1] = this.unescape(f[1])\n\n      f[8] = this.parse_attributes(f[8])\n      var parsed = {}\n      for (var i = 0; i < gff3_field_names.length; i++) {\n        parsed[gff3_field_names[i]] = f[i] == '.' ? null : f[i]\n      }\n      if (parsed.start !== null) {parsed.start = parseInt(parsed.start, 10)}\n      if (parsed.end !== null) {parsed.end = parseInt(parsed.end, 10)}\n      if (parsed.score !== null) {parsed.score = parseFloat(parsed.score, 10)}\n      if (parsed.strand !== null)\n        {parsed.strand = { '+': 1, '-': -1 }[parsed.strand] || 0}\n\n      return parsed\n    },\n\n    parse_directive: function (line) {\n      var match = /^\\s*\\#\\#\\s*(\\S+)\\s*(.*)/.exec(line)\n      if (!match) {return null}\n      var name = match[1],\n        contents = match[2]\n\n      var parsed = { directive: name }\n      if (contents.length) {\n        contents = contents.replace(/\\r?\\n$/, '')\n        parsed.value = contents\n      }\n\n      // do a little additional parsing for sequence-region and genome-build directives\n      if (name == 'sequence-region') {\n        var c = contents.split(/\\s+/, 3)\n        parsed.seq_id = c[0]\n        parsed.start = c[1].replace(/\\D/g, '')\n        parsed.end = c[2].replace(/\\D/g, '')\n      } else if (name == 'genome-build') {\n        var c = contents.split(/\\s+/, 2)\n        parsed.source = c[0]\n        parsed.buildname = c[1]\n      }\n\n      return parsed\n    },\n\n    unescape: function (s) {\n      if (s === null) {return null}\n\n      return s.replace(/%([0-9A-Fa-f]{2})/g, function (match, seq) {\n        return String.fromCharCode(parseInt(seq, 16))\n      })\n    },\n\n    escape: function (s) {\n      return s.replace(/[\\n\\r\\t;=%&,\\x00-\\x1f\\x7f-\\xff]/g, function (ch) {\n        var hex = ch.charCodeAt(0).toString(16).toUpperCase()\n        if (hex.length < 2)\n          // lol, apparently there's no native function for fixed-width hex output\n          {hex = '0' + hex}\n        return '%' + hex\n      })\n    },\n\n    parse_attributes: function (attrString) {\n      if (!(attrString && attrString.length) || attrString == '.') {return {}}\n\n      attrString = attrString.replace(/\\r?\\n$/, '')\n\n      var attrs = {}\n      var attr_pat = /^\\s*(.+)\\s+\"(.+)\"/\n      array.forEach(\n        attrString.split(';'),\n        function (a) {\n          var m\n          var nv = (m = attr_pat.exec(a)) ? m.slice(1) : []\n          //var nv = a.trim().replace(/\\\"+|\\'+/g,'').split(/\\s+/,2);\n          if (!(nv[1] && nv[1].length)) {return}\n          var arec = attrs[nv[0]]\n          if (!arec) {arec = attrs[nv[0]] = []}\n\n          arec.push.apply(arec, array.map(nv[1].split(','), this.unescape))\n        },\n        this,\n      )\n\n      return attrs\n    },\n\n    format_feature: function (f) {\n      var attrString =\n        f.attributes === null || typeof f.attributes == 'undefined'\n          ? '.'\n          : this.format_attributes(f.attributes)\n\n      var translate_strand = ['-', '.', '+']\n      var fields = []\n      for (var i = 0; i < 8; i++) {\n        var val = f[gff3_field_names[i]]\n        if (i == 6)\n          // deserialize strand\n          {fields[i] =\n            val === null || val === undefined ? '.' : translate_strand[val + 1]}\n        else\n          {fields[i] =\n            val === null || val === undefined ? '.' : this.escape('' + val)}\n      }\n      fields[8] = attrString\n\n      return fields.join('\\t') + '\\n'\n    },\n\n    format_attributes: function (attrs) {\n      var attrOrder = []\n      for (var tag in attrs) {\n        var val = attrs[tag]\n        var valstring = val.hasOwnProperty('toString')\n          ? this.escape(val.toString())\n          : val.values\n            ? function (val) {\n                return val instanceof Array\n                  ? array.map(val, this.escape).join(',')\n                  : this.escape(val)\n              }.call(this, val.values)\n            : val instanceof Array\n              ? array.map(val, this.escape).join(',')\n              : this.escape(val)\n        attrOrder.push(this.escape(tag) + '=' + valstring)\n      }\n      return attrOrder.length ? attrOrder.join(';') : '.'\n    },\n  }\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/Util/jszlib.js":{"size":70113,"mtime":1738905962363,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Util/jszlib.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"/* eslint-disable no-undef */\n/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\ndefine(['./arrayCopy'], function (arrayCopy) {\n  //\n  // Javascript ZLib\n  // By Thomas Down 2010-2011\n  //\n  // Based very heavily on portions of jzlib (by ymnk@jcraft.com), who in\n  // turn credits Jean-loup Gailly and Mark Adler for the original zlib code.\n  //\n  // inflate.js: ZLib inflate code\n  //\n\n  //\n  // Shared constants\n  //\n  //\n  // Original https://github.com/dasmoth/jszlib, then rehosted under rbuels\n  // and cmdcolin, before arriving here because it's probably better to not\n  // put this on NPM (people can use pako or something different in general)\n  //\n  //JSZlib is a Javascript implementation of zlib, for modern web browsers.\n  //It uses typed arrays instead of binary strings for storing data.\n  //Simplistic testing suggests that this can give about a 2-fold\n  //speedup, and also means that JSZlib is a good match for tools which use\n  //ArrayBuffers and/or typed arrays to access binary data.\n\n  //JSZlib currently just implements the \"inflate\" part of zlib, but there\n  //will hopefully be a port of the \"deflate\" portion in the future.\n\n  //JSZlib is based very closely on jzlib (http://www.jcraft.com/jzlib/), and\n  //is distributed under the same (BSD-style) license. The author of jzlib,\n  //ymnk, in turn credits Jean-loup Gailly and Mark Adler for the\n  //original zlib code.\n\n  var MAX_WBITS = 15 // 32K LZ77 window\n  var DEF_WBITS = MAX_WBITS\n  var MAX_MEM_LEVEL = 9\n  var MANY = 1440\n  var BMAX = 15\n\n  // preset dictionary flag in zlib header\n  var PRESET_DICT = 0x20\n\n  var Z_NO_FLUSH = 0\n  var Z_PARTIAL_FLUSH = 1\n  var Z_SYNC_FLUSH = 2\n  var Z_FULL_FLUSH = 3\n  var Z_FINISH = 4\n\n  var Z_DEFLATED = 8\n\n  var STATUS_STRINGS = []\n  var Z_OK = 0\n  STATUS_STRINGS[Z_OK] = 'Z_OK: stream correct'\n  var Z_STREAM_END = 1\n  STATUS_STRINGS[Z_STREAM_END] = 'Z_STREAM_END: end of stream'\n  var Z_NEED_DICT = 2\n  STATUS_STRINGS[Z_NEED_DICT] = 'Z_NEED_DICT: stream not yet complete'\n\n  var Z_ERRNO = -1\n  STATUS_STRINGS[Z_ERRNO] = 'Z_ERRNO'\n  var Z_STREAM_ERROR = -2\n  STATUS_STRINGS[Z_STREAM_ERROR] = 'Z_STREAM_ERROR'\n  var Z_DATA_ERROR = -3\n  STATUS_STRINGS[Z_DATA_ERROR] = 'Z_DATA_ERROR'\n  var Z_MEM_ERROR = -4\n  STATUS_STRINGS[Z_MEM_ERROR] = 'Z_MEM_ERROR'\n  var Z_BUF_ERROR = -5\n  STATUS_STRINGS[Z_BUF_ERROR] = 'Z_BUF_ERROR: premature end of buffer'\n  var Z_VERSION_ERROR = -6\n  STATUS_STRINGS[Z_VERSION_ERROR] = 'Z_VERSION_ERROR'\n\n  var METHOD = 0 // waiting for method byte\n  var FLAG = 1 // waiting for flag byte\n  var DICT4 = 2 // four dictionary check bytes to go\n  var DICT3 = 3 // three dictionary check bytes to go\n  var DICT2 = 4 // two dictionary check bytes to go\n  var DICT1 = 5 // one dictionary check byte to go\n  var DICT0 = 6 // waiting for inflateSetDictionary\n  var BLOCKS = 7 // decompressing blocks\n  var CHECK4 = 8 // four check bytes to go\n  var CHECK3 = 9 // three check bytes to go\n  var CHECK2 = 10 // two check bytes to go\n  var CHECK1 = 11 // one check byte to go\n  var DONE = 12 // finished check, done\n  var BAD = 13 // got an error--stay here\n\n  var inflate_mask = [\n    0x00000000, 0x00000001, 0x00000003, 0x00000007, 0x0000000f, 0x0000001f,\n    0x0000003f, 0x0000007f, 0x000000ff, 0x000001ff, 0x000003ff, 0x000007ff,\n    0x00000fff, 0x00001fff, 0x00003fff, 0x00007fff, 0x0000ffff,\n  ]\n\n  var IB_TYPE = 0 // get type bits (3, including end bit)\n  var IB_LENS = 1 // get lengths for stored\n  var IB_STORED = 2 // processing stored block\n  var IB_TABLE = 3 // get table lengths\n  var IB_BTREE = 4 // get bit lengths tree for a dynamic block\n  var IB_DTREE = 5 // get length, distance trees for a dynamic block\n  var IB_CODES = 6 // processing fixed or dynamic block\n  var IB_DRY = 7 // output remaining window bytes\n  var IB_DONE = 8 // finished last block, done\n  var IB_BAD = 9 // ot a data error--stuck here\n\n  var fixed_bl = 9\n  var fixed_bd = 5\n\n  var fixed_tl = [\n    96, 7, 256, 0, 8, 80, 0, 8, 16, 84, 8, 115, 82, 7, 31, 0, 8, 112, 0, 8, 48,\n    0, 9, 192, 80, 7, 10, 0, 8, 96, 0, 8, 32, 0, 9, 160, 0, 8, 0, 0, 8, 128, 0,\n    8, 64, 0, 9, 224, 80, 7, 6, 0, 8, 88, 0, 8, 24, 0, 9, 144, 83, 7, 59, 0, 8,\n    120, 0, 8, 56, 0, 9, 208, 81, 7, 17, 0, 8, 104, 0, 8, 40, 0, 9, 176, 0, 8,\n    8, 0, 8, 136, 0, 8, 72, 0, 9, 240, 80, 7, 4, 0, 8, 84, 0, 8, 20, 85, 8, 227,\n    83, 7, 43, 0, 8, 116, 0, 8, 52, 0, 9, 200, 81, 7, 13, 0, 8, 100, 0, 8, 36,\n    0, 9, 168, 0, 8, 4, 0, 8, 132, 0, 8, 68, 0, 9, 232, 80, 7, 8, 0, 8, 92, 0,\n    8, 28, 0, 9, 152, 84, 7, 83, 0, 8, 124, 0, 8, 60, 0, 9, 216, 82, 7, 23, 0,\n    8, 108, 0, 8, 44, 0, 9, 184, 0, 8, 12, 0, 8, 140, 0, 8, 76, 0, 9, 248, 80,\n    7, 3, 0, 8, 82, 0, 8, 18, 85, 8, 163, 83, 7, 35, 0, 8, 114, 0, 8, 50, 0, 9,\n    196, 81, 7, 11, 0, 8, 98, 0, 8, 34, 0, 9, 164, 0, 8, 2, 0, 8, 130, 0, 8, 66,\n    0, 9, 228, 80, 7, 7, 0, 8, 90, 0, 8, 26, 0, 9, 148, 84, 7, 67, 0, 8, 122, 0,\n    8, 58, 0, 9, 212, 82, 7, 19, 0, 8, 106, 0, 8, 42, 0, 9, 180, 0, 8, 10, 0, 8,\n    138, 0, 8, 74, 0, 9, 244, 80, 7, 5, 0, 8, 86, 0, 8, 22, 192, 8, 0, 83, 7,\n    51, 0, 8, 118, 0, 8, 54, 0, 9, 204, 81, 7, 15, 0, 8, 102, 0, 8, 38, 0, 9,\n    172, 0, 8, 6, 0, 8, 134, 0, 8, 70, 0, 9, 236, 80, 7, 9, 0, 8, 94, 0, 8, 30,\n    0, 9, 156, 84, 7, 99, 0, 8, 126, 0, 8, 62, 0, 9, 220, 82, 7, 27, 0, 8, 110,\n    0, 8, 46, 0, 9, 188, 0, 8, 14, 0, 8, 142, 0, 8, 78, 0, 9, 252, 96, 7, 256,\n    0, 8, 81, 0, 8, 17, 85, 8, 131, 82, 7, 31, 0, 8, 113, 0, 8, 49, 0, 9, 194,\n    80, 7, 10, 0, 8, 97, 0, 8, 33, 0, 9, 162, 0, 8, 1, 0, 8, 129, 0, 8, 65, 0,\n    9, 226, 80, 7, 6, 0, 8, 89, 0, 8, 25, 0, 9, 146, 83, 7, 59, 0, 8, 121, 0, 8,\n    57, 0, 9, 210, 81, 7, 17, 0, 8, 105, 0, 8, 41, 0, 9, 178, 0, 8, 9, 0, 8,\n    137, 0, 8, 73, 0, 9, 242, 80, 7, 4, 0, 8, 85, 0, 8, 21, 80, 8, 258, 83, 7,\n    43, 0, 8, 117, 0, 8, 53, 0, 9, 202, 81, 7, 13, 0, 8, 101, 0, 8, 37, 0, 9,\n    170, 0, 8, 5, 0, 8, 133, 0, 8, 69, 0, 9, 234, 80, 7, 8, 0, 8, 93, 0, 8, 29,\n    0, 9, 154, 84, 7, 83, 0, 8, 125, 0, 8, 61, 0, 9, 218, 82, 7, 23, 0, 8, 109,\n    0, 8, 45, 0, 9, 186, 0, 8, 13, 0, 8, 141, 0, 8, 77, 0, 9, 250, 80, 7, 3, 0,\n    8, 83, 0, 8, 19, 85, 8, 195, 83, 7, 35, 0, 8, 115, 0, 8, 51, 0, 9, 198, 81,\n    7, 11, 0, 8, 99, 0, 8, 35, 0, 9, 166, 0, 8, 3, 0, 8, 131, 0, 8, 67, 0, 9,\n    230, 80, 7, 7, 0, 8, 91, 0, 8, 27, 0, 9, 150, 84, 7, 67, 0, 8, 123, 0, 8,\n    59, 0, 9, 214, 82, 7, 19, 0, 8, 107, 0, 8, 43, 0, 9, 182, 0, 8, 11, 0, 8,\n    139, 0, 8, 75, 0, 9, 246, 80, 7, 5, 0, 8, 87, 0, 8, 23, 192, 8, 0, 83, 7,\n    51, 0, 8, 119, 0, 8, 55, 0, 9, 206, 81, 7, 15, 0, 8, 103, 0, 8, 39, 0, 9,\n    174, 0, 8, 7, 0, 8, 135, 0, 8, 71, 0, 9, 238, 80, 7, 9, 0, 8, 95, 0, 8, 31,\n    0, 9, 158, 84, 7, 99, 0, 8, 127, 0, 8, 63, 0, 9, 222, 82, 7, 27, 0, 8, 111,\n    0, 8, 47, 0, 9, 190, 0, 8, 15, 0, 8, 143, 0, 8, 79, 0, 9, 254, 96, 7, 256,\n    0, 8, 80, 0, 8, 16, 84, 8, 115, 82, 7, 31, 0, 8, 112, 0, 8, 48, 0, 9, 193,\n\n    80, 7, 10, 0, 8, 96, 0, 8, 32, 0, 9, 161, 0, 8, 0, 0, 8, 128, 0, 8, 64, 0,\n    9, 225, 80, 7, 6, 0, 8, 88, 0, 8, 24, 0, 9, 145, 83, 7, 59, 0, 8, 120, 0, 8,\n    56, 0, 9, 209, 81, 7, 17, 0, 8, 104, 0, 8, 40, 0, 9, 177, 0, 8, 8, 0, 8,\n    136, 0, 8, 72, 0, 9, 241, 80, 7, 4, 0, 8, 84, 0, 8, 20, 85, 8, 227, 83, 7,\n    43, 0, 8, 116, 0, 8, 52, 0, 9, 201, 81, 7, 13, 0, 8, 100, 0, 8, 36, 0, 9,\n    169, 0, 8, 4, 0, 8, 132, 0, 8, 68, 0, 9, 233, 80, 7, 8, 0, 8, 92, 0, 8, 28,\n    0, 9, 153, 84, 7, 83, 0, 8, 124, 0, 8, 60, 0, 9, 217, 82, 7, 23, 0, 8, 108,\n    0, 8, 44, 0, 9, 185, 0, 8, 12, 0, 8, 140, 0, 8, 76, 0, 9, 249, 80, 7, 3, 0,\n    8, 82, 0, 8, 18, 85, 8, 163, 83, 7, 35, 0, 8, 114, 0, 8, 50, 0, 9, 197, 81,\n    7, 11, 0, 8, 98, 0, 8, 34, 0, 9, 165, 0, 8, 2, 0, 8, 130, 0, 8, 66, 0, 9,\n    229, 80, 7, 7, 0, 8, 90, 0, 8, 26, 0, 9, 149, 84, 7, 67, 0, 8, 122, 0, 8,\n    58, 0, 9, 213, 82, 7, 19, 0, 8, 106, 0, 8, 42, 0, 9, 181, 0, 8, 10, 0, 8,\n    138, 0, 8, 74, 0, 9, 245, 80, 7, 5, 0, 8, 86, 0, 8, 22, 192, 8, 0, 83, 7,\n    51, 0, 8, 118, 0, 8, 54, 0, 9, 205, 81, 7, 15, 0, 8, 102, 0, 8, 38, 0, 9,\n    173, 0, 8, 6, 0, 8, 134, 0, 8, 70, 0, 9, 237, 80, 7, 9, 0, 8, 94, 0, 8, 30,\n    0, 9, 157, 84, 7, 99, 0, 8, 126, 0, 8, 62, 0, 9, 221, 82, 7, 27, 0, 8, 110,\n    0, 8, 46, 0, 9, 189, 0, 8, 14, 0, 8, 142, 0, 8, 78, 0, 9, 253, 96, 7, 256,\n    0, 8, 81, 0, 8, 17, 85, 8, 131, 82, 7, 31, 0, 8, 113, 0, 8, 49, 0, 9, 195,\n    80, 7, 10, 0, 8, 97, 0, 8, 33, 0, 9, 163, 0, 8, 1, 0, 8, 129, 0, 8, 65, 0,\n    9, 227, 80, 7, 6, 0, 8, 89, 0, 8, 25, 0, 9, 147, 83, 7, 59, 0, 8, 121, 0, 8,\n    57, 0, 9, 211, 81, 7, 17, 0, 8, 105, 0, 8, 41, 0, 9, 179, 0, 8, 9, 0, 8,\n    137, 0, 8, 73, 0, 9, 243, 80, 7, 4, 0, 8, 85, 0, 8, 21, 80, 8, 258, 83, 7,\n    43, 0, 8, 117, 0, 8, 53, 0, 9, 203, 81, 7, 13, 0, 8, 101, 0, 8, 37, 0, 9,\n    171, 0, 8, 5, 0, 8, 133, 0, 8, 69, 0, 9, 235, 80, 7, 8, 0, 8, 93, 0, 8, 29,\n    0, 9, 155, 84, 7, 83, 0, 8, 125, 0, 8, 61, 0, 9, 219, 82, 7, 23, 0, 8, 109,\n    0, 8, 45, 0, 9, 187, 0, 8, 13, 0, 8, 141, 0, 8, 77, 0, 9, 251, 80, 7, 3, 0,\n    8, 83, 0, 8, 19, 85, 8, 195, 83, 7, 35, 0, 8, 115, 0, 8, 51, 0, 9, 199, 81,\n    7, 11, 0, 8, 99, 0, 8, 35, 0, 9, 167, 0, 8, 3, 0, 8, 131, 0, 8, 67, 0, 9,\n    231, 80, 7, 7, 0, 8, 91, 0, 8, 27, 0, 9, 151, 84, 7, 67, 0, 8, 123, 0, 8,\n    59, 0, 9, 215, 82, 7, 19, 0, 8, 107, 0, 8, 43, 0, 9, 183, 0, 8, 11, 0, 8,\n    139, 0, 8, 75, 0, 9, 247, 80, 7, 5, 0, 8, 87, 0, 8, 23, 192, 8, 0, 83, 7,\n    51, 0, 8, 119, 0, 8, 55, 0, 9, 207, 81, 7, 15, 0, 8, 103, 0, 8, 39, 0, 9,\n    175, 0, 8, 7, 0, 8, 135, 0, 8, 71, 0, 9, 239, 80, 7, 9, 0, 8, 95, 0, 8, 31,\n    0, 9, 159, 84, 7, 99, 0, 8, 127, 0, 8, 63, 0, 9, 223, 82, 7, 27, 0, 8, 111,\n    0, 8, 47, 0, 9, 191, 0, 8, 15, 0, 8, 143, 0, 8, 79, 0, 9, 255,\n  ]\n  var fixed_td = [\n    80, 5, 1, 87, 5, 257, 83, 5, 17, 91, 5, 4097, 81, 5, 5, 89, 5, 1025, 85, 5,\n    65, 93, 5, 16385, 80, 5, 3, 88, 5, 513, 84, 5, 33, 92, 5, 8193, 82, 5, 9,\n    90, 5, 2049, 86, 5, 129, 192, 5, 24577, 80, 5, 2, 87, 5, 385, 83, 5, 25, 91,\n    5, 6145, 81, 5, 7, 89, 5, 1537, 85, 5, 97, 93, 5, 24577, 80, 5, 4, 88, 5,\n    769, 84, 5, 49, 92, 5, 12289, 82, 5, 13, 90, 5, 3073, 86, 5, 193, 192, 5,\n    24577,\n  ]\n\n  // Tables for deflate from PKZIP's appnote.txt.\n  var cplens = [\n    // Copy lengths for literal codes 257..285\n    3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67,\n    83, 99, 115, 131, 163, 195, 227, 258, 0, 0,\n  ]\n\n  // see note #13 above about 258\n  var cplext = [\n    // Extra bits for literal codes 257..285\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    1,\n    1,\n    2,\n    2,\n    2,\n    2,\n    3,\n    3,\n    3,\n    3,\n    4,\n    4,\n    4,\n    4,\n    5,\n    5,\n    5,\n    5,\n    0,\n    112,\n    112, // 112==invalid\n  ]\n\n  var cpdist = [\n    // Copy offsets for distance codes 0..29\n    1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513,\n    769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577,\n  ]\n\n  var cpdext = [\n    // Extra bits for distance codes\n    0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10,\n    11, 11, 12, 12, 13, 13,\n  ]\n\n  //\n  // ZStream.java\n  //\n\n  function ZStream() {}\n\n  ZStream.prototype.inflateInit = function (w, nowrap) {\n    if (!w) {\n      w = DEF_WBITS\n    }\n    if (nowrap) {\n      nowrap = false\n    }\n    this.istate = new Inflate()\n    return this.istate.inflateInit(this, nowrap ? -w : w)\n  }\n\n  ZStream.prototype.inflate = function (f) {\n    if (this.istate == null) {return Z_STREAM_ERROR}\n    return this.istate.inflate(this, f)\n  }\n\n  ZStream.prototype.inflateEnd = function () {\n    if (this.istate == null) {return Z_STREAM_ERROR}\n    var ret = istate.inflateEnd(this)\n    this.istate = null\n    return ret\n  }\n  ZStream.prototype.inflateSync = function () {\n    // if(istate == null) return Z_STREAM_ERROR;\n    return istate.inflateSync(this)\n  }\n  ZStream.prototype.inflateSetDictionary = function (dictionary, dictLength) {\n    // if(istate == null) return Z_STREAM_ERROR;\n    return istate.inflateSetDictionary(this, dictionary, dictLength)\n  }\n\n  /*\n\n  public int deflateInit(int level){\n    return deflateInit(level, MAX_WBITS);\n  }\n  public int deflateInit(int level, boolean nowrap){\n    return deflateInit(level, MAX_WBITS, nowrap);\n  }\n  public int deflateInit(int level, int bits){\n    return deflateInit(level, bits, false);\n  }\n  public int deflateInit(int level, int bits, boolean nowrap){\n    dstate=new Deflate();\n    return dstate.deflateInit(this, level, nowrap?-bits:bits);\n  }\n  public int deflate(int flush){\n    if(dstate==null){\n      return Z_STREAM_ERROR;\n    }\n    return dstate.deflate(this, flush);\n  }\n  public int deflateEnd(){\n    if(dstate==null) return Z_STREAM_ERROR;\n    int ret=dstate.deflateEnd();\n    dstate=null;\n    return ret;\n  }\n  public int deflateParams(int level, int strategy){\n    if(dstate==null) return Z_STREAM_ERROR;\n    return dstate.deflateParams(this, level, strategy);\n  }\n  public int deflateSetDictionary (byte[] dictionary, int dictLength){\n    if(dstate == null)\n      return Z_STREAM_ERROR;\n    return dstate.deflateSetDictionary(this, dictionary, dictLength);\n  }\n\n*/\n\n  /*\n  // Flush as much pending output as possible. All deflate() output goes\n  // through this function so some applications may wish to modify it\n  // to avoid allocating a large strm->next_out buffer and copying into it.\n  // (See also read_buf()).\n  void flush_pending(){\n    int len=dstate.pending;\n\n    if(len>avail_out) len=avail_out;\n    if(len==0) return;\n\n    if(dstate.pending_buf.length<=dstate.pending_out ||\n       next_out.length<=next_out_index ||\n       dstate.pending_buf.length<(dstate.pending_out+len) ||\n       next_out.length<(next_out_index+len)){\n      System.out.println(dstate.pending_buf.length+\", \"+dstate.pending_out+\n                         \", \"+next_out.length+\", \"+next_out_index+\", \"+len);\n      System.out.println(\"avail_out=\"+avail_out);\n    }\n\n    System.arraycopy(dstate.pending_buf, dstate.pending_out,\n                     next_out, next_out_index, len);\n\n    next_out_index+=len;\n    dstate.pending_out+=len;\n    total_out+=len;\n    avail_out-=len;\n    dstate.pending-=len;\n    if(dstate.pending==0){\n      dstate.pending_out=0;\n    }\n  }\n\n  // Read a new buffer from the current input stream, update the adler32\n  // and total number of bytes read.  All deflate() input goes through\n  // this function so some applications may wish to modify it to avoid\n  // allocating a large strm->next_in buffer and copying from it.\n  // (See also flush_pending()).\n  int read_buf(byte[] buf, int start, int size) {\n    int len=avail_in;\n\n    if(len>size) len=size;\n    if(len==0) return 0;\n\n    avail_in-=len;\n\n    if(dstate.noheader==0) {\n      adler=_adler.adler32(adler, next_in, next_in_index, len);\n    }\n    System.arraycopy(next_in, next_in_index, buf, start, len);\n    next_in_index  += len;\n    total_in += len;\n    return len;\n  }\n\n  public void free(){\n    next_in=null;\n    next_out=null;\n    msg=null;\n    _adler=null;\n  }\n}\n*/\n\n  //\n  // Inflate.java\n  //\n\n  function Inflate() {\n    this.was = [0]\n  }\n\n  Inflate.prototype.inflateReset = function (z) {\n    if (z == null || z.istate == null) {return Z_STREAM_ERROR}\n\n    z.total_in = z.total_out = 0\n    z.msg = null\n    z.istate.mode = z.istate.nowrap != 0 ? BLOCKS : METHOD\n    z.istate.blocks.reset(z, null)\n    return Z_OK\n  }\n\n  Inflate.prototype.inflateEnd = function (z) {\n    if (this.blocks != null) {this.blocks.free(z)}\n    this.blocks = null\n    return Z_OK\n  }\n\n  Inflate.prototype.inflateInit = function (z, w) {\n    z.msg = null\n    this.blocks = null\n\n    // handle undocumented nowrap option (no zlib header or check)\n    var nowrap = 0\n    if (w < 0) {\n      w = -w\n      nowrap = 1\n    }\n\n    // set window size\n    if (w < 8 || w > 15) {\n      this.inflateEnd(z)\n      return Z_STREAM_ERROR\n    }\n    this.wbits = w\n\n    z.istate.blocks = new InfBlocks(\n      z,\n      z.istate.nowrap != 0 ? null : this,\n      1 << w,\n    )\n\n    // reset state\n    this.inflateReset(z)\n    return Z_OK\n  }\n\n  Inflate.prototype.inflate = function (z, f) {\n    var r, b\n\n    if (z == null || z.istate == null || z.next_in == null)\n      {return Z_STREAM_ERROR}\n    f = f == Z_FINISH ? Z_BUF_ERROR : Z_OK\n    r = Z_BUF_ERROR\n    while (true) {\n      switch (z.istate.mode) {\n        case METHOD:\n          if (z.avail_in == 0) {return r}\n          r = f\n\n          z.avail_in--\n          z.total_in++\n          if (\n            ((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) !=\n            Z_DEFLATED\n          ) {\n            z.istate.mode = BAD\n            z.msg = 'unknown compression method'\n            z.istate.marker = 5 // can't try inflateSync\n            break\n          }\n          if ((z.istate.method >> 4) + 8 > z.istate.wbits) {\n            z.istate.mode = BAD\n            z.msg = 'invalid window size'\n            z.istate.marker = 5 // can't try inflateSync\n            break\n          }\n          z.istate.mode = FLAG\n        case FLAG:\n          if (z.avail_in == 0) {return r}\n          r = f\n\n          z.avail_in--\n          z.total_in++\n          b = z.next_in[z.next_in_index++] & 0xff\n\n          if (((z.istate.method << 8) + b) % 31 != 0) {\n            z.istate.mode = BAD\n            z.msg = 'incorrect header check'\n            z.istate.marker = 5 // can't try inflateSync\n            break\n          }\n\n          if ((b & PRESET_DICT) == 0) {\n            z.istate.mode = BLOCKS\n            break\n          }\n          z.istate.mode = DICT4\n        case DICT4:\n          if (z.avail_in == 0) {return r}\n          r = f\n\n          z.avail_in--\n          z.total_in++\n          z.istate.need =\n            ((z.next_in[z.next_in_index++] & 0xff) << 24) & 0xff000000\n          z.istate.mode = DICT3\n        case DICT3:\n          if (z.avail_in == 0) {return r}\n          r = f\n\n          z.avail_in--\n          z.total_in++\n          z.istate.need +=\n            ((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000\n          z.istate.mode = DICT2\n        case DICT2:\n          if (z.avail_in == 0) {return r}\n          r = f\n\n          z.avail_in--\n          z.total_in++\n          z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00\n          z.istate.mode = DICT1\n        case DICT1:\n          if (z.avail_in == 0) {return r}\n          r = f\n\n          z.avail_in--\n          z.total_in++\n          z.istate.need += z.next_in[z.next_in_index++] & 0xff\n          z.adler = z.istate.need\n          z.istate.mode = DICT0\n          return Z_NEED_DICT\n        case DICT0:\n          z.istate.mode = BAD\n          z.msg = 'need dictionary'\n          z.istate.marker = 0 // can try inflateSync\n          return Z_STREAM_ERROR\n        case BLOCKS:\n          r = z.istate.blocks.proc(z, r)\n          if (r == Z_DATA_ERROR) {\n            z.istate.mode = BAD\n            z.istate.marker = 0 // can try inflateSync\n            break\n          }\n          if (r == Z_OK) {\n            r = f\n          }\n          if (r != Z_STREAM_END) {\n            return r\n          }\n          r = f\n          z.istate.blocks.reset(z, z.istate.was)\n          if (z.istate.nowrap != 0) {\n            z.istate.mode = DONE\n            break\n          }\n          z.istate.mode = CHECK4\n        case CHECK4:\n          if (z.avail_in == 0) {return r}\n          r = f\n\n          z.avail_in--\n          z.total_in++\n          z.istate.need =\n            ((z.next_in[z.next_in_index++] & 0xff) << 24) & 0xff000000\n          z.istate.mode = CHECK3\n        case CHECK3:\n          if (z.avail_in == 0) {return r}\n          r = f\n\n          z.avail_in--\n          z.total_in++\n          z.istate.need +=\n            ((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000\n          z.istate.mode = CHECK2\n        case CHECK2:\n          if (z.avail_in == 0) {return r}\n          r = f\n\n          z.avail_in--\n          z.total_in++\n          z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00\n          z.istate.mode = CHECK1\n        case CHECK1:\n          if (z.avail_in == 0) {return r}\n          r = f\n\n          z.avail_in--\n          z.total_in++\n          z.istate.need += z.next_in[z.next_in_index++] & 0xff\n\n          if (z.istate.was[0] != z.istate.need) {\n            z.istate.mode = BAD\n            z.msg = 'incorrect data check'\n            z.istate.marker = 5 // can't try inflateSync\n            break\n          }\n\n          z.istate.mode = DONE\n        case DONE:\n          return Z_STREAM_END\n        case BAD:\n          return Z_DATA_ERROR\n        default:\n          return Z_STREAM_ERROR\n      }\n    }\n  }\n\n  Inflate.prototype.inflateSetDictionary = function (\n    z,\n    dictionary,\n    dictLength,\n  ) {\n    var index = 0\n    var length = dictLength\n    if (z == null || z.istate == null || z.istate.mode != DICT0)\n      {return Z_STREAM_ERROR}\n\n    if (adler32(1, dictionary, 0, dictLength) != z.adler) {\n      return Z_DATA_ERROR\n    }\n\n    z.adler = adler32(0, null, 0, 0)\n\n    if (length >= 1 << z.istate.wbits) {\n      length = (1 << z.istate.wbits) - 1\n      index = dictLength - length\n    }\n    z.istate.blocks.set_dictionary(dictionary, index, length)\n    z.istate.mode = BLOCKS\n    return Z_OK\n  }\n\n  //  static private byte[] mark = {(byte)0, (byte)0, (byte)0xff, (byte)0xff};\n  var mark = [0, 0, 255, 255]\n\n  Inflate.prototype.inflateSync = function (z) {\n    var n // number of bytes to look at\n    var p // pointer to bytes\n    var m // number of marker bytes found in a row\n    var r, w // temporaries to save total_in and total_out\n\n    // set up\n    if (z == null || z.istate == null) {return Z_STREAM_ERROR}\n    if (z.istate.mode != BAD) {\n      z.istate.mode = BAD\n      z.istate.marker = 0\n    }\n    if ((n = z.avail_in) == 0) {return Z_BUF_ERROR}\n    p = z.next_in_index\n    m = z.istate.marker\n\n    // search\n    while (n != 0 && m < 4) {\n      if (z.next_in[p] == mark[m]) {\n        m++\n      } else if (z.next_in[p] != 0) {\n        m = 0\n      } else {\n        m = 4 - m\n      }\n      p++\n      n--\n    }\n\n    // restore\n    z.total_in += p - z.next_in_index\n    z.next_in_index = p\n    z.avail_in = n\n    z.istate.marker = m\n\n    // return no joy or set up to restart on a new block\n    if (m != 4) {\n      return Z_DATA_ERROR\n    }\n    r = z.total_in\n    w = z.total_out\n    this.inflateReset(z)\n    z.total_in = r\n    z.total_out = w\n    z.istate.mode = BLOCKS\n    return Z_OK\n  }\n\n  // Returns true if inflate is currently at the end of a block generated\n  // by Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP\n  // implementation to provide an additional safety check. PPP uses Z_SYNC_FLUSH\n  // but removes the length bytes of the resulting empty stored block. When\n  // decompressing, PPP checks that at the end of input packet, inflate is\n  // waiting for these length bytes.\n  Inflate.prototype.inflateSyncPoint = function (z) {\n    if (z == null || z.istate == null || z.istate.blocks == null)\n      {return Z_STREAM_ERROR}\n    return z.istate.blocks.sync_point()\n  }\n\n  //\n  // InfBlocks.java\n  //\n\n  var INFBLOCKS_BORDER = [\n    16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15,\n  ]\n\n  function InfBlocks(z, checkfn, w) {\n    this.hufts = new Int32Array(MANY * 3)\n    this.window = new Uint8Array(w)\n    this.end = w\n    this.checkfn = checkfn\n    this.mode = IB_TYPE\n    this.reset(z, null)\n\n    this.left = 0 // if STORED, bytes left to copy\n\n    this.table = 0 // table lengths (14 bits)\n    this.index = 0 // index into blens (or border)\n    this.blens = null // bit lengths of codes\n    this.bb = new Int32Array(1) // bit length tree depth\n    this.tb = new Int32Array(1) // bit length decoding tree\n\n    this.codes = new InfCodes()\n\n    this.last = 0 // true if this block is the last block\n\n    // mode independent information\n    this.bitk = 0 // bits in bit buffer\n    this.bitb = 0 // bit buffer\n    this.read = 0 // window read pointer\n    this.write = 0 // window write pointer\n    this.check = 0 // check on output\n\n    this.inftree = new InfTree()\n  }\n\n  InfBlocks.prototype.reset = function (z, c) {\n    if (c) {c[0] = this.check}\n    if (this.mode == IB_CODES) {\n      this.codes.free(z)\n    }\n    this.mode = IB_TYPE\n    this.bitk = 0\n    this.bitb = 0\n    this.read = this.write = 0\n\n    if (this.checkfn) {\n      this.check = adler32(0, null, 0, 0)\n      z.adler = this.check\n    }\n  }\n\n  InfBlocks.prototype.proc = function (z, r) {\n    var t // temporary storage\n    var b // bit buffer\n    var k // bits in bit buffer\n    var p // input data pointer\n    var n // bytes available there\n    var q // output window write pointer\n    var m // bytes to end of window or read pointer\n\n    // copy input/output information to locals (UPDATE macro restores)\n    {\n      p = z.next_in_index\n      n = z.avail_in\n      b = this.bitb\n      k = this.bitk\n    }\n    {\n      q = this.write\n      m = q < this.read ? this.read - q - 1 : this.end - q\n    }\n\n    // process input based on current state\n    while (true) {\n      switch (this.mode) {\n        case IB_TYPE:\n          while (k < 3) {\n            if (n != 0) {\n              r = Z_OK\n            } else {\n              this.bitb = b\n              this.bitk = k\n              z.avail_in = n\n              z.total_in += p - z.next_in_index\n              z.next_in_index = p\n              this.write = q\n              return this.inflate_flush(z, r)\n            }\n            n--\n            b |= (z.next_in[p++] & 0xff) << k\n            k += 8\n          }\n          t = b & 7\n          this.last = t & 1\n\n          switch (t >>> 1) {\n            case 0: // stored\n              {\n                b >>>= 3\n                k -= 3\n              }\n              t = k & 7 // go to byte boundary\n\n              {\n                b >>>= t\n                k -= t\n              }\n              this.mode = IB_LENS // get length of stored block\n              break\n            case 1: // fixed\n              {\n                var bl = new Int32Array(1)\n                var bd = new Int32Array(1)\n                var tl = []\n                var td = []\n\n                inflate_trees_fixed(bl, bd, tl, td, z)\n                this.codes.init(bl[0], bd[0], tl[0], 0, td[0], 0, z)\n              }\n\n              {\n                b >>>= 3\n                k -= 3\n              }\n\n              this.mode = IB_CODES\n              break\n            case 2: // dynamic\n              {\n                b >>>= 3\n                k -= 3\n              }\n\n              this.mode = IB_TABLE\n              break\n            case 3: // illegal\n              {\n                b >>>= 3\n                k -= 3\n              }\n              this.mode = BAD\n              z.msg = 'invalid block type'\n              r = Z_DATA_ERROR\n\n              this.bitb = b\n              this.bitk = k\n              z.avail_in = n\n              z.total_in += p - z.next_in_index\n              z.next_in_index = p\n              this.write = q\n              return this.inflate_flush(z, r)\n          }\n          break\n        case IB_LENS:\n          while (k < 32) {\n            if (n != 0) {\n              r = Z_OK\n            } else {\n              this.bitb = b\n              this.bitk = k\n              z.avail_in = n\n              z.total_in += p - z.next_in_index\n              z.next_in_index = p\n              this.write = q\n              return this.inflate_flush(z, r)\n            }\n            n--\n            b |= (z.next_in[p++] & 0xff) << k\n            k += 8\n          }\n\n          if (((\\x7eb >>> 16) & 0xffff) != (b & 0xffff)) {\n            this.mode = BAD\n            z.msg = 'invalid stored block lengths'\n            r = Z_DATA_ERROR\n\n            this.bitb = b\n            this.bitk = k\n            z.avail_in = n\n            z.total_in += p - z.next_in_index\n            z.next_in_index = p\n            this.write = q\n            return this.inflate_flush(z, r)\n          }\n          this.left = b & 0xffff\n          b = k = 0 // dump bits\n          this.mode =\n            this.left != 0 ? IB_STORED : this.last != 0 ? IB_DRY : IB_TYPE\n          break\n        case IB_STORED:\n          if (n == 0) {\n            this.bitb = b\n            this.bitk = k\n            z.avail_in = n\n            z.total_in += p - z.next_in_index\n            z.next_in_index = p\n            this.write = q\n            return this.inflate_flush(z, r)\n          }\n\n          if (m == 0) {\n            if (q == end && read != 0) {\n              q = 0\n              m = q < this.read ? this.read - q - 1 : this.end - q\n            }\n            if (m == 0) {\n              this.write = q\n              r = this.inflate_flush(z, r)\n              q = this.write\n              m = q < this.read ? this.read - q - 1 : this.end - q\n              if (q == this.end && this.read != 0) {\n                q = 0\n                m = q < this.read ? this.read - q - 1 : this.end - q\n              }\n              if (m == 0) {\n                this.bitb = b\n                this.bitk = k\n                z.avail_in = n\n                z.total_in += p - z.next_in_index\n                z.next_in_index = p\n                this.write = q\n                return this.inflate_flush(z, r)\n              }\n            }\n          }\n          r = Z_OK\n\n          t = this.left\n          if (t > n) {t = n}\n          if (t > m) {t = m}\n          arrayCopy(z.next_in, p, this.window, q, t)\n          p += t\n          n -= t\n          q += t\n          m -= t\n          if ((this.left -= t) != 0) {break}\n          this.mode = this.last != 0 ? IB_DRY : IB_TYPE\n          break\n        case IB_TABLE:\n          while (k < 14) {\n            if (n != 0) {\n              r = Z_OK\n            } else {\n              this.bitb = b\n              this.bitk = k\n              z.avail_in = n\n              z.total_in += p - z.next_in_index\n              z.next_in_index = p\n              this.write = q\n              return this.inflate_flush(z, r)\n            }\n            n--\n            b |= (z.next_in[p++] & 0xff) << k\n            k += 8\n          }\n\n          this.table = t = b & 0x3fff\n          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {\n            this.mode = IB_BAD\n            z.msg = 'too many length or distance symbols'\n            r = Z_DATA_ERROR\n\n            this.bitb = b\n            this.bitk = k\n            z.avail_in = n\n            z.total_in += p - z.next_in_index\n            z.next_in_index = p\n            this.write = q\n            return this.inflate_flush(z, r)\n          }\n          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f)\n          if (this.blens == null || this.blens.length < t) {\n            this.blens = new Int32Array(t)\n          } else {\n            for (var i = 0; i < t; i++) {\n              this.blens[i] = 0\n            }\n          }\n\n          {\n            b >>>= 14\n            k -= 14\n          }\n\n          this.index = 0\n          this.mode = IB_BTREE\n        case IB_BTREE:\n          while (this.index < 4 + (this.table >>> 10)) {\n            while (k < 3) {\n              if (n != 0) {\n                r = Z_OK\n              } else {\n                this.bitb = b\n                this.bitk = k\n                z.avail_in = n\n                z.total_in += p - z.next_in_index\n                z.next_in_index = p\n                this.write = q\n                return this.inflate_flush(z, r)\n              }\n              n--\n              b |= (z.next_in[p++] & 0xff) << k\n              k += 8\n            }\n\n            this.blens[INFBLOCKS_BORDER[this.index++]] = b & 7\n\n            {\n              b >>>= 3\n              k -= 3\n            }\n          }\n\n          while (this.index < 19) {\n            this.blens[INFBLOCKS_BORDER[this.index++]] = 0\n          }\n\n          this.bb[0] = 7\n          t = this.inftree.inflate_trees_bits(\n            this.blens,\n            this.bb,\n            this.tb,\n            this.hufts,\n            z,\n          )\n          if (t != Z_OK) {\n            r = t\n            if (r == Z_DATA_ERROR) {\n              this.blens = null\n              this.mode = IB_BAD\n            }\n\n            this.bitb = b\n            this.bitk = k\n            z.avail_in = n\n            z.total_in += p - z.next_in_index\n            z.next_in_index = p\n            this.write = q\n            return this.inflate_flush(z, r)\n          }\n\n          this.index = 0\n          this.mode = IB_DTREE\n        case IB_DTREE:\n          while (true) {\n            t = this.table\n            if (!(this.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {\n              break\n            }\n\n            var h //int[]\n            var i, j, c\n\n            t = this.bb[0]\n\n            while (k < t) {\n              if (n != 0) {\n                r = Z_OK\n              } else {\n                this.bitb = b\n                this.bitk = k\n                z.avail_in = n\n                z.total_in += p - z.next_in_index\n                z.next_in_index = p\n                this.write = q\n                return this.inflate_flush(z, r)\n              }\n              n--\n              b |= (z.next_in[p++] & 0xff) << k\n              k += 8\n            }\n\n            //        if (this.tb[0]==-1){\n            //            dlog(\"null...\");\n            //        }\n\n            t = this.hufts[(this.tb[0] + (b & inflate_mask[t])) * 3 + 1]\n            c = this.hufts[(this.tb[0] + (b & inflate_mask[t])) * 3 + 2]\n\n            if (c < 16) {\n              b >>>= t\n              k -= t\n              this.blens[this.index++] = c\n            } else {\n              // c == 16..18\n              i = c == 18 ? 7 : c - 14\n              j = c == 18 ? 11 : 3\n\n              while (k < t + i) {\n                if (n != 0) {\n                  r = Z_OK\n                } else {\n                  this.bitb = b\n                  this.bitk = k\n                  z.avail_in = n\n                  z.total_in += p - z.next_in_index\n                  z.next_in_index = p\n                  this.write = q\n                  return this.inflate_flush(z, r)\n                }\n                n--\n                b |= (z.next_in[p++] & 0xff) << k\n                k += 8\n              }\n\n              b >>>= t\n              k -= t\n\n              j += b & inflate_mask[i]\n\n              b >>>= i\n              k -= i\n\n              i = this.index\n              t = this.table\n              if (\n                i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) ||\n                (c == 16 && i < 1)\n              ) {\n                this.blens = null\n                this.mode = IB_BAD\n                z.msg = 'invalid bit length repeat'\n                r = Z_DATA_ERROR\n\n                this.bitb = b\n                this.bitk = k\n                z.avail_in = n\n                z.total_in += p - z.next_in_index\n                z.next_in_index = p\n                this.write = q\n                return this.inflate_flush(z, r)\n              }\n\n              c = c == 16 ? this.blens[i - 1] : 0\n              do {\n                this.blens[i++] = c\n              } while (--j != 0)\n              this.index = i\n            }\n          }\n\n          this.tb[0] = -1\n          {\n            var bl = new Int32Array(1)\n            var bd = new Int32Array(1)\n            var tl = new Int32Array(1)\n            var td = new Int32Array(1)\n            bl[0] = 9 // must be <= 9 for lookahead assumptions\n            bd[0] = 6 // must be <= 9 for lookahead assumptions\n\n            t = this.table\n            t = this.inftree.inflate_trees_dynamic(\n              257 + (t & 0x1f),\n              1 + ((t >> 5) & 0x1f),\n              this.blens,\n              bl,\n              bd,\n              tl,\n              td,\n              this.hufts,\n              z,\n            )\n\n            if (t != Z_OK) {\n              if (t == Z_DATA_ERROR) {\n                this.blens = null\n                this.mode = BAD\n              }\n              r = t\n\n              this.bitb = b\n              this.bitk = k\n              z.avail_in = n\n              z.total_in += p - z.next_in_index\n              z.next_in_index = p\n              this.write = q\n              return this.inflate_flush(z, r)\n            }\n            this.codes.init(\n              bl[0],\n              bd[0],\n              this.hufts,\n              tl[0],\n              this.hufts,\n              td[0],\n              z,\n            )\n          }\n          this.mode = IB_CODES\n        case IB_CODES:\n          this.bitb = b\n          this.bitk = k\n          z.avail_in = n\n          z.total_in += p - z.next_in_index\n          z.next_in_index = p\n          this.write = q\n\n          if ((r = this.codes.proc(this, z, r)) != Z_STREAM_END) {\n            return this.inflate_flush(z, r)\n          }\n          r = Z_OK\n          this.codes.free(z)\n\n          p = z.next_in_index\n          n = z.avail_in\n          b = this.bitb\n          k = this.bitk\n          q = this.write\n          m = q < this.read ? this.read - q - 1 : this.end - q\n\n          if (this.last == 0) {\n            this.mode = IB_TYPE\n            break\n          }\n          this.mode = IB_DRY\n        case IB_DRY:\n          this.write = q\n          r = this.inflate_flush(z, r)\n          q = this.write\n          m = q < this.read ? this.read - q - 1 : this.end - q\n          if (this.read != this.write) {\n            this.bitb = b\n            this.bitk = k\n            z.avail_in = n\n            z.total_in += p - z.next_in_index\n            z.next_in_index = p\n            this.write = q\n            return this.inflate_flush(z, r)\n          }\n          this.mode = DONE\n        case IB_DONE:\n          r = Z_STREAM_END\n\n          this.bitb = b\n          this.bitk = k\n          z.avail_in = n\n          z.total_in += p - z.next_in_index\n          z.next_in_index = p\n          this.write = q\n          return this.inflate_flush(z, r)\n        case IB_BAD:\n          r = Z_DATA_ERROR\n\n          this.bitb = b\n          this.bitk = k\n          z.avail_in = n\n          z.total_in += p - z.next_in_index\n          z.next_in_index = p\n          this.write = q\n          return this.inflate_flush(z, r)\n\n        default:\n          r = Z_STREAM_ERROR\n\n          this.bitb = b\n          this.bitk = k\n          z.avail_in = n\n          z.total_in += p - z.next_in_index\n          z.next_in_index = p\n          this.write = q\n          return this.inflate_flush(z, r)\n      }\n    }\n  }\n\n  InfBlocks.prototype.free = function (z) {\n    this.reset(z, null)\n    this.window = null\n    this.hufts = null\n  }\n\n  InfBlocks.prototype.set_dictionary = function (d, start, n) {\n    arrayCopy(d, start, this.window, 0, n)\n    this.read = this.write = n\n  }\n\n  // Returns true if inflate is currently at the end of a block generated\n  // by Z_SYNC_FLUSH or Z_FULL_FLUSH.\n  InfBlocks.prototype.sync_point = function () {\n    return this.mode == IB_LENS\n  }\n\n  // copy as much as possible from the sliding window to the output area\n  InfBlocks.prototype.inflate_flush = function (z, r) {\n    var n\n    var p\n    var q\n\n    // local copies of source and destination pointers\n    p = z.next_out_index\n    q = this.read\n\n    // compute number of bytes to copy as far as end of window\n    n = (q <= this.write ? this.write : this.end) - q\n    if (n > z.avail_out) {n = z.avail_out}\n    if (n != 0 && r == Z_BUF_ERROR) {r = Z_OK}\n\n    // update counters\n    z.avail_out -= n\n    z.total_out += n\n\n    // update check information\n    if (this.checkfn != null) {\n      this.check = adler32(this.check, this.window, q, n)\n      z.adler = this.check\n    }\n\n    // copy as far as end of window\n    arrayCopy(this.window, q, z.next_out, p, n)\n    p += n\n    q += n\n\n    // see if more to copy at beginning of window\n    if (q == this.end) {\n      // wrap pointers\n      q = 0\n      if (this.write == this.end) {this.write = 0}\n\n      // compute bytes to copy\n      n = this.write - q\n      if (n > z.avail_out) {n = z.avail_out}\n      if (n != 0 && r == Z_BUF_ERROR) {r = Z_OK}\n\n      // update counters\n      z.avail_out -= n\n      z.total_out += n\n\n      // update check information\n      if (this.checkfn != null) {\n        this.check = adler32(this.check, this.window, q, n)\n        z.adler = this.check\n      }\n\n      // copy\n      arrayCopy(this.window, q, z.next_out, p, n)\n      p += n\n      q += n\n    }\n\n    // update pointers\n    z.next_out_index = p\n    this.read = q\n\n    // done\n    return r\n  }\n\n  //\n  // InfCodes.java\n  //\n\n  var IC_START = 0 // x: set up for LEN\n  var IC_LEN = 1 // i: get length/literal/eob next\n  var IC_LENEXT = 2 // i: getting length extra (have base)\n  var IC_DIST = 3 // i: get distance next\n  var IC_DISTEXT = 4 // i: getting distance extra\n  var IC_COPY = 5 // o: copying bytes in window, waiting for space\n  var IC_LIT = 6 // o: got literal, waiting for output space\n  var IC_WASH = 7 // o: got eob, possibly still output waiting\n  var IC_END = 8 // x: got eob and all data flushed\n  var IC_BADCODE = 9 // x: got error\n\n  function InfCodes() {}\n\n  InfCodes.prototype.init = function (bl, bd, tl, tl_index, td, td_index, z) {\n    this.mode = IC_START\n    this.lbits = bl\n    this.dbits = bd\n    this.ltree = tl\n    this.ltree_index = tl_index\n    this.dtree = td\n    this.dtree_index = td_index\n    this.tree = null\n  }\n\n  InfCodes.prototype.proc = function (s, z, r) {\n    var j // temporary storage\n    var t // temporary pointer (int[])\n    var tindex // temporary pointer\n    var e // extra bits or operation\n    var b = 0 // bit buffer\n    var k = 0 // bits in bit buffer\n    var p = 0 // input data pointer\n    var n // bytes available there\n    var q // output window write pointer\n    var m // bytes to end of window or read pointer\n    var f // pointer to copy strings from\n\n    // copy input/output information to locals (UPDATE macro restores)\n    p = z.next_in_index\n    n = z.avail_in\n    b = s.bitb\n    k = s.bitk\n    q = s.write\n    m = q < s.read ? s.read - q - 1 : s.end - q\n\n    // process input and output based on current state\n    while (true) {\n      switch (this.mode) {\n        // waiting for \"i:\"=input, \"o:\"=output, \"x:\"=nothing\n        case IC_START: // x: set up for LEN\n          if (m >= 258 && n >= 10) {\n            s.bitb = b\n            s.bitk = k\n            z.avail_in = n\n            z.total_in += p - z.next_in_index\n            z.next_in_index = p\n            s.write = q\n            r = this.inflate_fast(\n              this.lbits,\n              this.dbits,\n              this.ltree,\n              this.ltree_index,\n              this.dtree,\n              this.dtree_index,\n              s,\n              z,\n            )\n\n            p = z.next_in_index\n            n = z.avail_in\n            b = s.bitb\n            k = s.bitk\n            q = s.write\n            m = q < s.read ? s.read - q - 1 : s.end - q\n\n            if (r != Z_OK) {\n              this.mode = r == Z_STREAM_END ? IC_WASH : IC_BADCODE\n              break\n            }\n          }\n          this.need = this.lbits\n          this.tree = this.ltree\n          this.tree_index = this.ltree_index\n\n          this.mode = IC_LEN\n        case IC_LEN: // i: get length/literal/eob next\n          j = this.need\n\n          while (k < j) {\n            if (n != 0) {r = Z_OK}\n            else {\n              s.bitb = b\n              s.bitk = k\n              z.avail_in = n\n              z.total_in += p - z.next_in_index\n              z.next_in_index = p\n              s.write = q\n              return s.inflate_flush(z, r)\n            }\n            n--\n            b |= (z.next_in[p++] & 0xff) << k\n            k += 8\n          }\n\n          tindex = (this.tree_index + (b & inflate_mask[j])) * 3\n\n          b >>>= this.tree[tindex + 1]\n          k -= this.tree[tindex + 1]\n\n          e = this.tree[tindex]\n\n          if (e == 0) {\n            // literal\n            this.lit = this.tree[tindex + 2]\n            this.mode = IC_LIT\n            break\n          }\n          if ((e & 16) != 0) {\n            // length\n            this.get = e & 15\n            this.len = this.tree[tindex + 2]\n            this.mode = IC_LENEXT\n            break\n          }\n          if ((e & 64) == 0) {\n            // next table\n            this.need = e\n            this.tree_index = tindex / 3 + this.tree[tindex + 2]\n            break\n          }\n          if ((e & 32) != 0) {\n            // end of block\n            this.mode = IC_WASH\n            break\n          }\n          this.mode = IC_BADCODE // invalid code\n          z.msg = 'invalid literal/length code'\n          r = Z_DATA_ERROR\n\n          s.bitb = b\n          s.bitk = k\n          z.avail_in = n\n          z.total_in += p - z.next_in_index\n          z.next_in_index = p\n          s.write = q\n          return s.inflate_flush(z, r)\n\n        case IC_LENEXT: // i: getting length extra (have base)\n          j = this.get\n\n          while (k < j) {\n            if (n != 0) {r = Z_OK}\n            else {\n              s.bitb = b\n              s.bitk = k\n              z.avail_in = n\n              z.total_in += p - z.next_in_index\n              z.next_in_index = p\n              s.write = q\n              return s.inflate_flush(z, r)\n            }\n            n--\n            b |= (z.next_in[p++] & 0xff) << k\n            k += 8\n          }\n\n          this.len += b & inflate_mask[j]\n\n          b >>= j\n          k -= j\n\n          this.need = this.dbits\n          this.tree = this.dtree\n          this.tree_index = this.dtree_index\n          this.mode = IC_DIST\n        case IC_DIST: // i: get distance next\n          j = this.need\n\n          while (k < j) {\n            if (n != 0) {r = Z_OK}\n            else {\n              s.bitb = b\n              s.bitk = k\n              z.avail_in = n\n              z.total_in += p - z.next_in_index\n              z.next_in_index = p\n              s.write = q\n              return s.inflate_flush(z, r)\n            }\n            n--\n            b |= (z.next_in[p++] & 0xff) << k\n            k += 8\n          }\n\n          tindex = (this.tree_index + (b & inflate_mask[j])) * 3\n\n          b >>= this.tree[tindex + 1]\n          k -= this.tree[tindex + 1]\n\n          e = this.tree[tindex]\n          if ((e & 16) != 0) {\n            // distance\n            this.get = e & 15\n            this.dist = this.tree[tindex + 2]\n            this.mode = IC_DISTEXT\n            break\n          }\n          if ((e & 64) == 0) {\n            // next table\n            this.need = e\n            this.tree_index = tindex / 3 + this.tree[tindex + 2]\n            break\n          }\n          this.mode = IC_BADCODE // invalid code\n          z.msg = 'invalid distance code'\n          r = Z_DATA_ERROR\n\n          s.bitb = b\n          s.bitk = k\n          z.avail_in = n\n          z.total_in += p - z.next_in_index\n          z.next_in_index = p\n          s.write = q\n          return s.inflate_flush(z, r)\n\n        case IC_DISTEXT: // i: getting distance extra\n          j = this.get\n\n          while (k < j) {\n            if (n != 0) {r = Z_OK}\n            else {\n              s.bitb = b\n              s.bitk = k\n              z.avail_in = n\n              z.total_in += p - z.next_in_index\n              z.next_in_index = p\n              s.write = q\n              return s.inflate_flush(z, r)\n            }\n            n--\n            b |= (z.next_in[p++] & 0xff) << k\n            k += 8\n          }\n\n          this.dist += b & inflate_mask[j]\n\n          b >>= j\n          k -= j\n\n          this.mode = IC_COPY\n        case IC_COPY: // o: copying bytes in window, waiting for space\n          f = q - this.dist\n          while (f < 0) {\n            // modulo window size-\"while\" instead\n            f += s.end // of \"if\" handles invalid distances\n          }\n          while (this.len != 0) {\n            if (m == 0) {\n              if (q == s.end && s.read != 0) {\n                q = 0\n                m = q < s.read ? s.read - q - 1 : s.end - q\n              }\n              if (m == 0) {\n                s.write = q\n                r = s.inflate_flush(z, r)\n                q = s.write\n                m = q < s.read ? s.read - q - 1 : s.end - q\n\n                if (q == s.end && s.read != 0) {\n                  q = 0\n                  m = q < s.read ? s.read - q - 1 : s.end - q\n                }\n\n                if (m == 0) {\n                  s.bitb = b\n                  s.bitk = k\n                  z.avail_in = n\n                  z.total_in += p - z.next_in_index\n                  z.next_in_index = p\n                  s.write = q\n                  return s.inflate_flush(z, r)\n                }\n              }\n            }\n\n            s.window[q++] = s.window[f++]\n            m--\n\n            if (f == s.end) {f = 0}\n            this.len--\n          }\n          this.mode = IC_START\n          break\n        case IC_LIT: // o: got literal, waiting for output space\n          if (m == 0) {\n            if (q == s.end && s.read != 0) {\n              q = 0\n              m = q < s.read ? s.read - q - 1 : s.end - q\n            }\n            if (m == 0) {\n              s.write = q\n              r = s.inflate_flush(z, r)\n              q = s.write\n              m = q < s.read ? s.read - q - 1 : s.end - q\n\n              if (q == s.end && s.read != 0) {\n                q = 0\n                m = q < s.read ? s.read - q - 1 : s.end - q\n              }\n              if (m == 0) {\n                s.bitb = b\n                s.bitk = k\n                z.avail_in = n\n                z.total_in += p - z.next_in_index\n                z.next_in_index = p\n                s.write = q\n                return s.inflate_flush(z, r)\n              }\n            }\n          }\n          r = Z_OK\n\n          s.window[q++] = this.lit\n          m--\n\n          this.mode = IC_START\n          break\n        case IC_WASH: // o: got eob, possibly more output\n          if (k > 7) {\n            // return unused byte, if any\n            k -= 8\n            n++\n            p-- // can always return one\n          }\n\n          s.write = q\n          r = s.inflate_flush(z, r)\n          q = s.write\n          m = q < s.read ? s.read - q - 1 : s.end - q\n\n          if (s.read != s.write) {\n            s.bitb = b\n            s.bitk = k\n            z.avail_in = n\n            z.total_in += p - z.next_in_index\n            z.next_in_index = p\n            s.write = q\n            return s.inflate_flush(z, r)\n          }\n          this.mode = IC_END\n        case IC_END:\n          r = Z_STREAM_END\n          s.bitb = b\n          s.bitk = k\n          z.avail_in = n\n          z.total_in += p - z.next_in_index\n          z.next_in_index = p\n          s.write = q\n          return s.inflate_flush(z, r)\n\n        case IC_BADCODE: // x: got error\n          r = Z_DATA_ERROR\n\n          s.bitb = b\n          s.bitk = k\n          z.avail_in = n\n          z.total_in += p - z.next_in_index\n          z.next_in_index = p\n          s.write = q\n          return s.inflate_flush(z, r)\n\n        default:\n          r = Z_STREAM_ERROR\n\n          s.bitb = b\n          s.bitk = k\n          z.avail_in = n\n          z.total_in += p - z.next_in_index\n          z.next_in_index = p\n          s.write = q\n          return s.inflate_flush(z, r)\n      }\n    }\n  }\n\n  InfCodes.prototype.free = function (z) {\n    //  ZFREE(z, c);\n  }\n\n  // Called with number of bytes left to write in window at least 258\n  // (the maximum string length) and number of input bytes available\n  // at least ten.  The ten bytes are six bytes for the longest length/\n  // distance pair plus four bytes for overloading the bit buffer.\n\n  InfCodes.prototype.inflate_fast = function (\n    bl,\n    bd,\n    tl,\n    tl_index,\n    td,\n    td_index,\n    s,\n    z,\n  ) {\n    var t // temporary pointer\n    var tp // temporary pointer (int[])\n    var tp_index // temporary pointer\n    var e // extra bits or operation\n    var b // bit buffer\n    var k // bits in bit buffer\n    var p // input data pointer\n    var n // bytes available there\n    var q // output window write pointer\n    var m // bytes to end of window or read pointer\n    var ml // mask for literal/length tree\n    var md // mask for distance tree\n    var c // bytes to copy\n    var d // distance back to copy from\n    var r // copy source pointer\n\n    var tp_index_t_3 // (tp_index+t)*3\n\n    // load input, output, bit values\n    p = z.next_in_index\n    n = z.avail_in\n    b = s.bitb\n    k = s.bitk\n    q = s.write\n    m = q < s.read ? s.read - q - 1 : s.end - q\n\n    // initialize masks\n    ml = inflate_mask[bl]\n    md = inflate_mask[bd]\n\n    // do until not enough input or output space for fast loop\n    do {\n      // assume called with m >= 258 && n >= 10\n      // get literal/length code\n      while (k < 20) {\n        // max bits for literal/length code\n        n--\n        b |= (z.next_in[p++] & 0xff) << k\n        k += 8\n      }\n\n      t = b & ml\n      tp = tl\n      tp_index = tl_index\n      tp_index_t_3 = (tp_index + t) * 3\n      if ((e = tp[tp_index_t_3]) == 0) {\n        b >>= tp[tp_index_t_3 + 1]\n        k -= tp[tp_index_t_3 + 1]\n\n        s.window[q++] = tp[tp_index_t_3 + 2]\n        m--\n        continue\n      }\n      do {\n        b >>= tp[tp_index_t_3 + 1]\n        k -= tp[tp_index_t_3 + 1]\n\n        if ((e & 16) != 0) {\n          e &= 15\n          c = tp[tp_index_t_3 + 2] + (b & inflate_mask[e])\n\n          b >>= e\n          k -= e\n\n          // decode distance base of block to copy\n          while (k < 15) {\n            // max bits for distance code\n            n--\n            b |= (z.next_in[p++] & 0xff) << k\n            k += 8\n          }\n\n          t = b & md\n          tp = td\n          tp_index = td_index\n          tp_index_t_3 = (tp_index + t) * 3\n          e = tp[tp_index_t_3]\n\n          do {\n            b >>= tp[tp_index_t_3 + 1]\n            k -= tp[tp_index_t_3 + 1]\n\n            if ((e & 16) != 0) {\n              // get extra bits to add to distance base\n              e &= 15\n              while (k < e) {\n                // get extra bits (up to 13)\n                n--\n                b |= (z.next_in[p++] & 0xff) << k\n                k += 8\n              }\n\n              d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e])\n\n              b >>= e\n              k -= e\n\n              // do the copy\n              m -= c\n              if (q >= d) {\n                // offset before dest\n                //  just copy\n                r = q - d\n                if (q - r > 0 && 2 > q - r) {\n                  s.window[q++] = s.window[r++] // minimum count is three,\n                  s.window[q++] = s.window[r++] // so unroll loop a little\n                  c -= 2\n                } else {\n                  s.window[q++] = s.window[r++] // minimum count is three,\n                  s.window[q++] = s.window[r++] // so unroll loop a little\n                  c -= 2\n                }\n              } else {\n                // else offset after destination\n                r = q - d\n                do {\n                  r += s.end // force pointer in window\n                } while (r < 0) // covers invalid distances\n                e = s.end - r\n                if (c > e) {\n                  // if source crosses,\n                  c -= e // wrapped copy\n                  if (q - r > 0 && e > q - r) {\n                    do {\n                      s.window[q++] = s.window[r++]\n                    } while (--e != 0)\n                  } else {\n                    arrayCopy(s.window, r, s.window, q, e)\n                    q += e\n                    r += e\n                    e = 0\n                  }\n                  r = 0 // copy rest from start of window\n                }\n              }\n\n              // copy all or what's left\n              do {\n                s.window[q++] = s.window[r++]\n              } while (--c != 0)\n              break\n            } else if ((e & 64) == 0) {\n              t += tp[tp_index_t_3 + 2]\n              t += b & inflate_mask[e]\n              tp_index_t_3 = (tp_index + t) * 3\n              e = tp[tp_index_t_3]\n            } else {\n              z.msg = 'invalid distance code'\n\n              c = z.avail_in - n\n              c = k >> 3 < c ? k >> 3 : c\n              n += c\n              p -= c\n              k -= c << 3\n\n              s.bitb = b\n              s.bitk = k\n              z.avail_in = n\n              z.total_in += p - z.next_in_index\n              z.next_in_index = p\n              s.write = q\n\n              return Z_DATA_ERROR\n            }\n          } while (true)\n          break\n        }\n\n        if ((e & 64) == 0) {\n          t += tp[tp_index_t_3 + 2]\n          t += b & inflate_mask[e]\n          tp_index_t_3 = (tp_index + t) * 3\n          if ((e = tp[tp_index_t_3]) == 0) {\n            b >>= tp[tp_index_t_3 + 1]\n            k -= tp[tp_index_t_3 + 1]\n\n            s.window[q++] = tp[tp_index_t_3 + 2]\n            m--\n            break\n          }\n        } else if ((e & 32) != 0) {\n          c = z.avail_in - n\n          c = k >> 3 < c ? k >> 3 : c\n          n += c\n          p -= c\n          k -= c << 3\n\n          s.bitb = b\n          s.bitk = k\n          z.avail_in = n\n          z.total_in += p - z.next_in_index\n          z.next_in_index = p\n          s.write = q\n\n          return Z_STREAM_END\n        } else {\n          z.msg = 'invalid literal/length code'\n\n          c = z.avail_in - n\n          c = k >> 3 < c ? k >> 3 : c\n          n += c\n          p -= c\n          k -= c << 3\n\n          s.bitb = b\n          s.bitk = k\n          z.avail_in = n\n          z.total_in += p - z.next_in_index\n          z.next_in_index = p\n          s.write = q\n\n          return Z_DATA_ERROR\n        }\n      } while (true)\n    } while (m >= 258 && n >= 10)\n\n    // not enough input or output--restore pointers and return\n    c = z.avail_in - n\n    c = k >> 3 < c ? k >> 3 : c\n    n += c\n    p -= c\n    k -= c << 3\n\n    s.bitb = b\n    s.bitk = k\n    z.avail_in = n\n    z.total_in += p - z.next_in_index\n    z.next_in_index = p\n    s.write = q\n\n    return Z_OK\n  }\n\n  //\n  // InfTree.java\n  //\n\n  function InfTree() {}\n\n  InfTree.prototype.huft_build = function (\n    b,\n    bindex,\n    n,\n    s,\n    d,\n    e,\n    t,\n    m,\n    hp,\n    hn,\n    v,\n  ) {\n    // Given a list of code lengths and a maximum table size, make a set of\n    // tables to decode that set of codes.  Return Z_OK on success, Z_BUF_ERROR\n    // if the given code set is incomplete (the tables are still built in this\n    // case), Z_DATA_ERROR if the input is invalid (an over-subscribed set of\n    // lengths), or Z_MEM_ERROR if not enough memory.\n\n    var a // counter for codes of length k\n    var f // i repeats in table every f entries\n    var g // maximum code length\n    var h // table level\n    var i // counter, current code\n    var j // counter\n    var k // number of bits in current code\n    var l // bits per table (returned in m)\n    var mask // (1 << w) - 1, to avoid cc -O bug on HP\n    var p // pointer into c[], b[], or v[]\n    var q // points to current table\n    var w // bits before this table == (l * h)\n    var xp // pointer into x\n    var y // number of dummy codes added\n    var z // number of entries in current table\n\n    // Generate counts for each bit length\n\n    p = 0\n    i = n\n    do {\n      this.c[b[bindex + p]]++\n      p++\n      i-- // assume all entries <= BMAX\n    } while (i != 0)\n\n    if (this.c[0] == n) {\n      // null input--all zero length codes\n      t[0] = -1\n      m[0] = 0\n      return Z_OK\n    }\n\n    // Find minimum and maximum length, bound *m by those\n    l = m[0]\n    for (j = 1; j <= BMAX; j++) {if (this.c[j] != 0) {break}}\n    k = j // minimum code length\n    if (l < j) {\n      l = j\n    }\n    for (i = BMAX; i != 0; i--) {\n      if (this.c[i] != 0) {break}\n    }\n    g = i // maximum code length\n    if (l > i) {\n      l = i\n    }\n    m[0] = l\n\n    // Adjust last length count to fill out codes, if needed\n    for (y = 1 << j; j < i; j++, y <<= 1) {\n      if ((y -= this.c[j]) < 0) {\n        return Z_DATA_ERROR\n      }\n    }\n    if ((y -= this.c[i]) < 0) {\n      return Z_DATA_ERROR\n    }\n    this.c[i] += y\n\n    // Generate starting offsets into the value table for each length\n    this.x[1] = j = 0\n    p = 1\n    xp = 2\n    while (--i != 0) {\n      // note that i == g from above\n      this.x[xp] = j += this.c[p]\n      xp++\n      p++\n    }\n\n    // Make a table of values in order of bit lengths\n    i = 0\n    p = 0\n    do {\n      if ((j = b[bindex + p]) != 0) {\n        this.v[this.x[j]++] = i\n      }\n      p++\n    } while (++i < n)\n    n = this.x[g] // set n to length of v\n\n    // Generate the Huffman codes and for each, make the table entries\n    this.x[0] = i = 0 // first Huffman code is zero\n    p = 0 // grab values in bit order\n    h = -1 // no tables yet--level -1\n    w = -l // bits decoded == (l * h)\n    this.u[0] = 0 // just to keep compilers happy\n    q = 0 // ditto\n    z = 0 // ditto\n\n    // go through the bit lengths (k already is bits in shortest code)\n    for (; k <= g; k++) {\n      a = this.c[k]\n      while (a-- != 0) {\n        // here i is the Huffman code of length k bits for value *p\n        // make tables up to required level\n        while (k > w + l) {\n          h++\n          w += l // previous table always l bits\n          // compute minimum size table less than or equal to l bits\n          z = g - w\n          z = z > l ? l : z // table size upper limit\n          if ((f = 1 << (j = k - w)) > a + 1) {\n            // try a k-w bit table\n            // too few codes for k-w bit table\n            f -= a + 1 // deduct codes from patterns left\n            xp = k\n            if (j < z) {\n              while (++j < z) {\n                // try smaller tables up to z bits\n                if ((f <<= 1) <= this.c[++xp]) {break} // enough codes to use up j bits\n                f -= this.c[xp] // else deduct codes from patterns\n              }\n            }\n          }\n          z = 1 << j // table entries for j-bit table\n\n          // allocate new table\n          if (this.hn[0] + z > MANY) {\n            // (note: doesn't matter for fixed)\n            return Z_DATA_ERROR // overflow of MANY\n          }\n          this.u[h] = q = /*hp+*/ this.hn[0] // DEBUG\n          this.hn[0] += z\n\n          // connect to last table, if there is one\n          if (h != 0) {\n            this.x[h] = i // save pattern for backing up\n            this.r[0] = j // bits in this table\n            this.r[1] = l // bits to dump before this table\n            j = i >>> (w - l)\n            this.r[2] = q - this.u[h - 1] - j // offset to this table\n            arrayCopy(this.r, 0, hp, (this.u[h - 1] + j) * 3, 3) // connect to last table\n          } else {\n            t[0] = q // first table is returned result\n          }\n        }\n\n        // set up table entry in r\n        this.r[1] = k - w\n        if (p >= n) {\n          this.r[0] = 128 + 64 // out of values--invalid code\n        } else if (v[p] < s) {\n          this.r[0] = this.v[p] < 256 ? 0 : 32 + 64 // 256 is end-of-block\n          this.r[2] = this.v[p++] // simple code is just the value\n        } else {\n          this.r[0] = e[this.v[p] - s] + 16 + 64 // non-simple--look up in lists\n          this.r[2] = d[this.v[p++] - s]\n        }\n\n        // fill code-like entries with r\n        f = 1 << (k - w)\n        for (j = i >>> w; j < z; j += f) {\n          arrayCopy(this.r, 0, hp, (q + j) * 3, 3)\n        }\n\n        // backwards increment the k-bit code i\n        for (j = 1 << (k - 1); (i & j) != 0; j >>>= 1) {\n          i ^= j\n        }\n        i ^= j\n\n        // backup over finished tables\n        mask = (1 << w) - 1 // needed on HP, cc -O bug\n        while ((i & mask) != this.x[h]) {\n          h-- // don't need to update q\n          w -= l\n          mask = (1 << w) - 1\n        }\n      }\n    }\n    // Return Z_BUF_ERROR if we were given an incomplete table\n    return y != 0 && g != 1 ? Z_BUF_ERROR : Z_OK\n  }\n\n  InfTree.prototype.inflate_trees_bits = function (c, bb, tb, hp, z) {\n    var result\n    this.initWorkArea(19)\n    this.hn[0] = 0\n    result = this.huft_build(\n      c,\n      0,\n      19,\n      19,\n      null,\n      null,\n      tb,\n      bb,\n      hp,\n      this.hn,\n      this.v,\n    )\n\n    if (result == Z_DATA_ERROR) {\n      z.msg = 'oversubscribed dynamic bit lengths tree'\n    } else if (result == Z_BUF_ERROR || bb[0] == 0) {\n      z.msg = 'incomplete dynamic bit lengths tree'\n      result = Z_DATA_ERROR\n    }\n    return result\n  }\n\n  InfTree.prototype.inflate_trees_dynamic = function (\n    nl,\n    nd,\n    c,\n    bl,\n    bd,\n    tl,\n    td,\n    hp,\n    z,\n  ) {\n    var result\n\n    // build literal/length tree\n    this.initWorkArea(288)\n    this.hn[0] = 0\n    result = this.huft_build(\n      c,\n      0,\n      nl,\n      257,\n      cplens,\n      cplext,\n      tl,\n      bl,\n      hp,\n      this.hn,\n      this.v,\n    )\n    if (result != Z_OK || bl[0] == 0) {\n      if (result == Z_DATA_ERROR) {\n        z.msg = 'oversubscribed literal/length tree'\n      } else if (result != Z_MEM_ERROR) {\n        z.msg = 'incomplete literal/length tree'\n        result = Z_DATA_ERROR\n      }\n      return result\n    }\n\n    // build distance tree\n    this.initWorkArea(288)\n    result = this.huft_build(\n      c,\n      nl,\n      nd,\n      0,\n      cpdist,\n      cpdext,\n      td,\n      bd,\n      hp,\n      this.hn,\n      this.v,\n    )\n\n    if (result != Z_OK || (bd[0] == 0 && nl > 257)) {\n      if (result == Z_DATA_ERROR) {\n        z.msg = 'oversubscribed distance tree'\n      } else if (result == Z_BUF_ERROR) {\n        z.msg = 'incomplete distance tree'\n        result = Z_DATA_ERROR\n      } else if (result != Z_MEM_ERROR) {\n        z.msg = 'empty distance tree with lengths'\n        result = Z_DATA_ERROR\n      }\n      return result\n    }\n\n    return Z_OK\n  }\n\n  /*\n  static int inflate_trees_fixed(int[] bl,  //literal desired/actual bit depth\n                                 int[] bd,  //distance desired/actual bit depth\n                                 int[][] tl,//literal/length tree result\n                                 int[][] td,//distance tree result\n                                 ZStream z  //for memory allocation\n                                 ){\n\n*/\n\n  function inflate_trees_fixed(bl, bd, tl, td, z) {\n    bl[0] = fixed_bl\n    bd[0] = fixed_bd\n    tl[0] = fixed_tl\n    td[0] = fixed_td\n    return Z_OK\n  }\n\n  InfTree.prototype.initWorkArea = function (vsize) {\n    var i\n    if (this.hn == null) {\n      this.hn = new Int32Array(1)\n      this.v = new Int32Array(vsize)\n      this.c = new Int32Array(BMAX + 1)\n      this.r = new Int32Array(3)\n      this.u = new Int32Array(BMAX)\n      this.x = new Int32Array(BMAX + 1)\n    }\n    if (this.v.length < vsize) {\n      this.v = new Int32Array(vsize)\n    }\n    for (i = 0; i < vsize; i++) {\n      this.v[i] = 0\n    }\n    for (i = 0; i < BMAX + 1; i++) {\n      this.c[i] = 0\n    }\n    for (i = 0; i < 3; i++) {\n      this.r[i] = 0\n    }\n    //  for(int i=0; i<BMAX; i++){u[i]=0;}\n    arrayCopy(this.c, 0, this.u, 0, BMAX)\n    //  for(int i=0; i<BMAX+1; i++){x[i]=0;}\n    arrayCopy(this.c, 0, this.x, 0, BMAX + 1)\n  }\n\n  // largest prime smaller than 65536\n  var ADLER_BASE = 65521\n  // NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1\n  var ADLER_NMAX = 5552\n\n  function adler32(adler, /* byte[] */ buf, index, len) {\n    if (buf == null) {\n      return 1\n    }\n\n    var s1 = adler & 0xffff\n    var s2 = (adler >> 16) & 0xffff\n    var k\n\n    while (len > 0) {\n      k = len < ADLER_NMAX ? len : ADLER_NMAX\n      len -= k\n      while (k >= 16) {\n        s1 += buf[index++] & 0xff\n        s2 += s1\n        s1 += buf[index++] & 0xff\n        s2 += s1\n        s1 += buf[index++] & 0xff\n        s2 += s1\n        s1 += buf[index++] & 0xff\n        s2 += s1\n        s1 += buf[index++] & 0xff\n        s2 += s1\n        s1 += buf[index++] & 0xff\n        s2 += s1\n        s1 += buf[index++] & 0xff\n        s2 += s1\n        s1 += buf[index++] & 0xff\n        s2 += s1\n        s1 += buf[index++] & 0xff\n        s2 += s1\n        s1 += buf[index++] & 0xff\n        s2 += s1\n        s1 += buf[index++] & 0xff\n        s2 += s1\n        s1 += buf[index++] & 0xff\n        s2 += s1\n        s1 += buf[index++] & 0xff\n        s2 += s1\n        s1 += buf[index++] & 0xff\n        s2 += s1\n        s1 += buf[index++] & 0xff\n        s2 += s1\n        s1 += buf[index++] & 0xff\n        s2 += s1\n        k -= 16\n      }\n      if (k != 0) {\n        do {\n          s1 += buf[index++] & 0xff\n          s2 += s1\n        } while (--k != 0)\n      }\n      s1 %= ADLER_BASE\n      s2 %= ADLER_BASE\n    }\n    return (s2 << 16) | s1\n  }\n\n  return function (buffer, start, length, afterUncOffset) {\n    if (!start) {\n      buffer = new Uint8Array(buffer)\n    } else {\n      buffer = new Uint8Array(buffer, start, length)\n    }\n\n    var z = new ZStream()\n    z.inflateInit(DEF_WBITS, true)\n    z.next_in = buffer\n    z.next_in_index = 0\n    z.avail_in = buffer.length\n\n    var oBlockList = []\n    var totalSize = 0\n    while (true) {\n      var obuf = new Uint8Array(32000)\n      z.next_out = obuf\n      z.next_out_index = 0\n      z.avail_out = obuf.length\n      var status = z.inflate(Z_NO_FLUSH)\n      if (status != Z_OK && status != Z_STREAM_END) {\n        var error = z.msg\n          ? typeof z.msg == 'object'\n            ? z.msg\n            : typeof z.msg == 'string'\n              ? new Error(z.msg)\n              : new Error(\n                  'Unknown error in inflate: msg=\"' +\n                    z.msg +\n                    '\", status=\"' +\n                    STATUS_STRINGS[status] || status + '\"',\n                )\n          : new Error(\n              'Inflate error, status=\"' + STATUS_STRINGS[status] ||\n                status + '\")',\n            )\n        error.statusCode = status\n        error.statusString = STATUS_STRINGS[status]\n        throw error\n      }\n      if (z.avail_out != 0) {\n        var newob = new Uint8Array(obuf.length - z.avail_out)\n        arrayCopy(obuf, 0, newob, 0, obuf.length - z.avail_out)\n        obuf = newob\n      }\n      oBlockList.push(obuf)\n      totalSize += obuf.length\n      if (status == Z_STREAM_END) {\n        break\n      }\n    }\n\n    if (afterUncOffset) {\n      afterUncOffset[0] = (start || 0) + z.next_in_index\n    }\n\n    if (oBlockList.length == 1) {\n      return oBlockList[0].buffer\n    } else {\n      var out = new Uint8Array(totalSize)\n      var cursor = 0\n      for (var i = 0; i < oBlockList.length; ++i) {\n        var b = oBlockList[i]\n        arrayCopy(b, 0, out, cursor, b.length)\n        cursor += b.length\n      }\n      return out.buffer\n    }\n  }\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/Util/RejectableFastPromise.js":{"size":985,"mtime":1738905962367,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Util/RejectableFastPromise.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"/**\n * Fast implementation of a promise, used in performance-critical code\n * that still needs to be able to reject promises.  Dojo Deferred is\n * too heavy for some uses.\n */\n\ndefine([], function () {\n  var fastpromise = function () {\n    this.callbacks = []\n    this.errbacks = []\n  }\n\n  fastpromise.prototype.then = function (callback, errback) {\n    if ('value' in this) {callback(this.value)}\n    else if ('error' in this) {errback(this.error)}\n    else {\n      this.callbacks.push(callback)\n      this.errbacks.push(errback)\n    }\n  }\n\n  fastpromise.prototype.resolve = function (value) {\n    this.value = value\n    delete this.errbacks\n    var c = this.callbacks\n    delete this.callbacks\n    for (var i = 0; i < c.length; i++) {c[i](this.value)}\n  }\n\n  fastpromise.prototype.reject = function (error) {\n    this.error = error\n    delete this.callbacks\n    var c = this.errbacks\n    delete this.errbacks\n    for (var i = 0; i < c.length; i++) {c[i](error)}\n  }\n\n  return fastpromise\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/Util/TextIterator.js":{"size":1501,"mtime":1738905962372,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/Util/TextIterator.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/_FeatureDescriptionMixin.js":{"size":2130,"mtime":1738905962378,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/_FeatureDescriptionMixin.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define(['dojo/_base/declare', 'dojo/_base/lang'], function (declare, lang) {\n  return declare(null, {\n    // get the label string for a feature, based on the setting\n    // of this.config.label\n    getFeatureLabel: function (feature) {\n      return this._getFeatureDescriptiveThing('label', 'name,id', feature)\n    },\n\n    // get the description string for a feature, based on the setting\n    // of this.config.description\n    getFeatureDescription: function (feature) {\n      return this._getFeatureDescriptiveThing(\n        'description',\n        'note,description',\n        feature,\n      )\n    },\n\n    _getFeatureDescriptiveThing: function (field, defaultFields, feature) {\n      var dConf = this.config.style[field] || this.config[field]\n\n      if (!dConf) {return null}\n\n      // if the description is a function, just call it\n      if (typeof dConf == 'function') {\n        return dConf.call(this, feature)\n      }\n      // otherwise try to parse it as a field list\n      else {\n        if (!this.descriptionFields) {this.descriptionFields = {}}\n\n        // parse our description varname conf if necessary\n        var fields =\n          this.descriptionFields[field] ||\n          function () {\n            var f = dConf\n            if (f) {\n              if (lang.isArray(f)) {\n                f = f.join(',')\n              } else if (typeof f != 'string') {\n                console.warn(\n                  'invalid `description` setting (' +\n                    f +\n                    ') for \"' +\n                    (this.name || this.track.name) +\n                    '\" track, falling back to \"note,description\"',\n                )\n                f = defaultFields\n              }\n              f = f.toLowerCase().split(/\\s*\\,\\s*/)\n            } else {\n              f = []\n            }\n            this.descriptionFields[field] = f\n            return f\n          }.call(this)\n\n        // return the value of the first field that contains something\n        for (var i = 0; i < fields.length; i++) {\n          var d = feature.get(fields[i])\n          if (d) {return d}\n        }\n        return null\n      }\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/Animation.js":{"size":1822,"mtime":1738905962383,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/Animation.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([], function () {\n  /**\n   * @class\n   */\n  function Animation(subject, callback, time) {\n    //subject: what's being animated\n    //callback: function to call at the end of the animation\n    //time: time for the animation to run\n    if (subject === undefined) {return}\n    //don't want a zoom and a slide going on at the same time\n    if ('animation' in subject) {subject.animation.stop()}\n    this.index = 0\n    this.time = time\n    this.subject = subject\n    this.callback = callback\n\n    var myAnim = this\n    this.animFunction = function () {\n      myAnim.animate()\n    }\n    // number of milliseconds between frames (e.g., 33ms at 30fps)\n    this.animID = setTimeout(this.animFunction, 33)\n\n    this.frames = 0\n\n    subject.animation = this\n  }\n\n  Animation.prototype.animate = function () {\n    if (this.finished) {\n      this.stop()\n      return\n    }\n\n    // number of milliseconds between frames (e.g., 33ms at 30fps)\n    var nextTimeout = 33\n    var elapsed = 0\n    if (!('startTime' in this)) {\n      this.startTime = new Date().getTime()\n    } else {\n      elapsed = new Date().getTime() - this.startTime\n      //set the next timeout to be the average of the\n      //frame times we've achieved so far.\n      //The goal is to avoid overloading the browser\n      //and getting a jerky animation.\n      nextTimeout = Math.max(33, elapsed / this.frames)\n    }\n\n    if (elapsed < this.time) {\n      this.step(elapsed / this.time)\n      this.frames++\n    } else {\n      this.step(1)\n      this.finished = true\n      //console.log(\"final timeout: \" + nextTimeout);\n    }\n    this.animID = setTimeout(this.animFunction, nextTimeout)\n  }\n\n  Animation.prototype.stop = function () {\n    clearTimeout(this.animID)\n    delete this.subject.animation\n    this.callback.call(this.subject, this)\n  }\n  return Animation\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/Animation/Slider.js":{"size":724,"mtime":1738905962387,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/Animation/Slider.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/Animation/Zoomer.js":{"size":1512,"mtime":1738905962391,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/Animation/Zoomer.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define(['JBrowse/View/Animation'], function (Animation) {\n  /**\n   * @class\n   */\n  function Zoomer(scale, toScroll, callback, time, zoomLoc) {\n    Animation.call(this, toScroll, callback, time)\n    this.toZoom = toScroll.zoomContainer\n    var cWidth = this.toZoom.clientWidth\n\n    this.initialWidth = cWidth\n\n    // the container width when zoomFraction is 0\n    this.width0 = cWidth * Math.min(1, scale)\n    // the container width when zoomFraction is 1\n    var width1 = cWidth * Math.max(1, scale)\n    this.distance = width1 - this.width0\n    this.zoomingIn = scale > 1\n    //this.zoomLoc = zoomLoc;\n    this.center =\n      (toScroll.getX() + toScroll.elem.clientWidth * zoomLoc) /\n      toScroll.scrollContainer.clientWidth\n\n    // initialX and initialLeft can differ when we're scrolling\n    // using scrollTop and scrollLeft\n    this.initialX = this.subject.getX()\n    this.initialLeft = parseInt(this.toZoom.style.left)\n  }\n\n  Zoomer.prototype = new Animation()\n\n  Zoomer.prototype.step = function (pos) {\n    var zoomFraction = this.zoomingIn ? pos : 1 - pos\n    var newWidth = zoomFraction * zoomFraction * this.distance + this.width0\n    var newLeft = this.center * this.initialWidth - this.center * newWidth\n    this.toZoom.style.width = newWidth + 'px'\n    this.toZoom.style.left = this.initialLeft + newLeft + 'px'\n    var forceRedraw = this.toZoom.offsetTop\n\n    if (this.subject.updateStaticElements)\n      {this.subject.updateStaticElements({ x: this.initialX - newLeft })}\n  }\n\n  return Zoomer\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/ConfirmDialog.js":{"size":1412,"mtime":1738905962394,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/ConfirmDialog.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/DetailsMixin.js":{"size":9867,"mtime":1738905962405,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/DetailsMixin.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"/**\n * Mixin that provides generic functions for displaying nested data.\n */\ndefine([\n  'dojo/_base/declare',\n  'dojo/_base/lang',\n  'dojo/_base/array',\n  'dojo/query',\n  'dojo/dom-construct',\n  'dojo/dom-class',\n  'dstore/Memory',\n  'dgrid/OnDemandGrid',\n  'dgrid/extensions/DijitRegistry',\n  'JBrowse/Util',\n], function (\n  declare,\n  lang,\n  array,\n  query,\n  domConstruct,\n  domClass,\n  MemoryStore,\n  DGrid,\n  DGridDijitRegistry,\n  Util,\n) {\n  // make a DGrid that registers itself as a dijit widget\n  var Grid = declare([DGrid, DGridDijitRegistry])\n\n  return declare(null, {\n    renderDetailField: function (\n      parentElement,\n      title,\n      val,\n      f,\n      class_,\n      externalFieldMeta = {},\n      unsafe = false,\n    ) {\n      if (val === null || val === undefined) {return ''}\n\n      // if this object has a 'fmtDetailFooField' function, delegate to that\n      var fieldSpecificFormatter\n      if (\n        (fieldSpecificFormatter =\n          this['fmtDetail' + Util.ucFirst(title) + 'Field'])\n      )\n        {return fieldSpecificFormatter.apply(this, arguments)}\n\n      // otherwise, use default formatting\n\n      class_ = class_ || title.replace(/\\W/g, '_').toLowerCase()\n\n      var formatted_title = title\n      // if this object has a config value 'fmtDetailField_Foo' function, apply it to field title\n      if (\n        (fieldSpecificFormatter = this.config['fmtDetailField_' + title]) &&\n        f\n      ) {\n        formatted_title = fieldSpecificFormatter(title, f)\n        if (!formatted_title) {return ''} // if the callback returns null, remove field from dialog\n      } else if (\n        (fieldSpecificFormatter = this.config['fmtMetaField_' + title]) &&\n        !f\n      ) {\n        formatted_title = fieldSpecificFormatter(title)\n        if (!formatted_title) {return ''} // if the callback returns null, remove field from dialog\n      }\n\n      // special case for values that include metadata about their\n      // meaning, which are formed like { values: [], meta:\n      // {description: }.  break it out, putting the meta description in a `title`\n      // attr on the field name so that it shows on mouseover, and\n      // using the values as the new field value.\n      var fieldMeta\n      if (typeof val == 'object' && !Array.isArray(val) && 'values' in val) {\n        fieldMeta = (val.meta || {}).description || (val.meta || {}).Description\n        // join the description if it is an array\n        if (lang.isArray(fieldMeta)) {fieldMeta = fieldMeta.join(', ')}\n\n        val = val.values\n      } else {\n        fieldMeta = externalFieldMeta.description\n      }\n\n      if (\n        (fieldSpecificFormatter =\n          this.config['fmtDetailDescription_' + title]) &&\n        f\n      ) {\n        fieldMeta = fieldSpecificFormatter(fieldMeta)\n      } else if (\n        (fieldSpecificFormatter = this.config['fmtMetaDescription_' + title]) &&\n        !f\n      ) {\n        fieldMeta = fieldSpecificFormatter(fieldMeta)\n      }\n      var titleAttr = fieldMeta ? ' title=\"' + fieldMeta + '\"' : ''\n      var fieldContainer = domConstruct.create(\n        'div',\n        {\n          className: 'field_container',\n          innerHTML:\n            '<h2 class=\"field ' +\n            class_ +\n            '\"' +\n            titleAttr +\n            '>' +\n            formatted_title +\n            '</h2>',\n        },\n        parentElement,\n      )\n      var valueContainer = domConstruct.create(\n        'div',\n        { className: 'value_container ' + class_ },\n        fieldContainer,\n      )\n\n      var count = this.renderDetailValue(\n        valueContainer,\n        title,\n        val,\n        f,\n        class_,\n        unsafe,\n      )\n      if (typeof count == 'number' && count > 4) {\n        query('h2', fieldContainer)[0].innerHTML =\n          formatted_title + ' (' + count + ')'\n      }\n\n      return fieldContainer\n    },\n\n    renderDetailValue: function (\n      parent,\n      title,\n      val,\n      f,\n      class_,\n      unsafe = false,\n    ) {\n      var thisB = this\n\n      if (!lang.isArray(val) && val && val.values) {val = val.values}\n\n      // if this object has a 'fmtDetailFooValue' function, delegate to that\n      var fieldSpecificFormatter\n      if (\n        (fieldSpecificFormatter =\n          this['fmtDetail' + Util.ucFirst(title) + 'Value'])\n      )\n        {return fieldSpecificFormatter.apply(this, arguments)}\n\n      // otherwise, use default formatting\n\n      // if this object has a config value 'fmtDetailValue_Foo' function, apply it to val\n      if (\n        (fieldSpecificFormatter = this.config['fmtDetailValue_' + title]) &&\n        f\n      ) {\n        unsafe = true\n        val = fieldSpecificFormatter(val, f)\n        if (!val) {val = ''}\n        if (val.length == 1) {val = val[0]} // avoid recursion when an array of length 1 is returned\n      } else if (\n        (fieldSpecificFormatter = this.config['fmtMetaValue_' + title]) &&\n        !f\n      ) {\n        unsafe = true\n        val = fieldSpecificFormatter(val)\n        if (val.length == 1) {val = val[0]}\n      }\n\n      var valType = typeof val\n      if (valType == 'object' && val === null) {val = ''}\n      if (typeof val.toHTML == 'function') {val = val.toHTML()}\n      if (valType == 'boolean') {val = val ? 'yes' : 'no'}\n      else if (valType == 'undefined' || val === null) {return 0}\n      else if (lang.isArray(val)) {\n        var vals\n        if (val.length > 0 && lang.isObject(val[0])) {\n          parent.style.width = '90%'\n          vals = val.map(v => {\n            const itemContainer = domConstruct.create(\n              'div',\n              {\n                className: 'value_container ' + class_,\n                style: { width: '100%' },\n              },\n              parent,\n            )\n            this.renderDetailValue(itemContainer, title, v, f, class_, unsafe)\n            return itemContainer\n          })\n        } else {\n          vals = array.map(\n            val,\n            function (v) {\n              return this.renderDetailValue(parent, title, v, f, class_, unsafe)\n            },\n            this,\n          )\n        }\n        if (vals.length > 1) {domClass.add(parent, 'multi_value')}\n        if (vals.length > 10) {domClass.add(parent, 'big')}\n        return vals.length\n      } else if (valType == 'object') {\n        var keys = Util.dojof.keys(val).sort()\n        var count = keys.length\n        if (count > 5) {\n          this.renderDetailValueGrid(\n            parent,\n            title,\n            f,\n            // iterator\n            function () {\n              if (!keys.length) {return null}\n              var k = keys.shift()\n              var value = val[k]\n\n              var item = { id: k }\n\n              if (typeof value == 'object') {\n                for (var field in value) {\n                  item[field] = thisB._valToString(value[field])\n                }\n              } else {\n                item.value = value\n              }\n\n              return item\n            },\n            {\n              descriptions: (function () {\n                if (!keys.length) {return {}}\n\n                var subValue = val[keys[0]]\n                var descriptions = {}\n                for (var k in subValue) {\n                  descriptions[k] =\n                    (subValue[k].meta && subValue[k].meta.description) || null\n                }\n                return descriptions\n              })(),\n            },\n          )\n          return count\n        } else {\n          array.forEach(\n            keys,\n            function (k) {\n              return this.renderDetailField(\n                parent,\n                k,\n                val[k],\n                f,\n                class_,\n                {},\n                unsafe,\n              )\n            },\n            this,\n          )\n          return keys.length\n        }\n      }\n\n      domConstruct.create(\n        'div',\n        {\n          className:\n            'value ' +\n            (val.length > 70 && val.indexOf(' ') == -1 ? 'long ' : '') +\n            class_,\n          innerHTML:\n            unsafe || this.config.unsafePopup ? val : Util.escapeHTML(val),\n        },\n        parent,\n      )\n      return 1\n    },\n\n    renderDetailValueGrid: function (parent, title, f, iterator, attrs) {\n      var thisB = this\n      var rows = []\n      var item\n      var descriptions = attrs.descriptions || {}\n      var cellRenderers = attrs.renderCell || {}\n      while ((item = iterator())) {rows.push(item)}\n\n      if (!rows.length) {return document.createElement('span')}\n\n      function defaultRenderCell(field, value, node, options) {\n        thisB.renderDetailValue(node, '', value, f, '')\n      }\n\n      var columns = []\n      for (var field in rows[0]) {\n        ;(function (field) {\n          var column = {\n            label: { id: 'Name' }[field] || Util.ucFirst(field),\n            field: field,\n            renderCell: cellRenderers[field] || defaultRenderCell,\n            renderHeaderCell: function (contentNode) {\n              if (descriptions[field]) {contentNode.title = descriptions[field]}\n              contentNode.appendChild(\n                document.createTextNode(column.label || column.field),\n              )\n            },\n          }\n          columns.push(column)\n        })(field)\n      }\n\n      // create the grid\n      parent.style.overflow = 'hidden'\n      parent.style.width = '90%'\n      var grid = new Grid(\n        {\n          columns: columns,\n          collection: new MemoryStore({ data: rows }),\n        },\n        parent,\n      )\n\n      return parent\n    },\n\n    _valToString: function (val) {\n      if (!val) {return ''}\n      if (lang.isArray(val)) {\n        return array.map(val, lang.hitch(this, '_valToString')).join(' ')\n      } else if (typeof val == 'object') {\n        if ('values' in val) {return this._valToString(val.values)}\n        else {return JSON.stringify(val)}\n      }\n      return '' + val\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/Dialog/OpenDirectory.js":{"size":6203,"mtime":1738905962416,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/Dialog/OpenDirectory.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/Dialog/Preferences.js":{"size":4170,"mtime":1738905962423,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/Dialog/Preferences.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/Dialog/QuickHelp.js":{"size":3647,"mtime":1738905962427,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/Dialog/QuickHelp.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/Dialog/Search.js":{"size":6988,"mtime":1738905962435,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/Dialog/Search.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/Dialog/SetHighlight.js":{"size":2519,"mtime":1738905962440,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/Dialog/SetHighlight.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'dojo/dom-construct',\n  'dijit/focus',\n  'dijit/form/TextBox',\n  'JBrowse/View/Dialog/WithActionBar',\n  'dojo/on',\n  'dijit/form/Button',\n  'JBrowse/Model/Location',\n], function (\n  declare,\n  dom,\n  focus,\n  dijitTextBox,\n  ActionBarDialog,\n  on,\n  Button,\n  Location,\n) {\n  return declare(\n    ActionBarDialog,\n\n    /**\n     * Dijit Dialog subclass that pops up prompt for the user to\n     * manually set a new highlight.\n     * @lends JBrowse.View.InfoDialog\n     */\n    {\n      autofocus: false,\n      title: 'Set highlight',\n\n      constructor: function (args) {\n        this.browser = args.browser\n        this.setCallback = args.setCallback || function () {}\n        this.cancelCallback = args.cancelCallback || function () {}\n      },\n\n      _fillActionBar: function (actionBar) {\n        var thisB = this\n        new Button({\n          iconClass: 'dijitIconDelete',\n          label: 'Cancel',\n          onClick: function () {\n            thisB.cancelCallback && thisB.cancelCallback()\n            thisB.hide()\n          },\n        }).placeAt(actionBar)\n        new Button({\n          iconClass: 'dijitIconFilter',\n          label: 'Highlight',\n          onClick: function () {\n            thisB.setCallback && thisB.setCallback(thisB.getLocation())\n            thisB.hide()\n          },\n        }).placeAt(actionBar)\n      },\n\n      show: function (callback) {\n        var thisB = this\n\n        dojo.addClass(this.domNode, 'setHighlightDialog')\n\n        var visibleLocation = this.browser.view.visibleRegionLocString()\n        if (visibleLocation) {visibleLocation += ' (current view)'}\n\n        this.highlightInput = new dijitTextBox({\n          id: 'newhighlight_locstring',\n          value:\n            (this.browser.getHighlight() || '').toString() ||\n            visibleLocation ||\n            '',\n          placeHolder: visibleLocation || 'ctgA:1234..5678',\n        })\n\n        this.set('content', [\n          dom.create('label', {\n            for: 'newhighlight_locstring',\n            innerHTML: 'Location',\n          }),\n          this.highlightInput.domNode,\n        ])\n\n        this.inherited(arguments)\n      },\n\n      getLocation: function () {\n        // have to use onChange to get the value of the text box to work around a bug in dijit\n        return new Location(this.highlightInput.get('value'))\n      },\n\n      hide: function () {\n        this.inherited(arguments)\n        window.setTimeout(dojo.hitch(this, 'destroyRecursive'), 500)\n      },\n    },\n  )\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/Dialog/SetTrackHeight.js":{"size":2296,"mtime":1738905962447,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/Dialog/SetTrackHeight.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'dojo/dom-construct',\n  'dijit/focus',\n  'dijit/form/NumberSpinner',\n  'JBrowse/View/Dialog/WithActionBar',\n  'dojo/on',\n  'dijit/form/Button',\n  'JBrowse/Model/Location',\n], function (\n  declare,\n  dom,\n  focus,\n  NumberSpinner,\n  ActionBarDialog,\n  on,\n  Button,\n  Location,\n) {\n  return declare(ActionBarDialog, {\n    /**\n     * Dijit Dialog subclass that pops up prompt for the user to\n     * manually set a new track height.\n     * @lends JBrowse.View.InfoDialog\n     */\n    title: 'Set new track height',\n\n    constructor: function (args) {\n      this.height = args.height || 100\n      this.browser = args.browser\n      this.setCallback = args.setCallback || function () {}\n      this.cancelCallback = args.cancelCallback || function () {}\n      this.heightConstraints = { min: 10, max: args.maxHeight || 750 }\n      this.msg = args.msg\n    },\n\n    _fillActionBar: function (actionBar) {\n      var ok_button = new Button({\n        label: 'OK',\n        onClick: dojo.hitch(this, function () {\n          var height = parseInt(this.heightSpinner.getValue())\n          if (\n            isNaN(height) ||\n            height < this.heightConstraints.min ||\n            height > this.heightConstraints.max\n          )\n            {return}\n          this.setCallback && this.setCallback(height)\n          this.hide()\n        }),\n      }).placeAt(actionBar)\n\n      var cancel_button = new Button({\n        label: 'Cancel',\n        onClick: dojo.hitch(this, function () {\n          this.cancelCallback && this.cancelCallback()\n          this.hide()\n        }),\n      }).placeAt(actionBar)\n    },\n\n    show: function (callback) {\n      dojo.addClass(this.domNode, 'setTrackHeightDialog')\n\n      this.heightSpinner = new NumberSpinner({\n        value: this.height,\n        smallDelta: 10,\n        constraints: this.heightConstraints,\n      })\n\n      this.set('content', [\n        dom.create('label', {\n          for: 'newhighlight_locstring',\n          innerHTML: '',\n        }),\n        this.heightSpinner.domNode,\n        dom.create('span', { innerHTML: this.msg || ' pixels' }),\n      ])\n\n      this.inherited(arguments)\n    },\n\n    hide: function () {\n      this.inherited(arguments)\n      window.setTimeout(dojo.hitch(this, 'destroyRecursive'), 500)\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/Dialog/WithActionBar.js":{"size":921,"mtime":1738905962450,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/Dialog/WithActionBar.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/Export.js":{"size":1279,"mtime":1738905962453,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/Export.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/Export/BED.js":{"size":2074,"mtime":1738905962457,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/Export/BED.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'dojo/_base/array',\n  'JBrowse/View/Export',\n], function (declare, array, ExportBase) {\n  return declare(\n    ExportBase,\n\n    /**\n     * @lends JBrowse.View.Export.BED.prototype\n     */\n    {\n      /**\n       * Data export driver for BED format.\n       * @constructs\n       */\n      constructor: function (args) {\n        this._printHeader()\n      },\n\n      /**\n       * print the BED track definition line\n       * @private\n       */\n      _printHeader: function () {\n        // print the BED header\n        this.print('track')\n        if (this.track) {\n          if (this.track.name) {this.print(' name=\"' + this.track.name + '\"')}\n          var metadata = this.track.getMetadata()\n          if (metadata.key) {this.print(' description=\"' + metadata.key + '\"')}\n        }\n        this.print(' useScore=0')\n        this.print('\\n')\n      },\n\n      bed_field_names: [\n        'seq_id',\n        'start',\n        'end',\n        'name',\n        'score',\n        'strand',\n        'thickStart',\n        'thickEnd',\n        'itemRgb',\n        'blockCount',\n        'blockSizes',\n        'blockStarts',\n      ],\n\n      /**\n       * Format a feature into a string.\n       * @param {Object} feature feature object (like those returned from JBrowse/Store/SeqFeature/*)\n       * @returns {String} BED string representation of the feature\n       */\n      formatFeature: function (feature) {\n        var fields = array.map(\n          [feature.get('seq_id') || this.refSeq.name].concat(\n            dojo.map(\n              this.bed_field_names.slice(1, 11),\n              function (field) {\n                return feature.get(field)\n              },\n              this,\n            ),\n          ),\n          function (data) {\n            var t = typeof data\n            if (t == 'string' || t == 'number') {return data}\n            return ''\n          },\n          this,\n        )\n\n        // normalize the strand field\n        fields[5] = { 1: '+', '-1': '-', 0: '+' }[fields[5]] || fields[5]\n        return fields.join('\\t') + '\\n'\n      },\n    },\n  )\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/Export/bedGraph.js":{"size":1013,"mtime":1738905962462,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/Export/bedGraph.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'dojo/_base/array',\n  'JBrowse/View/Export/BED',\n], function (declare, array, bedExport) {\n  return declare(\n    bedExport,\n    /**\n     * @lends JBrowse.View.Export.bedGraph.prototype\n     */\n    {\n      /**\n       * Data export driver for bedGraph format.\n       * @constructs\n       */\n      constructor: function (args) {},\n\n      _printHeader: function () {\n        // print the track definition\n        this.print('track type=bedGraph')\n        if (this.track) {\n          if (this.track.name) {this.print(' name=\"' + this.track.name + '\"')}\n          var metadata = this.track.getMetadata()\n          if (metadata.key) {this.print(' description=\"' + metadata.key + '\"')}\n        }\n        this.print('\\n')\n      },\n\n      formatFeature: function (f) {\n        return (\n          [\n            f.get('seq_id') || this.refSeq.name,\n            f.get('start'),\n            f.get('end'),\n            f.get('score'),\n          ].join('\\t') + '\\n'\n        )\n      },\n    },\n  )\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/Export/FASTA.js":{"size":1103,"mtime":1738905962464,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/Export/FASTA.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/Export/GFF3.js":{"size":6687,"mtime":1738905962472,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/Export/GFF3.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"import gff from '@gmod/gff'\n\ndefine([\n  'dojo/_base/declare',\n  'dojo/_base/lang',\n  'dojo/_base/array',\n  'JBrowse/View/Export',\n], function (declare, lang, array, ExportBase) {\n  return declare(\n    ExportBase,\n    /**\n     * @lends JBrowse.View.Export.GFF3.prototype\n     */\n    {\n      /**\n       * Data export driver for GFF3 format.\n       * @constructs\n       */\n      constructor: function (args) {\n        this._idCounter = 0\n        this.lastSync = 0\n      },\n\n      gff3_field_names: [\n        'seq_id',\n        'source',\n        'type',\n        'start',\n        'end',\n        'score',\n        'strand',\n        'phase',\n        'attributes',\n      ],\n\n      gff3_reserved_attributes: [\n        'ID',\n        'Name',\n        'Alias',\n        'Parent',\n        'Target',\n        'Gap',\n        'Derives_from',\n        'Note',\n        'Dbxref',\n        'Ontology_term',\n        'Is_circular',\n      ],\n\n      /**\n       * @returns false if the field goes in tabular portion of gff3, true otherwise\n       * @private\n       */\n      _is_not_gff3_tab_field: function (fieldname) {\n        if (!this._gff3_fields_by_name) {\n          var fields = {}\n          dojo.forEach(this.gff3_field_names, function (f) {\n            fields[f] = true\n          })\n          this._gff3_fields_by_name = fields\n        }\n\n        return !this._gff3_fields_by_name[fieldname.toLowerCase()]\n      },\n\n      /**\n       * @returns the capitalized attribute name if the given field name\n       * corresponds to a GFF3 reserved attribute\n       * @private\n       */\n      _gff3_reserved_attribute: function (fieldname) {\n        if (!this._gff3_reserved_attributes_by_lcname) {\n          var fields = {}\n          dojo.forEach(this.gff3_reserved_attributes, function (f) {\n            fields[f.toLowerCase()] = f\n          })\n          this._gff3_reserved_attributes_by_lcname = fields\n        }\n\n        return this._gff3_reserved_attributes_by_lcname[fieldname.toLowerCase()]\n      },\n\n      exportRegion(region, callback) {\n        this.print('##gff-version 3\\n')\n        this.print(\n          `##sequence-region ${region.ref} ${region.start + 1} ${region.end}\\n`,\n        )\n        this.inherited(arguments)\n      },\n\n      /**\n       * Format a feature into a string.\n       * @param {Object} feature feature object (like those returned from JBrowse/Store/SeqFeature/*)\n       * @returns {String} GFF3 string representation of the feature\n       */\n      formatFeature: function (feature, parentID) {\n        var fields = dojo.map(\n          [feature.get('seq_id') || this.refSeq.name].concat(\n            dojo.map(\n              this.gff3_field_names.slice(1, 8),\n              function (field) {\n                return feature.get(field)\n              },\n              this,\n            ),\n          ),\n          function (data) {\n            var dt = typeof data\n            return gff.util.escapeColumn(\n              dt == 'string' || dt == 'number' ? data : '.',\n            )\n          },\n          this,\n        )\n\n        // convert back from interbase\n        if (typeof parseInt(fields[3]) == 'number') {fields[3]++}\n        // normalize the strand field\n        fields[6] = { 1: '+', '-1': '-', 0: '.' }[fields[6]] || fields[6]\n\n        // format the attributes\n        var attr = this._gff3_attributes(feature)\n        if (parentID) {attr.Parent = parentID}\n        else {delete attr.Parent}\n\n        var subfeatures = array.map(\n          feature.get('subfeatures') || [],\n          function (feat) {\n            if (!attr.ID) {\n              attr.ID = ++this._idCounter\n            }\n            return this.formatFeature(feat, attr.ID)\n          },\n          this,\n        )\n\n        // need to format the attrs after doing the subfeatures,\n        // because the subfeature formatting might have autocreated an\n        // ID for the parent\n        fields[8] = this._gff3_format_attributes(attr)\n\n        var fl = fields.join('\\t') + '\\n'\n        subfeatures.unshift(fl)\n        return subfeatures.join('')\n      },\n\n      /**\n       * Write the feature to the GFF3 under construction.\n       * @returns nothing\n       */\n      writeFeature: function (feature) {\n        var fmt = this.formatFeature(feature)\n        this.print(fmt)\n\n        // avoid printing sync marks more than every 10 lines\n        if (this.lastSync >= 9) {\n          this.lastSync = 0\n          this.print('###\\n')\n        } else {\n          this.lastSync += fmt.length || 1\n        }\n      },\n\n      /**\n       * Extract a key-value object of gff3 attributes from the given\n       * feature.  Attribute names will have proper capitalization.\n       * @private\n       */\n      _gff3_attributes: function (feature) {\n        var tags = array.filter(\n          feature.tags(),\n          dojo.hitch(this, function (f) {\n            f = f.toLowerCase()\n            return this._is_not_gff3_tab_field(f) && f != 'subfeatures'\n          }),\n        )\n        var attrs = {}\n        array.forEach(\n          tags,\n          function (tag) {\n            var val = feature.get(tag)\n            var valtype = typeof val\n            if (valtype == 'boolean') {val = val ? 1 : 0}\n            else if (valtype == 'undefined') {return}\n            tag =\n              this._gff3_reserved_attribute(tag) ||\n              this._ensure_non_reserved(tag)\n            attrs[tag] = val\n          },\n          this,\n        )\n        return attrs\n      },\n\n      // ensure that an attribute name is not reserved.  currently does\n      // this by adding a leading underscore to attribute names that\n      // have initial capital letters.\n      _ensure_non_reserved: function (str) {\n        return str.replace(/^[A-Z]/, function () {\n          return '_' + str[0]\n        })\n      },\n\n      /**\n       * @private\n       * @returns {String} formatted attribute string\n       */\n      _gff3_format_attributes: function (attrs) {\n        var attrOrder = []\n        for (var tag in attrs) {\n          var val = attrs[tag]\n          if (!val) {\n            continue\n          }\n\n          var valstring = val.hasOwnProperty('toString')\n            ? gff.util.escape(val.toString())\n            : val instanceof Array\n              ? array.map(val, s => gff.util.escape(s)).join(',')\n              : val instanceof Object\n                ? gff.util.escape(JSON.stringify(val))\n                : val.values\n                  ? val instanceof Array\n                    ? array.map(val, s => gff.util.escape(s)).join(',')\n                    : gff.util.escape(val)\n                  : gff.util.escape(val)\n          attrOrder.push(gff.util.escape(tag) + '=' + valstring)\n        }\n        return attrOrder.join(';') || '.'\n      },\n    },\n  )\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/Export/SequinTable.js":{"size":2616,"mtime":1738905962478,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/Export/SequinTable.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"/**\n * Support for Sequin Feature table export.  See\n * http://www.ncbi.nlm.nih.gov/Sequin/table.html.\n */\n\ndefine([\n  'dojo/_base/declare',\n  'dojo/_base/array',\n  'JBrowse/View/Export',\n], function (declare, array, ExportBase) {\n  return declare(\n    ExportBase,\n\n    {\n      /**\n       * Data export driver for BED format.\n       * @constructs\n       */\n      // constructor: function( args ) {\n      // },\n\n      /**\n       * print the BED track definition line\n       * @private\n       */\n      _printHeader: function (feature) {\n        // print the BED header\n        this.print(\n          '>Feature ' + (feature.get('seq_id') || this.refSeq.name) + '\\n',\n        )\n        return true\n      },\n\n      /**\n       * Format a feature into a string.\n       * @param {Object} feature feature object (like those returned from JBrowse/Store/SeqFeature/*)\n       * @returns {String} BED string representation of the feature\n       */\n      formatFeature: function (feature) {\n        var thisB = this\n        if (!this.headerPrinted) {this.headerPrinted = this._printHeader(feature)}\n\n        var featLine = [\n          feature.get('start') + 1,\n          feature.get('end'),\n          feature.get('type') || 'region',\n        ]\n        if (feature.get('strand') == -1) {\n          var t = featLine[0]\n          featLine[0] = featLine[1]\n          featLine[1] = t\n        }\n\n        // make the qualifiers\n        var qualifiers = array\n          .map(\n            array.filter(feature.tags(), function (t) {\n              return !{\n                start: 1,\n                end: 1,\n                type: 1,\n                strand: 1,\n                seq_id: 1,\n                subfeatures: 1,\n              }[t.toLowerCase()]\n            }),\n            function (tag) {\n              return [\n                tag.toLowerCase(),\n                thisB.stringifyAttributeValue(feature.get(tag)),\n              ]\n            },\n          )\n          .filter(t => !!t[1])\n\n        return (\n          featLine.join('\\t') +\n          '\\n' +\n          array\n            .map(qualifiers, function (q) {\n              return '\\t\\t\\t' + q.join('\\t') + '\\n'\n            })\n            .join('') +\n          array.map(feature.children(), f => this.formatFeature(f)).join('')\n        )\n      },\n\n      stringifyAttributeValue: function (val) {\n        if (val == null) {return null}\n        return val.hasOwnProperty('toString')\n          ? val.toString()\n          : val instanceof Array\n            ? val.join(',')\n            : val.values instanceof Array\n              ? val.join(',')\n              : val\n      },\n    },\n  )\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/Export/Wiggle.js":{"size":1682,"mtime":1738905962483,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/Export/Wiggle.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'dojo/_base/array',\n  'JBrowse/View/Export',\n], function (declare, array, ExportBase) {\n  return declare(\n    ExportBase,\n    /**\n     * @lends JBrowse.View.Export.Wiggle.prototype\n     */\n    {\n      /**\n       * Data export driver for Wiggle format.\n       * @constructs\n       */\n      constructor: function (args) {\n        // print the track definition\n        this.print('track type=wiggle_0')\n        if (this.track) {\n          if (this.track.name) {this.print(' name=\"' + this.track.name + '\"')}\n          var metadata = this.track.getMetadata()\n          if (metadata.key) {this.print(' description=\"' + metadata.key + '\"')}\n        }\n        this.print('\\n')\n      },\n\n      /**\n       * print the Wiggle step\n       * @private\n       */\n      _printStep: function (span, ref) {\n        this.print(\n          'variableStep' +\n            (ref ? ' chrom=' + ref : '') +\n            ' span=' +\n            span +\n            '\\n',\n        )\n      },\n\n      exportRegion: function (region, callback) {\n        var curspan\n        var curref\n        this.store.getFeatures(\n          region,\n          dojo.hitch(this, function (f) {\n            var span = f.get('end') - f.get('start')\n            var ref = f.get('seq_id') || this.refSeq.name\n            if (!(curspan == span && ref == curref)) {\n              this._printStep(span, ref == curref ? null : ref)\n              curref = ref\n              curspan = span\n            }\n            this.print(f.get('start') + 1 + '\\t' + f.get('score') + '\\n')\n          }),\n          dojo.hitch(this, function () {\n            callback(this.output)\n          }),\n        )\n      },\n    },\n  )\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/FASTA.js":{"size":2709,"mtime":1738905962488,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/FASTA.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'dojo/dom-construct',\n\n  'dijit/Toolbar',\n  'dijit/form/Button',\n  'JBrowse/Util',\n  'JBrowse/has',\n], function (declare, dom, Toolbar, Button, Util, has) {\n  return declare(null, {\n    constructor: function (args) {\n      if (typeof args === 'undefined') {\n        this.width = 78\n        return\n      }\n\n      this.width = args.width || 78\n      this.htmlMaxRows = args.htmlMaxRows || 15\n      this.track = args.track\n      this.canSaveFiles =\n        args.track && args.track._canSaveFiles && args.track._canSaveFiles()\n\n      // hook point\n      if (typeof this.initData === 'function') {this.initData(args)}\n    },\n    renderHTML: function (region, seq, parent) {\n      var thisB = this\n      var text = this.renderText(region, seq)\n      var lineCount = text.match(/\\n/g).length + 1\n      var container = dom.create('div', { className: 'fastaView' }, parent)\n\n      if (this.canSaveFiles) {\n        var toolbar = new Toolbar().placeAt(container)\n        var thisB = this\n\n        // hook point\n        if (typeof thisB.addButtons === 'function')\n          {thisB.addButtons(region, seq, toolbar)}\n\n        toolbar.addChild(\n          new Button({\n            iconClass: 'dijitIconSave',\n            label: 'FASTA',\n            title: 'save as FASTA',\n            disabled: !has('save-generated-files'),\n            onClick: function () {\n              thisB.track._fileDownload({\n                format: 'FASTA',\n                filename: Util.assembleLocString(region) + '.fasta',\n                data: text,\n              })\n            },\n          }),\n        )\n      }\n\n      var textArea = dom.create(\n        'textarea',\n        {\n          className: 'fasta',\n          cols: this.width,\n          rows: Math.min(lineCount, this.htmlMaxRows),\n          readonly: true,\n        },\n        container,\n      )\n      var c = 0\n      textArea.innerHTML = text.replace(/\\n/g, function () {\n        return c++ ? '' : '\\n'\n      })\n      return container\n    },\n    /**\n     * returns FASTA formatted string\n     * @param {region object} region - fasta formated text string\n     * @param {string} seq - unformated sequence\n     * @returns {String} - fasta formated string\n     */\n    renderText: function (region, seq) {\n      return (\n        '>' +\n        region.ref +\n        ' ' +\n        Util.assembleLocString(region) +\n        (region.type ? ' class=' + region.type : '') +\n        ' length=' +\n        (region.end - region.start) +\n        '\\n' +\n        this._wrap(seq, this.width)\n      )\n    },\n    _wrap: function (string, length) {\n      length = length || this.width\n      return string.replace(new RegExp('(.{' + length + '})', 'g'), '$1\\n')\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/FastaFileDialog.js":{"size":3072,"mtime":1738905962493,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/FastaFileDialog.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/FeatureGlyph.js":{"size":5800,"mtime":1738905962504,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/FeatureGlyph.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'dojo/_base/array',\n  'dojo/aspect',\n  'JBrowse/Component',\n], function (declare, array, aspect, Component) {\n  return declare(Component, {\n    constructor: function (args) {\n      this.track = args.track\n      this.booleanAlpha = 0.17\n\n      // This allows any features that are completely masked to have their transparency set before being rendered,\n      // saving the hassle of clearing and rerendering later on.\n      aspect.before(\n        this,\n        'renderFeature',\n        function (context, fRect) {\n          if (fRect.m) {\n            var l = Math.floor(fRect.l)\n            var w = Math.ceil(fRect.w + fRect.l) - l\n            fRect.m.sort(function (a, b) {\n              return a.l - b.l\n            })\n            var m = fRect.m[0]\n            if (m.l <= l) {\n              // Determine whether the feature is entirely masked.\n              var end = fRect.m[0].l\n              for (var i in fRect.m) {\n                var m = fRect.m[i]\n                if (m.l > end) {break}\n                end = m.l + m.w\n              }\n              if (end >= l + w) {\n                context.globalAlpha = this.booleanAlpha\n                fRect.noMask = true\n              }\n            }\n          }\n        },\n        true,\n      )\n\n      // after rendering the features, do masking if required\n      aspect.after(\n        this,\n        'renderFeature',\n        function (context, fRect) {\n          if (fRect.m && !fRect.noMask) {\n            this.maskBySpans(context, fRect)\n          } else if (fRect.noMask) {\n            delete fRect.noMask\n            context.globalAlpha = 1\n          }\n        },\n        true,\n      )\n    },\n\n    getStyle: function (feature, name) {\n      return this.getConfForFeature('style.' + name, feature)\n    },\n\n    /**\n     * Like getConf, but get a conf value that explicitly can vary\n     * feature by feature.  Provides a uniform function signature for\n     * user-defined callbacks.\n     */\n    getConfForFeature: function (path, feature) {\n      return this.getConf(path, [feature, path, this, this.track])\n    },\n\n    mouseoverFeature: function (context, fRect) {\n      this.renderFeature(context, fRect)\n\n      // highlight the feature rectangle if we're moused over\n      context.fillStyle = this.getStyle(fRect.f, 'mouseovercolor')\n      context.fillRect(fRect.rect.l, fRect.t, fRect.rect.w, fRect.rect.h)\n    },\n\n    /**\n     * Get the dimensions of the rendered feature in pixels.\n     */\n    _getFeatureRectangle: function (viewInfo, feature) {\n      var block = viewInfo.block\n      var fRect = {\n        l: block.bpToX(feature.get('start')),\n        h: this._getFeatureHeight(viewInfo, feature),\n        viewInfo: viewInfo,\n        f: feature,\n        glyph: this,\n      }\n\n      fRect.w = block.bpToX(feature.get('end')) - fRect.l\n\n      this._addMasksToRect(viewInfo, feature, fRect)\n    },\n\n    _addMasksToRect: function (viewArgs, feature, fRect) {\n      // if the feature has masks, add them to the fRect.\n      var block = viewArgs.block\n\n      if (feature.masks) {\n        fRect.m = []\n        array.forEach(feature.masks, function (m) {\n          var tempM = { l: block.bpToX(m.start) }\n          tempM.w = block.bpToX(m.end) - tempM.l\n          fRect.m.push(tempM)\n        })\n      }\n\n      return fRect\n    },\n\n    layoutFeature: function (viewArgs, layout, feature) {\n      var fRect = this._getFeatureRectangle(viewArgs, feature)\n\n      var scale = viewArgs.scale\n      var leftBase = viewArgs.leftBase\n      var startbp = fRect.l / scale + leftBase\n      var endbp = (fRect.l + fRect.w) / scale + leftBase\n      fRect.t = layout.addRect(feature.id(), startbp, endbp, fRect.h, feature)\n      if (fRect.t === null) {return null}\n\n      fRect.f = feature\n\n      return fRect\n    },\n\n    //stub\n    renderFeature: function (context, fRect) {},\n\n    /* If it's a boolean track, mask accordingly */\n    maskBySpans: function (context, fRect) {\n      var canvasHeight = context.canvas.height\n\n      var thisB = this\n\n      // make a temporary canvas to store image data\n      var tempCan = dojo.create('canvas', {\n        height: canvasHeight,\n        width: context.canvas.width,\n      })\n      var ctx2 = tempCan.getContext('2d')\n      var l = Math.floor(fRect.l)\n      var w = Math.ceil(fRect.w + fRect.l) - l\n\n      /* note on the above: the rightmost pixel is determined\n           by l+w. If either of these is a float, then canvas\n           methods will not behave as desired (i.e. clear and\n           draw will not treat borders in the same way).*/\n      array.forEach(fRect.m, function (m) {\n        try {\n          if (m.l < l) {\n            m.w += m.l - l\n            m.l = l\n          }\n          if (m.w > w) {m.w = w}\n          if (m.l < 0) {\n            m.w += m.l\n            m.l = 0\n          }\n          if (m.l + m.w > l + w) {m.w = w + l - m.l}\n          if (m.l + m.w > context.canvas.width) {m.w = context.canvas.width - m.l}\n          ctx2.drawImage(\n            context.canvas,\n            m.l,\n            fRect.t,\n            m.w,\n            fRect.h,\n            m.l,\n            fRect.t,\n            m.w,\n            fRect.h,\n          )\n          context.globalAlpha = thisB.booleanAlpha\n          // clear masked region and redraw at lower opacity.\n          context.clearRect(m.l, fRect.t, m.w, fRect.h)\n          context.drawImage(\n            tempCan,\n            m.l,\n            fRect.t,\n            m.w,\n            fRect.h,\n            m.l,\n            fRect.t,\n            m.w,\n            fRect.h,\n          )\n          context.globalAlpha = 1\n        } catch (e) {}\n      })\n    },\n\n    _getFeatureHeight: function (viewArgs, feature) {\n      return this.getStyle(feature, 'height')\n    },\n\n    updateStaticElements: function (context, fRect, viewArgs) {},\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/FeatureGlyph/_FeatureLabelMixin.js":{"size":3874,"mtime":1738905962512,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/FeatureGlyph/_FeatureLabelMixin.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'dojo/_base/lang',\n  'JBrowse/View/_FeatureDescriptionMixin',\n], function (declare, lang, FeatureDescriptionMixin) {\n  var fontMeasurementsCache = {}\n\n  return declare(FeatureDescriptionMixin, {\n    /**\n     * Estimate the height and width, in pixels, of the given\n     * feature's label text, and trim it if necessary to fit within\n     * the track's maxFeatureGlyphExpansion limit.\n     */\n    makeFeatureLabel: function (feature, fRect, text) {\n      var text = text || this.getFeatureLabel(feature)\n      if (!text) {return null}\n      text = '' + text\n      var font = this.getStyle(feature, 'textFont')\n      var l = fRect\n        ? this.makeBottomOrTopLabel(text, font, fRect)\n        : this.makePopupLabel(text, font)\n      l.fill = this.getStyle(feature, 'textColor')\n      return l\n    },\n\n    /**\n     * Estimate the height and width, in pixels, of the given\n     * feature's description text, and trim it if necessary to fit\n     * within the track's maxFeatureGlyphExpansion limit.\n     */\n    makeFeatureDescriptionLabel: function (feature, fRect, text) {\n      var text = text || this.getFeatureDescription(feature)\n      if (!text) {return null}\n      text = '' + text\n      var font = this.getStyle(feature, 'text2Font')\n      var l = fRect\n        ? this.makeBottomOrTopLabel(text, font, fRect)\n        : this.makePopupLabel(text, font)\n      l.fill = this.getStyle(feature, 'text2Color')\n      return l\n    },\n\n    /**\n     * Makes a label that sits on the left or right side of a feature,\n     * respecting maxFeatureGlyphExpansion.\n     */\n    makeSideLabel: function (text, font, fRect) {\n      if (!text) {return null}\n\n      var dims = this.measureFont(font)\n      var excessCharacters = Math.round(\n        (text.length * dims.w -\n          this.track.getConf('maxFeatureGlyphExpansion')) /\n          dims.w,\n      )\n      if (excessCharacters > 0)\n        {text = text.slice(0, text.length - excessCharacters - 1) + '…'}\n\n      return {\n        text: text,\n        font: font,\n        baseline: 'middle',\n        w: dims.w * text.length,\n        h: dims.h,\n      }\n    },\n\n    /**\n     * Makes a label that lays across the bottom edge of a feature,\n     * respecting maxFeatureGlyphExpansion.\n     */\n    makeBottomOrTopLabel: function (text, font, fRect) {\n      if (!text) {return null}\n\n      var dims = this.measureFont(font)\n      var excessCharacters = Math.round(\n        (text.length * dims.w -\n          fRect.w -\n          this.track.getConf('maxFeatureGlyphExpansion')) /\n          dims.w,\n      )\n      if (excessCharacters > 0)\n        {text = text.slice(0, text.length - excessCharacters - 1) + '…'}\n\n      return {\n        text: text,\n        font: font,\n        baseline: 'bottom',\n        w: dims.w * text.length,\n        h: dims.h,\n      }\n    },\n\n    /**\n     * Makes a label that can be put in a popup or tooltip,\n     * not respecting maxFeatureGlyphExpansion or the width of the fRect.\n     */\n    makePopupLabel: function (text, font) {\n      if (!text) {return null}\n      var dims = this.measureFont(font)\n      return {\n        text: text,\n        font: font,\n        w: dims.w * text.length,\n        h: dims.h,\n      }\n    },\n\n    /**\n     * Return an object with average `h` and `w` of characters in the\n     * font described by the given string.\n     */\n    measureFont: function (font) {\n      return (\n        fontMeasurementsCache[font] ||\n        (fontMeasurementsCache[font] = function () {\n          var ctx = document.createElement('canvas').getContext('2d')\n          ctx.font = font\n          var testString = 'MMMMMMMMMMMMXXXXXXXXXX1234567890-.CGCC12345'\n          var m = ctx.measureText(testString)\n          return {\n            h: m.height || parseInt(font.match(/(\\d+)px/)[1]),\n            w: m.width / testString.length,\n          }\n        }.call(this))\n      )\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/FeatureGlyph/Alignment.js":{"size":5750,"mtime":1738905962519,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/FeatureGlyph/Alignment.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'dojo/_base/array',\n  'JBrowse/View/FeatureGlyph/Box',\n  'JBrowse/View/FeatureGlyph/AlignmentColoring',\n  'JBrowse/Store/SeqFeature/_MismatchesMixin',\n], function (declare, array, BoxGlyph, AlignmentColoring, MismatchesMixin) {\n  return declare([BoxGlyph, MismatchesMixin], {\n    constructor: function () {\n      // if showMismatches is false, stub out this object's\n      // _drawMismatches to be a no-op\n      if (!this.config.style.showMismatches)\n        {this._drawMismatches = function () {}}\n    },\n\n    _defaultConfig: function () {\n      return this._mergeConfigs(dojo.clone(this.inherited(arguments)), {\n        //maxFeatureScreenDensity: 400\n        style: {\n          color: AlignmentColoring.colorAlignment,\n          color_fwd_strand_not_proper: '#ECC8C8',\n          color_rev_strand_not_proper: '#BEBED8',\n          color_fwd_strand: '#EC8B8B',\n          color_rev_strand: '#8F8FD8',\n          color_fwd_missing_mate: '#D11919',\n          color_rev_missing_mate: '#1919D1',\n          color_fwd_diff_chr: '#000000',\n          color_rev_diff_chr: '#969696',\n          color_pair_lr: 'grey',\n          color_pair_rr: 'navy',\n          color_pair_rl: 'teal',\n          color_pair_ll: 'green',\n          color_nostrand: '#999999',\n          color_interchrom: 'orange',\n          color_longinsert: 'red',\n          color_shortinsert: 'pink',\n          border_color: null,\n\n          strandArrow: false,\n          height: 7,\n          marginBottom: 1,\n          showMismatches: true,\n          mismatchFont: 'bold 10px Courier New,monospace',\n          orientationType: 'fr', // default illumina adapter sequence --> <--\n        },\n      })\n    },\n\n    renderFeature: function (context, fRect) {\n      this.inherited(arguments)\n\n      // draw some mismatches if the feature is more than 3px wide:\n      //     draw everything if zoomed in past 0.2 px/bp, otherwise\n      //     draw only skips and deletions (the mismatches that\n      //     might be large enough to see)\n      if (fRect.w > 2) {\n        if (fRect.viewInfo.scale > 0.2)\n          {this._drawMismatches(context, fRect, this._getMismatches(fRect.f))}\n        else\n          {this._drawMismatches(\n            context,\n            fRect,\n            this._getSkipsAndDeletions(fRect.f),\n          )}\n      }\n    },\n\n    // draw both gaps and mismatches\n    _drawMismatches: function (context, fRect, mismatches, f) {\n      var feature = f || fRect.f\n      var block = fRect.viewInfo.block\n      var scale = block.scale\n\n      var charSize = this.getCharacterMeasurements(context)\n      context.textBaseline = 'middle' // reset to alphabetic (the default) after loop\n\n      array.forEach(\n        mismatches,\n        function (mismatch) {\n          var start = feature.get('start') + mismatch.start\n          var end = start + mismatch.length\n\n          var mRect = {\n            h: (fRect.rect || {}).h || fRect.h,\n            l: block.bpToX(start),\n            t: fRect.rect.t,\n          }\n          mRect.w = Math.max(block.bpToX(end) - mRect.l, 1)\n\n          if (mismatch.type == 'mismatch' || mismatch.type == 'deletion') {\n            context.fillStyle = this.track.colorForBase(\n              mismatch.type == 'deletion' ? 'deletion' : mismatch.base,\n            )\n            context.fillRect(mRect.l, mRect.t, mRect.w, mRect.h)\n\n            if (mRect.w >= charSize.w && mRect.h >= charSize.h - 3) {\n              context.font = this.config.style.mismatchFont\n              context.fillStyle =\n                mismatch.type == 'deletion' ? 'white' : 'black'\n              context.fillText(\n                mismatch.base,\n                mRect.l + (mRect.w - charSize.w) / 2 + 1,\n                mRect.t + mRect.h / 2,\n              )\n            }\n          } else if (mismatch.type == 'insertion') {\n            context.fillStyle = 'purple'\n            context.fillRect(mRect.l - 1, mRect.t + 1, 2, mRect.h - 2)\n            context.fillRect(mRect.l - 2, mRect.t, 4, 1)\n            context.fillRect(mRect.l - 2, mRect.t + mRect.h - 1, 4, 1)\n            if (mRect.w >= charSize.w && mRect.h >= charSize.h - 3) {\n              context.font = this.config.style.mismatchFont\n              context.fillText(\n                '(' + mismatch.base + ')',\n                mRect.l + 2,\n                mRect.t + mRect.h / 2,\n              )\n            }\n          } else if (\n            mismatch.type == 'hardclip' ||\n            mismatch.type == 'softclip'\n          ) {\n            context.fillStyle = mismatch.type == 'hardclip' ? 'red' : 'blue'\n            context.fillRect(mRect.l - 1, mRect.t + 1, 2, mRect.h - 2)\n            context.fillRect(mRect.l - 2, mRect.t, 4, 1)\n            context.fillRect(mRect.l - 2, mRect.t + mRect.h - 1, 4, 1)\n            if (mRect.w >= charSize.w && mRect.h >= charSize.h - 3) {\n              context.font = this.config.style.mismatchFont\n              context.fillText(\n                '(' + mismatch.base + ')',\n                mRect.l + 2,\n                mRect.t + mRect.h / 2,\n              )\n            }\n          } else if (mismatch.type == 'skip') {\n            context.clearRect(mRect.l, mRect.t, mRect.w, mRect.h)\n            context.fillStyle = '#333'\n            context.fillRect(mRect.l, mRect.t + (mRect.h - 2) / 2, mRect.w, 2)\n          }\n        },\n        this,\n      )\n\n      context.textBaseline = 'alphabetic'\n    },\n\n    getCharacterMeasurements: function (context) {\n      return (this.charSize =\n        this.charSize ||\n        function () {\n          var fpx\n\n          try {\n            fpx = (this.config.style.mismatchFont.match(/(\\d+)px/i) || [])[1]\n          } catch (e) {}\n\n          fpx = fpx || Infinity\n          return { w: fpx, h: fpx }\n        }.call(this))\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/FeatureGlyph/AlignmentColoring.js":{"size":7006,"mtime":1738905962529,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/FeatureGlyph/AlignmentColoring.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define(['JBrowse/Util'], function (Util) {\n  var c = {\n    colorAlignment(feature, score, glyph, track) {\n      var strand = feature.get('strand')\n      if (Math.abs(strand) != 1 && strand != '+' && strand != '-') {\n        return track.colorForBase('reference')\n      } else if (track.config.colorByOrientationAndSize) {\n        return c.colorByOrientationAndSize.apply(null, arguments)\n      } else if (track.config.colorByOrientation) {\n        return c.colorByOrientation.apply(null, arguments)\n      } else if (track.config.colorBySize) {\n        return c.colorByInsertSizePercentile.apply(null, arguments)\n      } else if (track.config.useXS) {\n        return c.colorByXS.apply(null, arguments)\n      } else if (track.config.useTS) {\n        return c.colorByTS.apply(null, arguments)\n      } else if (track.config.colorByMAPQ) {\n        return c.colorByMAPQ.apply(null, arguments)\n      } else if (track.config.defaultColor || track.config.useReverseTemplate) {\n        if (feature.get('multi_segment_template')) {\n          var revflag = feature.get('multi_segment_first')\n          if (feature.get('multi_segment_all_correctly_aligned')) {\n            if (revflag || !track.config.useReverseTemplate) {\n              return strand == 1 || strand == '+'\n                ? glyph.getStyle(feature, 'color_fwd_strand')\n                : glyph.getStyle(feature, 'color_rev_strand')\n            } else {\n              return strand == 1 || strand == '+'\n                ? glyph.getStyle(feature, 'color_rev_strand')\n                : glyph.getStyle(feature, 'color_fwd_strand')\n            }\n          }\n          if (feature.get('multi_segment_next_segment_unmapped')) {\n            if (revflag || !track.config.useReverseTemplate) {\n              return strand == 1 || strand == '+'\n                ? glyph.getStyle(feature, 'color_fwd_missing_mate')\n                : glyph.getStyle(feature, 'color_rev_missing_mate')\n            } else {\n              return strand == 1 || strand == '+'\n                ? glyph.getStyle(feature, 'color_rev_missing_mate')\n                : glyph.getStyle(feature, 'color_fwd_missing_mate')\n            }\n          }\n          if (feature.get('seq_id') == feature.get('next_seq_id')) {\n            if (revflag || !track.config.useReverseTemplate) {\n              return strand == 1 || strand == '+'\n                ? glyph.getStyle(feature, 'color_fwd_strand_not_proper')\n                : glyph.getStyle(feature, 'color_rev_strand_not_proper')\n            } else {\n              return strand == 1 || strand == '+'\n                ? glyph.getStyle(feature, 'color_rev_strand_not_proper')\n                : glyph.getStyle(feature, 'color_fwd_strand_not_proper')\n            }\n          }\n          // should only leave aberrant chr\n          return strand == 1 || strand == '+'\n            ? glyph.getStyle(feature, 'color_fwd_diff_chr')\n            : glyph.getStyle(feature, 'color_rev_diff_chr')\n        }\n        return strand == 1 || strand == '+'\n          ? glyph.getStyle(feature, 'color_fwd_strand')\n          : glyph.getStyle(feature, 'color_rev_strand')\n      } else {return glyph.getStyle(feature, 'color_nostrand')}\n    },\n\n    getOrientation(feature, score, glyph, track) {\n      const type = Util.orientationTypes[track.config.orientationType]\n      const orientation = type[feature.get('pair_orientation')]\n      const map = {\n        LR: 'color_pair_lr',\n        RR: 'color_pair_rr',\n        RL: 'color_pair_rl',\n        LL: 'color_pair_ll',\n      }\n      return map[orientation]\n    },\n\n    colorByOrientation(feature, score, glyph, track) {\n      const p = c.getOrientation.apply(null, arguments)\n      return glyph.getStyle(feature, p || 'color_nostrand')\n    },\n\n    colorByOrientationAndSize(feature, score, glyph, track) {\n      const p = c.getInsertSizePercentile.apply(null, arguments)\n      if (!p) {\n        return c.colorByOrientation.apply(null, arguments)\n      }\n      return glyph.getStyle(feature, p)\n    },\n    getInsertSizePercentile(feature, score, glyph, track) {\n      if (feature.get('is_paired')) {\n        const len = Math.abs(feature.get('template_length'))\n        if (feature.get('seq_id') != feature.get('next_seq_id')) {\n          return 'color_interchrom'\n        } else if (track.insertSizeStats.upper < len) {\n          return 'color_longinsert'\n        } else if (track.insertSizeStats.lower > len) {\n          return 'color_shortinsert'\n        }\n      }\n      return null\n    },\n    colorByInsertSizePercentile(feature, score, glyph, track) {\n      const p = c.getInsertSizePercentile.apply(null, arguments)\n      return glyph.getStyle(feature, p || 'color_nostrand')\n    },\n\n    colorByInsertSize(feature, score, glyph, track) {\n      if (\n        feature.get('is_paired') &&\n        feature.get('seq_id') != feature.get('next_seq_id')\n      ) {\n        return glyph.getStyle(feature, 'color_interchrom')\n      }\n      const s = Math.abs(score / 10)\n      return `hsl(${s},50%,50%)`\n    },\n\n    colorArcs(feature, score, glyph, track) {\n      if (track.config.colorByOrientationAndSize) {\n        return c.colorByOrientationAndSize.apply(null, arguments)\n      } else if (track.config.colorBySize) {\n        return c.colorByInsertSizePercentile.apply(null, arguments)\n      } else if (track.config.colorByOrientation) {\n        return c.colorByOrientation.apply(null, arguments)\n      } else if (track.config.colorByMAPQ) {\n        return c.colorByMAPQ.apply(null, arguments)\n      } else {\n        return c.colorByInsertSize.apply(null, arguments)\n      }\n    },\n\n    connectorColor(feature, score, glyph, track) {\n      if (track.config.colorByOrientation) {\n        return c.colorByOrientation.apply(null, arguments)\n      } else if (track.config.colorByOrientationAndSize) {\n        return c.colorByOrientationAndSize.apply(null, arguments)\n      } else {\n        return 'black'\n      }\n    },\n\n    colorByXS(feature, score, glyph, track) {\n      const map = {\n        '-': 'color_rev_strand',\n        '+': 'color_fwd_strand',\n      }\n      return glyph.getStyle(\n        feature,\n        map[\n          feature.get('xs') ||\n            feature.get('ts') ||\n            feature.get('tags').XS ||\n            feature.get('tags').TS\n        ] || 'color_nostrand',\n      )\n    },\n\n    // TS is flipped from XS\n    colorByTS(feature, score, glyph, track) {\n      const map = {\n        '-':\n          feature.get('strand') === -1\n            ? 'color_fwd_strand'\n            : 'color_rev_strand',\n        '+':\n          feature.get('strand') === -1\n            ? 'color_rev_strand'\n            : 'color_fwd_strand',\n      }\n      return glyph.getStyle(\n        feature,\n        map[feature.get('ts') || feature.get('tags').TS] || 'color_nostrand',\n      )\n    },\n\n    // assumes score cap at 60, which is used by bwa-mem and other tools. some cap at 37\n    colorByMAPQ(feature, score, glyph, track) {\n      const c = Math.min(feature.get('score') * 4, 200)\n      return `rgb(${c},${c},${c})`\n    },\n  }\n\n  return c\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/FeatureGlyph/Box.js":{"size":11760,"mtime":1738905962544,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/FeatureGlyph/Box.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'dojo/_base/lang',\n  'JBrowse/Util/FastPromise',\n  'JBrowse/View/FeatureGlyph',\n  './_FeatureLabelMixin',\n  'JBrowse/Util',\n], function (\n  declare,\n  lang,\n  FastPromise,\n  FeatureGlyph,\n  FeatureLabelMixin,\n  Util,\n) {\n  return declare([FeatureGlyph, FeatureLabelMixin], {\n    constructor: function () {\n      this._embeddedImagePromises = {}\n    },\n\n    _defaultConfig: function () {\n      return this._mergeConfigs(this.inherited(arguments), {\n        style: {\n          maxDescriptionLength: 70,\n\n          color: 'goldenrod',\n          mouseovercolor: 'rgba(0,0,0,0.3)',\n          borderColor: null,\n          borderWidth: 0.5,\n          height: 11,\n          marginBottom: 2,\n\n          strandArrow: true,\n\n          label: 'name, id',\n          textFont: 'normal 12px Univers,Helvetica,Arial,sans-serif',\n          textColor: 'black',\n          text2Color: 'blue',\n          text2Font: 'normal 12px Univers,Helvetica,Arial,sans-serif',\n\n          description: 'note, description',\n        },\n      })\n    },\n\n    _getFeatureHeight: function (viewArgs, feature) {\n      var h = this.getStyle(feature, 'height')\n\n      if (viewArgs.displayMode == 'compact') {h = Math.round(0.45 * h)}\n\n      if (this.getStyle(feature, 'strandArrow')) {\n        var strand = feature.get('strand')\n        if (strand == 1) {h = Math.max(this._embeddedImages.plusArrow.height, h)}\n        else if (strand == -1)\n          {h = Math.max(this._embeddedImages.minusArrow.height, h)}\n      }\n\n      return h\n    },\n\n    _getFeatureRectangle: function (viewArgs, feature) {\n      var block = viewArgs.block\n      var fRect = {\n        l: block.bpToX(feature.get('start')),\n        h: this._getFeatureHeight(viewArgs, feature),\n        viewInfo: viewArgs,\n        f: feature,\n        glyph: this,\n      }\n\n      fRect.w = block.bpToX(feature.get('end')) - fRect.l\n\n      // save the original rect in `rect` as the dimensions\n      // we'll use for the rectangle itself\n      fRect.rect = {\n        l: fRect.l,\n        h: fRect.h,\n        w: Math.max(fRect.w, 2),\n        t: 0,\n      }\n      fRect.w = fRect.rect.w // in case it was increased\n      if (viewArgs.displayMode != 'compact')\n        {fRect.h += this.getStyle(feature, 'marginBottom') || 0}\n      // if we are showing strand arrowheads, expand the frect a little\n      if (this.getStyle(feature, 'strandArrow')) {\n        var strand = (fRect.strandArrow = feature.get('strand'))\n\n        if (strand == -1) {\n          var i = this._embeddedImages.minusArrow\n          fRect.w += i.width\n          fRect.l -= i.width\n        } else {\n          var i = this._embeddedImages.plusArrow\n          fRect.w += i.width\n        }\n      }\n\n      // no labels or descriptions if displayMode is collapsed, so stop here\n      if (viewArgs.displayMode == 'collapsed') {return fRect}\n\n      this._expandRectangleWithLabels(viewArgs, feature, fRect)\n      this._addMasksToRect(viewArgs, feature, fRect)\n\n      return fRect\n    },\n\n    layoutFeature: function (viewArgs, layout, feature) {\n      var rect = this.inherited(arguments)\n      if (!rect) {return rect}\n\n      // need to set the top of the inner rect\n      rect.rect.t = rect.t\n\n      return rect\n    },\n\n    // given an under-construction feature layout rectangle, expand it\n    // to accomodate a label and/or a description\n    _expandRectangleWithLabels: function (viewArgs, feature, fRect) {\n      // maybe get the feature's name, and update the layout box\n      // accordingly\n      if (viewArgs.showLabels) {\n        var label = this.makeFeatureLabel(feature, fRect)\n        if (label) {\n          fRect.h += label.h\n          fRect.w = Math.max(label.w, fRect.w)\n          fRect.label = label\n          label.yOffset = fRect.rect.h + label.h\n        }\n      }\n\n      // maybe get the feature's description if available, and\n      // update the layout box accordingly\n      if (viewArgs.showDescriptions) {\n        var description = this.makeFeatureDescriptionLabel(feature, fRect)\n        if (description) {\n          fRect.description = description\n          fRect.h += description.h\n          fRect.w = Math.max(description.w, fRect.w)\n          description.yOffset =\n            fRect.h - (this.getStyle(feature, 'marginBottom') || 0)\n        }\n      }\n    },\n\n    _embeddedImages: {\n      plusArrow: {\n        data: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAFCAYAAACXU8ZrAAAATUlEQVQIW2NkwATGQKFYIG4A4g8gacb///+7AWlBmNq+vj6V4uLiJiD/FRBXA/F8xu7u7kcVFRWyMEVATQz//v0Dcf9CxaYRZxIxbgIARiAhmifVe8UAAAAASUVORK5CYII=',\n        width: 9,\n        height: 5,\n      },\n\n      minusArrow: {\n        data: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAFCAYAAACXU8ZrAAAASklEQVQIW2NkQAABILMBiBcD8VkkcQZGIAeEE4G4FYjFent764qKiu4gKXoPUjAJiLOggsxMTEwMjIwgYQjo6Oh4TLRJME043QQA+W8UD/sdk9IAAAAASUVORK5CYII=',\n        width: 9,\n        height: 5,\n      },\n    },\n\n    /**\n     * Returns a promise for an Image object for the image with the\n     * given name.  Image data comes from a data URL embedded in this\n     * source code.\n     */\n    getEmbeddedImage: function (name) {\n      return (\n        this._embeddedImagePromises[name] ||\n        function () {\n          var p = new FastPromise()\n          var imgRec = this._embeddedImages[name]\n          if (!imgRec) {\n            p.resolve(null)\n          } else {\n            var i = new Image()\n            var thisB = this\n            i.onload = function () {\n              p.resolve(this)\n            }\n            i.src = imgRec.data\n          }\n          return (this._embeddedImagePromises[name] = p)\n        }.call(this)\n      )\n    },\n\n    renderFeature: function (context, fRect) {\n      if (this.track.displayMode != 'collapsed')\n        {context.clearRect(\n          Math.floor(fRect.l),\n          fRect.t,\n          Math.ceil(fRect.w - Math.floor(fRect.l) + fRect.l),\n          fRect.h,\n        )}\n\n      this.renderBox(\n        context,\n        fRect.viewInfo,\n        fRect.f,\n        fRect.t,\n        fRect.rect.h,\n        fRect.f,\n      )\n      this.renderLabel(context, fRect)\n      this.renderDescription(context, fRect)\n      this.renderArrowhead(context, fRect)\n    },\n\n    // top and height are in px\n    renderBox: function (\n      context,\n      viewInfo,\n      feature,\n      top,\n      overallHeight,\n      parentFeature,\n      style,\n    ) {\n      var left = viewInfo.block.bpToX(feature.get('start'))\n      var width = viewInfo.block.bpToX(feature.get('end')) - left\n      //left = Math.round( left );\n      //width = Math.round( width );\n\n      style = style || lang.hitch(this, 'getStyle')\n\n      var height = this._getFeatureHeight(viewInfo, feature)\n      if (!height) {return}\n      if (height != overallHeight)\n        {top += Math.round((overallHeight - height) / 2)}\n\n      // background\n      var bgcolor = style(feature, 'color')\n      if (bgcolor) {\n        context.fillStyle = bgcolor\n        context.fillRect(left, top, Math.max(1, width), height)\n      } else {\n        context.clearRect(left, top, Math.max(1, width), height)\n      }\n\n      // foreground border\n      var borderColor, lineWidth\n      if (\n        (borderColor = style(feature, 'borderColor')) &&\n        (lineWidth = style(feature, 'borderWidth'))\n      ) {\n        if (width > 3) {\n          context.lineWidth = lineWidth\n          context.strokeStyle = borderColor\n\n          // need to stroke a smaller rectangle to remain within\n          // the bounds of the feature's overall height and\n          // width, because of the way stroking is done in\n          // canvas.  thus the +0.5 and -1 business.\n          context.strokeRect(\n            left + lineWidth / 2,\n            top + lineWidth / 2,\n            width - lineWidth,\n            height - lineWidth,\n          )\n        } else {\n          context.globalAlpha = (lineWidth * 2) / width\n          context.fillStyle = borderColor\n          context.fillRect(left, top, Math.max(1, width), height)\n          context.globalAlpha = 1\n        }\n      }\n    },\n\n    // feature label is handled by updateStaticElements\n    renderLabel: function (context, fRect) {},\n\n    // feature description is handled by updateStaticElements\n    renderDescription: function (context, fRect) {},\n\n    // strand arrowhead is sometimes drawn normally, sometimes *also* as a static element\n    renderArrowhead: function (context, fRect) {\n      if (fRect.strandArrow) {\n        if (\n          fRect.strandArrow == 1 &&\n          fRect.rect.l + fRect.rect.w <= context.canvas.width\n        ) {\n          this.getEmbeddedImage('plusArrow').then(function (img) {\n            context.imageSmoothingEnabled = false\n            context.drawImage(\n              img,\n              fRect.rect.l + fRect.rect.w,\n              fRect.t + (fRect.rect.h - img.height) / 2,\n            )\n          })\n        } else if (fRect.strandArrow == -1 && fRect.rect.l >= 0) {\n          this.getEmbeddedImage('minusArrow').then(function (img) {\n            context.imageSmoothingEnabled = false\n            context.drawImage(\n              img,\n              fRect.rect.l - 9,\n              fRect.t + (fRect.rect.h - img.height) / 2,\n            )\n          })\n        }\n      }\n    },\n\n    updateStaticElements(context, fRect, viewArgs) {\n      const vMin = viewArgs.minVisible\n      const vMax = viewArgs.maxVisible\n      const block = fRect.viewInfo.block\n\n      const bpToPx = viewArgs.bpToPx\n      const feature = fRect.f\n\n      const fMin = feature.get('start')\n      const fMax = feature.get('end')\n      const bMin = block.startBase\n      const bMax = block.endBase\n\n      if (fRect.strandArrow) {\n        if (fRect.strandArrow == 1 && fMax >= vMax && fMin <= vMax) {\n          this.getEmbeddedImage('plusArrow').then(function (img) {\n            context.imageSmoothingEnabled = false\n            context.drawImage(\n              img,\n              bpToPx(vMax) - bpToPx(vMin) - 9,\n              fRect.t + (fRect.rect.h - img.height) / 2,\n            )\n          })\n        } else if (fRect.strandArrow == -1 && fMin <= vMin && fMax >= vMin) {\n          this.getEmbeddedImage('minusArrow').then(function (img) {\n            context.imageSmoothingEnabled = false\n            context.drawImage(img, 0, fRect.t + (fRect.rect.h - img.height) / 2)\n          })\n        }\n      }\n\n      // if the feature is within the view and within this block\n      if (fMin < vMax && fMax > vMin && fMin < bMax && fMax > bMin) {\n        let fRectLeft = fRect.l + bpToPx(block.startBase - vMin + 1)\n\n        let clamp = (val, min, max) => Math.min(Math.max(val, min), max)\n        let renderText = fLabelRecord => {\n          let maxLabelLeft = fRectLeft + fRect.w - fLabelRecord.w\n          let labelTop = fRect.t + (fLabelRecord.yOffset || 0)\n          let labelLeft = fRectLeft + (fLabelRecord.xOffset || 0)\n          labelLeft = clamp(labelLeft, 0, maxLabelLeft)\n\n          context.font = fLabelRecord.font\n          context.fillStyle = fLabelRecord.fill\n          context.textBaseline = fLabelRecord.baseline\n\n          let clearTop\n          if (fLabelRecord.baseline === 'bottom') {\n            clearTop = labelTop - fLabelRecord.h\n          } else if (fLabelRecord.baseline === 'top') {\n            clearTop = labelTop\n          } else if (fLabelRecord.baseline === 'middle') {\n            clearTop = labelTop - fLabelRecord.h / 2\n          }\n          if (clearTop)\n            {context.clearRect(\n              labelLeft,\n              clearTop,\n              fLabelRecord.w,\n              fLabelRecord.h,\n            )}\n\n          context.fillText(fLabelRecord.text, labelLeft, labelTop)\n        }\n\n        if (fRect.label) {\n          renderText(fRect.label)\n        }\n        if (fRect.description) {\n          renderText(fRect.description)\n        }\n      }\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/FeatureGlyph/Diamond.js":{"size":2653,"mtime":1738905962550,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/FeatureGlyph/Diamond.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define(['dojo/_base/declare', 'dojo/_base/lang', './Box'], function (\n  declare,\n  lang,\n  Box,\n) {\n  return declare(Box, {\n    renderBox: function (\n      context,\n      viewInfo,\n      feature,\n      top,\n      overallHeight,\n      parentFeature,\n      style,\n    ) {\n      var left = viewInfo.block.bpToX(feature.get('start'))\n      var width = viewInfo.block.bpToX(feature.get('end')) - left\n      //left = Math.round( left );\n      //width = Math.round( width );\n\n      style = style || lang.hitch(this, 'getStyle')\n\n      var height = this._getFeatureHeight(viewInfo, feature)\n      if (!height) {return}\n      if (height != overallHeight)\n        {top += Math.round((overallHeight - height) / 2)}\n\n      // background\n      var bgcolor = style(feature, 'color')\n      if (bgcolor) {\n        context.fillStyle = bgcolor\n        context.beginPath()\n        context.moveTo(left, top + height / 2)\n        context.lineTo(left + Math.max(1, width) / 2, top)\n        context.lineTo(left + Math.max(1, width), top + height / 2)\n        context.lineTo(left + Math.max(1, width) / 2, top + height)\n        context.closePath()\n        context.fill()\n      } else {\n        context.clearRect(left, top, Math.max(1, width), height)\n      }\n\n      // foreground border\n      var borderColor, lineWidth\n      if (\n        (borderColor = style(feature, 'borderColor')) &&\n        (lineWidth = style(feature, 'borderWidth'))\n      ) {\n        if (width > 3) {\n          context.lineWidth = lineWidth\n          context.strokeStyle = borderColor\n\n          // need to stroke a smaller rectangle to remain within\n          // the bounds of the feature's overall height and\n          // width, because of the way stroking is done in\n          // canvas.  thus the +0.5 and -1 business.\n          //context.stroke();\n          context.beginPath()\n          context.moveTo(left, top + height / 2)\n          context.lineTo(left + Math.max(1, width) / 2, top)\n          context.lineTo(left + Math.max(1, width), top + height / 2)\n          context.lineTo(left + Math.max(1, width) / 2, top + height)\n          context.closePath()\n          context.stroke()\n        } else {\n          context.globalAlpha = (lineWidth * 2) / width\n          context.fillStyle = borderColor\n          context.beginPath()\n          context.moveTo(left, top + height / 2)\n          context.lineTo(left + Math.max(1, width) / 2, top)\n          context.lineTo(left + Math.max(1, width), top + height / 2)\n          context.lineTo(left + Math.max(1, width) / 2, top + height)\n          context.closePath()\n          context.fill()\n          context.globalAlpha = 1\n        }\n      }\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/FeatureGlyph/Gene.js":{"size":6129,"mtime":1738905962558,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/FeatureGlyph/Gene.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'dojo/_base/lang',\n  'dojo/_base/array',\n  'JBrowse/View/FeatureGlyph/Box',\n  'JBrowse/View/FeatureGlyph/UnprocessedTranscript',\n  'JBrowse/View/FeatureGlyph/ProcessedTranscript',\n], function (\n  declare,\n  lang,\n  array,\n  BoxGlyph,\n  UnprocessedTranscript,\n  ProcessedTranscriptGlyph,\n) {\n  return declare(BoxGlyph, {\n    _defaultConfig: function () {\n      return this._mergeConfigs(this.inherited(arguments), {\n        transcriptType: 'mRNA',\n        noncodingType: ['ncRNA', 'lnc_RNA', 'lncRNA', 'miRNA'],\n        style: {\n          transcriptLabelFont: 'normal 10px Univers,Helvetica,Arial,sans-serif',\n          transcriptLabelColor: 'black',\n          textFont: 'bold 12px Univers,Helvetica,Arial,sans-serif',\n        },\n        labelTranscripts: true,\n        marginBottom: 0,\n      })\n    },\n\n    _boxGlyph: function () {\n      return (\n        this.__boxGlyph ||\n        (this.__boxGlyph = new BoxGlyph({\n          track: this.track,\n          browser: this.browser,\n          config: this.config,\n        }))\n      )\n    },\n    _ntGlyph: function () {\n      return (\n        this.__ntGlyph ||\n        (this.__ntGlyph = new UnprocessedTranscript({\n          track: this.track,\n          browser: this.browser,\n          config: this.config,\n        }))\n      )\n    },\n    _ptGlyph: function () {\n      return (\n        this.__ptGlyph ||\n        (this.__ptGlyph = new ProcessedTranscriptGlyph({\n          track: this.track,\n          browser: this.browser,\n          config: this.config,\n        }))\n      )\n    },\n\n    _getFeatureRectangle(viewArgs, feature) {\n      // we need to lay out rects for each of the subfeatures\n      var subArgs = lang.mixin({}, viewArgs)\n      subArgs.showDescriptions = subArgs.showLabels = false\n      var subfeatures = feature.children()\n\n      // if this gene weirdly has no subfeatures, just render as a box\n      if (!subfeatures || !subfeatures.length) {return this.inherited(arguments)}\n\n      // get the rects for the children\n      var padding = 1\n      var fRect = {\n        l: 0,\n        h: 0,\n        r: 0,\n        w: 0,\n        subRects: [],\n        viewInfo: viewArgs,\n        f: feature,\n        glyph: this,\n      }\n      if (subfeatures && subfeatures.length) {\n        // sort the children by name\n        subfeatures.sort(function (a, b) {\n          return (a.get('name') || a.get('id') || '').localeCompare(\n            b.get('name') || b.get('id') || '',\n          )\n        })\n\n        fRect.l = Infinity\n        fRect.r = -Infinity\n\n        var transcriptType = this.getConfForFeature('transcriptType', feature)\n        var noncodingType = this.getConfForFeature('noncodingType', feature)\n        for (var i = 0; i < subfeatures.length; i++) {\n          var subRect = (\n            subfeatures[i].get('type') == transcriptType\n              ? this._ptGlyph()\n              : noncodingType.includes(subfeatures[i].get('type'))\n                ? this._ntGlyph()\n                : this._boxGlyph()\n          )._getFeatureRectangle(subArgs, subfeatures[i])\n\n          padding = i == subfeatures.length - 1 ? 0 : 1\n          subRect.t = subRect.rect.t =\n            fRect.h && viewArgs.displayMode != 'collapsed'\n              ? fRect.h + padding\n              : 0\n\n          if (\n            viewArgs.showLabels &&\n            this.getConfForFeature('labelTranscripts', subfeatures[i])\n          ) {\n            var transcriptLabel = this.makeSideLabel(\n              this.getFeatureLabel(subfeatures[i]),\n              this.getStyle(subfeatures[i], 'transcriptLabelFont'),\n              subRect,\n            )\n            if (transcriptLabel) {\n              transcriptLabel.fill = this.getStyle(\n                subfeatures[i],\n                'transcriptLabelColor',\n              )\n              subRect.label = transcriptLabel\n              subRect.l -= transcriptLabel.w\n              subRect.w += transcriptLabel.w\n              if (transcriptLabel.h > subRect.h) {subRect.h = transcriptLabel.h}\n              transcriptLabel.yOffset = Math.floor(subRect.h / 2)\n              transcriptLabel.xOffset = 0\n            }\n          }\n\n          fRect.subRects.push(subRect)\n          fRect.r = Math.max(fRect.r, subRect.l + subRect.w - 1)\n          fRect.l = Math.min(fRect.l, subRect.l)\n          fRect.h = subRect.t + subRect.h + padding\n        }\n      }\n\n      // calculate the width\n      fRect.w = Math.max(fRect.r - fRect.l + 1, 2)\n      delete fRect.r\n      fRect.rect = { l: fRect.l, h: fRect.h, w: fRect.w }\n      if (viewArgs.displayMode != 'compact')\n        {fRect.h += this.getStyle(feature, 'marginBottom') || 0}\n\n      // no labels or descriptions if displayMode is collapsed, so stop here\n      if (viewArgs.displayMode == 'collapsed') {return fRect}\n\n      // expand the fRect to accommodate labels if necessary\n      this._expandRectangleWithLabels(viewArgs, feature, fRect)\n      this._addMasksToRect(viewArgs, feature, fRect)\n\n      return fRect\n    },\n\n    layoutFeature: function (viewInfo, layout, feature) {\n      var fRect = this.inherited(arguments)\n      if (fRect)\n        {array.forEach(fRect.subRects, function (subrect) {\n          subrect.t += fRect.t\n          subrect.rect.t += fRect.t\n        })}\n      return fRect\n    },\n\n    renderFeature(context, fRect) {\n      const subRects = fRect.subRects\n      if (!subRects || subRects.length === 0) {return this.inherited(arguments)}\n\n      if (fRect.viewInfo.displayMode != 'collapsed')\n        {context.clearRect(\n          Math.floor(fRect.l),\n          fRect.t,\n          Math.ceil(fRect.w - Math.floor(fRect.l) + fRect.l),\n          fRect.h,\n        )}\n\n      for (var i = 0; i < subRects.length; i++) {\n        subRects[i].glyph.renderFeature(context, subRects[i])\n      }\n\n      this.renderLabel(context, fRect)\n      this.renderDescription(context, fRect)\n    },\n\n    updateStaticElements: function (context, fRect, viewArgs) {\n      this.inherited(arguments)\n\n      var subRects = fRect.subRects || []\n      for (var i = 0; i < subRects.length; i++) {\n        subRects[i].glyph.updateStaticElements(context, subRects[i], viewArgs)\n      }\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/FeatureGlyph/PairedAlignment.js":{"size":8886,"mtime":1738905962574,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/FeatureGlyph/PairedAlignment.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'dojo/_base/array',\n  'dojo/_base/lang',\n  'JBrowse/View/FeatureGlyph/Alignment',\n  'JBrowse/View/FeatureGlyph/AlignmentColoring',\n  'JBrowse/Util',\n], function (declare, array, lang, Alignment, AlignmentColoring, Util) {\n  return declare(Alignment, {\n    clearFeat(context, fRect) {\n      if (this.track.displayMode != 'collapsed')\n        {context.clearRect(\n          Math.floor(fRect.l),\n          fRect.t,\n          Math.ceil(fRect.w),\n          fRect.h,\n        )}\n    },\n    renderFeature(context, fRect) {\n      const f = fRect.f\n      this.clearFeat(context, fRect)\n\n      if (f.pairedFeature()) {\n        this.renderConnector(context, fRect)\n        this.renderSegments(context, fRect)\n        if (fRect.w > 2) {\n          if (fRect.viewInfo.scale > 0.2) {\n            this._drawMismatches(\n              context,\n              fRect,\n              this._getMismatches(f.read1),\n              f.read1,\n            )\n            this._drawMismatches(\n              context,\n              fRect,\n              this._getMismatches(f.read2),\n              f.read2,\n            )\n          } else {\n            this._drawMismatches(\n              context,\n              fRect,\n              this._getSkipsAndDeletions(f.read1),\n              f.read1,\n            )\n            this._drawMismatches(\n              context,\n              fRect,\n              this._getSkipsAndDeletions(f.read2),\n              f.read2,\n            )\n          }\n        }\n        const x1 = f.read1.get('start')\n        const x2 = f.read1.get('end')\n        const y1 = f.read2.get('start')\n        const y2 = f.read2.get('end')\n        if (Util.intersect(x1, x2, y1, y2)) {\n          const s1 = x2 > y2 ? x1 : y1\n          const s2 = x1 > y1 ? y2 : x2\n          const block = fRect.viewInfo.block\n          const l = block.bpToX(s1)\n          const r = block.bpToX(s2)\n          // avoid drawing small overlaps\n          if (r - l > 2) {\n            context.fillStyle = this.getStyle(f, 'overlapColor')\n            context.fillRect(\n              l, // left\n              fRect.rect.t,\n              r - l, // width\n              fRect.rect.h,\n            )\n\n            var s = this.getStyle(f, 'overlapStroke')\n            if (s) {\n              context.strokeStyle = s\n              context.strokeRect(\n                l, // left\n                fRect.rect.t,\n                r - l, // width\n                fRect.rect.h,\n              )\n            }\n            if (fRect.viewInfo.scale > 0.2) {\n              var m1 = this._getMismatches(f.read1)\n              var m2 = this._getMismatches(f.read2)\n              if (!m1 && !m2) {\n                return\n              } else {\n                var mismatches = []\n                for (var i = 0; i < m1.length; i++) {\n                  let foundMatching = false\n                  for (var j = 0; j < m2.length; j++) {\n                    if (\n                      x1 + m1[i].start == y1 + m2[j].start &&\n                      s1 <= x1 + m1[i].start &&\n                      s2 >= x1 + m1[i].start\n                    ) {\n                      foundMatching = true\n                      mismatches.push({\n                        start: m1[i].start,\n                        base1: m1[i].base,\n                        base2: m2[j].base,\n                        type: 'mismatch',\n                        length: 1,\n                      })\n                    }\n                  }\n                  if (\n                    m1[i].type == 'mismatch' &&\n                    s1 <= x1 + m1[i].start &&\n                    s2 >= x1 + m1[i].start &&\n                    !foundMatching\n                  ) {\n                    mismatches.push({\n                      start: m1[i].start,\n                      base1: m1[i].base,\n                      base2: '-',\n                      type: 'mismatch',\n                      length: 1,\n                    })\n                  }\n                }\n                if (mismatches.length !== 0) {\n                  this._drawOverlappingMismatches(\n                    context,\n                    fRect,\n                    mismatches,\n                    x1,\n                  )\n                }\n                mismatches = []\n                for (var i = 0; i < m2.length; i++) {\n                  let foundMatching = false\n                  for (var j = 0; j < m1.length; j++) {\n                    if (\n                      x1 + m1[j].start == y1 + m2[i].start &&\n                      s1 <= y1 + m2[i].start &&\n                      s2 >= y1 + m2[i].start\n                    ) {\n                      //    mismatches.push({ start: m2[i].start, base1: m2[i].base, base2: m1[j].base, type: 'mismatch', length: 1 });\n                      //    would have been found in above loop also previous iteration\n                      foundMatching = true\n                    }\n                  }\n                  if (\n                    m2[i].type == 'mismatch' &&\n                    s1 <= y1 + m2[i].start &&\n                    s2 >= y1 + m2[i].start &&\n                    !foundMatching\n                  ) {\n                    mismatches.push({\n                      start: m2[i].start,\n                      base1: m2[i].base,\n                      base2: '-',\n                      type: 'mismatch',\n                      length: 1,\n                    })\n                  }\n                }\n                if (mismatches.length !== 0) {\n                  this._drawOverlappingMismatches(\n                    context,\n                    fRect,\n                    mismatches,\n                    y1,\n                  )\n                }\n              }\n            }\n          }\n        }\n      } else {\n        this.inherited(arguments)\n      }\n    },\n\n    renderSegments(context, fRect) {\n      this.renderBox(\n        context,\n        fRect.viewInfo,\n        fRect.f.read1,\n        fRect.t,\n        fRect.rect.h,\n        fRect.f,\n      )\n      this.renderBox(\n        context,\n        fRect.viewInfo,\n        fRect.f.read2,\n        fRect.t,\n        fRect.rect.h,\n        fRect.f,\n      )\n    },\n\n    renderConnector(context, fRect) {\n      // connector\n      var connectorColor = this.getStyle(fRect.f, 'connectorColor')\n      if (connectorColor) {\n        context.fillStyle = connectorColor\n        var connectorThickness = this.getStyle(fRect.f, 'connectorThickness')\n        context.fillRect(\n          fRect.rect.l, // left\n          Math.round(fRect.rect.t + (fRect.rect.h - connectorThickness) / 2), // top\n          fRect.rect.w, // width\n          connectorThickness,\n        )\n      }\n    },\n\n    // draw both gaps and mismatches\n    _drawOverlappingMismatches(context, fRect, mismatches, fstart) {\n      var block = fRect.viewInfo.block\n      var scale = block.scale\n\n      var charSize = this.getCharacterMeasurements(context)\n      context.textBaseline = 'middle' // reset to alphabetic (the default) after loop\n\n      array.forEach(\n        mismatches,\n        function (mismatch) {\n          var start = fstart + mismatch.start\n          var end = fstart + mismatch.start + mismatch.length\n\n          var mRect = {\n            h: (fRect.rect || {}).h || fRect.h,\n            l: block.bpToX(start),\n            t: fRect.rect.t,\n          }\n          mRect.w = Math.max(block.bpToX(end) - mRect.l, 1)\n\n          if (mismatch.type == 'mismatch') {\n            if (mismatch.base1 == mismatch.base2) {\n              context.fillStyle = this.track.colorForBase(\n                mismatch.type == 'deletion' ? 'deletion' : mismatch.base1,\n              )\n            } else {\n              context.fillStyle = 'black'\n            }\n            context.fillRect(mRect.l, mRect.t, mRect.w, mRect.h)\n\n            if (mRect.w >= charSize.w && mRect.h >= charSize.h - 3) {\n              context.font = this.config.style.mismatchFont\n              if (mismatch.base1 == mismatch.base2) {\n                context.fillStyle = 'black'\n                context.fillText(\n                  mismatch.base1,\n                  mRect.l + (mRect.w - charSize.w) / 2 + 1,\n                  mRect.t + mRect.h / 2,\n                )\n              } else if (scale >= 10) {\n                context.fillStyle = 'white'\n                context.fillText(\n                  mismatch.base1 + '/' + mismatch.base2,\n                  mRect.l + (mRect.w - charSize.w * 2) / 2 + 1,\n                  mRect.t + mRect.h / 2,\n                )\n              }\n            }\n          }\n        },\n        this,\n      )\n\n      context.textBaseline = 'alphabetic'\n    },\n\n    _defaultConfig() {\n      return this._mergeConfigs(dojo.clone(this.inherited(arguments)), {\n        style: {\n          connectorColor: AlignmentColoring.connectorColor,\n          connectorThickness: 1,\n          overlapColor: 'lightgrey',\n          overlapStroke: 'grey',\n        },\n      })\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/FeatureGlyph/PairedArc.js":{"size":2743,"mtime":1738905962579,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/FeatureGlyph/PairedArc.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/FeatureGlyph/PairedReadCloud.js":{"size":1703,"mtime":1738905962582,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/FeatureGlyph/PairedReadCloud.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/FeatureGlyph/ProcessedTranscript.js":{"size":7526,"mtime":1738905962593,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/FeatureGlyph/ProcessedTranscript.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'dojo/_base/array',\n\n  'dojox/color/Palette',\n\n  'JBrowse/Model/SimpleFeature',\n  'JBrowse/View/FeatureGlyph/Segments',\n], function (\n  declare,\n  array,\n\n  Palette,\n\n  SimpleFeature,\n  SegmentsGlyph,\n) {\n  return declare(SegmentsGlyph, {\n    _defaultConfig: function () {\n      return this._mergeConfigs(this.inherited(arguments), {\n        style: {\n          utrColor: function (feature, variable, glyph, track) {\n            return glyph\n              ._utrColor(glyph.getStyle(feature.parent(), 'color'))\n              .toString()\n          },\n\n          utrHeightPercent: 65,\n        },\n\n        subParts: 'CDS, UTR, five_prime_UTR, three_prime_UTR',\n\n        impliedUTRs: false,\n\n        inferCdsParts: false,\n        subSubParts: () => true, // render sub-subparts by default\n      })\n    },\n\n    _getSubparts: function (f) {\n      var c = f.children()\n      if (!c) {return []}\n\n      if (c && this.config.inferCdsParts) {c = this._makeCDSs(f, c)}\n\n      if (c && this.config.impliedUTRs) {c = this._makeUTRs(f, c)}\n\n      var filtered = []\n      for (var i = 0; i < c.length; i++)\n        {if (this._filterSubpart(c[i])) {filtered.push(c[i])}}\n\n      return filtered\n    },\n\n    _makeCDSs: function (parent, subparts) {\n      // infer CDS parts from exon coordinates\n\n      var codeStart = Infinity,\n        codeEnd = -Infinity\n\n      var i\n\n      // gather exons, find coding start and end\n      var type,\n        codeIndices = [],\n        exons = []\n      for (i = 0; i < subparts.length; i++) {\n        type = subparts[i].get('type')\n        if (/^cds/i.test(type)) {\n          // if any CDSs parts are present already,\n          // bail and return all subparts as-is\n          if (/:CDS:/i.test(subparts[i].get('name'))) {return subparts}\n\n          codeIndices.push(i)\n          if (codeStart > subparts[i].get('start'))\n            {codeStart = subparts[i].get('start')}\n          if (codeEnd < subparts[i].get('end')) {codeEnd = subparts[i].get('end')}\n        } else {\n          if (/exon/i.test(type)) {\n            exons.push(subparts[i])\n          }\n        }\n      }\n\n      // splice out unspliced cds parts\n      codeIndices.sort(function (a, b) {\n        return b - a\n      })\n      for (i = codeIndices.length - 1; i >= 0; i--)\n        {subparts.splice(codeIndices[i], 1)}\n\n      // bail if we don't have exons and cds\n      if (!(exons.length && codeStart < Infinity && codeEnd > -Infinity))\n        {return subparts}\n\n      // make sure the exons are sorted by coord\n      exons.sort(function (a, b) {\n        return a.get('start') - b.get('start')\n      })\n\n      // iterate thru exons again, and calculate cds parts\n      var strand = parent.get('strand')\n      var codePartStart = Infinity,\n        codePartEnd = -Infinity\n      for (i = 0; i < exons.length; i++) {\n        var start = exons[i].get('start')\n        var end = exons[i].get('end')\n\n        // CDS containing exon\n        if (codeStart >= start && codeEnd <= end) {\n          codePartStart = codeStart\n          codePartEnd = codeEnd\n        }\n        // 5' terminal CDS part\n        else if (codeStart >= start && codeStart < end) {\n          codePartStart = codeStart\n          codePartEnd = end\n        }\n        // 3' terminal CDS part\n        else if (codeEnd > start && codeEnd <= end) {\n          codePartStart = start\n          codePartEnd = codeEnd\n        }\n        // internal CDS part\n        else if (start < codeEnd && end > codeStart) {\n          codePartStart = start\n          codePartEnd = end\n        }\n\n        // \"splice in\" the calculated cds part into subparts\n        // at beginning of _makeCDSs() method, bail if cds subparts are encountered\n        subparts.splice(\n          i,\n          0,\n          new SimpleFeature({\n            parent: parent,\n            data: {\n              start: codePartStart,\n              end: codePartEnd,\n              strand: strand,\n              type: 'CDS',\n              name: parent.get('uniqueID') + ':CDS:' + i,\n            },\n          }),\n        )\n      }\n\n      // make sure the subparts are sorted by coord\n      subparts.sort(function (a, b) {\n        return a.get('start') - b.get('start')\n      })\n\n      return subparts\n    },\n\n    _makeUTRs: function (parent, subparts) {\n      // based on Lincoln's UTR-making code in Bio::Graphics::Glyph::processed_transcript\n\n      var codeStart = Infinity,\n        codeEnd = -Infinity\n\n      var i\n\n      var haveLeftUTR, haveRightUTR\n\n      // gather exons, find coding start and end, and look for UTRs\n      var type,\n        exons = []\n      for (i = 0; i < subparts.length; i++) {\n        type = subparts[i].get('type')\n        if (/^cds/i.test(type)) {\n          if (codeStart > subparts[i].get('start'))\n            {codeStart = subparts[i].get('start')}\n          if (codeEnd < subparts[i].get('end')) {codeEnd = subparts[i].get('end')}\n        } else if (/exon/i.test(type)) {\n          exons.push(subparts[i])\n        } else if (this._isUTR(subparts[i])) {\n          haveLeftUTR = subparts[i].get('start') == parent.get('start')\n          haveRightUTR = subparts[i].get('end') == parent.get('end')\n        }\n      }\n\n      // bail if we don't have exons and CDS\n      if (!(exons.length && codeStart < Infinity && codeEnd > -Infinity))\n        {return subparts}\n\n      // make sure the exons are sorted by coord\n      exons.sort(function (a, b) {\n        return a.get('start') - b.get('start')\n      })\n\n      var strand = parent.get('strand')\n\n      // make the left-hand UTRs\n      var start, end\n      if (!haveLeftUTR)\n        {for (i = 0; i < exons.length; i++) {\n          start = exons[i].get('start')\n          if (start >= codeStart) {break}\n          end =\n            codeStart > exons[i].get('end') ? exons[i].get('end') : codeStart\n\n          subparts.unshift(\n            new SimpleFeature({\n              parent: parent,\n              data: {\n                start: start,\n                end: end,\n                strand: strand,\n                type: strand >= 0 ? 'five_prime_UTR' : 'three_prime_UTR',\n              },\n            }),\n          )\n        }}\n\n      // make the right-hand UTRs\n      if (!haveRightUTR)\n        {for (i = exons.length - 1; i >= 0; i--) {\n          end = exons[i].get('end')\n          if (end <= codeEnd) {break}\n\n          start =\n            codeEnd < exons[i].get('start') ? exons[i].get('start') : codeEnd\n          subparts.push(\n            new SimpleFeature({\n              parent: parent,\n              data: {\n                start: start,\n                end: end,\n                strand: strand,\n                type: strand >= 0 ? 'three_prime_UTR' : 'five_prime_UTR',\n              },\n            }),\n          )\n        }}\n\n      return subparts\n    },\n\n    _utrColor: function (baseColor) {\n      return (\n        this._palette ||\n        (this._palette = Palette.generate(baseColor, 'splitComplementary'))\n      ).colors[1]\n    },\n\n    _isUTR: function (feature) {\n      return /(\\bUTR|_UTR|untranslated[_\\s]region)\\b/.test(\n        feature.get('type') || '',\n      )\n    },\n\n    getStyle: function (feature, name) {\n      if (name == 'color') {\n        if (this._isUTR(feature)) {\n          return this.getStyle(feature, 'utrColor')\n        }\n      }\n\n      return this.inherited(arguments)\n    },\n\n    _getFeatureHeight: function (viewInfo, feature) {\n      var height = this.inherited(arguments)\n\n      if (this._isUTR(feature))\n        {return (height * this.getStyle(feature, 'utrHeightPercent')) / 100}\n\n      return height\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/FeatureGlyph/Segments.js":{"size":5171,"mtime":1738905962601,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/FeatureGlyph/Segments.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'dojo/_base/Color',\n  'JBrowse/View/FeatureGlyph/Box',\n], function (declare, Color, BoxGlyph) {\n  return declare(BoxGlyph, {\n    _defaultConfig: function () {\n      return this._mergeConfigs(this.inherited(arguments), {\n        style: {\n          connectorColor: '#333',\n          connectorThickness: 1,\n          borderColor: 'rgba( 0, 0, 0, 0.3 )',\n        },\n        subParts: () => true, // accept all subparts by default\n\n        subSubParts: () => true, // render sub-subparts by default\n      })\n    },\n\n    renderFeature: function (context, fRect) {\n      if (this.track.displayMode != 'collapsed')\n        {context.clearRect(\n          Math.floor(fRect.l),\n          fRect.t,\n          Math.ceil(fRect.w),\n          fRect.h,\n        )}\n\n      this.renderConnector(context, fRect)\n      this.renderSegments(context, fRect)\n      this.renderLabel(context, fRect)\n      this.renderDescription(context, fRect)\n      this.renderArrowhead(context, fRect)\n    },\n\n    renderConnector: function (context, fRect) {\n      // connector\n      var connectorColor = this.getStyle(fRect.f, 'connectorColor')\n      if (connectorColor) {\n        context.fillStyle = connectorColor\n        var connectorThickness = this.getStyle(fRect.f, 'connectorThickness')\n        context.fillRect(\n          fRect.rect.l, // left\n          Math.round(fRect.rect.t + (fRect.rect.h - connectorThickness) / 2), // top\n          fRect.rect.w, // width\n          connectorThickness,\n        )\n      }\n    },\n\n    renderSegments(context, fRect) {\n      let subparts = this._getSubparts(fRect.f)\n      if (!subparts.length) {return}\n\n      let parentFeature = fRect.f\n      let styleFunc = (feature, stylename) => {\n        if (stylename === 'height')\n          {return this._getFeatureHeight(fRect.viewInfo, feature)}\n\n        return (\n          this.getStyle(feature, stylename) ||\n          this.getStyle(parentFeature, stylename)\n        )\n      }\n\n      for (let i = 0; i < subparts.length; ++i) {\n        this.renderSegment(\n          context,\n          fRect.viewInfo,\n          subparts[i],\n          fRect.t,\n          fRect.rect.h,\n          fRect.f,\n          styleFunc,\n        )\n      }\n    },\n\n    renderSegment(\n      context,\n      viewInfo,\n      segmentFeature,\n      topPx,\n      heightPx,\n      parentFeature,\n      styleFunc,\n    ) {\n      this.renderBox(\n        context,\n        viewInfo,\n        segmentFeature,\n        topPx,\n        heightPx,\n        parentFeature,\n        styleFunc,\n      )\n      // if we have sub-subparts (stop codons and the like), draw them as shaded boxes\n      let subsubParts = this._getSubSubparts(segmentFeature)\n      if (subsubParts.length) {\n        let subsubStyleFunc = (feature, stylename) => {\n          // use a subSubParts-specific style if one is configured\n          let subsubSpecificStyle = styleFunc(\n            feature,\n            `subSubPart_${stylename}`,\n          )\n          if (subsubSpecificStyle) {return subsubSpecificStyle}\n\n          // otherwise use the main style and darken it somewhat\n          let style = styleFunc(feature, stylename)\n          if (\n            style &&\n            (stylename.includes('color') || stylename.includes('Color'))\n          ) {\n            let originalColor = Color.fromString(style)\n            if (originalColor) {\n              style = String(\n                Color.blendColors(\n                  originalColor,\n                  Color.fromArray([0, 0, 0, 1]),\n                  0.25,\n                ),\n              )\n            }\n          }\n\n          return style\n        }\n\n        subsubParts.forEach(subsubFeature => {\n          this.renderBox(\n            context,\n            viewInfo,\n            subsubFeature,\n            topPx,\n            heightPx,\n            segmentFeature,\n            subsubStyleFunc,\n          )\n        })\n      }\n    },\n\n    _getSubparts(feature) {\n      let children = feature.children() || []\n      return children.filter(this._filterSubpart.bind(this))\n    },\n\n    _getSubSubparts(feature) {\n      let children = feature.children() || []\n      return children.filter(this._filterSubSubpart.bind(this))\n    },\n\n    _filterSubpart(feature) {\n      if (!this._subpartsFilter)\n        {this._subpartsFilter = this._makeSubpartsFilter('subParts')}\n      return this._subpartsFilter(feature)\n    },\n\n    _filterSubSubpart(feature) {\n      if (!this._subSubpartsFilter)\n        {this._subSubpartsFilter = this._makeSubpartsFilter('subSubParts')}\n\n      return this._subSubpartsFilter(feature)\n    },\n\n    // make a function that will filter features features according to the\n    // subParts conf var\n    _makeSubpartsFilter(confKey = 'subParts') {\n      let filter = this.getConf(confKey)\n\n      if (typeof filter == 'string')\n        // convert to array\n        {filter = filter.split(/\\s*,\\s*/)}\n\n      if (Array.isArray(filter)) {\n        let typeNames = filter.map(typeName => typeName.toLowerCase())\n        return feature => typeNames.includes(feature.get('type').toLowerCase())\n      } else if (typeof filter === 'function') {\n        return filter\n      } else {\n        return () => true\n      }\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/FeatureGlyph/UCSC/BED.js":{"size":10997,"mtime":1738905962615,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/FeatureGlyph/UCSC/BED.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define(['dojo/_base/declare', 'JBrowse/View/FeatureGlyph/Segments'], function (\n  declare,\n  SegmentsGlyph,\n) {\n  return declare(SegmentsGlyph, {\n    _defaultConfig: function () {\n      return this._mergeConfigs(this.inherited(arguments), {\n        style: {\n          connectorColor: '#333',\n          connectorThickness: 1,\n          borderColor: 'rgba( 0, 0, 0, 0.3 )',\n        },\n        itemRgb: true,\n        height: 11,\n        thinHeight: 5,\n        subParts: () => false, // UCSC BED-like features don't have formal subparts\n        subSubParts: () => false, // UCSC BED-like features don't have formal subparts\n      })\n    },\n\n    parseItemRgb(itemRgb) {\n      const stringEncoding = /(\\d+),(\\d+),(\\d+)/.exec(itemRgb)\n      const hex2 = num => num.toString(16).padStart(2, '0')\n      if (stringEncoding) {\n        const r = Number(stringEncoding[1])\n        const g = Number(stringEncoding[2])\n        const b = Number(stringEncoding[3])\n        if (!isNaN(r) && !isNaN(g) && !isNaN(b) && (r || g || b))\n          {return `#${hex2(r)}${hex2(g)}${hex2(b)}`}\n      } else {\n        const rgb = Number(itemRgb)\n        if (rgb) {return `#${rgb.toString(16).padStart(6, '0')}`}\n      }\n    },\n\n    renderSegments(context, fRect) {\n      const styleFunc = (feature, stylename) => {\n        if (stylename === 'height')\n          {return this._getFeatureHeight(fRect.viewInfo, feature)}\n        else if (\n          stylename === 'color' &&\n          this.getConf('itemRgb', [feature, this])\n        ) {\n          const itemRgb = this.parseItemRgb(\n            feature.get('itemRgb') || feature.get('reserved'),\n          )\n          if (itemRgb) {return itemRgb}\n        }\n\n        return this.getStyle(feature, stylename)\n      }\n\n      const thickStart = Number(fRect.f.get('thick_start'))\n      const thickEnd = Number(fRect.f.get('thick_end'))\n\n      const blockCount = Number(fRect.f.get('block_count'))\n\n      if (blockCount && fRect.f.get('end') - fRect.f.get('start') > 5) {\n        let sizes = fRect.f.get('block_sizes')\n        if (!Array.isArray(sizes))\n          {sizes = sizes.split(',').map(str => Number(str))}\n\n        let starts = fRect.f.get('chrom_starts')\n        if (!Array.isArray(starts))\n          {starts = starts.split(',').map(str => Number(str))}\n\n        const blocksOffset = fRect.f.get('start')\n\n        for (let b = 0; b < blockCount; b += 1) {\n          const blockStart = (starts[b] | 0) + blocksOffset\n          const blockEnd = blockStart + (sizes[b] | 0)\n\n          // render the sub-block, either as a rect, or as a stroked path\n          this.renderSegment(\n            context,\n            fRect.viewInfo,\n            blockStart,\n            blockEnd,\n            thickStart,\n            thickEnd,\n            fRect.t,\n            fRect.rect.h,\n            fRect.f,\n            styleFunc,\n          )\n        }\n      } else {\n        // render the whole thing as a single block\n        this.renderSegment(\n          context,\n          fRect.viewInfo,\n          fRect.f.get('start'),\n          fRect.f.get('end'),\n          thickStart,\n          thickEnd,\n          fRect.t,\n          fRect.rect.h,\n          fRect.f,\n          styleFunc,\n        )\n      }\n    },\n\n    renderSegment(\n      context,\n      viewInfo,\n      start,\n      end,\n      thickStart,\n      thickEnd,\n      top,\n      overallHeight,\n      parentFeature,\n      style,\n    ) {\n      const left = viewInfo.block.bpToX(start)\n      const width = viewInfo.block.bpToX(end) - left\n      const right = left + width\n      const height = this._getFeatureHeight(viewInfo, parentFeature)\n      if (!height) {return}\n      if (height !== overallHeight)\n        {top += Math.round((overallHeight - height) / 2)}\n      const bottom = top + height\n      const thickStartPx = viewInfo.block.bpToX(thickStart)\n      const thickEndPx = viewInfo.block.bpToX(thickEnd)\n\n      const widthClamped = Math.max(1, width)\n      const thinHeight = this.getConf('thinHeight', [parentFeature, this])\n      const thinHeightDiff = (height - thinHeight) / 2\n\n      const bgcolor = style(parentFeature, 'color')\n      const borderColor = style(parentFeature, 'borderColor')\n      const lineWidth = style(parentFeature, 'borderWidth')\n      const halfLineWidth = lineWidth / 2\n\n      if (width > 3) {\n        let pathPoints\n        let strokePoints\n        if (thickStart <= start && thickEnd >= end) {\n          // ===========\n          pathPoints = [left, top, width, height]\n          strokePoints = [\n            left + halfLineWidth,\n            top + halfLineWidth,\n            width - lineWidth,\n            height - lineWidth,\n          ]\n        } else if (thickStart >= end || thickEnd <= start) {\n          // -----------\n          pathPoints = [left, top + thinHeightDiff, width, thinHeight]\n          strokePoints = [\n            left + halfLineWidth,\n            top + halfLineWidth + thinHeightDiff,\n            width - lineWidth,\n            thinHeight - lineWidth,\n          ]\n        } else if (thickStart <= start && thickEnd < end) {\n          // ====-------\n          pathPoints = [\n            [left, top],\n            [thickEndPx, top],\n            [thickEndPx, top + thinHeightDiff],\n            [right, top + thinHeightDiff],\n            [right, bottom - thinHeightDiff],\n            [thickEndPx, bottom - thinHeightDiff],\n            [thickEndPx, bottom],\n            [left, bottom],\n          ]\n          strokePoints = [\n            [left + halfLineWidth, top + halfLineWidth],\n            [thickEndPx - halfLineWidth, top + halfLineWidth],\n            [thickEndPx - halfLineWidth, top + thinHeightDiff + halfLineWidth],\n            [right - halfLineWidth, top + thinHeightDiff + halfLineWidth],\n            [right - halfLineWidth, bottom - thinHeightDiff - halfLineWidth],\n            [\n              thickEndPx - halfLineWidth,\n              bottom - thinHeightDiff - halfLineWidth,\n            ],\n            [thickEndPx - halfLineWidth, bottom - halfLineWidth],\n            [left + halfLineWidth, bottom - halfLineWidth],\n          ]\n        } else if (thickStart > start && thickEnd >= end) {\n          // -----======\n          pathPoints = [\n            [left, top + thinHeightDiff],\n            [thickStartPx, top + thinHeightDiff],\n            [thickStartPx, top],\n            [right, top],\n            [right, bottom],\n            [thickStartPx, bottom],\n            [thickStartPx, bottom - thinHeightDiff],\n            [left, bottom - thinHeightDiff],\n          ]\n          strokePoints = [\n            [left + halfLineWidth, top + thinHeightDiff + halfLineWidth],\n            [\n              thickStartPx + halfLineWidth,\n              top + thinHeightDiff + halfLineWidth,\n            ],\n            [thickStartPx + halfLineWidth, top + halfLineWidth],\n            [right - halfLineWidth, top + halfLineWidth],\n            [right - halfLineWidth, bottom - halfLineWidth],\n            [thickStartPx + halfLineWidth, bottom - halfLineWidth],\n            [\n              thickStartPx + halfLineWidth,\n              bottom - thinHeightDiff - halfLineWidth,\n            ],\n            [left + halfLineWidth, bottom - thinHeightDiff - halfLineWidth],\n          ]\n        } else if (thickStart > start && thickEnd < end) {\n          // ----====---\n          pathPoints = [\n            [left, top + thinHeightDiff],\n            [thickStartPx, top + thinHeightDiff],\n            [thickStartPx, top],\n            [thickEndPx, top],\n            [thickEndPx, top + thinHeightDiff],\n            [right, top + thinHeightDiff],\n            [right, bottom - thinHeightDiff],\n            [thickEndPx, bottom - thinHeightDiff],\n            [thickEndPx, bottom],\n            [thickStartPx, bottom],\n            [thickStartPx, bottom - thinHeightDiff],\n            [left, bottom - thinHeightDiff],\n          ]\n          strokePoints = [\n            [left + halfLineWidth, top + thinHeightDiff + halfLineWidth],\n            [\n              thickStartPx + halfLineWidth,\n              top + thinHeightDiff + halfLineWidth,\n            ],\n            [thickStartPx + halfLineWidth, top + halfLineWidth],\n            [thickEndPx - halfLineWidth, top + halfLineWidth],\n            [thickEndPx - halfLineWidth, top + thinHeightDiff + halfLineWidth],\n            [right - halfLineWidth, top + thinHeightDiff + halfLineWidth],\n            [right - halfLineWidth, bottom - thinHeightDiff - halfLineWidth],\n            [\n              thickEndPx - halfLineWidth,\n              bottom - thinHeightDiff - halfLineWidth,\n            ],\n            [thickEndPx - halfLineWidth, bottom - halfLineWidth],\n            [thickStartPx + halfLineWidth, bottom - halfLineWidth],\n            [\n              thickStartPx + halfLineWidth,\n              bottom - thinHeightDiff - halfLineWidth,\n            ],\n            [left + halfLineWidth, bottom - thinHeightDiff - halfLineWidth],\n          ]\n        }\n\n        // background\n        if (bgcolor) {\n          context.fillStyle = bgcolor\n          if (pathPoints[0].length) {\n            context.beginPath()\n            context.moveTo(...pathPoints[0])\n            for (let i = 1; i < pathPoints.length; i += 1) {\n              context.lineTo(...pathPoints[i])\n            }\n            context.fill()\n          } else {\n            context.fillRect(...pathPoints)\n          }\n        }\n\n        // foreground border\n        if (borderColor && lineWidth) {\n          context.lineWidth = lineWidth\n          context.strokeStyle = borderColor\n\n          // need to stroke a smaller path to remain within\n          // the bounds of the feature's overall height and\n          // width, because of the way stroking is done in\n          // canvas.  thus the +0.5 and -1 business.\n          //context.strokeRect( left + lineWidth / 2, top + lineWidth / 2, width - lineWidth, height - lineWidth );\n          if (strokePoints[0].length) {\n            context.beginPath()\n            context.moveTo(...strokePoints[0])\n            for (let i = 1; i < strokePoints.length; i += 1) {\n              context.lineTo(...strokePoints[i])\n            }\n            context.stroke()\n          } else {\n            context.strokeRect(...strokePoints)\n          }\n        }\n      } else {\n        // for very tiny features, just draw them as rectangles of blurry height, and shade them\n        context.globalAlpha = 1\n        context.fillStyle = bgcolor\n        if (thickStart <= start && thickEnd >= end) {\n          context.fillRect(left, top, widthClamped, height)\n          context.globalAlpha = (lineWidth * 2) / width\n          context.fillStyle = borderColor\n          context.fillRect(left, top, widthClamped, height)\n          context.globalAlpha = 1\n        } else {\n          context.fillRect(left, top + thinHeightDiff, widthClamped, thinHeight)\n          context.globalAlpha = (lineWidth * 2) / width\n          context.fillStyle = borderColor\n          context.fillRect(left, top + thinHeightDiff, widthClamped, thinHeight)\n          context.globalAlpha = 1\n        }\n      }\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/FeatureGlyph/UnprocessedTranscript.js":{"size":900,"mtime":1738905962618,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/FeatureGlyph/UnprocessedTranscript.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'dojo/_base/lang',\n  'JBrowse/View/FeatureGlyph/Segments',\n], function (declare, lang, Segments) {\n  return declare(Segments, {\n    _defaultConfig: function () {\n      return this._mergeConfigs(this.inherited(arguments), {\n        style: {\n          unprocessedTranscriptColor: 'red',\n        },\n      })\n    },\n    renderBox: function (\n      context,\n      viewInfo,\n      feature,\n      top,\n      overallHeight,\n      parentFeature,\n      style,\n    ) {\n      style = style || lang.hitch(this, 'getStyle')\n      return this.inherited(arguments, [\n        context,\n        viewInfo,\n        feature,\n        top,\n        overallHeight,\n        parentFeature,\n        function (feat, attr) {\n          if (attr == 'color')\n            {return style(parentFeature, 'unprocessedTranscriptColor')}\n          return style(feat, attr)\n        },\n      ])\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/FileDialog.js":{"size":9420,"mtime":1738905962630,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/FileDialog.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/FileDialog/ResourceList.js":{"size":10530,"mtime":1738905962642,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/FileDialog/ResourceList.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'dojo/_base/array',\n  'dojo/dom-construct',\n  'dijit/form/Select',\n], function (declare, array, dom, Select) {\n  return declare(null, {\n    constructor: function (args) {\n      this.dialog = args.dialog\n      this.domNode = dom.create('div', { className: 'resourceList' })\n      this._updateView()\n    },\n\n    clearLocalFiles: function () {\n      this._resources = array.filter(this._resources || [], function (res) {\n        return !res.file\n      })\n      this._notifyChange()\n    },\n\n    _notifyChange: function () {\n      this.onChange(\n        array.map(this._resources || [], function (res) {\n          var r = {}\n          if (res.file) {r.file = res.file}\n          if (res.url) {r.url = res.url}\n          r.type = res.type.get('value')\n          return r\n        }),\n      )\n    },\n\n    _addResources: function (resources) {\n      var seenFile = {}\n      var allRes = (this._resources || []).concat(resources)\n      this._resources = array\n        .filter(allRes.reverse(), function (res) {\n          var key = (res.file && res.file.name) || res.url\n          if (seenFile[key]) {\n            return false\n          }\n          seenFile[key] = true\n          return true\n        })\n        .reverse()\n\n      this._updateView()\n      this._notifyChange()\n    },\n\n    addLocalFiles: function (fileList) {\n      this._addResources(\n        array.map(fileList, function (file) {\n          return { file: file }\n        }),\n      )\n    },\n\n    clearURLs: function () {\n      this._resources = array.filter(this._resources || [], function (res) {\n        return !res.url\n      })\n      this._notifyChange()\n    },\n    addURLs: function (urls) {\n      this._addResources(\n        array.map(urls, function (u) {\n          return { url: u }\n        }),\n      )\n    },\n\n    // old-style handler stub\n    onChange: function () {},\n\n    _updateView: function () {\n      var container = this.domNode\n      dom.empty(container)\n\n      dom.create('h3', { innerHTML: 'Files and URLs' }, container)\n\n      if ((this._resources || []).length) {\n        var table = dom.create('table', {}, container)\n\n        // render rows in the resource table for each resource in our\n        // list\n        array.forEach(\n          this._resources,\n          function (res, i) {\n            var that = this\n            var tr = dom.create('tr', {}, table)\n            var name = res.url || res.file.name\n\n            // make a selector for the resource's type\n            var typeSelect = new Select({\n              options: [\n                {\n                  label: '<span class=\"ghosted\">file type?</span>',\n                  value: null,\n                },\n                { label: 'GFF3', value: 'gff3' },\n                { label: 'GTF', value: 'gtf' },\n                { label: 'BigWig', value: 'bigwig' },\n                { label: 'BAM', value: 'bam' },\n                { label: 'BAM index', value: 'bam.bai' },\n                { label: 'FASTA', value: 'fasta' },\n                { label: 'FASTA index', value: 'fai' },\n                { label: 'BGZIP FASTA', value: 'fasta.gz' },\n                {\n                  label: 'BGZIP FASTA index (.gz.fai)',\n                  value: 'fasta.gz.fai',\n                },\n                {\n                  label: 'BGZIP index (.gz.gzi)',\n                  value: 'gzi',\n                },\n                { label: '2bit', value: '2bit' },\n                { label: 'BigBed', value: 'bb' },\n                { label: 'VCF+bgzip', value: 'vcf.gz' },\n                { label: 'VCF', value: 'vcf' },\n                { label: 'IGV/GATK Index', value: 'idx' },\n                { label: 'BED+bgzip', value: 'bed.gz' },\n                { label: 'BED', value: 'bed' },\n                { label: 'GFF3+bgzip', value: 'gff3.gz' },\n                {\n                  label: 'VCF+Tabix index',\n                  value: 'vcf.gz.tbi',\n                },\n                {\n                  label: 'GFF3+Tabix index',\n                  value: 'gff3.gz.tbi',\n                },\n                {\n                  label: 'BED+Tabix index',\n                  value: 'bed.gz.tbi',\n                },\n                { label: 'BED+CSI index', value: 'bed.gz.csi' },\n                { label: 'VCF+CSI index', value: 'vcf.gz.csi' },\n                {\n                  label: 'GFF3+CSI index',\n                  value: 'gff3.gz.csi',\n                },\n                { label: 'BAM+CSI index', value: 'bam.csi' },\n                { label: 'CRAM', value: 'cram' },\n                { label: 'CRAM index', value: 'cram.crai' },\n                { label: 'Chrom sizes', value: 'chrom.sizes' },\n              ],\n              value: this.guessType(name),\n              onChange: function () {\n                that._rememberedTypes = that._rememberedTypes || {}\n                that._rememberedTypes[name] = this.get('value')\n                that._notifyChange()\n              },\n            })\n            typeSelect.placeAt(dojo.create('td', { width: '4%' }, tr))\n            res.type = typeSelect\n\n            dojo.create(\n              'td',\n              {\n                width: '1%',\n                innerHTML:\n                  '<div class=\"' +\n                  (res.file ? 'dijitIconFile' : 'jbrowseIconLink') +\n                  '\"></div>',\n              },\n              tr,\n            )\n            dojo.create('td', { innerHTML: name }, tr)\n            dojo.create(\n              'td',\n              {\n                width: '1%',\n                innerHTML: '<div class=\"dijitIconDelete\"></div>',\n                onclick: function (e) {\n                  e.preventDefault && e.preventDefault()\n                  that.deleteResource(res)\n                },\n              },\n              tr,\n            )\n          },\n          this,\n        )\n      } else {\n        dom.create(\n          'div',\n          {\n            className: 'emptyMessage',\n            innerHTML: 'Add files and URLs using the controls above.',\n          },\n          container,\n        )\n      }\n\n      // little elements used to show pipeline-like connections between the controls\n      dom.create(\n        'div',\n        { className: 'connector', innerHTML: '&nbsp;' },\n        container,\n      )\n    },\n\n    deleteResource: function (resource) {\n      this._resources = array.filter(this._resources || [], function (res) {\n        return res !== resource\n      })\n      this._updateView()\n      this._notifyChange()\n    },\n\n    guessType: function (name) {\n      return (\n        (this._rememberedTypes || {})[name] ||\n        (/\\.bam$/i.test(name)\n          ? 'bam'\n          : /\\.bai$/i.test(name)\n            ? 'bam.bai'\n            : /\\.gff3?$/i.test(name)\n              ? 'gff3'\n              : /\\.gtf?$/i.test(name)\n                ? 'gtf'\n                : /\\.(bw|bigwig)$/i.test(name)\n                  ? 'bigwig'\n                  : /\\.(fa|fasta|fna|mfa)$/i.test(name)\n                    ? 'fasta'\n                    : /\\.(fa|fasta|fna|mfa)\\.gz$/i.test(name)\n                      ? 'fasta.gz'\n                      : /\\.(fa|fasta|fna|mfa)\\.gz\\.fai$/i.test(name)\n                        ? 'fasta.gz.fai'\n                        : /\\.2bit$/i.test(name)\n                          ? '2bit'\n                          : /\\.fai$/i.test(name)\n                            ? 'fai'\n                            : /\\.idx$/i.test(name)\n                              ? 'idx'\n                              : /\\.vcf$/i.test(name)\n                                ? 'vcf'\n                                : /\\.vcf\\.gz$/i.test(name)\n                                  ? 'vcf.gz'\n                                  : /\\.bed\\.gz$/i.test(name)\n                                    ? 'bed.gz'\n                                    : /\\.gzi$/i.test(name)\n                                      ? 'gzi'\n                                      : /\\.gff3?\\.gz$/i.test(name)\n                                        ? 'gff3.gz'\n                                        : /\\.bed$/i.test(name)\n                                          ? 'bed'\n                                          : /\\.(bb|bigbed)$/i.test(name)\n                                            ? 'bb'\n                                            : /\\.gff3?\\.gz.tbi$/i.test(name)\n                                              ? 'gff3.gz.tbi'\n                                              : /\\.vcf.gz.tbi$/i.test(name)\n                                                ? 'vcf.gz.tbi'\n                                                : /\\.bed.gz.tbi$/i.test(name)\n                                                  ? 'bed.gz.tbi'\n                                                  : /\\.bed.gz.csi/i.test(name)\n                                                    ? 'bed.gz.csi'\n                                                    : /\\.gff3?\\.gz.csi$/i.test(\n                                                          name,\n                                                        )\n                                                      ? 'gff3.gz.csi'\n                                                      : /\\.vcf.gz.csi$/i.test(\n                                                            name,\n                                                          )\n                                                        ? 'vcf.gz.csi'\n                                                        : /\\.bam.csi$/i.test(\n                                                              name,\n                                                            )\n                                                          ? 'bam.csi'\n                                                          : /\\.cram$/i.test(\n                                                                name,\n                                                              )\n                                                            ? 'cram'\n                                                            : /\\.crai$/i.test(\n                                                                  name,\n                                                                )\n                                                              ? 'cram.crai'\n                                                              : /\\.sizes$/i.test(\n                                                                    name,\n                                                                  )\n                                                                ? 'chrom.sizes'\n                                                                : null)\n      )\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/FileDialog/TrackList.js":{"size":6708,"mtime":1738905962651,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/FileDialog/TrackList.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'dojo/_base/array',\n  'dojo/dom-construct',\n  'JBrowse/Util',\n  'dijit/form/TextBox',\n  'dijit/form/Select',\n  'dijit/form/Button',\n  'JBrowse/View/TrackConfigEditor',\n], function (\n  declare,\n  array,\n  dom,\n  Util,\n  TextBox,\n  Select,\n  Button,\n  TrackConfigEditor,\n) {\n  var uniqCounter = 0\n\n  return declare(null, {\n    constructor: function (args) {\n      this.browser = args.browser\n      this.fileDialog = args.fileDialog\n      this.domNode = dom.create('div', {\n        className: 'trackList',\n        innerHTML: 'track list!',\n      })\n\n      this._updateDisplay()\n    },\n\n    getTrackConfigurations: function () {\n      return Util.dojof.values(this.trackConfs || {})\n    },\n\n    update: function (resources) {\n      this.storeConfs = {}\n      this.trackConfs = {}\n\n      this._makeStoreConfs(resources)\n\n      // make some track configurations from the store configurations\n      this._makeTrackConfs()\n\n      this._updateDisplay()\n    },\n\n    _makeStoreConfs: function (resources) {\n      // when called, rebuild the store and track configurations that we are going to add\n      this.storeConfs = this.storeConfs || {}\n\n      var typeDrivers = this.fileDialog.getFileTypeDrivers()\n\n      // anneal the given resources into a set of data store\n      // configurations by offering each file to each type driver in\n      // turn until no more are being accepted\n      var lastLength = 0\n      while (resources.length && resources.length != lastLength) {\n        resources = array.filter(\n          resources,\n          function (resource) {\n            return !array.some(\n              typeDrivers,\n              function (typeDriver) {\n                return typeDriver.tryResource(this.storeConfs, resource)\n              },\n              this,\n            )\n          },\n          this,\n        )\n\n        lastLength = resources.length\n      }\n\n      array.forEach(\n        typeDrivers,\n        function (typeDriver) {\n          typeDriver.finalizeConfiguration(this.storeConfs)\n        },\n        this,\n      )\n\n      if (resources.length)\n        {console.warn(\n          'Not all resources could be assigned to tracks.  Unused resources:',\n          resources,\n        )}\n    },\n\n    _makeTrackConfs: function () {\n      // object that maps store type -> default track type to use for the store\n      var typeMap = this.browser.getTrackTypes().trackTypeDefaults\n\n      // find any store configurations that appear to be coverage stores\n      var coverageStores = {}\n      for (var n in this.storeConfs) {\n        if (this.storeConfs[n].fileBasename) {\n          var baseBase = this.storeConfs[n].fileBasename.replace(\n            /\\.(coverage|density|histograms?)$/,\n            '',\n          )\n          if (baseBase != this.storeConfs[n].fileBasename) {\n            coverageStores[baseBase] = {\n              store: this.storeConfs[n],\n              name: n,\n              used: false,\n            }\n          }\n        }\n      }\n\n      // make track configurations for each store configuration\n      for (var n in this.storeConfs) {\n        var store = this.storeConfs[n]\n        var trackType =\n          typeMap[store.type] || 'JBrowse/View/Track/CanvasFeatures'\n\n        this.trackConfs = this.trackConfs || {}\n\n        this.trackConfs[n] = {\n          store: this.storeConfs[n],\n          storeClass: this.storeConfs[n].type,\n          label: n,\n          key: n.replace(/_\\d+$/, '').replace(/_/g, ' '),\n          type: trackType,\n          category: 'Local tracks',\n          autoscale: 'local', // make locally-opened BigWig tracks default to local autoscaling\n        }\n\n        // if we appear to have a coverage store for this one, use it\n        // and mark it to have its track removed after all the tracks are made\n        var cov = coverageStores[store.fileBasename]\n        if (cov) {\n          this.trackConfs[n].histograms = {\n            store: cov.store,\n            description: cov.store.fileBasename,\n          }\n          cov.used = true\n        }\n      }\n\n      // delete the separate track confs for any of the stores that were\n      // incorporated into other tracks as histograms\n      for (var n in coverageStores) {\n        if (coverageStores[n].used)\n          {delete this.trackConfs[coverageStores[n].name]}\n      }\n    },\n\n    _delete: function (trackname) {\n      delete (this.trackConfs || {})[trackname]\n      this._updateDisplay()\n    },\n\n    _updateDisplay: function () {\n      var that = this\n\n      // clear it\n      dom.empty(this.domNode)\n\n      dom.create('h3', { innerHTML: 'New Tracks' }, this.domNode)\n\n      if (!Util.dojof.keys(this.trackConfs || {}).length) {\n        dom.create(\n          'div',\n          { className: 'emptyMessage', innerHTML: 'None' },\n          this.domNode,\n        )\n      } else {\n        var table = dom.create(\n          'table',\n          {\n            innerHTML:\n              '<tr class=\"head\"><th>Name</th><th>Display</th><th></th></tr>',\n          },\n          this.domNode,\n        )\n\n        var trackTypes = this.browser.getTrackTypes()\n\n        Object.entries(this.trackConfs).forEach(([n, t]) => {\n          var r = dom.create('tr', {}, table)\n          new TextBox({\n            value: t.key,\n            onChange: function () {\n              t.key = this.get('value')\n            },\n          }).placeAt(dom.create('td', { className: 'name' }, r))\n          new Select({\n            options: array.map(trackTypes.knownTrackTypes, function (t) {\n              var l =\n                trackTypes.trackTypeLabels[t] ||\n                t.replace('JBrowse/View/Track/', '').replace(/\\//g, ' ')\n              return { label: l, value: t }\n            }),\n            value: t.type,\n            onChange: function () {\n              t.type = this.get('value')\n            },\n          }).placeAt(dom.create('td', { className: 'type' }, r))\n\n          new Button({\n            className: 'edit',\n            title: 'edit configuration',\n            innerHTML: 'Edit Configuration',\n            onClick: function () {\n              new TrackConfigEditor(t).show(function (result) {\n                dojo.mixin(t, result.conf)\n                that._updateDisplay()\n              })\n            },\n          }).placeAt(dom.create('td', { className: 'edit' }, r))\n\n          dojo.create(\n            'td',\n            {\n              width: '1%',\n              innerHTML: '<div class=\"dijitIconDelete\"></div>',\n              onclick: function (e) {\n                e.preventDefault && e.preventDefault()\n                that._delete(n)\n              },\n            },\n            r,\n          )\n\n          dom.create('td', { className: 'type' }, r)\n        })\n      }\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/FileDialog/TrackList/_IndexedFileDriver.js":{"size":6424,"mtime":1738905962661,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/FileDialog/TrackList/_IndexedFileDriver.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'JBrowse/Util',\n  'JBrowse/Model/FileBlob',\n  'JBrowse/Model/XHRBlob',\n], function (declare, Util, FileBlob, XHRBlob) {\n  var uniqCounter = 0\n  return declare(null, {\n    tryResource: function (configs, resource) {\n      if (resource.type == this.fileExtension) {\n        var basename = Util.basename(\n          resource.file ? resource.file.name : resource.url ? resource.url : '',\n        )\n        if (!basename) {return false}\n\n        // go through the configs and see if there is one for an index that seems to match\n        for (var n in configs) {\n          var c = configs[n]\n          if (\n            Util.basename(\n              c[this.indexConfKey]\n                ? c[this.indexConfKey].url || c[this.indexConfKey].blob.name\n                : c[this.indexUrlConfKey],\n              '.' + this.indexExtension,\n            ) == basename\n          ) {\n            // it's a match, put it in\n            c[this.fileConfKey] = this._makeBlob(resource)\n            return true\n          }\n        }\n        // go through again and look for index files that don't have the base extension in them\n        basename = Util.basename(basename, '.' + this.fileExtension)\n        for (var n in configs) {\n          var c = configs[n]\n          if (\n            Util.basename(\n              c[this.indexConfKey]\n                ? c[this.indexConfKey].url || c[this.indexConfKey].blob.name\n                : c[this.indexUrlConfKey],\n              '.' + this.indexExtension,\n            ) == basename\n          ) {\n            // it's a match, put it in\n            c[this.fileConfKey] = this._makeBlob(resource)\n            return true\n          }\n        }\n\n        // otherwise make a new store config for it\n        var newName = this.name + '_' + basename + '_' + uniqCounter++\n        configs[newName] = {\n          type: this.storeType,\n          name: newName,\n          fileBasename: basename,\n        }\n        configs[newName][this.fileConfKey] = this._makeBlob(resource)\n\n        return true\n      } else if (resource.type == this.indexExtension) {\n        var basename = Util.basename(\n          resource.file ? resource.file.name : resource.url ? resource.url : '',\n          '.' + this.indexExtension,\n        )\n        if (!basename) {return false}\n\n        // go through the configs and look for data files that match like zee.bam -> zee.bam.bai\n        for (var n in configs) {\n          var c = configs[n]\n          if (\n            Util.basename(\n              c[this.fileConfKey]\n                ? c[this.fileConfKey].url || c[this.fileConfKey].blob.name\n                : c[this.fileUrlConfKey],\n            ) == basename\n          ) {\n            // it's a match, put it in\n            c[this.indexConfKey] = this._makeBlob(resource)\n            return true\n          }\n        }\n        // go through again and look for data files that match like zee.bam -> zee.bai\n        for (var n in configs) {\n          var c = configs[n]\n          if (\n            Util.basename(\n              c[this.fileConfKey]\n                ? c[this.fileConfKey].url || c[this.fileConfKey].blob.name\n                : c[this.fileUrlConfKey],\n              '.' + this.fileExtension,\n            ) == basename\n          ) {\n            // it's a match, put it in\n            c[this.indexConfKey] = this._makeBlob(resource)\n            return true\n          }\n        }\n\n        // otherwise make a new store\n        var newName =\n          this.name +\n          '_' +\n          Util.basename(basename, '.' + this.fileExtension) +\n          '_' +\n          uniqCounter++\n        configs[newName] = {\n          name: newName,\n          type: this.storeType,\n        }\n\n        configs[newName][this.indexConfKey] = this._makeBlob(resource)\n        return true\n      } else {return false}\n    },\n\n    // try to merge any singleton file and index stores.  currently can only do this if there is one of each\n    finalizeConfiguration: function (configs) {\n      var singletonIndexes = {}\n      var singletonIndexCount = 0\n      var singletonFiles = {}\n      var singletonFileCount = 0\n      for (var n in configs) {\n        var conf = configs[n]\n        if (conf.type === this.storeType) {\n          if (\n            (conf[this.indexConfKey] || conf[this.indexUrlConfKey]) &&\n            !(conf[this.fileConfKey] || conf[this.fileUrlConfKey])\n          ) {\n            // singleton Index\n            singletonIndexCount++\n            singletonIndexes[n] = conf\n          } else if (\n            (conf[this.fileConfKey] || conf[this.fileUrlConfKey]) &&\n            !(conf[this.indexConfKey] || conf[this.indexUrlConfKey])\n          ) {\n            // singleton File\n            singletonFileCount++\n            singletonFiles[n] = conf\n          }\n        }\n      }\n\n      // if we have a single File and single Index left at the end,\n      // stick them together and we'll see what happens\n      if (singletonFileCount == 1 && singletonIndexCount == 1) {\n        for (var indexName in singletonIndexes) {\n          for (var fileName in singletonFiles) {\n            if (singletonIndexes[indexName][this.indexUrlConfKey])\n              {singletonFiles[fileName][this.indexUrlConfKey] =\n                singletonIndexes[indexName][this.indexUrlConfKey]}\n            if (singletonIndexes[indexName][this.indexConfKey])\n              {singletonFiles[fileName][this.indexConfKey] =\n                singletonIndexes[indexName][this.indexConfKey]}\n\n            delete configs[indexName]\n          }\n        }\n      }\n\n      // delete any remaining singleton Indexes, since they don't have\n      // a hope of working\n      for (var indexName in singletonIndexes) {\n        delete configs[indexName]\n      }\n\n      // delete any remaining singleton Files, unless they are URLs\n      for (var fileName in singletonFiles) {\n        if (!configs[fileName][this.fileUrlConfKey]) {delete configs[fileName]}\n      }\n    },\n\n    _makeBlob: function (resource) {\n      var r = resource.file\n        ? new FileBlob(resource.file)\n        : resource.url\n          ? new XHRBlob(resource.url)\n          : null\n      if (!r) {throw 'unknown resource type'}\n      return r\n    },\n\n    confIsValid: function (conf) {\n      return (\n        (conf[this.fileConfKey] || conf[this.fileUrlConfKey]) &&\n        (conf[this.indexConfKey] ||\n          conf[this.indexUrlConfKey] ||\n          conf[this.fileUrlConfKey])\n      )\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/FileDialog/TrackList/_MultiIndexedFileDriver.js":{"size":7751,"mtime":1738905962670,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/FileDialog/TrackList/_MultiIndexedFileDriver.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'JBrowse/Util',\n  'JBrowse/Model/FileBlob',\n  'JBrowse/Model/XHRBlob',\n], function (declare, Util, FileBlob, XHRBlob) {\n  var uniqCounter = 0\n  return declare(null, {\n    tryResource: function (configs, resource) {\n      if (resource.type == this.fileExtension) {\n        var basename = Util.basename(\n          resource.file ? resource.file.name : resource.url ? resource.url : '',\n        )\n        if (!basename) {return false}\n\n        // go through the configs and see if there is one for an index that seems to match\n        for (var n in configs) {\n          var c = configs[n]\n          for (const m in this.indexTypes) {\n            var index = this.indexTypes[m]\n            if (\n              Util.basename(\n                c[index.indexConfKey]\n                  ? c[index.indexConfKey].url || c[index.indexConfKey].blob.name\n                  : c[index.indexUrlConfKey],\n                index.indexExtensionMap || '.' + index.indexExtension,\n              ) == basename\n            ) {\n              // it's a match, put it in\n              c[this.fileConfKey] = this._makeBlob(resource)\n              return true\n            }\n          }\n        }\n        // go through again and look for index files that don't have the base extension in them\n        basename = Util.basename(\n          basename,\n          this.fileExtensionMap || '.' + this.fileExtension,\n        )\n        for (var n in configs) {\n          var c = configs[n]\n          for (const m in this.indexTypes) {\n            var index = this.indexTypes[m]\n            if (\n              Util.basename(\n                c[index.indexConfKey]\n                  ? c[index.indexConfKey].url || c[index.indexConfKey].blob.name\n                  : c[index.indexUrlConfKey],\n                index.indexExtensionMap || '.' + index.indexExtension,\n              ) == basename\n            ) {\n              // it's a match, put it in\n              c[this.fileConfKey] = this._makeBlob(resource)\n              return true\n            }\n          }\n        }\n\n        // otherwise make a new store config for it\n        var newName = this.name + '_' + basename + '_' + uniqCounter++\n        configs[newName] = {\n          type: this.storeType,\n          name: newName,\n          fileBasename: basename,\n        }\n        configs[newName][this.fileConfKey] = this._makeBlob(resource)\n\n        return true\n      } else {\n        for (const m in this.indexTypes) {\n          var index = this.indexTypes[m]\n          if (resource.type == index.indexExtension) {\n            var basename = Util.basename(\n              resource.file\n                ? resource.file.name\n                : resource.url\n                  ? resource.url\n                  : '',\n              index.indexExtensionMap || '.' + index.indexExtension,\n            )\n            if (!basename) {return false}\n\n            // go through the configs and look for data files that match like zee.bam -> zee.bam.bai\n            for (var n in configs) {\n              var c = configs[n]\n              if (\n                Util.basename(\n                  c[this.fileConfKey]\n                    ? c[this.fileConfKey].url || c[this.fileConfKey].blob.name\n                    : c[this.fileUrlConfKey],\n                ) == basename\n              ) {\n                // it's a match, put it in\n                c[index.indexConfKey] = this._makeBlob(resource)\n                return true\n              }\n            }\n            // go through again and look for data files that match like zee.bam -> zee.bai\n            for (var n in configs) {\n              var c = configs[n]\n              if (\n                Util.basename(\n                  c[this.fileConfKey]\n                    ? c[this.fileConfKey].url || c[this.fileConfKey].blob.name\n                    : c[this.fileUrlConfKey],\n                  this.fileExtensionMap || '.' + this.fileExtension,\n                ) == basename\n              ) {\n                // it's a match, put it in\n                c[index.indexConfKey] = this._makeBlob(resource)\n                return true\n              }\n            }\n\n            // otherwise make a new store\n            var newName =\n              this.name +\n              '_' +\n              Util.basename(\n                basename,\n                this.fileExtensionMap || '.' + this.fileExtension,\n              ) +\n              '_' +\n              uniqCounter++\n            configs[newName] = {\n              name: newName,\n              type: this.storeType,\n            }\n\n            configs[newName][index.indexConfKey] = this._makeBlob(resource)\n            return true\n          }\n        }\n      }\n      return false\n    },\n\n    // try to merge any singleton file and index stores.  currently can only do this if there is one of each\n    finalizeConfiguration: function (configs) {\n      var singletonIndexes = {}\n      var singletonIndexCount = 0\n      var singletonFiles = {}\n      var singletonFileCount = 0\n      for (var n in configs) {\n        var conf = configs[n]\n        if (conf.type === this.storeType) {\n          var flag = false\n          for (const m in this.indexTypes) {\n            const index = this.indexTypes[m]\n            flag |= !!(conf[index.indexConfKey] || conf[index.indexUrlConfKey])\n          }\n          if (flag && !(conf[this.fileConfKey] || conf[this.fileUrlConfKey])) {\n            singletonIndexCount++\n            singletonIndexes[n] = conf\n          }\n\n          flag = true\n          for (const m in this.indexTypes) {\n            const index = this.indexTypes[m]\n            flag &= !(conf[index.indexConfKey] || conf[index.indexUrlConfKey])\n          }\n          if (flag && !!(conf[this.fileConfKey] || conf[this.fileUrlConfKey])) {\n            singletonFileCount++\n            singletonFiles[n] = conf\n          }\n        }\n      }\n\n      // if we have a single File and single Index left at the end,\n      // stick them together and we'll see what happens\n      if (singletonFileCount == 1 && singletonIndexCount == 1) {\n        for (var indexName in singletonIndexes) {\n          for (var fileName in singletonFiles) {\n            for (const m in this.indexTypes) {\n              const index = this.indexTypes[m]\n              if (singletonIndexes[indexName][index.indexUrlConfKey])\n                {singletonFiles[fileName][index.indexUrlConfKey] =\n                  singletonIndexes[indexName][index.indexUrlConfKey]}\n              if (singletonIndexes[indexName][index.indexConfKey])\n                {singletonFiles[fileName][index.indexConfKey] =\n                  singletonIndexes[indexName][index.indexConfKey]}\n\n              delete configs[indexName]\n            }\n          }\n        }\n      }\n\n      // delete any remaining singleton Indexes, since they don't have\n      // a hope of working\n      for (var indexName in singletonIndexes) {\n        delete configs[indexName]\n      }\n\n      // delete any remaining singleton Files, unless they are URLs\n      for (var fileName in singletonFiles) {\n        if (!configs[fileName][this.fileUrlConfKey]) {delete configs[fileName]}\n      }\n    },\n\n    _makeBlob: function (resource) {\n      var r = resource.file\n        ? new FileBlob(resource.file)\n        : resource.url\n          ? new XHRBlob(resource.url)\n          : null\n      if (!r) {throw 'unknown resource type'}\n      return r\n    },\n\n    confIsValid: function (conf) {\n      var valid = false\n      for (var m in this.indexTypes) {\n        var index = this.indexTypes[m]\n        valid |=\n          (conf[this.fileConfKey] || conf[this.fileUrlConfKey]) &&\n          (conf[index.indexConfKey] ||\n            conf[index.indexUrlConfKey] ||\n            conf[this.fileUrlConfKey])\n      }\n      return valid\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/FileDialog/TrackList/_OptionallyIndexedFileDriver.js":{"size":2365,"mtime":1738905962675,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/FileDialog/TrackList/_OptionallyIndexedFileDriver.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'JBrowse/Util',\n  './_IndexedFileDriver',\n], function (declare, Util, _IndexedFileDriver) {\n  return declare(_IndexedFileDriver, {\n    // try to merge any singleton file and index stores.  currently can only do this if there is one of each\n    finalizeConfiguration: function (configs) {\n      var singletonIndexes = {}\n      var singletonIndexCount = 0\n      var singletonFiles = {}\n      var singletonFileCount = 0\n      for (var n in configs) {\n        var conf = configs[n]\n        if (conf.type === this.storeType) {\n          if (\n            (conf[this.indexConfKey] || conf[this.indexUrlConfKey]) &&\n            !(conf[this.fileConfKey] || conf[this.fileUrlConfKey])\n          ) {\n            // singleton Index\n            singletonIndexCount++\n            singletonIndexes[n] = conf\n          } else if (\n            (conf[this.fileConfKey] || conf[this.fileUrlConfKey]) &&\n            !(conf[this.indexConfKey] || conf[this.indexUrlConfKey])\n          ) {\n            // singleton File\n            singletonFileCount++\n            singletonFiles[n] = conf\n          }\n        }\n      }\n\n      // if we have a single File and single Index left at the end,\n      // stick them together and we'll see what happens\n      if (singletonFileCount == 1 && singletonIndexCount == 1) {\n        for (var indexName in singletonIndexes) {\n          for (var fileName in singletonFiles) {\n            if (singletonIndexes[indexName][this.indexUrlConfKey])\n              {singletonFiles[fileName][this.indexUrlConfKey] =\n                singletonIndexes[indexName][this.indexUrlConfKey]}\n            if (singletonIndexes[indexName][this.indexConfKey])\n              {singletonFiles[fileName][this.indexConfKey] =\n                singletonIndexes[indexName][this.indexConfKey]}\n\n            delete configs[indexName]\n          }\n        }\n      }\n\n      // delete any remaining singleton Indexes, since they don't have\n      // a hope of working\n      for (var indexName in singletonIndexes) {\n        delete configs[indexName]\n      }\n\n      // make any remaining singleton data files be unindexed stores\n      for (var fileName in singletonFiles) {\n        configs[fileName].type = this.unindexedStoreType\n      }\n    },\n\n    confIsValid: function (conf) {\n      return conf[this.fileConfKey] || conf[this.fileUrlConfKey]\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/FileDialog/TrackList/BAMDriver.js":{"size":587,"mtime":1738905962677,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/FileDialog/TrackList/BAMDriver.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/FileDialog/TrackList/BEDDriver.js":{"size":1200,"mtime":1738905962680,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/FileDialog/TrackList/BEDDriver.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'JBrowse/Util',\n  'JBrowse/Model/FileBlob',\n  'JBrowse/Model/XHRBlob',\n], function (declare, Util, FileBlob, XHRBlob) {\n  var uniqCounter = 0\n  return declare(null, {\n    storeType: 'JBrowse/Store/SeqFeature/BED',\n\n    tryResource: function (configs, resource) {\n      if (resource.type == 'bed') {\n        var basename = Util.basename(\n          resource.file ? resource.file.name : resource.url ? resource.url : '',\n          ['.bed'],\n        )\n        if (!basename) {return false}\n\n        var newName = 'BED_' + basename + '_' + uniqCounter++\n        configs[newName] = {\n          type: this.storeType,\n          fileBasename: basename,\n          blob: this._makeBlob(resource),\n          name: newName,\n        }\n        return true\n      } else {return false}\n    },\n\n    finalizeConfiguration: function (configs) {},\n\n    _makeBlob: function (resource) {\n      var r = resource.file\n        ? new FileBlob(resource.file)\n        : resource.url\n          ? new XHRBlob(resource.url)\n          : null\n      if (!r) {throw 'unknown resource type'}\n      return r\n    },\n\n    confIsValid: function (conf) {\n      return conf.blob || conf.urlTemplate\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/FileDialog/TrackList/BEDTabixDriver.js":{"size":412,"mtime":1738905962682,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/FileDialog/TrackList/BEDTabixDriver.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/FileDialog/TrackList/BgzipIndexedFASTADriver.js":{"size":6390,"mtime":1738905962692,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/FileDialog/TrackList/BgzipIndexedFASTADriver.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'JBrowse/Util',\n  'JBrowse/Model/FileBlob',\n  'JBrowse/Model/XHRBlob',\n], function (declare, Util, FileBlob, XHRBlob) {\n  var uniqCounter = 0\n  return declare(null, {\n    name: 'BGZFASTA',\n    storeType: 'JBrowse/Store/SeqFeature/BgzipIndexedFasta',\n    fileExtension: 'fasta.gz',\n    fileExtensionMap: ['.fasta.gz', '.fa.gz', '.fna.gz', '.mfa.gz'],\n    fileConfKey: 'bgzfa',\n    fileUrlConfKey: 'urlTemplate',\n\n    indexExtension: 'fasta.gz.fai',\n    indexExtensionMap: [\n      '.fasta.gz.fai',\n      '.fa.gz.fai',\n      '.fna.gz.fai',\n      '.mfa.gz.fai',\n    ],\n    indexConfKey: 'fai',\n    indexUrlConfKey: 'faiUrlTemplate',\n\n    doubleIndexExtension: 'gzi',\n    doubleIndexExtensionMap: [\n      '.fasta.gz.gzi',\n      '.fa.gz.gzi',\n      '.fna.gz.gzi',\n      '.mfa.gz.gzi',\n    ],\n    doubleIndexConfKey: 'gzi',\n    doubleIndexUrlConfKey: 'gziUrlTemplate',\n\n    tryResource: function (configs, resource) {\n      if (resource.type == this.fileExtension) {\n        var basename = Util.basename(\n          resource.file ? resource.file.name : resource.url ? resource.url : '',\n          this.fileExtensionMap,\n        )\n        if (!basename) {return false}\n\n        // go through the configs and see if there is one for an index that seems to match\n        for (var n in configs) {\n          var c = configs[n]\n          if (\n            Util.basename(\n              c[this.indexConfKey]\n                ? c[this.indexConfKey].url || c[this.indexConfKey].blob.name\n                : c[this.indexUrlConfKey],\n              this.indexExtensionMap,\n            ) == basename ||\n            Util.basename(\n              c[this.doubleIndexConfKey]\n                ? c[this.doubleIndexConfKey].url ||\n                    c[this.doubleIndexConfKey].blob.name\n                : c[this.doubleIndexUrlConfKey],\n              this.doubleIndexExtensionMap,\n            ) == basename\n          ) {\n            // it's a match, put it in\n            c[this.fileConfKey] = this._makeBlob(resource)\n            return true\n          }\n        }\n        // otherwise make a new store config for it\n        var newName = this.name + '_' + basename + '_' + uniqCounter++\n        configs[newName] = {\n          type: this.storeType,\n          name: newName,\n          fileBasename: basename,\n        }\n        configs[newName][this.fileConfKey] = this._makeBlob(resource)\n\n        return true\n      } else if (resource.type == this.indexExtension) {\n        var basename = Util.basename(\n          resource.file ? resource.file.name : resource.url ? resource.url : '',\n          this.indexExtensionMap,\n        )\n        if (!basename) {return false}\n\n        for (var n in configs) {\n          var c = configs[n]\n          if (\n            Util.basename(\n              c[this.fileConfKey]\n                ? c[this.fileConfKey].url || c[this.fileConfKey].blob.name\n                : c[this.fileConfKey],\n              this.fileExtensionMap,\n            ) == basename ||\n            Util.basename(\n              c[this.doubleIndexConfKey]\n                ? c[this.doubleIndexConfKey].url ||\n                    c[this.doubleIndexConfKey].blob.name\n                : c[this.doubleIndexUrlConfKey],\n              this.doubleIndexExtensionMap,\n            ) == basename\n          ) {\n            // it's a match, put it in\n            c[this.indexConfKey] = this._makeBlob(resource)\n            return true\n          }\n        }\n\n        // otherwise make a new store\n        var newName =\n          this.name +\n          '_' +\n          Util.basename(basename, '.' + this.fileExtension) +\n          '_' +\n          uniqCounter++\n        configs[newName] = {\n          name: newName,\n          type: this.storeType,\n        }\n\n        configs[newName][this.indexConfKey] = this._makeBlob(resource)\n        return true\n      } else if (resource.type == this.doubleIndexExtension) {\n        var basename = Util.basename(\n          resource.file ? resource.file.name : resource.url ? resource.url : '',\n          this.doubleIndexExtensionMap,\n        )\n        if (!basename) {return false}\n\n        for (var n in configs) {\n          var c = configs[n]\n          if (\n            Util.basename(\n              c[this.fileConfKey]\n                ? c[this.fileConfKey].url || c[this.fileConfKey].blob.name\n                : c[this.fileConfKey],\n              this.fileExtensionMap,\n            ) == basename ||\n            Util.basename(\n              c[this.indexConfKey]\n                ? c[this.indexConfKey].url || c[this.indexConfKey].blob.name\n                : c[this.indexUrlConfKey],\n              this.indexExtensionMap,\n            ) == basename\n          ) {\n            // it's a match, put it in\n            c[this.doubleIndexConfKey] = this._makeBlob(resource)\n            return true\n          }\n        }\n\n        // otherwise make a new store\n        var newName =\n          this.name +\n          '_' +\n          Util.basename(basename, '.' + this.fileExtension) +\n          '_' +\n          uniqCounter++\n        configs[newName] = {\n          name: newName,\n          type: this.storeType,\n        }\n\n        configs[newName][this.doubleIndexConfKey] = this._makeBlob(resource)\n        return true\n      } else {return false}\n    },\n\n    // try to merge any singleton file and index stores.  currently can only do this if there is one of each\n    finalizeConfiguration: function (configs) {\n      for (var n in configs) {\n        var conf = configs[n]\n        if (conf.type === this.storeType) {\n          var v1 = conf[this.indexConfKey] || conf[this.indexUrlConfKey]\n          var v2 = conf[this.fileConfKey] || conf[this.fileUrlConfKey]\n          var v3 =\n            conf[this.doubleIndexConfKey] || conf[this.doubleIndexUrlConfKey]\n          if (!(v1 && v2 && v3)) {\n            delete configs[n]\n          }\n        }\n      }\n    },\n\n    _makeBlob: function (resource) {\n      var r = resource.file\n        ? new FileBlob(resource.file)\n        : resource.url\n          ? new XHRBlob(resource.url)\n          : null\n      if (!r) {throw 'unknown resource type'}\n      return r\n    },\n\n    confIsValid: function (conf) {\n      return (\n        (conf[this.fileConfKey] || conf[this.fileUrlConfKey]) &&\n        (conf[this.indexConfKey] || conf[this.indexUrlConfKey]) &&\n        (conf[this.doubleIndexConfKey] || conf[this.doubleIndexUrlConfKey])\n      )\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/FileDialog/TrackList/BigBedDriver.js":{"size":1204,"mtime":1738905962695,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/FileDialog/TrackList/BigBedDriver.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'JBrowse/Util',\n  'JBrowse/Model/FileBlob',\n  'JBrowse/Model/XHRBlob',\n], function (declare, Util, FileBlob, XHRBlob) {\n  var uniqCounter = 0\n  return declare(null, {\n    storeType: 'JBrowse/Store/SeqFeature/BigBed',\n\n    tryResource: function (configs, resource) {\n      if (resource.type == 'bb') {\n        var basename = Util.basename(\n          resource.file ? resource.file.name : resource.url ? resource.url : '',\n          ['.bb'],\n        )\n        if (!basename) {return false}\n\n        var newName = 'BigBed_' + basename + '_' + uniqCounter++\n        configs[newName] = {\n          type: this.storeType,\n          fileBasename: basename,\n          blob: this._makeBlob(resource),\n          name: newName,\n        }\n        return true\n      } else {return false}\n    },\n\n    finalizeConfiguration: function (configs) {},\n\n    _makeBlob: function (resource) {\n      var r = resource.file\n        ? new FileBlob(resource.file)\n        : resource.url\n          ? new XHRBlob(resource.url)\n          : null\n      if (!r) {throw 'unknown resource type'}\n      return r\n    },\n\n    confIsValid: function (conf) {\n      return conf.blob || conf.urlTemplate\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/FileDialog/TrackList/BigWigDriver.js":{"size":1325,"mtime":1738905962699,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/FileDialog/TrackList/BigWigDriver.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'JBrowse/Util',\n  'JBrowse/Model/FileBlob',\n  'JBrowse/Model/XHRBlob',\n], function (declare, Util, FileBlob, XHRBlob) {\n  var uniqCounter = 0\n  return declare(null, {\n    storeType: 'JBrowse/Store/SeqFeature/BigWig',\n\n    tryResource: function (configs, resource) {\n      if (resource.type == 'bigwig') {\n        var basename = Util.basename(\n          resource.file ? resource.file.name : resource.url ? resource.url : '',\n          ['.bw', '.bigwig'],\n        )\n        if (!basename) {return false}\n\n        var newName = 'BigWig_' + basename + '_' + uniqCounter++\n        configs[newName] = {\n          fileBasename: basename,\n          type: this.storeType,\n          blob: this._makeBlob(resource),\n          name: newName,\n        }\n        return true\n      } else {return false}\n    },\n\n    // try to merge any singleton BAM and BAI stores.  currently can only do this if there is one of each\n    finalizeConfiguration: function (configs) {},\n\n    _makeBlob: function (resource) {\n      var r = resource.file\n        ? new FileBlob(resource.file)\n        : resource.url\n          ? new XHRBlob(resource.url)\n          : null\n      if (!r) {throw 'unknown resource type'}\n      return r\n    },\n\n    confIsValid: function (conf) {\n      return conf.blob || conf.urlTemplate\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/FileDialog/TrackList/ChromSizesDriver.js":{"size":1217,"mtime":1738905962702,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/FileDialog/TrackList/ChromSizesDriver.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'JBrowse/Util',\n  'JBrowse/Model/FileBlob',\n  'JBrowse/Model/XHRBlob',\n], function (declare, Util, FileBlob, XHRBlob) {\n  var uniqCounter = 0\n  return declare(null, {\n    storeType: 'JBrowse/Store/SeqFeature/ChromSizes',\n\n    tryResource: function (configs, resource) {\n      if (resource.type == 'chrom.sizes') {\n        var basename = Util.basename(\n          resource.file ? resource.file.name : resource.url ? resource.url : '',\n          ['.sizes'],\n        )\n        if (!basename) {return false}\n\n        var newName = 'REF_' + basename + '_' + uniqCounter++\n        configs[newName] = {\n          type: this.storeType,\n          fileBasename: basename,\n          blob: this._makeBlob(resource),\n          name: newName,\n        }\n        return true\n      } else {return false}\n    },\n\n    finalizeConfiguration: function (configs) {},\n\n    _makeBlob: function (resource) {\n      var r = resource.file\n        ? new FileBlob(resource.file)\n        : resource.url\n          ? new XHRBlob(resource.url)\n          : null\n      if (!r) {throw 'unknown resource type'}\n      return r\n    },\n\n    confIsValid: function (conf) {\n      return conf.blob || conf.urlTemplate\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/FileDialog/TrackList/CRAMDriver.js":{"size":402,"mtime":1738905962704,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/FileDialog/TrackList/CRAMDriver.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/FileDialog/TrackList/GFF3Driver.js":{"size":1212,"mtime":1738905962707,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/FileDialog/TrackList/GFF3Driver.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'JBrowse/Util',\n  'JBrowse/Model/FileBlob',\n  'JBrowse/Model/XHRBlob',\n], function (declare, Util, FileBlob, XHRBlob) {\n  var uniqCounter = 0\n  return declare(null, {\n    storeType: 'JBrowse/Store/SeqFeature/GFF3',\n\n    tryResource: function (configs, resource) {\n      if (resource.type == 'gff3') {\n        var basename = Util.basename(\n          resource.file ? resource.file.name : resource.url ? resource.url : '',\n          ['.gff3', '.gff'],\n        )\n        if (!basename) {return false}\n\n        var newName = 'GFF3_' + basename + '_' + uniqCounter++\n        configs[newName] = {\n          type: this.storeType,\n          fileBasename: basename,\n          blob: this._makeBlob(resource),\n          name: newName,\n        }\n        return true\n      } else {return false}\n    },\n\n    finalizeConfiguration: function (configs) {},\n\n    _makeBlob: function (resource) {\n      var r = resource.file\n        ? new FileBlob(resource.file)\n        : resource.url\n          ? new XHRBlob(resource.url)\n          : null\n      if (!r) {throw 'unknown resource type'}\n      return r\n    },\n\n    confIsValid: function (conf) {\n      return conf.blob || conf.urlTemplate\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/FileDialog/TrackList/GFF3TabixDriver.js":{"size":779,"mtime":1738905962710,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/FileDialog/TrackList/GFF3TabixDriver.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/FileDialog/TrackList/GTFDriver.js":{"size":1252,"mtime":1738905962714,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/FileDialog/TrackList/GTFDriver.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'JBrowse/Util',\n  'JBrowse/Model/FileBlob',\n  'JBrowse/Model/XHRBlob',\n], function (declare, Util, FileBlob, XHRBlob) {\n  var uniqCounter = 0\n  return declare(null, {\n    storeType: 'JBrowse/Store/SeqFeature/GTF',\n\n    tryResource: function (configs, resource) {\n      if (resource.type == 'gtf') {\n        var basename = Util.basename(\n          resource.file ? resource.file.name : resource.url ? resource.url : '',\n        )\n        if (!basename) {return false}\n\n        var newName = 'GTF_' + basename + '_' + uniqCounter++\n        configs[newName] = {\n          type: this.storeType,\n          blob: this._makeBlob(resource),\n          name: newName,\n        }\n        return true\n      } else {return false}\n    },\n\n    // try to merge any singleton BAM and BAI stores.  currently can only do this if there is one of each\n    finalizeConfiguration: function (configs) {},\n\n    _makeBlob: function (resource) {\n      var r = resource.file\n        ? new FileBlob(resource.file)\n        : resource.url\n          ? new XHRBlob(resource.url)\n          : null\n      if (!r) {throw 'unknown resource type'}\n      return r\n    },\n\n    confIsValid: function (conf) {\n      return conf.blob || conf.urlTemplate\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/FileDialog/TrackList/IndexedFASTADriver.js":{"size":502,"mtime":1738905962717,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/FileDialog/TrackList/IndexedFASTADriver.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/FileDialog/TrackList/TwoBitDriver.js":{"size":1314,"mtime":1738905962720,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/FileDialog/TrackList/TwoBitDriver.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'JBrowse/Util',\n  'JBrowse/Model/FileBlob',\n  'JBrowse/Model/XHRBlob',\n], function (declare, Util, FileBlob, XHRBlob) {\n  var uniqCounter = 0\n  return declare(null, {\n    storeType: 'JBrowse/Store/SeqFeature/TwoBit',\n\n    tryResource: function (configs, resource) {\n      if (resource.type == '2bit') {\n        var basename = Util.basename(\n          resource.file ? resource.file.name : resource.url ? resource.url : '',\n          ['.2bit'],\n        )\n        if (!basename) {return false}\n\n        var newName = 'TwoBit_' + basename + '_' + uniqCounter++\n        configs[newName] = {\n          fileBasename: basename,\n          type: this.storeType,\n          blob: this._makeBlob(resource),\n          name: newName,\n        }\n        return true\n      } else {return false}\n    },\n\n    // try to merge any singleton BAM and BAI stores.  currently can only do this if there is one of each\n    finalizeConfiguration: function (configs) {},\n\n    _makeBlob: function (resource) {\n      var r = resource.file\n        ? new FileBlob(resource.file)\n        : resource.url\n          ? new XHRBlob(resource.url)\n          : null\n      if (!r) {throw 'unknown resource type'}\n      return r\n    },\n\n    confIsValid: function (conf) {\n      return conf.blob || conf.urlTemplate\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/FileDialog/TrackList/VCFTabixDriver.js":{"size":608,"mtime":1738905962722,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/FileDialog/TrackList/VCFTabixDriver.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/FileDialog/TrackList/VCFTribbleDriver.js":{"size":402,"mtime":1738905962724,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/FileDialog/TrackList/VCFTribbleDriver.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/GranularRectLayout.js":{"size":13107,"mtime":1738905962740,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/GranularRectLayout.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"/**\n * Rectangle-layout manager that lays out rectangles using bitmaps at\n * resolution that, for efficiency, may be somewhat lower than that of\n * the coordinate system for the rectangles being laid out.  `pitchX`\n * and `pitchY` are the ratios of input scale resolution to internal\n * bitmap resolution.\n */\n\n// minimum excess size of the array at which we garbage collect\nconst minSizeToBotherWith = 10000\nconst maxFeaturePitchWidth = 20000\n\n// a single row in the layout\nclass LayoutRow {\n  constructor(rowNumber) {\n    this.rowNumber = rowNumber\n    this.padding = 1\n    this.sizeLimit = 1000000\n\n    // this.offset is the offset of the bits array relative to the genomic coordinates\n    //      (modified by pitchX, but we don't know that in this class)\n    // this.bits is the array of items in the layout row, indexed by (x - this.offset)\n    // this.min is the leftmost edge of all the rectangles we have in the layout\n    // this.max is the rightmost edge of all the rectangles we have in the layout\n  }\n\n  log(msg) {\n    //if (this.rowNumber === 0)\n    console.log(`r${this.rowNumber}: ${msg}`)\n  }\n\n  setAllFilled(data) {\n    this.allFilled = data\n  }\n\n  getItemAt(x) {\n    if (this.allFilled) {return this.allFilled}\n    // return (\n    //     this.min !== undefined &&\n    //     x >= this.min &&\n    //     x <= this.max &&\n    //     this.bits[x - this.min]\n    // )\n\n    if (this.min === undefined) {return undefined}\n    if (x < this.min) {return undefined}\n    if (x >= this.max) {return undefined}\n    const offset = x - this.offset\n    // if (offset < 0)\n    //     debugger\n    // if (offset >= this.bits.length)\n    //     debugger\n    return this.bits[offset]\n  }\n\n  isRangeClear(left, right) {\n    if (this.allFilled) {return false}\n\n    if (this.min === undefined) {return true}\n\n    if (right <= this.min || left >= this.max) {return true}\n\n    // TODO: check right and middle before looping\n    const maxX = Math.min(this.max, right)\n    let x = Math.max(this.min, left)\n    for (; x < right && x < maxX; x += 1) {if (this.getItemAt(x)) {return false}}\n\n    return true\n  }\n\n  initialize(left, right) {\n    // NOTE: this.min, this.max, and this.offset are interbase coordinates\n    const rectWidth = right - left\n    this.offset = left - rectWidth\n    this.min = left\n    this.max = right\n    this.bits = new Array(right - left + 2 * rectWidth)\n    // this.log(`initialize ${this.min} - ${this.max} (${this.bits.length})`)\n  }\n\n  addRect(rect, data) {\n    const left = rect.l\n    const right = rect.r + this.padding // only padding on the right\n\n    // initialize if necessary\n    if (this.min === undefined) {\n      this.initialize(left, right)\n    } else {\n      // or check if we need to expand to the left and/or to the right\n\n      // expand rightward by the feature length + whole current length if necessary\n      const currLength = this.bits.length\n\n      if (right - this.offset >= this.bits.length) {\n        const additionalLength =\n          right - this.offset - this.bits.length + 1 + this.bits.length\n        if (this.bits.length + additionalLength > this.sizeLimit) {\n          console.warn(\n            `Layout width limit exceeded, discarding old layout. Please be more careful about discarding unused blocks.`,\n          )\n          this.initialize(left, right)\n        } else if (additionalLength > 0) {\n          this.bits = this.bits.concat(new Array(additionalLength))\n          // this.log(`expand right (${additionalLength}): ${this.offset} | ${this.min} - ${this.max}`)\n        }\n      }\n\n      // expand by 2x leftward if necessary\n      if (left < this.offset) {\n        const additionalLength = this.offset - left + currLength\n        if (this.bits.length + additionalLength > this.sizeLimit) {\n          console.warn(\n            `Layout width limit exceeded, discarding old layout. Please be more careful about discarding unused blocks.`,\n          )\n          this.initialize(left, right)\n        } else {\n          this.bits = new Array(additionalLength).concat(this.bits)\n          this.offset -= additionalLength\n          // this.log(`expand left (${additionalLength}): ${this.offset} | ${this.min} - ${this.max}`)\n        }\n      }\n    }\n\n    // set the bits in the bitmask\n    const oLeft = left - this.offset\n    const oRight = right - this.offset\n    // if (oLeft < 0) debugger\n    // if (oRight < 0) debugger\n    // if (oRight <= oLeft) debugger\n    // if (oRight > this.bits.length) debugger\n    if (oRight - oLeft > maxFeaturePitchWidth) {\n      console.warn(\n        `Layout X pitch set too low, feature spans ${oRight - oLeft} bits in a single row.`,\n        rect,\n        data,\n      )\n    }\n\n    for (let x = oLeft; x < oRight; x += 1) {\n      //if (this.bits[x] && this.bits[x].get('name') !== data.get('name')) debugger\n      this.bits[x] = data\n    }\n\n    if (left < this.min) {this.min = left}\n    if (right > this.max) {this.max = right}\n    //// this.log(`added ${leftX} - ${rightX}`)\n  }\n\n  /**\n   *  Given a range of interbase coordinates, deletes all data dealing with that range\n   */\n  discardRange(left, right) {\n    if (this.allFilled) {return} // allFilled is irrevocable currently\n\n    // if we have no data, do nothing\n    if (!this.bits) {return}\n\n    // if doesn't overlap at all, do nothing\n    if (right <= this.min || left >= this.max) {return}\n\n    // if completely encloses range, discard everything\n    if (left <= this.min && right >= this.max) {\n      this.min = undefined\n      this.max = undefined\n      this.bits = undefined\n      this.offset = undefined\n      return\n    }\n\n    // if overlaps left edge, adjust the min\n    if (right > this.min && left <= this.min) {\n      this.min = right\n    }\n\n    // if overlaps right edge, adjust the max\n    if (left < this.max && right >= this.max) {\n      this.max = left\n    }\n\n    // now trim the left, right, or both sides of the array\n    if (\n      this.offset < this.min - minSizeToBotherWith &&\n      this.bits.length > this.max + minSizeToBotherWith - this.offset\n    ) {\n      // trim both sides\n      const leftTrimAmount = this.min - this.offset\n      const rightTrimAmount = this.bits.length - 1 - (this.max - this.offset)\n      // if (rightTrimAmount <= 0) debugger\n      // if (leftTrimAmount <= 0) debugger\n      // this.log(`trim both sides, ${leftTrimAmount} from left, ${rightTrimAmount} from right`)\n      this.bits = this.bits.slice(\n        leftTrimAmount,\n        this.bits.length - rightTrimAmount,\n      )\n      this.offset += leftTrimAmount\n      // if (this.offset > this.min) debugger\n      // if (this.bits.length <= this.max - this.offset) debugger\n    } else if (this.offset < this.min - minSizeToBotherWith) {\n      // trim left side\n      const desiredOffset = this.min - Math.floor(minSizeToBotherWith / 2)\n      const trimAmount = desiredOffset - this.offset\n      // this.log(`trim left side by ${trimAmount}`)\n      this.bits.splice(0, trimAmount)\n      this.offset += trimAmount\n      // if (this.offset > this.min) debugger\n      // if (this.bits.length <= this.max - this.offset) debugger\n    } else if (\n      this.bits.length >\n      this.max - this.offset + minSizeToBotherWith\n    ) {\n      // trim right side\n      const desiredLength =\n        this.max - this.offset + 1 + Math.floor(minSizeToBotherWith / 2)\n      // this.log(`trim right side by ${this.bits.length-desiredLength}`)\n      // if (desiredLength > this.bits.length) debugger\n      this.bits.length = desiredLength\n      // if (this.offset > this.min) debugger\n      // if (this.bits.length <= this.max - this.offset) debugger\n    }\n\n    // if (this.offset > this.min) debugger\n    // if (this.bits.length <= this.max - this.offset) debugger\n\n    // if range now enclosed in the new bounds, loop through and clear the bits\n    const oLeft = Math.max(this.min, left) - this.offset\n    // if (oLeft < 0) debugger\n    // if (oLeft >= this.bits.length) debugger\n    // if (oRight < 0) debugger\n    // if (oRight >= this.bits.length) debugger\n\n    const oRight = Math.min(right, this.max) - this.offset\n    for (let x = oLeft; x >= 0 && x < oRight; x += 1) {\n      this.bits[x] = undefined\n    }\n  }\n}\n\ndefine(['dojo/_base/declare'], declare =>\n  declare(null, {\n    /**\n     * @param args.pitchX  layout grid pitch in the X direction\n     * @param args.pitchY  layout grid pitch in the Y direction\n     * @param args.maxHeight  maximum layout height, default Infinity (no max)\n     */\n    constructor(args) {\n      this.pitchX = args.pitchX || 10\n      this.pitchY = args.pitchY || 10\n\n      this.displayMode = args.displayMode\n\n      // reduce the pitchY to try and pack the features tighter\n      if (this.displayMode === 'compact') {\n        this.pitchY = Math.round(this.pitchY / 4) || 1\n        this.pitchX = Math.round(this.pitchX / 4) || 1\n      }\n\n      // console.log(`pitch: ${this.pitchX} / ${this.pitchY}`)\n\n      this.bitmap = []\n      this.rectangles = {}\n      this.maxHeight = Math.ceil((args.maxHeight || Infinity) / this.pitchY)\n      this.pTotalHeight = 0 // total height, in units of bitmap squares (px/pitchY)\n    },\n\n    /**\n     * @returns {Number} top position for the rect, or Null if laying out the rect would exceed maxHeight\n     */\n    addRect(id, left, right, height, data) {\n      // if we have already laid it out, return its layout\n      if (id in this.rectangles) {\n        const storedRec = this.rectangles[id]\n        if (storedRec.top === null) {return null}\n\n        // add it to the bitmap again, since that bitmap range may have been discarded\n        this._addRectToBitmap(storedRec, data)\n        return storedRec.top * this.pitchY\n      }\n\n      const pLeft = Math.floor(left / this.pitchX)\n      const pRight = Math.floor(right / this.pitchX)\n      const pHeight = Math.ceil(height / this.pitchY)\n\n      const midX = Math.floor((pLeft + pRight) / 2)\n      const rectangle = { id, l: pLeft, r: pRight, mX: midX, h: pHeight }\n      if (data) {rectangle.data = data}\n\n      const maxTop = this.maxHeight - pHeight\n      let top = 0\n      for (; top <= maxTop; top += 1) {\n        if (!this._collides(rectangle, top)) {break}\n      }\n\n      if (top > maxTop) {\n        rectangle.top = top = null\n        this.rectangles[id] = rectangle\n        this.pTotalHeight = Math.max(this.pTotalHeight || 0, top + pHeight)\n        return null\n      }\n      rectangle.top = top\n      this._addRectToBitmap(rectangle, data)\n      this.rectangles[id] = rectangle\n      this.pTotalHeight = Math.max(this.pTotalHeight || 0, top + pHeight)\n      // console.log(`G2 ${data.get('name')} ${top}`)\n      return top * this.pitchY\n    },\n\n    _collides(rect, top) {\n      if (this.displayMode === 'collapsed') {return false}\n\n      const bitmap = this.bitmap\n      // var mY = top + rect.h/2; // Y midpoint: ( top+height  + top ) / 2\n\n      // test exhaustively\n      const maxY = top + rect.h\n      for (let y = top; y < maxY; y += 1) {\n        const row = bitmap[y]\n        if (row && !row.isRangeClear(rect.l, rect.r)) {\n          return true\n        }\n      }\n\n      return false\n    },\n\n    /**\n     * make a subarray if it does not exist\n     * @private\n     */\n    _autovivifyRow(bitmap, y) {\n      let row = bitmap[y]\n      if (!row) {\n        row = new LayoutRow(y)\n        bitmap[y] = row\n      }\n      return row\n    },\n\n    _addRectToBitmap(rect, data) {\n      if (rect.top === null) {return}\n\n      data = data || true\n      const bitmap = this.bitmap\n      const av = this._autovivifyRow\n      const yEnd = rect.top + rect.h\n      if (rect.r - rect.l > maxFeaturePitchWidth) {\n        // the rect is very big in relation to the view size, just\n        // pretend, for the purposes of layout, that it extends\n        // infinitely.  this will cause weird layout if a user\n        // scrolls manually for a very, very long time along the\n        // genome at the same zoom level.  but most users will not\n        // do that.  hopefully.\n        for (let y = rect.top; y < yEnd; y += 1) {\n          av(bitmap, y).setAllFilled(data)\n        }\n      } else {\n        for (let y = rect.top; y < yEnd; y += 1) {\n          av(bitmap, y).addRect(rect, data)\n        }\n      }\n    },\n\n    /**\n     *  Given a range of X coordinates, deletes all data dealing with\n     *  the features.\n     */\n    discardRange(left, right) {\n      // console.log( 'discard', left, right );\n      const pLeft = Math.floor(left / this.pitchX)\n      const pRight = Math.floor(right / this.pitchX)\n      const bitmap = this.bitmap\n      for (let y = 0; y < bitmap.length; y += 1) {\n        const row = bitmap[y]\n        if (row) {row.discardRange(pLeft, pRight)}\n      }\n    },\n\n    hasSeen(id) {\n      return !!this.rectangles[id]\n    },\n\n    getByCoord(x, y) {\n      const pY = Math.floor(y / this.pitchY)\n      const row = this.bitmap[pY]\n      if (!row) {return undefined}\n      const pX = Math.floor(x / this.pitchX)\n      return row.getItemAt(pX)\n    },\n\n    getByID(id) {\n      const r = this.rectangles[id]\n      if (r) {\n        return r.data || true\n      }\n      return undefined\n    },\n\n    cleanup() {},\n\n    getTotalHeight() {\n      return this.pTotalHeight * this.pitchY\n    },\n  }))\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/InfoDialog.js":{"size":1844,"mtime":1738905962744,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/InfoDialog.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'dojo/_base/array',\n  'dijit/focus',\n  'JBrowse/View/Dialog/WithActionBar',\n  'dojo/on',\n  'dijit/form/Button',\n], function (declare, array, focus, ActionBarDialog, on, dijitButton) {\n  return declare(\n    ActionBarDialog,\n\n    /**\n     * JBrowse ActionDialog subclass with a few customizations that make it\n     * more pleasant for use as an information popup.\n     * @lends JBrowse.View.InfoDialog\n     */\n    {\n      refocus: false,\n      autofocus: false,\n\n      _fillActionBar: function (actionBar) {\n        new dijitButton({\n          className: 'OK',\n          label: 'OK',\n          onClick: dojo.hitch(this, 'hide'),\n        }).placeAt(actionBar)\n      },\n\n      show: function () {\n        this.inherited(arguments)\n\n        var thisB = this\n\n        // holds the handles for the extra events we are registering\n        // so we can clean them up in the hide() method\n        this._extraEvents = []\n\n        // make it so that clicking outside the dialog (on the underlay) will close it\n        var underlay = ((dijit || {})._underlay || {}).domNode\n        if (underlay) {\n          this._extraEvents.push(\n            on(underlay, 'click', dojo.hitch(this, 'hideIfVisible')),\n          )\n        }\n\n        // also make ESCAPE or ENTER close the dialog box\n        this._extraEvents.push(\n          on(document.body, 'keydown', function (evt) {\n            if ([dojo.keys.ESCAPE, dojo.keys.ENTER].indexOf(evt.keyCode) >= 0)\n              {thisB.hideIfVisible()}\n          }),\n        )\n\n        focus.focus(this.closeButtonNode)\n      },\n\n      hideIfVisible: function () {\n        if (this.get('open')) {this.hide()}\n      },\n\n      hide: function () {\n        this.inherited(arguments)\n\n        array.forEach(this._extraEvents, function (e) {\n          e.remove()\n        })\n      },\n    },\n  )\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/LocationChoiceDialog.js":{"size":3592,"mtime":1738905962748,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/LocationChoiceDialog.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/LocationList.js":{"size":2782,"mtime":1738905962753,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/LocationList.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"/**\n * Generic component that displays a list of genomic locations, along\n * with buttons to execute actions on them.\n */\n\ndefine([\n  'dojo/_base/declare',\n  'dojo/_base/array',\n  'dojo/dom-construct',\n  'dijit/form/Button',\n  'JBrowse/Util',\n  'dstore/Memory',\n  'dgrid/OnDemandGrid',\n  'dgrid/extensions/DijitRegistry',\n], function (\n  declare,\n  array,\n  dom,\n  dijitButton,\n  Util,\n  MemoryStore,\n  DGrid,\n  DGridDijitRegistry,\n) {\n  var Grid = declare([DGrid, DGridDijitRegistry])\n\n  return declare(null, {\n    constructor: function (args, parent) {\n      var thisB = this\n      this.browser = args.browser\n\n      // transform our data first, so that it's sortable.\n      var locations = array.map(args.locations || [], function (l) {\n        return {\n          locstring: Util.assembleLocString(l),\n          location: l,\n          label: l.label || l.objectName,\n          description: l.description,\n          score: l.score,\n          tracks: array\n            .map(\n              array.filter(l.tracks || [], function (t) {\n                return t\n              }), // remove nulls\n              function (t) {\n                return t.key || t.name || t.label || t\n              },\n            )\n            .join(', '),\n        }\n      })\n\n      // build the column list\n      var columns = []\n      if (\n        array.some(locations, function (l) {\n          return l.label\n        })\n      )\n        {columns.unshift({ label: 'Name', field: 'label' })}\n      if (\n        array.some(locations, function (l) {\n          return l.description\n        })\n      )\n        {columns.unshift({ label: 'Description', field: 'description' })}\n      if (\n        array.some(locations, function (l) {\n          return l.score\n        })\n      )\n        {columns.unshift({ label: 'Score', field: 'score' })}\n      columns.push({ label: 'Location', field: 'locstring' })\n      if (locations.length && locations[0].tracks)\n        {columns.push({ label: 'Track', field: 'tracks' })}\n      if (args.buttons) {\n        columns.push({\n          label: '',\n          className: 'goButtonColumn',\n          renderCell: function (object, value, node, options) {\n            var container = dom.create('div')\n            array.forEach(args.buttons, function (button) {\n              var buttonArgs = dojo.mixin({}, button)\n              buttonArgs.onClick = function () {\n                button.onClick(object.location, value, node, options)\n              }\n              new dijitButton(buttonArgs).placeAt(container)\n            })\n            return container\n          },\n        })\n      }\n\n      // create the grid\n      this.grid = new Grid(\n        {\n          columns: columns,\n          collection: new MemoryStore({ data: locations }),\n        },\n        parent,\n      )\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/Ruler.js":{"size":2611,"mtime":1738905962806,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/Ruler.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/query',\n  'dojox/charting/Chart',\n  'dojox/charting/axis2d/Default',\n  'dojox/charting/plot2d/Bubble',\n  'dojo/NodeList-dom',\n  'dojo/number',\n], function (query, Chart) {\n  /**\n   * Ruler, with ticks and numbers, drawn with HTML elements. Can be\n   * stretched to any length.\n   *\n   * @class\n   * @constructor\n   *\n   * @param {Number} args.min\n   * @param {Number} args.max\n   * @param {String} [args.direction=\"up\"] The direction of increasing numbers.\n   *   Either \"up\" or \"down\".\n   * @param {Boolean} args.leftBottom=true Should the ticks and labels be on the right\n   * or the left.\n   *\n   */\n\n  function Ruler(args) {\n    dojo.mixin(this, args)\n  }\n\n  Ruler.prototype.render_to = function (target_div) {\n    if (typeof target_div == 'string') {target_div = dojo.byId(target_div)}\n\n    var target_dims = dojo.position(target_div)\n\n    // make an inner container that's styled to compensate for the\n    // 12px edge-padding that dojox.charting has builtin that we can't\n    // change, making the tick marks align correctly with the images\n    var label_digits = Math.floor(Math.log(this.max + 1) / Math.log(10)) + 1\n\n    var container = dojo.create(\n      'div',\n      {\n        style: {\n          position: 'absolute',\n          left: '-9px',\n          bottom: '-9px',\n          width: '10px',\n          height: target_dims.h + 18 + 'px',\n        },\n      },\n      target_div,\n    )\n\n    try {\n      var chart1 = new Chart(container, { fill: 'transparent' })\n      chart1.addAxis('y', {\n        vertical: true,\n        fill: 'transparent',\n        min: this.min,\n        max: this.max,\n        fixLower: this.fixBounds\n          ? typeof this.fixBounds == 'string'\n            ? this.fixBounds\n            : 'major'\n          : 'none',\n        fixUpper: this.fixBounds\n          ? typeof this.fixBounds == 'string'\n            ? this.fixBounds\n            : 'major'\n          : 'none',\n        leftBottom: this.leftBottom,\n        // minorTickStep: 0.5,\n        // majorTickStep: 1\n        //labels: [{value: 1, text: \"One\"}, {value: 3, text: \"Ten\"}]\n      })\n      chart1.addPlot('default', { type: 'Bubble', fill: 'transparent' })\n      chart1.render()\n\n      // hack to remove undesirable opaque white rectangles.  do\n      // this a little bit later\n      query('svg rect', chart1.domNode).orphan()\n\n      this.scaler = chart1.axes.y.scaler\n    } catch (x) {\n      console.error(x + '')\n      console.error(\n        'Failed to draw Ruler with SVG, your browser may not support the necessary technology.',\n      )\n      target_div.removeChild(container)\n    }\n  }\n\n  return Ruler\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/StandaloneDatasetList.js":{"size":923,"mtime":1738905962809,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/StandaloneDatasetList.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/Track/_AlignmentsMixin.js":{"size":15384,"mtime":1738905962828,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/Track/_AlignmentsMixin.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"/**\n * Mixin with methods used for displaying alignments and their mismatches.\n */\ndefine([\n  'dojo/_base/declare',\n  'dojo/_base/array',\n  'dojo/_base/lang',\n  'dojo/when',\n  'JBrowse/Util',\n  'JBrowse/Store/SeqFeature/_MismatchesMixin',\n  'JBrowse/View/Track/_NamedFeatureFiltersMixin',\n], function (\n  declare,\n  array,\n  lang,\n  when,\n  Util,\n  MismatchesMixin,\n  NamedFeatureFiltersMixin,\n) {\n  return declare([MismatchesMixin, NamedFeatureFiltersMixin], {\n    /**\n     * Make a default feature detail page for the given feature.\n     * @returns {HTMLElement} feature detail page HTML\n     */\n    defaultFeatureDetail: function (\n      /** JBrowse.Track */ track,\n      /** Object */ f,\n      /** HTMLElement */ div,\n    ) {\n      let container\n      if (f.pairedFeature() && track.config.viewAsPairs) {\n        container = dojo.create('div', {\n          className:\n            'detail feature-detail feature-detail-' +\n            track.name.replace(/\\s+/g, '_').toLowerCase(),\n          style: { width: '1000px' },\n        })\n        dojo.place('<div><h1>Paired read details</h1></div><br />', container)\n        var flexContainer = dojo.create(\n          'div',\n          {\n            className:\n              'detail feature-detail feature-detail-' +\n              track.name.replace(/\\s+/g, '_').toLowerCase(),\n            style: {\n              display: 'flex',\n              'flex-direction': 'row',\n            },\n          },\n          container,\n        )\n        var c1 = dojo.create(\n          'div',\n          { className: 'detail feature-detail' },\n          flexContainer,\n        )\n        var c2 = dojo.create(\n          'div',\n          { className: 'detail feature-detail' },\n          flexContainer,\n        )\n        var ret = this.defaultAlignmentDetail(track, f.read1, c1)\n        var ret2 = this.defaultAlignmentDetail(track, f.read2, c2)\n        dojo.place(ret, c1)\n        dojo.place(ret2, c2)\n        return container\n      } else {\n        container = this.defaultAlignmentDetail(track, f, div)\n      }\n      return container\n    },\n    defaultAlignmentDetail(track, f, div) {\n      var container = dojo.create('div', {\n        className:\n          'detail feature-detail feature-detail-' +\n          track.name.replace(/\\s+/g, '_').toLowerCase(),\n        innerHTML: '',\n      })\n      var fmt = dojo.hitch(this, function (name, value, feature, unsafe) {\n        name = Util.ucFirst(name.replace(/_/g, ' '))\n        return this.renderDetailField(\n          container,\n          name,\n          value,\n          feature,\n          null,\n          {},\n          unsafe,\n        )\n      })\n\n      this._renderCoreDetails(track, f, div, container)\n\n      if (f.get('seq')) {\n        fmt('Sequence and Quality', this._renderSeqQual(f), f, true)\n      }\n\n      var renameTags = { length_on_ref: 'seq_length_on_ref' }\n      var additionalTags = array\n        .filter(f.tags(), function (t) {\n          return !{\n            name: 1,\n            score: 1,\n            start: 1,\n            end: 1,\n            strand: 1,\n            note: 1,\n            subfeatures: 1,\n            type: 1,\n            cram_read_features: 1,\n          }[t.toLowerCase()]\n        })\n        .map(function (tagName) {\n          return [renameTags[tagName] || tagName, f.get(tagName)]\n        })\n        .sort(function (a, b) {\n          return a[0].localeCompare(b[0])\n        })\n\n      dojo.forEach(additionalTags, function (t) {\n        fmt(t[0], t[1], f)\n      })\n\n      // genotypes in a separate section\n      if (this.config.renderAlignment || this.config.renderPrettyAlignment) {\n        this._renderTable(container, track, f, div)\n      }\n\n      return container\n    },\n\n    // takes a feature, returns an HTML representation of its 'seq'\n    // and 'qual', if it has at least a seq. empty string otherwise.\n    _renderSeqQual: function (feature) {\n      var seq = feature.get('seq'),\n        qual = feature.get('qual') || ''\n      if (!seq) {return ''}\n\n      qual = qual.split(/\\s+/)\n\n      var html = ''\n      for (var i = 0; i < seq.length; i++) {\n        html +=\n          '<div class=\"basePosition\" title=\"position ' +\n          (i + 1) +\n          '\"><span class=\"seq\">' +\n          seq[i] +\n          '</span>'\n        if (qual[i]) {html += '<span class=\"qual\">' + qual[i] + '</span>'}\n        html += '</div>'\n      }\n      return '<div class=\"baseQuality\">' + html + '</div>'\n    },\n\n    // recursively find all the stylesheets that are loaded in the\n    // current browsing session, traversing imports and such\n    _getStyleSheets: function (inSheets) {\n      var outSheets = []\n      array.forEach(inSheets, sheet => {\n        try {\n          let rules = sheet.cssRules || sheet.rules\n          let includedSheets = [sheet]\n          array.forEach(rules, rule => {\n            if (rule.styleSheet)\n              {includedSheets.push(...this._getStyleSheets([rule.styleSheet]))}\n          })\n          outSheets.push(...includedSheets)\n        } catch (e) {\n          //console.warn('could not read stylesheet',sheet)\n        }\n      })\n\n      return outSheets\n    },\n\n    // get the appropriate HTML color string to use for a given base\n    // letter.  case insensitive.  'reference' gives the color to draw matches with the reference.\n    colorForBase: function (base) {\n      // get the base colors out of CSS\n      this._baseStyles =\n        this._baseStyles ||\n        function () {\n          var colors = {}\n          try {\n            var styleSheets = this._getStyleSheets(document.styleSheets)\n            array.forEach(styleSheets, function (sheet) {\n              // avoid modifying cssRules for plugins which generates SecurityException on Firefox\n              var classes = sheet.rules || sheet.cssRules\n              if (!classes) {return}\n              array.forEach(classes, function (c) {\n                var match = /^\\.jbrowse\\s+\\.base_([^\\s_]+)$/.exec(\n                  c.selectorText,\n                )\n                if (match && match[1]) {\n                  var base = match[1]\n                  match = /\\#[0-9a-f]{3,6}|(?:rgb|hsl)a?\\([^\\)]*\\)/gi.exec(\n                    c.cssText,\n                  )\n                  if (match && match[0]) {\n                    colors[base.toLowerCase()] = match[0]\n                    colors[base.toUpperCase()] = match[0]\n                  }\n                }\n              })\n            })\n          } catch (e) {\n            console.error(e)\n            /* catch errors from cross-domain stylesheets */\n          }\n\n          return colors\n        }.call(this)\n\n      return this._baseStyles[base] || '#999'\n    },\n\n    // filters for BAM alignments according to some flags\n    _getNamedFeatureFilters: function () {\n      return lang.mixin({}, this.inherited(arguments), {\n        hideDuplicateReads: {\n          desc: 'Hide PCR/Optical duplicate reads',\n          func: function (f) {\n            return !(f.get('duplicate') === true)\n          },\n        },\n        hideQCFailingReads: {\n          desc: 'Hide reads failing vendor QC',\n          func: function (f) {\n            return !(f.get('qc_failed') === true)\n          },\n        },\n        hideSecondary: {\n          desc: 'Hide secondary alignments',\n          func: function (f) {\n            return !(f.get('secondary_alignment') === true)\n          },\n        },\n        hideSupplementary: {\n          desc: 'Hide supplementary alignments',\n          func: function (f) {\n            return !(f.get('supplementary_alignment') === true)\n          },\n        },\n        hideMissingMatepairs: {\n          desc: 'Hide reads with missing mate pairs',\n          func: function (f) {\n            return !(\n              f.get('multi_segment_template') &&\n              f.get('multi_segment_next_segment_unmapped')\n            )\n          },\n        },\n        hideImproperPairs: {\n          desc: 'Hide reads that with improper pairs',\n          func: function (f) {\n            return !(\n              f.get('multi_segment_template') &&\n              !f.get('multi_segment_all_aligned')\n            )\n          },\n        },\n\n        hideUnmapped: {\n          desc: 'Hide unmapped reads',\n          func: function (f) {\n            return !(f.get('unmapped') === true)\n          },\n        },\n        hideForwardStrand: {\n          desc: 'Hide reads aligned to the forward strand',\n          func: function (f) {\n            return f.get('strand') !== 1\n          },\n        },\n        hideReverseStrand: {\n          desc: 'Hide reads aligned to the reverse strand',\n          func: function (f) {\n            return f.get('strand') !== -1\n          },\n        },\n        hideUnsplicedReads: {\n          desc: 'Hide unspliced reads',\n          func: function (f) {\n            return (f.get('cigar') || '').indexOf('N') != -1\n          },\n        },\n      })\n    },\n\n    _alignmentsFilterTrackMenuOptions: function () {\n      // add toggles for feature filters\n      var track = this\n      return when(this._getNamedFeatureFilters()).then(function (filters) {\n        return track._makeFeatureFilterTrackMenuItems(\n          [\n            'hideDuplicateReads',\n            'hideQCFailingReads',\n            'hideMissingMatepairs',\n            'hideImproperPairs',\n            'hideSecondary',\n            'hideSupplementary',\n            'hideUnmapped',\n            'SEPARATOR',\n            'hideForwardStrand',\n            'hideReverseStrand',\n            'hideUnsplicedReads',\n          ],\n          filters,\n        )\n      })\n    },\n\n    _renderTable: function (parentElement, track, feat, featDiv) {\n      var thisB = this\n\n      var mismatches = track._getMismatches(feat)\n      var seq = feat.get('seq')\n      if (!seq) {\n        var gContainer = dojo.create(\n          'div',\n          {\n            className: 'renderTable',\n            innerHTML:\n              '<h2 class=\"sectiontitle\">Matches</h2><div style=\\\"font-family: Courier; white-space: pre;\\\">' +\n              'No sequence on feature, cannot render alignment</div>',\n          },\n          parentElement,\n        )\n        return\n      }\n\n      var start = feat.get('start')\n      var query_str = '',\n        align_str = '',\n        refer_str = ''\n      var curr_mismatch = 0\n      var genome_pos = 0\n      var curr_pos = 0\n\n      mismatches.sort(function (a, b) {\n        return a.start - b.start\n      })\n      for (var i = 0; curr_pos < seq.length; i++) {\n        var f = false\n        var mismatchesAtCurrentPosition = []\n        for (var j = curr_mismatch; j < mismatches.length; j++) {\n          var mismatch = mismatches[j]\n          if (genome_pos == mismatch.start) {\n            mismatchesAtCurrentPosition.push(mismatch)\n          }\n        }\n\n        mismatchesAtCurrentPosition.sort(function (a, b) {\n          if (a.type == 'insertion') {return -1}\n          else if (a.type == 'deletion') {return 1}\n          else if (a.type == 'mismatch') {return 1}\n          else if (a.type == 'skip') {return 1}\n          else {return 0}\n        })\n\n        for (var k = 0; k < mismatchesAtCurrentPosition.length; k++) {\n          var mismatch = mismatchesAtCurrentPosition[k]\n          curr_mismatch++\n          if (mismatch.type == 'softclip') {\n            for (var l = 0; l < mismatch.cliplen; l++) {\n              query_str += seq[curr_pos + l]\n              align_str += ' '\n              refer_str += '.'\n            }\n            curr_pos += mismatch.cliplen\n            f = true\n          } else if (mismatch.type == 'insertion') {\n            for (var l = 0; l < +mismatch.base; l++) {\n              query_str += seq[curr_pos + l]\n              align_str += ' '\n              refer_str += '-'\n            }\n            curr_pos += +mismatch.base || mismatch.base.length\n            f = true\n          } else if (mismatch.type == 'deletion') {\n            for (var l = 0; l < mismatch.length; l++) {\n              query_str += '-'\n              align_str += ' '\n              refer_str += (mismatch.seq || {})[l] || '.'\n            }\n            genome_pos += mismatch.length\n            f = true\n          } else if (mismatch.type == 'skip') {\n            for (var l = 0; l < Math.min(mismatch.length, 10000); l++) {\n              query_str += '.'\n              align_str += ' '\n              refer_str += 'N'\n            }\n            genome_pos += mismatch.length\n            f = true\n          } else if (mismatch.type == 'mismatch') {\n            query_str += mismatch.base\n            align_str += ' '\n            refer_str += mismatch.altbase\n            curr_pos++\n            genome_pos++\n            f = true\n          }\n        }\n        if (!f) {\n          query_str += seq[curr_pos]\n          align_str += '|'\n          refer_str += seq[curr_pos]\n          genome_pos++\n          curr_pos++\n        }\n      }\n      if (this.config.renderPrettyAlignment) {\n        var s1, s2, s3, ret_str\n        s1 = s2 = s3 = ret_str = ''\n        var qpos = 0\n        var rpos =\n          mismatches.length && mismatches[0].type == 'softclip'\n            ? start - mismatches[0].cliplen\n            : start\n        var w = this.config.renderAlignmentWidth || 50\n        for (var i = 0; i < query_str.length; i += w) {\n          s1 = query_str.substring(i, i + w)\n          s2 = align_str.substring(i, i + w)\n          s3 = refer_str.substring(i, i + w)\n          var padding = rpos.toString().replace(/./g, ' ')\n          var offset1 = s1.length - (s1.match(/[-N\\.]/g) || []).length\n          var offset2 = s3.length - (s3.match(/[-]/g) || []).length\n          ret_str +=\n            'Query    ' +\n            this.pad(padding, qpos, true) +\n            ': ' +\n            s1 +\n            ' ' +\n            (qpos + offset1) +\n            '<br>'\n          ret_str += '         ' + padding + '  ' + s2 + '   <br>'\n          ret_str +=\n            'Ref:     ' +\n            rpos +\n            ': ' +\n            s3 +\n            ' ' +\n            (rpos + offset2) +\n            '  <br><br>'\n          qpos += offset1\n          rpos += offset2\n        }\n        var gContainer = dojo.create(\n          'div',\n          {\n            className: 'renderTable',\n            innerHTML:\n              '<h2 class=\"sectiontitle\">Matches</h2><div style=\\\"font-family: Courier; white-space: pre;\\\">' +\n              ret_str +\n              '</div>',\n          },\n          parentElement,\n        )\n      } else if (this.config.renderAlignment) {\n        var gContainer = dojo.create(\n          'div',\n          {\n            className: 'renderTable',\n            innerHTML:\n              '<h2 class=\"sectiontitle\">Matches</h2><div style=\\\"font-family: Courier; white-space: pre;\\\">' +\n              'Query: ' +\n              query_str +\n              '   <br>' +\n              '       ' +\n              align_str +\n              '   <br>' +\n              'Ref:   ' +\n              refer_str +\n              '   </div>',\n          },\n          parentElement,\n        )\n      }\n\n      return {\n        val1: query_str,\n        val2: align_str,\n        val3: refer_str,\n      }\n    },\n\n    //stackoverflow http://stackoverflow.com/questions/2686855/is-there-a-javascript-function-that-can-pad-a-string-to-get-to-a-determined-leng\n    pad: function (pad, str, padLeft) {\n      if (typeof str === 'undefined') {return pad}\n      if (padLeft) {\n        return (pad + str).slice(-pad.length)\n      } else {\n        return (str + pad).substring(0, pad.length)\n      }\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/Track/_ExportMixin.js":{"size":13780,"mtime":1738905962851,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/Track/_ExportMixin.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'dojo/_base/array',\n  'dojo/_base/lang',\n  'dojo/aspect',\n  'dojo/on',\n  'JBrowse/has',\n  'dojo/window',\n  'dojo/dom-construct',\n  'JBrowse/Util',\n  'dijit/form/TextBox',\n  'dijit/form/Button',\n  'dijit/form/RadioButton',\n  'dijit/Dialog',\n  'FileSaver/FileSaver',\n], function (\n  declare,\n  array,\n  lang,\n  aspect,\n  on,\n  has,\n  dojoWindow,\n  dom,\n  Util,\n  dijitTextBox,\n  dijitButton,\n  dijitRadioButton,\n  dijitDialog,\n  FileSaver,\n) {\n  /**\n   * Mixin for a track that can export its data.\n   * @lends JBrowse.View.Track.ExportMixin\n   */\n  return declare(null, {\n    _canSaveFiles: function () {\n      return has('save-generated-files') && !this.config.noExportFiles\n    },\n\n    _canExport: function () {\n      if (this.config.noExport) {return false}\n\n      var highlightedRegion = this.browser.getHighlight()\n      var visibleRegion = this.browser.view.visibleRegion()\n      var wholeRefSeqRegion = {\n        ref: this.refSeq.name,\n        start: this.refSeq.start,\n        end: this.refSeq.end,\n      }\n      var canExportVisibleRegion = this._canExportRegion(visibleRegion)\n      var canExportWholeRef = this._canExportRegion(wholeRefSeqRegion)\n      return (\n        (highlightedRegion && this._canExportRegion(highlightedRegion)) ||\n        this._canExportRegion(visibleRegion) ||\n        this._canExportRegion(wholeRefSeqRegion)\n      )\n    },\n\n    _possibleExportRegions: function () {\n      var regions = [\n        // the visible region\n        function () {\n          var r = dojo.clone(this.browser.view.visibleRegion())\n          r.description = 'Visible region'\n          r.name = 'visible'\n          return r\n        }.call(this),\n        // whole reference sequence\n        {\n          ref: this.refSeq.name,\n          start: this.refSeq.start,\n          end: this.refSeq.end,\n          description: 'Whole reference sequence',\n          name: 'wholeref',\n        },\n      ]\n\n      var highlightedRegion = this.browser.getHighlight()\n      if (highlightedRegion) {\n        const { start, end, ref } = highlightedRegion\n        regions.unshift({\n          start,\n          end,\n          ref,\n          description: 'Highlighted region',\n          name: 'highlight',\n        })\n      }\n\n      return regions\n    },\n\n    _exportDialogContent: function () {\n      // note that the `this` for this content function is not the track, it's the menu-rendering context\n      var possibleRegions = this.track._possibleExportRegions()\n\n      // for each region, calculate its length and determine whether we can export it\n      array.forEach(\n        possibleRegions,\n        function (region) {\n          region.length = Math.round(region.end - region.start + 1)\n          region.canExport = this._canExportRegion(region)\n        },\n        this.track,\n      )\n\n      var setFilenameValue = dojo.hitch(this.track, function () {\n        var region = this._readRadio(form.elements.region)\n        var format = nameToExtension[this._readRadio(form.elements.format)]\n        form.elements.filename.value =\n          ((this.key || this.label) + '-' + region).replace(\n            /[^ .a-zA-Z0-9_-]/g,\n            '-',\n          ) +\n          '.' +\n          format\n      })\n\n      var form = dom.create('form', {\n        onSubmit: function () {\n          return false\n        },\n      })\n      var regionFieldset = dom.create('fieldset', { className: 'region' }, form)\n      dom.create('legend', { innerHTML: 'Region to save' }, regionFieldset)\n\n      var checked = 0\n      array.forEach(possibleRegions, function (r) {\n        var locstring = Util.assembleLocString(r)\n        var regionButton = new dijitRadioButton({\n          name: 'region',\n          id: 'region_' + r.name,\n          value: locstring,\n          checked: r.canExport && !checked++ ? 'checked' : '',\n        })\n        regionFieldset.appendChild(regionButton.domNode)\n        var regionButtonLabel = dom.create(\n          'label',\n          {\n            for: regionButton.id,\n            innerHTML:\n              r.description +\n              ' - <span class=\"locString\">' +\n              locstring +\n              '</span> (' +\n              Util.humanReadableNumber(r.length) +\n              (r.canExport ? 'b' : 'b, too large') +\n              ')',\n          },\n          regionFieldset,\n        )\n        if (!r.canExport) {\n          regionButton.domNode.disabled = 'disabled'\n          regionButtonLabel.className = 'ghosted'\n        }\n\n        on(regionButton, 'click', setFilenameValue)\n\n        dom.create('br', {}, regionFieldset)\n      })\n\n      var formatFieldset = dom.create('fieldset', { className: 'format' }, form)\n      dom.create('legend', { innerHTML: 'Format' }, formatFieldset)\n\n      checked = 0\n      var nameToExtension = {}\n      array.forEach(\n        this.track._exportFormats(),\n        function (fmt) {\n          if (!fmt.name) {\n            fmt = { name: fmt, label: fmt }\n          }\n          if (!fmt.fileExt) {\n            fmt.fileExt = fmt.name || fmt\n          }\n          nameToExtension[fmt.name] = fmt.fileExt\n          var formatButton = new dijitRadioButton({\n            name: 'format',\n            id: 'format' + fmt.name,\n            value: fmt.name,\n            checked: checked++ ? '' : 'checked',\n          })\n          formatFieldset.appendChild(formatButton.domNode)\n          var formatButtonLabel = dom.create(\n            'label',\n            { for: formatButton.id, innerHTML: fmt.label },\n            formatFieldset,\n          )\n\n          on(formatButton, 'click', setFilenameValue)\n          dom.create('br', {}, formatFieldset)\n        },\n        this,\n      )\n\n      var filenameFieldset = dom.create(\n        'fieldset',\n        { className: 'filename' },\n        form,\n      )\n      dom.create('legend', { innerHTML: 'Filename' }, filenameFieldset)\n      dom.create(\n        'input',\n        { type: 'text', name: 'filename', style: { width: '100%' } },\n        filenameFieldset,\n      )\n\n      setFilenameValue()\n\n      var actionBar = dom.create('div', {\n        className: 'dijitDialogPaneActionBar',\n      })\n\n      // note that the `this` for this content function is not the track, it's the menu-rendering context\n      var dialog = this.dialog\n\n      new dijitButton({\n        iconClass: 'dijitIconDelete',\n        onClick: dojo.hitch(dialog, 'hide'),\n        label: 'Cancel',\n      }).placeAt(actionBar)\n      var viewButton = new dijitButton({\n        iconClass: 'dijitIconTask',\n        label: 'View',\n        disabled: !array.some(possibleRegions, function (r) {\n          return r.canExport\n        }),\n        onClick: lang.partial(\n          this.track._exportViewButtonClicked,\n          this.track,\n          form,\n          dialog,\n        ),\n      }).placeAt(actionBar)\n\n      // don't show a download button if we for some reason can't save files\n      if (this.track._canSaveFiles()) {\n        var dlButton = new dijitButton({\n          iconClass: 'dijitIconSave',\n          label: 'Save',\n          disabled: !array.some(possibleRegions, function (r) {\n            return r.canExport\n          }),\n          onClick: dojo.hitch(this.track, function () {\n            var format = this._readRadio(form.elements.format)\n            var region = this._readRadio(form.elements.region)\n            var filename = form.elements.filename.value.replace(\n              /[^ .a-zA-Z0-9_-]/g,\n              '-',\n            )\n            dlButton.set('disabled', true)\n            dlButton.set('iconClass', 'jbrowseIconBusy')\n            this.exportRegion(\n              region,\n              format,\n              dojo.hitch(this, function (output) {\n                dialog.hide()\n                this._fileDownload({\n                  format: format,\n                  data: output,\n                  filename: filename,\n                })\n              }),\n            )\n          }),\n        }).placeAt(actionBar)\n      }\n\n      return [form, actionBar]\n    },\n\n    // run when the 'View' button is clicked in the export dialog\n    _exportViewButtonClicked: function (track, form, dialog) {\n      var viewButton = this\n      viewButton.set('disabled', true)\n      viewButton.set('iconClass', 'jbrowseIconBusy')\n\n      var region = track._readRadio(form.elements.region)\n      var format = track._readRadio(form.elements.format)\n      var filename = form.elements.filename.value.replace(\n        /[^ .a-zA-Z0-9_-]/g,\n        '-',\n      )\n      track.exportRegion(region, format, function (output) {\n        dialog.hide()\n        var text = dom.create('textarea', {\n          rows: Math.round((dojoWindow.getBox().h / 12) * 0.5),\n          wrap: 'off',\n          cols: 80,\n          style:\n            'maxWidth: 90em; overflow: scroll; overflow-y: scroll; overflow-x: scroll; overflow:-moz-scrollbars-vertical;',\n          readonly: true,\n        })\n        text.value = output\n        var actionBar = dom.create('div', {\n          className: 'dijitDialogPaneActionBar',\n        })\n        var exportView = new dijitDialog({\n          className: 'export-view-dialog',\n          title:\n            format +\n            ' export - <span class=\"locString\">' +\n            region +\n            '</span> (' +\n            Util.humanReadableNumber(output.length) +\n            'bytes)',\n          content: [text, actionBar],\n        })\n        new dijitButton({\n          iconClass: 'dijitIconDelete',\n          label: 'Close',\n          onClick: dojo.hitch(exportView, 'hide'),\n        }).placeAt(actionBar)\n\n        // only show a button if the browser can save files\n        if (track._canSaveFiles()) {\n          var saveDiv = dom.create('div', { className: 'save' }, actionBar)\n\n          var saveButton = new dijitButton({\n            iconClass: 'dijitIconSave',\n            label: 'Save',\n            onClick: function () {\n              var filename = fileNameText\n                .get('value')\n                .replace(/[^ .a-zA-Z0-9_-]/g, '-')\n              exportView.hide()\n              track._fileDownload({\n                format: format,\n                data: output,\n                filename: filename,\n              })\n            },\n          }).placeAt(saveDiv)\n          var fileNameText = new dijitTextBox({\n            value: filename,\n            style: 'width: 24em',\n          }).placeAt(saveDiv)\n        }\n\n        aspect.after(exportView, 'hide', function () {\n          // manually unhook and free the (possibly huge) text area\n          text.parentNode.removeChild(text)\n          text = null\n          setTimeout(function () {\n            exportView.destroyRecursive()\n          }, 500)\n        })\n        exportView.show()\n      })\n    },\n\n    _fileDownload: function (args) {\n      FileSaver.saveAs(\n        new Blob([args.data], {\n          type: args.format\n            ? 'application/x-' + args.format.toLowerCase()\n            : 'text/plain',\n        }),\n        args.filename,\n      )\n      // We will need to check whether this breaks the WebApollo plugin.\n    },\n\n    // cross-platform function for (portably) reading the value of a radio control. sigh. *rolls eyes*\n    _readRadio: function (r) {\n      if (r.length) {\n        for (var i = 0; i < r.length; i++) {\n          if (r[i].checked) {return r[i].value}\n        }\n      }\n      return r.value\n    },\n\n    exportRegion: function (region, format, callback) {\n      // parse the locstring if necessary\n      if (typeof region == 'string') {region = Util.parseLocString(region)}\n\n      // we can only export from the currently-visible reference\n      // sequence right now\n      if (region.ref != this.refSeq.name) {\n        console.error(\n          'cannot export data for ref seq ' +\n            region.ref +\n            ', ' +\n            'exporting is currently only supported for the ' +\n            'currently-visible reference sequence',\n        )\n        return\n      }\n\n      dojo.global.require(\n        [format.match(/\\//) ? format : 'JBrowse/View/Export/' + format],\n        dojo.hitch(this, function (exportDriver) {\n          new exportDriver({\n            refSeq: this.refSeq,\n            track: this,\n            store: this.store,\n          }).exportRegion(region, callback)\n        }),\n      )\n    },\n\n    _trackMenuOptions: function () {\n      var opts = this.inherited(arguments)\n\n      if (!this.config.noExport)\n        // add a \"Save track data as\" option to the track menu\n        {opts.push({\n          label: 'Save track data',\n          iconClass: 'dijitIconSave',\n          disabled: !this._canExport(),\n          action: 'bareDialog',\n          content: this._exportDialogContent,\n          dialog: { id: 'exportDialog', className: 'export-dialog' },\n        })}\n\n      return opts\n    },\n\n    _canExportRegion: function (l) {\n      //console.log('can generic export?');\n      if (!l) {return false}\n\n      // if we have a maxExportSpan configured for this track, use it.\n      if (\n        typeof this.config.maxExportSpan == 'number' ||\n        typeof this.config.maxExportSpan == 'string'\n      ) {\n        return l.end - l.start + 1 <= this.config.maxExportSpan\n      } else {\n        // if we know the store's feature density, then use that with\n        // a limit of maxExportFeatures or 5,000 features\n        var thisB = this\n        var storeStats = {}\n        // will return immediately if the stats are available\n        this.store.getGlobalStats(\n          function (s) {\n            storeStats = s\n          },\n          function (error) {},\n        ) // error callback does nothing for now\n        if (storeStats.featureDensity) {\n          return (\n            storeStats.featureDensity * (l.end - l.start) <=\n            (thisB.config.maxExportFeatures || 50000)\n          )\n        }\n      }\n\n      // otherwise, i guess we can export\n      return true\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/Track/_FeatureContextMenusMixin.js":{"size":1633,"mtime":1738905962854,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/Track/_FeatureContextMenusMixin.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/Track/_FeatureDetailMixin.js":{"size":10964,"mtime":1738905962869,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/Track/_FeatureDetailMixin.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"/**\n * Mixin with methods for parsing making default feature detail dialogs.\n */\ndefine([\n  'dojo/_base/declare',\n  'dojo/_base/array',\n  'dojo/_base/lang',\n  'dojo/aspect',\n  'dojo/on',\n  'dojo/dom-construct',\n  'JBrowse/Util',\n  'JBrowse/View/FASTA',\n  'JBrowse/View/_FeatureDescriptionMixin',\n], function (\n  declare,\n  array,\n  lang,\n  aspect,\n  on,\n  domConstruct,\n  Util,\n  FASTAView,\n  FeatureDescriptionMixin,\n) {\n  return declare(FeatureDescriptionMixin, {\n    constructor: function () {\n      // clean up the eventHandlers at destruction time if possible\n      if (typeof this.destroy == 'function') {\n        aspect.before(this, 'destroy', function () {\n          delete this.eventHandlers\n        })\n      }\n    },\n\n    _setupEventHandlers: function () {\n      // make a default click event handler\n      var eventConf = dojo.clone(this.config.events || {})\n      if (!eventConf.click) {\n        eventConf.click = (this.config.style || {}).linkTemplate\n          ? {\n              action: 'newWindow',\n              url: this.config.style.linkTemplate,\n            }\n          : {\n              action: 'contentDialog',\n              title: '{type} {name}',\n              content: dojo.hitch(this, 'defaultFeatureDetail'),\n            }\n      }\n\n      // process the configuration to set up our event handlers\n      this.eventHandlers = function () {\n        var handlers = dojo.clone(eventConf)\n        // find conf vars that set events, like `onClick`\n        for (var key in this.config) {\n          var handlerName = key.replace(/^on(?=[A-Z])/, '')\n          if (handlerName != key)\n            {handlers[handlerName.toLowerCase()] = this.config[key]}\n        }\n        // interpret handlers that are just strings to be URLs that should be opened\n        for (key in handlers) {\n          if (typeof handlers[key] == 'string')\n            {handlers[key] = { url: handlers[key] }}\n        }\n        return handlers\n      }.call(this)\n      this.eventHandlers.click = this._makeClickHandler(\n        this.eventHandlers.click,\n      )\n    },\n\n    /**\n     * Make a default feature detail page for the given feature.\n     * @returns {HTMLElement} feature detail page HTML\n     */\n    defaultFeatureDetail: function (\n      /** JBrowse.Track */ track,\n      /** Object */ f,\n      /** HTMLElement */ featDiv,\n      /** HTMLElement */ container,\n      layer,\n    ) {\n      container =\n        container ||\n        dojo.create('div', {\n          className:\n            'detail feature-detail feature-detail-' +\n            track.name.replace(/\\s+/g, '_').toLowerCase(),\n          innerHTML: '',\n        })\n\n      this._renderCoreDetails(track, f, featDiv, container)\n\n      this._renderAdditionalTagsDetail(track, f, featDiv, container)\n\n      if (!this.config.hideSequenceBox) {\n        this._renderUnderlyingReferenceSequence(track, f, featDiv, container)\n      }\n\n      this._renderSubfeaturesDetail(track, f, featDiv, container, layer || 1)\n\n      // hook function extendedRender(track,f,featDiv,container)\n      if (typeof this.extendedRender === 'function') {\n        this.extendedRender(track, f, featDiv, container)\n      }\n\n      return container\n    },\n\n    _renderCoreDetails: function (track, f, featDiv, container) {\n      var coreDetails = dojo.create('div', { className: 'core' }, container)\n      var fmt = dojo.hitch(this, 'renderDetailField', coreDetails)\n      coreDetails.innerHTML += '<h2 class=\"sectiontitle\">Primary Data</h2>'\n\n      fmt('Name', this.getFeatureLabel(f), f)\n      fmt('Type', f.get('type'), f)\n      fmt('Score', f.get('score'), f)\n      fmt('Description', this.getFeatureDescription(f), f)\n      fmt(\n        'Position',\n        Util.assembleLocString({\n          start: f.get('start'),\n          end: f.get('end'),\n          ref: this.refSeq.name,\n          strand: f.get('strand'),\n        }),\n        f,\n      )\n      fmt('Length', Util.addCommas(f.get('end') - f.get('start')) + ' bp', f)\n    },\n\n    // render any subfeatures this feature has\n    _renderSubfeaturesDetail: function (track, f, featDiv, container, layer) {\n      var thisB = this\n      var subfeatures = f.get('subfeatures')\n      if (subfeatures && subfeatures.length) {\n        if (f.get('strand') == -1) {\n          // Feature is on the oposite strand, lets reverse the order of the subfeatures according to their start position\n          subfeatures.sort(function (a, b) {\n            return b.get('start') - a.get('start')\n          })\n        }\n        if (\n          !(track.config.subfeatureDetailLevel != null) ||\n          layer < track.config.subfeatureDetailLevel\n        ) {\n          this._subfeaturesDetail(track, subfeatures, container, f, layer + 1)\n        } else if (layer >= track.config.subfeatureDetailLevel) {\n          var b = domConstruct.create(\n            'button',\n            {\n              className: 'subfeature-load-button',\n              innerHTML: 'Show subfeatures...',\n            },\n            container,\n          )\n          on(b, 'click', function () {\n            thisB._subfeaturesDetail(\n              track,\n              subfeatures,\n              container,\n              f,\n              layer + 1,\n            )\n            dojo.destroy(b)\n          })\n        }\n      }\n    },\n\n    _isReservedTag: function (t) {\n      return {\n        name: 1,\n        start: 1,\n        end: 1,\n        strand: 1,\n        note: 1,\n        subfeatures: 1,\n        type: 1,\n        score: 1,\n      }[t.toLowerCase()]\n    },\n\n    // render any additional tags as just key/value\n    _renderAdditionalTagsDetail: function (track, f, featDiv, container) {\n      var thisB = this\n      var additionalTags = array.filter(\n        f.tags(),\n        function (t) {\n          if (thisB.config.showNoteInAttributes && t.toLowerCase() == 'note') {\n            return true\n          }\n          return !this._isReservedTag(t)\n        },\n        this,\n      )\n\n      if (additionalTags.length) {\n        var atElement = domConstruct.create(\n          'div',\n          {\n            className: 'additional',\n            innerHTML: '<h2 class=\"sectiontitle\">Attributes</h2>',\n          },\n          container,\n        )\n        additionalTags.sort().forEach(t => {\n          this.renderDetailField(\n            atElement,\n            t,\n            f.get(t),\n            f,\n            undefined,\n            track.store.getTagMetadata(t),\n          )\n        })\n      }\n    },\n\n    _renderUnderlyingReferenceSequence: function (\n      track,\n      f,\n      featDiv,\n      container,\n    ) {\n      // render the sequence underlying this feature if possible\n      var field_container = dojo.create(\n        'div',\n        { className: 'field_container feature_sequence' },\n        container,\n      )\n      dojo.create(\n        'h2',\n        {\n          className: 'field feature_sequence',\n          innerHTML: 'Region sequence',\n          title:\n            'reference sequence underlying this ' +\n            (f.get('type') || 'feature'),\n        },\n        field_container,\n      )\n      var valueContainerID = 'feature_sequence' + this._uniqID()\n      var valueContainer = dojo.create(\n        'div',\n        {\n          id: valueContainerID,\n          innerHTML: '<div style=\"height: 12em\">Loading...</div>',\n          className: 'value feature_sequence',\n        },\n        field_container,\n      )\n      var maxSize = this.config.maxFeatureSizeForUnderlyingRefSeq\n      if (maxSize < f.get('end') - f.get('start')) {\n        valueContainer.innerHTML =\n          'Not displaying underlying reference sequence, feature is longer than maximum of ' +\n          Util.humanReadableNumber(maxSize) +\n          'bp'\n      } else {\n        track.browser.getStore(\n          'refseqs',\n          dojo.hitch(this, function (refSeqStore) {\n            valueContainer = dojo.byId(valueContainerID) || valueContainer\n            if (refSeqStore) {\n              refSeqStore.getReferenceSequence(\n                {\n                  ref: this.refSeq.name,\n                  start: f.get('start'),\n                  end: f.get('end'),\n                },\n                // feature callback\n                dojo.hitch(this, function (seq) {\n                  valueContainer = dojo.byId(valueContainerID) || valueContainer\n                  valueContainer.innerHTML = ''\n                  // the HTML is rewritten by the dojo dialog\n                  // parser, but this callback may be called either\n                  // before or after that happens.  if the fetch by\n                  // ID fails, we have come back before the parse.\n                  var textArea = new FASTAView({\n                    track: this,\n                    width: 62,\n                    htmlMaxRows: 10,\n                  }).renderHTML(\n                    {\n                      ref: this.refSeq.name,\n                      start: f.get('start'),\n                      end: f.get('end'),\n                      strand: f.get('strand'),\n                      type: f.get('type'),\n                    },\n                    f.get('strand') == -1 ? Util.revcom(seq) : seq,\n                    valueContainer,\n                  )\n                }),\n                // end callback\n                function () {},\n                // error callback\n                dojo.hitch(this, function () {\n                  valueContainer = dojo.byId(valueContainerID) || valueContainer\n                  valueContainer.innerHTML =\n                    '<span class=\"ghosted\">reference sequence not available</span>'\n                }),\n              )\n            } else {\n              valueContainer.innerHTML =\n                '<span class=\"ghosted\">reference sequence not available</span>'\n            }\n          }),\n        )\n      }\n    },\n\n    _uniqID: function () {\n      this._idCounter = this._idCounter || 0\n      return this._idCounter++\n    },\n\n    _subfeaturesDetail: function (track, subfeatures, container, f, layer) {\n      var field_container = dojo.create(\n        'div',\n        { className: 'field_container subfeatures' },\n        container,\n      )\n      dojo.create(\n        'h2',\n        { className: 'field subfeatures', innerHTML: 'Subfeatures' },\n        field_container,\n      )\n      var subfeaturesContainer = dojo.create(\n        'div',\n        { className: 'value subfeatures' },\n        field_container,\n      )\n\n      array.forEach(\n        subfeatures || [],\n        function (subfeature) {\n          this.defaultFeatureDetail(\n            track,\n            subfeature,\n            null,\n            dojo.create(\n              'div',\n              {\n                className:\n                  'detail feature-detail subfeature-detail feature-detail-' +\n                  track.name +\n                  ' subfeature-detail-' +\n                  track.name,\n                innerHTML: '',\n              },\n              subfeaturesContainer,\n            ),\n            layer,\n          )\n        },\n        this,\n      )\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/Track/_NamedFeatureFiltersMixin.js":{"size":2257,"mtime":1738905962873,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/Track/_NamedFeatureFiltersMixin.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define(['dojo/_base/declare', 'dojo/_base/array', 'dojo/when'], function (\n  declare,\n  array,\n  when,\n) {\n  return declare(null, {\n    constructor: function () {\n      this._initializeConfiguredFeatureFilters()\n    },\n\n    _initializeConfiguredFeatureFilters: function () {\n      // initialize toggling feature filters\n      var thisB = this\n      return when(this._getNamedFeatureFilters()).then(function (filters) {\n        for (var filtername in filters) {\n          if (thisB.config[filtername])\n            {thisB.addFeatureFilter(filters[filtername].func, filtername)}\n          else {thisB.removeFeatureFilter(filtername)}\n        }\n      })\n    },\n\n    _toggleFeatureFilter: function (filtername, setActive) {\n      // if no setActive, we will toggle it\n      if (setActive === undefined) {setActive = !this.config[filtername]}\n\n      // nothing to do if not changed\n      if (!!setActive === !!this.config[filtername]) {return}\n\n      this.config[filtername] = setActive\n\n      var thisB = this\n      when(this._getNamedFeatureFilters(), function (filters) {\n        if (setActive)\n          {thisB.addFeatureFilter(filters[filtername].func, filtername)}\n        else {thisB.removeFeatureFilter(filtername)}\n\n        thisB.changed()\n      })\n    },\n\n    _getNamedFeatureFilters: function () {\n      return {}\n      // return lang.mixin(\n      //     {},\n      //     this.inherited(arguments),\n      //     {\n\n      //     });\n    },\n\n    _makeFeatureFilterTrackMenuItems: function (names, filters) {\n      var thisB = this\n      return when(filters || this._getNamedFeatureFilters()).then(\n        function (filters) {\n          return array.map(names, function (name) {\n            return thisB._makeFeatureFilterTrackMenuItem(name, filters[name])\n          })\n        },\n      )\n    },\n\n    _makeFeatureFilterTrackMenuItem: function (filtername, filterspec) {\n      var thisB = this\n      if (filtername == 'SEPARATOR') {return { type: 'dijit/MenuSeparator' }}\n      return {\n        label: filterspec.desc,\n        title: filterspec.title,\n        type: 'dijit/CheckedMenuItem',\n        checked: !!thisB.config[filtername],\n        onClick: function (event) {\n          thisB._toggleFeatureFilter(filtername, this.checked)\n        },\n      }\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/Track/_TrackDetailsStatsMixin.js":{"size":671,"mtime":1738905962875,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/Track/_TrackDetailsStatsMixin.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/Track/_VariantDetailMixin.js":{"size":12455,"mtime":1738905962891,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/Track/_VariantDetailMixin.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"/**\n * Mixin to provide a `defaultFeatureDetail` method that is optimized\n * for displaying variant data from VCF files.\n */\n\ndefine([\n  'dojo/_base/declare',\n  'dojo/_base/array',\n  'dojo/_base/lang',\n  'dojo/dom-construct',\n  'dojo/promise/all',\n  'JBrowse/Util',\n  'JBrowse/View/Track/_FeatureDetailMixin',\n  'JBrowse/View/Track/_NamedFeatureFiltersMixin',\n  'JBrowse/Model/NestedFrequencyTable',\n], function (\n  declare,\n  array,\n  lang,\n  domConstruct,\n  all,\n  Util,\n  FeatureDetailMixin,\n  NamedFeatureFiltersMixin,\n  NestedFrequencyTable,\n) {\n  return declare([FeatureDetailMixin, NamedFeatureFiltersMixin], {\n    defaultFeatureDetail: function (\n      /** JBrowse.Track */ track,\n      /** Object */ f,\n      /** HTMLElement */ featDiv,\n      /** HTMLElement */ container,\n    ) {\n      container =\n        container ||\n        domConstruct.create('div', {\n          className: 'detail feature-detail feature-detail-' + track.name,\n          innerHTML: '',\n        })\n\n      this._renderCoreDetails(track, f, featDiv, container)\n\n      this._renderAdditionalTagsDetail(track, f, featDiv, container)\n\n      // genotypes in a separate section\n      this._renderGenotypes(container, track, f, featDiv)\n\n      return container\n    },\n    renderDetailValue: function (parent, title, val, f, class_) {\n      if (title == 'alternative_alleles') {\n        val = val.join(',')\n      }\n      return this.inherited(arguments, [parent, title, val, f, class_])\n    },\n    _isReservedTag: function (t) {\n      return this.inherited(arguments) || { genotypes: 1 }[t.toLowerCase()]\n    },\n\n    _renderGenotypes: function (parentElement, track, f) {\n      var thisB = this\n      var genotypes = f.get('genotypes')\n      if (!genotypes) {return}\n\n      var keys = Util.dojof.keys(genotypes).sort()\n      var gCount = keys.length\n      if (!gCount) {return}\n\n      var alt = (f.get('alternative_alleles') || {}).values\n\n      var gContainer = domConstruct.create(\n        'div',\n        {\n          className: 'genotypes',\n          innerHTML: '<h2 class=\"sectiontitle\">Genotypes (' + gCount + ')</h2>',\n        },\n        parentElement,\n      )\n\n      function render(underlyingRefSeq) {\n        thisB._renderGenotypeSummary(gContainer, genotypes, alt)\n\n        var valueContainer = domConstruct.create(\n          'div',\n          { className: 'value_container genotypes' },\n          gContainer,\n        )\n\n        thisB.renderDetailValueGrid(\n          valueContainer,\n          'Genotypes',\n          f,\n          // iterator\n          function () {\n            if (!keys.length) {return null}\n            var k = keys.shift()\n            var value = genotypes[k]\n            var item = { id: k }\n            for (var field in value) {\n              item[field] =\n                field === 'GT'\n                  ? thisB._mungeGenotypeVal(\n                      value[field].values,\n                      alt,\n                      underlyingRefSeq,\n                    )\n                  : genotypes[k][field]\n            }\n            return item\n          },\n          {\n            descriptions: (function () {\n              if (!keys.length) {return {}}\n\n              var subValue = genotypes[keys[0]]\n              var descriptions = {}\n              for (var k in subValue) {\n                descriptions[k] =\n                  f.parser.getMetadata('FORMAT', k, 'Description') || null\n              }\n              return descriptions\n            })(),\n            renderCell: {\n              GT: function (field, value, node, options) {\n                thisB.renderDetailValue(node, '', value, f, '')\n              },\n            },\n          },\n        )\n      }\n\n      track.browser.getStore('refseqs', function (refSeqStore) {\n        if (refSeqStore) {\n          refSeqStore.getReferenceSequence(\n            {\n              ref: track.refSeq.name,\n              start: f.get('start'),\n              end: f.get('end'),\n            },\n            render,\n            function () {\n              render()\n            },\n          )\n        } else {\n          render()\n        }\n      })\n    },\n\n    _mungeGenotypeVal: function (values, alt, underlyingRefSeq) {\n      // handle the GT field specially, translating the genotype indexes into the actual ALT strings\n      let value_parse\n      if (values == null) {value_parse = '.'}\n      else {value_parse = values[0]}\n\n      var splitter = (value_parse.match(/[\\|\\/]/g) || [])[0] // only accept | and / splitters since . can mean no call\n      var refseq = underlyingRefSeq ? 'ref (' + underlyingRefSeq + ')' : 'ref'\n      values = array\n        .map(\n          splitter ? value_parse.split(splitter) : value_parse,\n          function (gtIndex) {\n            gtIndex = parseInt(gtIndex) || gtIndex\n            if (gtIndex == '.') {\n              return 'no-call'\n            } else if (gtIndex == 0) {\n              return refseq\n            } else {return alt ? alt[gtIndex - 1] : gtIndex}\n          },\n        )\n        .join(' ' + splitter + ' ')\n      return values\n    },\n\n    _renderGenotypeSummary: function (parentElement, genotypes, alt) {\n      if (!genotypes) {return}\n\n      var counts = new NestedFrequencyTable()\n      for (var gname in genotypes) {\n        if (genotypes.hasOwnProperty(gname)) {\n          // increment the appropriate count\n          var gtVals = (genotypes[gname].GT || {}).values\n          if (gtVals == null) {gtVals = ['.']}\n          var gt = gtVals[0].split(/\\||\\//)\n          if (lang.isArray(gt)) {\n            // if all zero, non-variant/hom-ref\n            if (\n              array.every(gt, function (g) {\n                return parseInt(g) == 0\n              })\n            ) {\n              counts\n                .getNested('non-variant')\n                .increment('homozygous for reference')\n            } else if (\n              array.every(gt, function (g) {\n                return g == '.'\n              })\n            ) {\n              counts.getNested('non-variant').increment('no call')\n            } else if (\n              array.every(gt, function (g) {\n                return g == gt[0]\n              })\n            ) {\n              if (alt)\n                {counts\n                  .getNested('variant/homozygous')\n                  .increment(alt[parseInt(gt[0]) - 1] + ' variant')}\n              else {counts.getNested('variant').increment('homozygous')}\n            } else {\n              counts.getNested('variant').increment('heterozygous')\n            }\n          }\n        }\n      }\n\n      var total = counts.total()\n      if (!total) {return}\n\n      var valueContainer = domConstruct.create(\n        'div',\n        { className: 'value_container big genotype_summary' },\n        parentElement,\n      )\n      //domConstruct.create('h3', { innerHTML: 'Summary' }, valueContainer);\n\n      var tableElement = domConstruct.create('table', {}, valueContainer)\n\n      function renderFreqTable(table, level) {\n        table.forEach(function (count, categoryName) {\n          var tr = domConstruct.create('tr', {}, tableElement)\n          domConstruct.create(\n            'td',\n            {\n              className: 'category level_' + level,\n              innerHTML: categoryName,\n            },\n            tr,\n          )\n          if (typeof count == 'object') {\n            var thisTotal = count.total()\n            domConstruct.create(\n              'td',\n              {\n                className: 'count level_' + level,\n                innerHTML: thisTotal,\n              },\n              tr,\n            )\n            domConstruct.create(\n              'td',\n              {\n                className: 'pct level_' + level,\n                innerHTML: Math.round((thisTotal / total) * 10000) / 100 + '%',\n              },\n              tr,\n            )\n            renderFreqTable(count, level + 1)\n          } else {\n            domConstruct.create(\n              'td',\n              {\n                className: 'count level_' + level,\n                innerHTML: count,\n              },\n              tr,\n            )\n            domConstruct.create(\n              'td',\n              {\n                className: 'pct level_' + level,\n                innerHTML: Math.round((count / total) * 10000) / 100 + '%',\n              },\n              tr,\n            )\n          }\n        })\n      }\n\n      renderFreqTable(counts, 0)\n\n      var totalTR = domConstruct.create('tr', {}, tableElement)\n      domConstruct.create(\n        'td',\n        { className: 'category total', innerHTML: 'Total' },\n        totalTR,\n      )\n      domConstruct.create(\n        'td',\n        { className: 'count total', innerHTML: total },\n        totalTR,\n      )\n      domConstruct.create(\n        'td',\n        { className: 'pct total', innerHTML: '100%' },\n        totalTR,\n      )\n    },\n\n    // filters for VCF sites\n    _getNamedFeatureFilters: function () {\n      var thisB = this\n      return all([\n        this.store.getParser().then(parser => parser.getMetadata()),\n        this.inherited(arguments),\n      ]).then(function (results) {\n        if (results[0]) {return thisB._makeVCFFilters.apply(thisB, results)}\n        else {return results[1]}\n      })\n    },\n\n    // given VCF metadata, make some appropriate named feature\n    // filters to filter its data\n    _makeVCFFilters: function (vcfMetadata, inheritedFilters) {\n      // wraps the callback to return true if there\n      // is no filter attr\n      function makeFilterFilter(condition) {\n        return function (f) {\n          f = f.get('filter')\n          return !f || condition(f)\n        }\n      }\n      var filters = lang.mixin({}, inheritedFilters, {\n        hideFilterPass: {\n          desc: 'Hide sites passing all filters',\n          func: makeFilterFilter(function (filter) {\n            try {\n              return filter.values.join('').toUpperCase() != 'PASS'\n            } catch (e) {\n              return filter.toUpperCase() != 'PASS'\n            }\n          }),\n        },\n        hideNotFilterPass: {\n          desc: 'Hide sites not passing all filters',\n          func: makeFilterFilter(function (f) {\n            try {\n              return f.values.join('').toUpperCase() == 'PASS'\n            } catch (e) {\n              return f.toUpperCase() != 'PASS'\n            }\n          }),\n        },\n      })\n      if (vcfMetadata.FILTER) {\n        for (var filterName in vcfMetadata.FILTER) {\n          filters[filterName + '_hide'] = function (filterName, filterSpec) {\n            return {\n              desc: 'Hide sites passing filter \"' + filterName + '\"',\n              title: filterName + ': ' + filterSpec.description,\n              func: makeFilterFilter(function (f) {\n                var fs = f.values || f\n                if (!fs[0]) {return true}\n\n                return !array.some(fs, function (fname) {\n                  return fname == filterName\n                })\n              }),\n            }\n          }.call(this, filterName, vcfMetadata.FILTER[filterName])\n        }\n        for (var filterName in vcfMetadata.FILTER) {\n          filters[filterName + '_include'] = function (filterName, filterSpec) {\n            return {\n              desc: 'Include sites passing filter \"' + filterName + '\"',\n              title: filterName + ': ' + filterSpec.description,\n              func: makeFilterFilter(function (f) {\n                var fs = f.values || f\n                if (!fs[0]) {return true}\n\n                return array.some(fs, function (fname) {\n                  return fname == filterName\n                })\n              }),\n            }\n          }.call(this, filterName, vcfMetadata.FILTER[filterName])\n        }\n      }\n      return filters\n    },\n\n    _variantsFilterTrackMenuOptions: function () {\n      // add toggles for feature filters\n      var track = this\n      return this._getNamedFeatureFilters().then(function (filters) {\n        // merge our builtin filters with additional ones\n        // that might have been generated in\n        // _getNamedFeatureFilters() based on e.g. the VCF\n        // header\n        var menuItems = ['hideFilterPass', 'hideNotFilterPass', 'SEPARATOR']\n        var withAdditional = Util.uniq(\n          menuItems.concat(Util.dojof.keys(filters)),\n        )\n        if (withAdditional.length > menuItems.length) {menuItems = withAdditional}\n        else {menuItems.pop()} //< pop off the separator since we have no additional ones\n\n        return track._makeFeatureFilterTrackMenuItems(menuItems, filters)\n      })\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/Track/_YScaleMixin.js":{"size":3840,"mtime":1738905962899,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/Track/_YScaleMixin.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/Track/Alignments.js":{"size":7022,"mtime":1738905962907,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/Track/Alignments.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'dojo/_base/array',\n  'dojo/promise/all',\n  'JBrowse/Util',\n  'JBrowse/View/Track/HTMLFeatures',\n  'JBrowse/View/Track/_AlignmentsMixin',\n], function (declare, array, all, Util, HTMLFeatures, AlignmentsMixin) {\n  // return declare( HTMLFeatures,\n  return declare(\n    [HTMLFeatures, AlignmentsMixin],\n    /**\n     * @lends JBrowse.View.Track.Alignments\n     */\n    {\n      _defaultConfig: function () {\n        return Util.deepUpdate(dojo.clone(this.inherited(arguments)), {\n          maxFeatureScreenDensity: 1.5,\n          layoutPitchY: 4,\n\n          hideDuplicateReads: true,\n          hideQCFailingReads: true,\n          hideSecondary: true,\n          hideSupplementary: true,\n          hideMissingMatepairs: false,\n          hideImproperPairs: false,\n          hideUnmapped: true,\n          hideUnsplicedReads: false,\n          hideForwardStrand: false,\n          hideReverseStrand: false,\n\n          style: {\n            _defaultLabelScale: 50,\n            className: 'alignment',\n            arrowheadClass: 'arrowhead',\n            centerChildrenVertically: true,\n            showMismatches: true,\n            showSubfeatures: false,\n            showLabels: false,\n          },\n        })\n      },\n\n      renderFeature: function (\n        feature,\n        uniqueId,\n        block,\n        scale,\n        labelScale,\n        descriptionScale,\n        containerStart,\n        containerEnd,\n      ) {\n        var featDiv = this.inherited(arguments)\n        if (!featDiv) {return null}\n\n        var displayStart = Math.max(feature.get('start'), containerStart)\n        var displayEnd = Math.min(feature.get('end'), containerEnd)\n        if (this.config.style.showMismatches) {\n          this._drawMismatches(\n            feature,\n            featDiv,\n            scale,\n            displayStart,\n            displayEnd,\n          )\n        }\n\n        // if this feature is part of a multi-segment read, and not\n        // all of its segments are aligned, add missing_mate to its\n        // class\n        if (\n          feature.get('multi_segment_template') &&\n          !feature.get('multi_segment_all_aligned')\n        )\n          {featDiv.className += ' missing_mate'}\n\n        return featDiv\n      },\n\n      handleSubFeatures: function (\n        feature,\n        featDiv,\n        displayStart,\n        displayEnd,\n        block,\n      ) {\n        if (this.config.style.showSubfeatures) {\n          this.inherited(arguments)\n        }\n      },\n\n      /**\n       * draw base-mismatches on the feature\n       */\n      _drawMismatches: function (\n        feature,\n        featDiv,\n        scale,\n        displayStart,\n        displayEnd,\n      ) {\n        var featLength = displayEnd - displayStart\n        // recall: scale is pixels/basepair\n        if (featLength * scale > 1) {\n          var mismatches = this._getMismatches(feature)\n          var charSize = this.getCharacterMeasurements()\n          var drawChars = scale >= charSize.w\n          array.forEach(\n            mismatches,\n            function (mismatch) {\n              var start = feature.get('start') + mismatch.start\n              var end = start + mismatch.length\n\n              // if the feature has been truncated to where it doesn't cover\n              // this mismatch anymore, just skip this mismatch\n              if (end <= displayStart || start >= displayEnd) {return}\n\n              var base = mismatch.base\n              var mDisplayStart = Math.max(start, displayStart)\n              var mDisplayEnd = Math.min(end, displayEnd)\n              var mDisplayWidth = mDisplayEnd - mDisplayStart\n              var overall = dojo.create(\n                'span',\n                {\n                  className: mismatch.type + ' base_' + base.toLowerCase(),\n                  style: {\n                    position: 'absolute',\n                    left:\n                      (100 * (mDisplayStart - displayStart)) / featLength + '%',\n                    width:\n                      scale * mDisplayWidth > 1\n                        ? (100 * mDisplayWidth) / featLength + '%'\n                        : '1px',\n                  },\n                },\n                featDiv,\n              )\n\n              // give the mismatch a mouseover if not drawing a character with the mismatch base\n              if (!drawChars) {overall.title = base}\n\n              if (drawChars && mismatch.length <= 20) {\n                for (var i = 0; i < mismatch.length; i++) {\n                  var basePosition = start + i\n                  if (\n                    basePosition >= mDisplayStart &&\n                    basePosition <= mDisplayEnd\n                  ) {\n                    dojo.create(\n                      'span',\n                      {\n                        className: 'base base_' + base.toLowerCase(),\n                        style: {\n                          position: 'absolute',\n                          width: scale + 'px',\n                          left:\n                            ((basePosition - mDisplayStart) / mDisplayWidth) *\n                              100 +\n                            '%',\n                        },\n                        innerHTML: base,\n                      },\n                      overall,\n                    )\n                  }\n                }\n              }\n            },\n            this,\n          )\n        }\n      },\n\n      /**\n       * @returns {Object} containing <code>h</code> and <code>w</code>,\n       *      in pixels, of the characters being used for sequences\n       */\n      getCharacterMeasurements: function () {\n        if (!this._measurements)\n          {this._measurements = this._measureSequenceCharacterSize(this.div)}\n        return this._measurements\n      },\n\n      /**\n       * Conducts a test with DOM elements to measure sequence text width\n       * and height.\n       */\n      _measureSequenceCharacterSize: function (containerElement) {\n        var widthTest = dojo.create(\n          'div',\n          {\n            innerHTML:\n              '<span class=\"base mismatch\">A</span>' +\n              '<span class=\"base mismatch\">C</span>' +\n              '<span class=\"base mismatch\">T</span>' +\n              '<span class=\"base mismatch\">G</span>' +\n              '<span class=\"base mismatch\">N</span>',\n            style: {\n              visibility: 'hidden',\n              position: 'absolute',\n              left: '0px',\n            },\n          },\n          containerElement,\n        )\n        var result = {\n          w: widthTest.clientWidth / 5,\n          h: widthTest.clientHeight,\n        }\n        containerElement.removeChild(widthTest)\n        return result\n      },\n\n      _trackMenuOptions: function () {\n        return all([\n          this.inherited(arguments),\n          this._alignmentsFilterTrackMenuOptions(),\n        ]).then(function (options) {\n          var o = options.shift()\n          options.unshift({ type: 'dijit/MenuSeparator' })\n          return o.concat.apply(o, options)\n        })\n      },\n    },\n  )\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/Track/Alignments2.js":{"size":16874,"mtime":1738905962926,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/Track/Alignments2.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'dojo/_base/array',\n  'dijit/MenuItem',\n  'JBrowse/View/Dialog/SetTrackHeight',\n  'JBrowse/Util',\n  'JBrowse/View/Track/CanvasFeatures',\n  'JBrowse/View/Track/_AlignmentsMixin',\n], function (\n  declare,\n  array,\n  MenuItem,\n  Dialog,\n  Util,\n  CanvasFeatureTrack,\n  AlignmentsMixin,\n) {\n  return declare([CanvasFeatureTrack, AlignmentsMixin], {\n    _defaultConfig: function () {\n      var c = Util.deepUpdate(dojo.clone(this.inherited(arguments)), {\n        glyph: 'JBrowse/View/FeatureGlyph/Alignment',\n        maxFeatureGlyphExpansion: 0,\n        maxFeatureScreenDensity: 15,\n        orientationType: 'fr',\n\n        hideDuplicateReads: true,\n        hideQCFailingReads: true,\n        hideSecondary: true,\n        hideSupplementary: true,\n        hideUnmapped: true,\n        hideUnsplicedReads: false,\n        hideMissingMatepairs: false,\n        hideImproperPairs: false,\n        hideForwardStrand: false,\n        hideReverseStrand: false,\n        useXS: false,\n        useTS: false,\n        useReverseTemplate: false,\n        useReverseTemplateOption: true,\n        viewAsPairs: false,\n        viewAsSpans: false,\n        maxInsertSize: 50000,\n        readCloudLogScale: true,\n        showInterchromosomalArcs: true,\n        showLargeArcs: true,\n\n        histograms: {\n          description: 'coverage depth',\n          binsPerBlock: 200,\n        },\n\n        style: {\n          showLabels: false,\n        },\n      })\n      c.menuTemplate.push(\n        {\n          iconClass: 'dijitIconUndo',\n          url: function (track, feature) {\n            return track.browser.makeCurrentViewURL({\n              loc: track._nextSegmentViewLoc(feature, 0.8),\n              highlight: feature.get('next_segment_position'),\n              tracklist: 0,\n            })\n          },\n          action: 'iframeDialog',\n          title: 'Open {next_segment_position} in a popup',\n          disabled: function (track, feature) {\n            return (\n              !feature.get('next_segment_position') ||\n              feature.get('paired_feature')\n            )\n          },\n          label: 'Quick-view mate/next location',\n        },\n        {\n          iconClass: 'dijitIconUndo',\n          url: function (track, feature) {\n            return track.browser.makeCurrentViewURL({\n              loc: track._nextSegmentViewLoc(feature),\n              highlight: feature.get('next_segment_position'),\n            })\n          },\n          action: 'newWindow',\n          title: 'Open {next_segment_position} in a new tab',\n          disabled: function (track, feature) {\n            return (\n              !feature.get('next_segment_position') ||\n              feature.get('paired_feature')\n            )\n          },\n          label: 'Open mate/next location in new tab',\n        },\n      )\n      return c\n    },\n\n    _trackType: function () {},\n    // make a locstring for a view of the given feature's next segment\n    // (in a multi-segment read)\n    _nextSegmentViewLoc: function (feature, factor) {\n      var nextLocStr = feature.get('next_segment_position')\n      if (!nextLocStr) {return undefined}\n\n      var s = nextLocStr.split(':')\n      var refName = s[0]\n      var start = parseInt(s[1])\n\n      var visibleRegion = this.browser.view.visibleRegion()\n      var visibleRegionSize = Math.round(\n        (visibleRegion.end - visibleRegion.start + 1) * (factor || 1),\n      )\n\n      return Util.assembleLocString({\n        start: Math.round(start - visibleRegionSize / 2),\n        end: Math.round(start + visibleRegionSize / 2),\n        ref: refName,\n      })\n    },\n\n    _trackMenuOptions() {\n      var thisB = this\n      var displayOptions = []\n\n      var m = {\n        type: 'dijit/Menu',\n        label: 'Track visualization types',\n        children: [],\n      }\n      var c = {\n        type: 'dijit/Menu',\n        label: 'Coloring options',\n        children: [],\n      }\n\n      displayOptions.push(m)\n      displayOptions.push(c)\n\n      m.children.push({\n        label: 'View as unpaired',\n        type: 'dijit/RadioMenuItem',\n        checked: this.config.glyph == 'JBrowse/View/FeatureGlyph/Alignment',\n        onClick: function (event) {\n          thisB.config.glyph = 'JBrowse/View/FeatureGlyph/Alignment'\n          thisB.browser.publish('/jbrowse/v1/v/tracks/replace', [thisB.config])\n        },\n      })\n\n      m.children.push({\n        label: 'View as pairs',\n        type: 'dijit/RadioMenuItem',\n        checked:\n          this.config.glyph == 'JBrowse/View/FeatureGlyph/PairedAlignment',\n        onClick: function (event) {\n          thisB.config.glyph = 'JBrowse/View/FeatureGlyph/PairedAlignment'\n          thisB.browser.publish('/jbrowse/v1/v/tracks/replace', [thisB.config])\n        },\n      })\n\n      m.children.push({\n        label: 'View as arcs',\n        type: 'dijit/RadioMenuItem',\n        checked: this.config.glyph == 'JBrowse/View/FeatureGlyph/PairedArc',\n        onClick: function (event) {\n          thisB.config.glyph = 'JBrowse/View/FeatureGlyph/PairedArc'\n          thisB.browser.publish('/jbrowse/v1/v/tracks/replace', [thisB.config])\n        },\n      })\n      m.children.push({\n        label: 'View as read cloud',\n        type: 'dijit/RadioMenuItem',\n        checked:\n          this.config.glyph == 'JBrowse/View/FeatureGlyph/PairedReadCloud',\n        onClick: function (event) {\n          thisB.config.glyph = 'JBrowse/View/FeatureGlyph/PairedReadCloud'\n          thisB.browser.publish('/jbrowse/v1/v/tracks/replace', [thisB.config])\n        },\n      })\n\n      m.children.push({\n        label: 'View coverage',\n        type: 'dijit/RadioMenuItem',\n        checked: false,\n        onClick: function (event) {\n          thisB.config.type = 'JBrowse/View/Track/SNPCoverage'\n          thisB.config._oldAlignmentsHeight = thisB.config.style.height\n          thisB.config.style.height = thisB.config._oldSnpCoverageHeight\n          thisB.browser.publish('/jbrowse/v1/v/tracks/replace', [thisB.config])\n        },\n      })\n\n      c.children.push({\n        label: 'Color by default',\n        type: 'dijit/RadioMenuItem',\n        checked: !!this.config.defaultColor,\n        onClick: function (event) {\n          thisB.clearColorConfig()\n          thisB.config.defaultColor = this.get('checked')\n          thisB.browser.publish('/jbrowse/v1/v/tracks/replace', [thisB.config])\n        },\n      })\n      c.children.push({\n        label: 'Color by XS or TS tag (RNA-seq orientation)',\n        type: 'dijit/RadioMenuItem',\n        checked: !!this.config.useXS,\n        onClick: function (event) {\n          thisB.clearColorConfig()\n          thisB.config.useXS = this.get('checked')\n          thisB.browser.publish('/jbrowse/v1/v/tracks/replace', [thisB.config])\n        },\n      })\n\n      c.children.push({\n        label: 'Color by ts tag (minimap2 RNA-seq orientation)',\n        type: 'dijit/RadioMenuItem',\n        checked: !!this.config.useTS,\n        onClick: function (event) {\n          thisB.clearColorConfig()\n          thisB.config.useTS = this.get('checked')\n          thisB.browser.publish('/jbrowse/v1/v/tracks/replace', [thisB.config])\n        },\n      })\n      c.children.push({\n        label: 'Color mate pair as flipped (RNA-seq orientation)',\n        type: 'dijit/RadioMenuItem',\n        checked: !!this.config.useReverseTemplate,\n        onClick: function (event) {\n          thisB.clearColorConfig()\n          thisB.config.useReverseTemplate = this.get('checked')\n          thisB.browser.publish('/jbrowse/v1/v/tracks/replace', [thisB.config])\n        },\n      })\n\n      c.children.push({\n        label: 'Color by mapping quality',\n        type: 'dijit/RadioMenuItem',\n        checked: !!this.config.colorByMAPQ,\n        onClick: function (event) {\n          thisB.clearColorConfig()\n          thisB.config.colorByMAPQ = this.get('checked')\n          thisB.browser.publish('/jbrowse/v1/v/tracks/replace', [thisB.config])\n        },\n      })\n      c.children.push({\n        label: 'Color by orientation',\n        type: 'dijit/RadioMenuItem',\n        checked: !!this.config.colorByOrientation,\n        onClick: function (event) {\n          thisB.clearColorConfig()\n          thisB.config.colorByOrientation = this.get('checked')\n          thisB.browser.publish('/jbrowse/v1/v/tracks/replace', [thisB.config])\n        },\n      })\n      c.children.push({\n        label: 'Color by insert size',\n        type: 'dijit/RadioMenuItem',\n        checked: !!this.config.colorBySize,\n        onClick: function (event) {\n          thisB.clearColorConfig()\n          thisB.config.colorBySize = this.get('checked')\n          thisB.browser.publish('/jbrowse/v1/v/tracks/replace', [thisB.config])\n        },\n      })\n      c.children.push({\n        label: 'Color by orientation and insert size',\n        type: 'dijit/RadioMenuItem',\n        checked: !!this.config.colorByOrientationAndSize,\n        onClick: function (event) {\n          thisB.clearColorConfig()\n          thisB.config.colorByOrientationAndSize = this.get('checked')\n          thisB.browser.publish('/jbrowse/v1/v/tracks/replace', [thisB.config])\n        },\n      })\n      if (this.config.glyph == 'JBrowse/View/FeatureGlyph/PairedReadCloud') {\n        displayOptions.push({\n          type: 'dijit/Menu',\n          label: 'Read cloud options',\n          children: [\n            {\n              label: 'View log scale',\n              type: 'dijit/CheckedMenuItem',\n              checked: !!this.config.readCloudLogScale,\n              onClick: function (event) {\n                thisB.config.readCloudLogScale = this.get('checked')\n                thisB.browser.publish('/jbrowse/v1/v/tracks/replace', [\n                  thisB.config,\n                ])\n              },\n            },\n            {\n              label: 'Set Y-scale size',\n              onClick: function (event) {\n                new Dialog({\n                  title:\n                    'Set read cloud Y-scale in terms of the maximum expected insert size',\n                  msg: ' expected max insert size',\n                  maxHeight: Infinity,\n                  height: thisB.config.readCloudYScaleMax || 50000,\n                  setCallback: ret => {\n                    thisB.config.readCloudYScaleMax = ret\n                    thisB.browser.publish('/jbrowse/v1/v/tracks/replace', [\n                      thisB.config,\n                    ])\n                  },\n                }).show()\n              },\n            },\n          ],\n        })\n      }\n      if (this.config.glyph == 'JBrowse/View/FeatureGlyph/PairedArc') {\n        displayOptions.push({\n          type: 'dijit/Menu',\n          label: 'Paired arc options',\n          children: [\n            {\n              label: 'Show interchromosomal',\n              type: 'dijit/CheckedMenuItem',\n              checked: !!this.config.showInterchromosomalArcs,\n              onClick: function (event) {\n                thisB.config.showInterchromosomalArcs = this.get('checked')\n                thisB.browser.publish('/jbrowse/v1/v/tracks/replace', [\n                  thisB.config,\n                ])\n              },\n            },\n            {\n              label: 'Show large arcs',\n              type: 'dijit/CheckedMenuItem',\n              checked: !!this.config.showLargeArcs,\n              onClick: function (event) {\n                thisB.config.showLargeArcs = this.get('checked')\n                thisB.browser.publish('/jbrowse/v1/v/tracks/replace', [\n                  thisB.config,\n                ])\n              },\n            },\n          ],\n        })\n      }\n\n      displayOptions.push({\n        type: 'dijit/MenuItem',\n        label: 'Re-estimate insert size stats',\n        onClick: function (event) {\n          thisB.insertSizeStats = null\n          thisB.store.cleanStatsCache()\n          thisB.redraw()\n        },\n      })\n      return Promise.all([\n        this.inherited(arguments),\n        this._alignmentsFilterTrackMenuOptions(),\n        displayOptions,\n      ]).then(function (options) {\n        var o = options.shift()\n        options.unshift({ type: 'dijit/MenuSeparator' })\n        return o.concat.apply(o, options)\n      })\n    },\n    clearColorConfig() {\n      Object.assign(this.config, {\n        defaultColor: false,\n        useTS: false,\n        useXS: false,\n        useReverseTemplate: false,\n        colorByMAPQ: false,\n        colorByOrientation: false,\n        colorBySize: false,\n        colorByOrientationAndSize: false,\n      })\n    },\n\n    // override getLayout to access addRect method\n    _getLayout() {\n      var layout = this.inherited(arguments)\n      if (\n        this.config.glyph == 'JBrowse/View/FeatureGlyph/PairedReadCloud' ||\n        this.config.glyph == 'JBrowse/View/FeatureGlyph/PairedArc'\n      ) {\n        layout = declare.safeMixin(layout, {\n          addRect: function () {\n            this.pTotalHeight = this.maxHeight\n            return 0\n          },\n        })\n      }\n      return layout\n    },\n\n    fillFeatures(args) {\n      const finishCallback = args.finishCallback\n      const errorCallback = e => {\n        console.error(e)\n        this._handleError(e, args)\n        finishCallback(e)\n      }\n\n      if (\n        this.config.viewAsPairs ||\n        this.config.viewAsSpans ||\n        this.config.colorByOrientationAndSize ||\n        (this.config.colorBySize && !this.insertSizeStats)\n      ) {\n        let supermethod = this.getInherited(arguments)\n        const blockLen = args.rightBase - args.leftBase\n        let min\n        let max\n\n        if (this.config.glyph == 'JBrowse/View/FeatureGlyph/PairedArc') {\n          // paired arc the insert size can be large and therefore we request a number of neighboring blocks\n          const numNeighboringBlockFetches = 6\n          min = Math.max(\n            0,\n            args.leftBase -\n              Math.min(\n                Math.max(\n                  blockLen * numNeighboringBlockFetches,\n                  this.config.maxInsertSize,\n                ),\n                100000,\n              ),\n          )\n          max =\n            args.rightBase +\n            Math.min(\n              Math.max(\n                blockLen * numNeighboringBlockFetches,\n                this.config.maxInsertSize,\n              ),\n              100000,\n            )\n        } else {\n          // otherwise we just request based on maxInsertSize\n          min = Math.max(0, args.leftBase - this.config.maxInsertSize)\n          max = args.rightBase + this.config.maxInsertSize\n        }\n\n        var cachePromise = new Promise((resolve, reject) => {\n          this.store.getFeatures(\n            {\n              ref: this.refSeq.name,\n              start: min,\n              end: max,\n              viewAsPairs: this.config.viewAsPairs,\n              viewAsSpans: this.config.viewAsSpans,\n              maxInsertSize: this.config.maxInsertSize,\n            },\n            () => {\n              /* do nothing except initialize caches on store backend */\n            },\n            () => {\n              this.insertSizeStats =\n                this.insertSizeStats || this.store.getInsertSizeStats()\n              resolve()\n            },\n            reject,\n          )\n        })\n        cachePromise.then(() => {\n          args.finishCallback = () => {\n            finishCallback()\n            this.store.cleanFeatureCache({\n              ref: this.refSeq.name,\n              start: min,\n              end: max,\n            })\n          }\n          supermethod.call(this, args)\n        }, errorCallback)\n      } else {\n        this.inherited(arguments)\n      }\n    },\n\n    constructor() {\n      // automatically set parameters for the track based on glyph types\n      if (this.config.glyph == 'JBrowse/View/FeatureGlyph/PairedArc') {\n        this.config.viewAsSpans = true\n        this.config.viewAsPairs = false\n      } else if (\n        this.config.glyph == 'JBrowse/View/FeatureGlyph/PairedAlignment' ||\n        this.config.glyph == 'JBrowse/View/FeatureGlyph/PairedReadCloud'\n      ) {\n        this.config.viewAsPairs = true\n        this.config.viewAsSpans = false\n      } else {\n        this.config.viewAsPairs = false\n        this.config.viewAsSpans = false\n      }\n      this.insertSizeStats = this.config.insertSizeStats\n\n      // determine if alternate color scheme in use, otherwise make default\n      var elts = [\n        'defaultColor',\n        'useXS',\n        'useTS',\n        'useReverseTemplate',\n        'colorByOrientation',\n        'colorBySize',\n        'colorByOrientationAndSize',\n        'colorByMAPQ',\n      ]\n\n      if (!elts.some(e => this.config[e] == true)) {\n        this.config.defaultColor = true\n      }\n    },\n\n    renderClickMap() {\n      if (\n        this.config.glyph == 'JBrowse/View/FeatureGlyph/PairedArc' ||\n        this.config.glyph == 'JBrowse/View/FeatureGlyph/PairedReadCloud'\n      ) {\n        return\n      } else {\n        this.inherited(arguments)\n      }\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/Track/BlockBased.js":{"size":46195,"mtime":1738905962967,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/Track/BlockBased.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'dojo/_base/lang',\n  'dojo/_base/array',\n  'dojo/json',\n  'dojo/aspect',\n  'dojo/dom-construct',\n  'dojo/dom-geometry',\n  'dojo/dom-class',\n  'dojo/dom-style',\n  'dojo/query',\n  'dojo/on',\n  'dojo/when',\n  'dijit/Destroyable',\n  'JBrowse/View/InfoDialog',\n  'dijit/Dialog',\n  'dijit/Menu',\n  'dijit/PopupMenuItem',\n  'dijit/MenuItem',\n  'dijit/CheckedMenuItem',\n  'dijit/MenuSeparator',\n  'dijit/RadioMenuItem',\n  'JBrowse/Util',\n  'JBrowse/Component',\n  'JBrowse/FeatureFiltererMixin',\n  'JBrowse/Errors',\n  'JBrowse/Model/Location',\n  'JBrowse/View/TrackConfigEditor',\n  'JBrowse/View/ConfirmDialog',\n  'JBrowse/View/Track/BlockBased/Block',\n  'JBrowse/View/DetailsMixin',\n], function (\n  declare,\n  lang,\n  array,\n  JSON,\n  aspect,\n  domConstruct,\n  domGeom,\n  domClass,\n  domStyle,\n  query,\n  on,\n  when,\n  Destroyable,\n  InfoDialog,\n  Dialog,\n  dijitMenu,\n  dijitPopupMenuItem,\n  dijitMenuItem,\n  dijitCheckedMenuItem,\n  dijitMenuSeparator,\n  dijitRadioMenuItem,\n  Util,\n  Component,\n  FeatureFiltererMixin,\n  Errors,\n  Location,\n  TrackConfigEditor,\n  ConfirmDialog,\n  Block,\n  DetailsMixin,\n) {\n  // we get `own` and `destroy` from Destroyable, see dijit/Destroyable docs\n\n  return declare(\n    [Component, DetailsMixin, FeatureFiltererMixin, Destroyable],\n    /**\n     * @lends JBrowse.View.Track.BlockBased.prototype\n     */\n    {\n      /**\n       * Base class for all JBrowse tracks.\n       * @constructs\n       */\n      constructor: function (args) {\n        args = args || {}\n\n        this.refSeq = args.refSeq\n        this.name = args.label || this.config.label\n        this.key = args.key || this.config.key || this.name\n\n        this._changedCallback = args.changeCallback || function () {}\n        this.height = 0\n        this.shown = true\n        this.empty = false\n        this.browser = args.browser\n\n        this.setFeatureFilterParentComponent(this.browser.view)\n\n        this.store = args.store\n\n        // retrieve any user-set style info\n        lang.mixin(this.config.style, this.getUserStyles())\n      },\n\n      // get/set persistent per-user style information for this track\n      updateUserStyles: function (settings) {\n        // set in this object\n        lang.mixin(this.config.style, settings)\n        // set in the saved style\n        var saved = JSON.parse(\n          this.browser.cookie('track-style-' + this.name) || '{}',\n        )\n        lang.mixin(saved, settings)\n        this.browser.cookie('track-style-' + this.name, saved)\n        // redraw this track\n        this.redraw()\n      },\n      getUserStyles: function () {\n        return JSON.parse(\n          this.browser.cookie('track-style-' + this.name) || '{}',\n        )\n      },\n\n      /**\n       * Returns object holding the default configuration for this track\n       * type.  Might want to override in subclasses.\n       * @private\n       */\n      _defaultConfig: function () {\n        return {\n          maxFeatureSizeForUnderlyingRefSeq: 250000,\n          subfeatureDetailLevel: 2,\n        }\n      },\n\n      heightUpdate: function (height, blockIndex) {\n        if (!this.shown) {\n          this.heightUpdateCallback(0)\n          return\n        }\n\n        if (blockIndex !== undefined) {this.blockHeights[blockIndex] = height}\n\n        this.height = Math.max(this.height, height)\n\n        if (!this.inShowRange) {\n          this.heightUpdateCallback(Math.max(this.labelHeight, this.height))\n\n          // reposition any height-overflow markers in our blocks\n          query('.height_overflow_message', this.div).style(\n            'top',\n            this.height - 16 + 'px',\n          )\n        }\n      },\n\n      setViewInfo: function (\n        genomeView,\n        heightUpdate,\n        numBlocks,\n        trackDiv,\n        widthPct,\n        widthPx,\n        scale,\n      ) {\n        this.genomeView = genomeView\n        this.heightUpdateCallback = heightUpdate\n        this.div = trackDiv\n        this.widthPct = widthPct\n        this.widthPx = widthPx\n\n        this.leftBlank = document.createElement('div')\n        this.leftBlank.className = 'blank-block'\n        this.rightBlank = document.createElement('div')\n        this.rightBlank.className = 'blank-block'\n        this.div.appendChild(this.rightBlank)\n        this.div.appendChild(this.leftBlank)\n\n        this.sizeInit(numBlocks, widthPct)\n        this.labelHTML = ''\n        this.labelHeight = 0\n\n        if (this.config.pinned) {this.setPinned(true)}\n\n        if (!this.label) {\n          this.makeTrackLabel()\n        }\n        this.setLabel(this.key)\n      },\n\n      makeTrackLabel: function () {\n        var params = {\n          className: 'track-label dojoDndHandle',\n          id: 'label_' + this.name,\n          style: {\n            position: 'absolute',\n          },\n        }\n\n        if (\n          typeof this.browser.config.trackLabels !== 'undefined' &&\n          this.browser.config.trackLabels === 'no-block'\n        ) {\n          params.style.top = '-30px'\n        }\n\n        var labelDiv = dojo.create('div', params, this.div)\n\n        this.label = labelDiv\n\n        if ((this.config.style || {}).trackLabelCss) {\n          labelDiv.style.cssText += ';' + this.config.style.trackLabelCss\n        }\n\n        var closeButton = dojo.create(\n          'div',\n          {\n            className: 'track-close-button',\n          },\n          labelDiv,\n        )\n        this.own(\n          on(\n            closeButton,\n            'click',\n            dojo.hitch(this, function (evt) {\n              this.browser.view.suppressDoubleClick(100)\n              this.browser.publish('/jbrowse/v1/v/tracks/hide', [this.config])\n              evt.stopPropagation()\n            }),\n          ),\n        )\n\n        var labelText = dojo.create(\n          'span',\n          { className: 'track-label-text' },\n          labelDiv,\n        )\n        var menuButton = dojo.create(\n          'div',\n          {\n            className: 'track-menu-button',\n          },\n          labelDiv,\n        )\n        dojo.create('div', {}, menuButton) // will be styled with an icon by CSS\n        this.labelMenuButton = menuButton\n\n        // make the track menu with things like 'save as'\n        this.makeTrackMenu()\n      },\n\n      hide: function () {\n        if (this.shown) {\n          this.div.style.display = 'none'\n          this.shown = false\n        }\n      },\n\n      show: function () {\n        if (!this.shown) {\n          this.div.style.display = 'block'\n          this.shown = true\n        }\n      },\n\n      initBlocks: function () {\n        this.blocks = new Array(this.numBlocks)\n        this.blockHeights = new Array(this.numBlocks)\n        for (var i = 0; i < this.numBlocks; i++) {this.blockHeights[i] = 0}\n        this.firstAttached = null\n        this.lastAttached = null\n        this._adjustBlanks()\n      },\n\n      clear: function () {\n        if (this.blocks) {\n          for (var i = 0; i < this.numBlocks; i++) {this._hideBlock(i)}\n        }\n        this.initBlocks()\n        this.makeTrackMenu()\n      },\n\n      setLabel: function (newHTML) {\n        if (this.label === undefined || this.labelHTML == newHTML) {return}\n\n        this.labelHTML = newHTML\n        query('.track-label-text', this.label).forEach(function (n) {\n          n.innerHTML = newHTML\n        })\n        this.labelHeight = this.label.offsetHeight\n      },\n\n      /**\n       * Stub.\n       */\n      transfer: function () {},\n\n      /**\n       *  Stub.\n       */\n      startZoom: function (destScale, destStart, destEnd) {},\n\n      /**\n       * Stub.\n       */\n      endZoom: function (destScale, destBlockBases) {},\n\n      showRange: function (\n        first,\n        last,\n        startBase,\n        bpPerBlock,\n        scale,\n        containerStart,\n        containerEnd,\n        finishCallback,\n      ) {\n        if (this.fatalError) {\n          this.showFatalError(this.fatalError)\n          return\n        }\n\n        if (this.blocks === undefined || !this.blocks.length) {return}\n\n        // this might make more sense in setViewInfo, but the label element\n        // isn't in the DOM tree yet at that point\n        if (this.labelHeight == 0 && this.label)\n          {this.labelHeight = this.label.offsetHeight}\n\n        this.inShowRange = true\n        this.height = this.labelHeight\n\n        var firstAttached =\n          null == this.firstAttached ? last + 1 : this.firstAttached\n        var lastAttached =\n          null == this.lastAttached ? first - 1 : this.lastAttached\n\n        var i, leftBase\n        var maxHeight = 0\n        var blockShowingPromises = []\n        //fill left, including existing blocks (to get their heights)\n        for (i = lastAttached; i >= first; i--) {\n          leftBase = startBase + bpPerBlock * (i - first)\n          blockShowingPromises.push(\n            new Promise((resolve, reject) => {\n              this._showBlock(\n                i,\n                leftBase,\n                leftBase + bpPerBlock,\n                scale,\n                containerStart,\n                containerEnd,\n                resolve,\n              )\n            }),\n          )\n        }\n        //fill right\n        for (i = lastAttached + 1; i <= last; i++) {\n          leftBase = startBase + bpPerBlock * (i - first)\n          blockShowingPromises.push(\n            new Promise((resolve, reject) => {\n              this._showBlock(\n                i,\n                leftBase,\n                leftBase + bpPerBlock,\n                scale,\n                containerStart,\n                containerEnd,\n                resolve,\n              )\n            }),\n          )\n        }\n        // if we have a finishing callback, call it when we have finished all our _showBlock calls\n        if (finishCallback)\n          {Promise.all(blockShowingPromises).then(finishCallback, finishCallback)}\n\n        //detach left blocks\n        var destBlock = this.blocks[first]\n        for (i = firstAttached; i < first; i++) {\n          this.transfer(\n            this.blocks[i],\n            destBlock,\n            scale,\n            containerStart,\n            containerEnd,\n          )\n          this.cleanupBlock(this.blocks[i])\n          this._hideBlock(i)\n        }\n        //detach right blocks\n        destBlock = this.blocks[last]\n        for (i = lastAttached; i > last; i--) {\n          this.transfer(\n            this.blocks[i],\n            destBlock,\n            scale,\n            containerStart,\n            containerEnd,\n          )\n          this.cleanupBlock(this.blocks[i])\n          this._hideBlock(i)\n        }\n\n        this.firstAttached = first\n        this.lastAttached = last\n        this._adjustBlanks()\n        this.inShowRange = false\n\n        this.heightUpdate(this.height)\n        this.updateStaticElements(this.genomeView.getPosition())\n      },\n\n      cleanupBlock: function (block) {\n        if (block) {block.destroy()}\n      },\n\n      /**\n       * Called when this track object is destroyed.  Cleans up things\n       * to avoid memory leaks.\n       */\n      destroy: function () {\n        array.forEach(\n          this.blocks || [],\n          function (block) {\n            this.cleanupBlock(block)\n          },\n          this,\n        )\n        delete this.blocks\n        delete this.div\n\n        this.inherited(arguments)\n      },\n\n      _hideBlock: function (blockIndex) {\n        if (this.blocks[blockIndex]) {\n          this.div.removeChild(this.blocks[blockIndex].domNode)\n          this.cleanupBlock(this.blocks[blockIndex])\n          this.blocks[blockIndex] = undefined\n          this.blockHeights[blockIndex] = 0\n        }\n      },\n\n      _adjustBlanks: function () {\n        if (this.firstAttached === null || this.lastAttached === null) {\n          this.leftBlank.style.left = '0px'\n          this.leftBlank.style.width = '50%'\n          this.rightBlank.style.left = '50%'\n          this.rightBlank.style.width = '50%'\n        } else {\n          this.leftBlank.style.width = this.firstAttached * this.widthPct + '%'\n          this.rightBlank.style.left =\n            (this.lastAttached + 1) * this.widthPct + '%'\n          this.rightBlank.style.width =\n            (this.numBlocks - this.lastAttached - 1) * this.widthPct + '%'\n        }\n      },\n\n      hideAll: function () {\n        if (null == this.firstAttached) {return}\n        for (var i = this.firstAttached; i <= this.lastAttached; i++)\n          {this._hideBlock(i)}\n\n        this.firstAttached = null\n        this.lastAttached = null\n        this._adjustBlanks()\n      },\n\n      // hides all blocks that overlap the given region/location\n      hideRegion: function (location) {\n        if (null == this.firstAttached) {return}\n        // hide all blocks that overlap the given region\n        for (var i = this.firstAttached; i <= this.lastAttached; i++)\n          {if (\n            this.blocks[i] &&\n            location.ref == this.refSeq.name &&\n            !(\n              this.blocks[i].leftBase > location.end ||\n              this.blocks[i].rightBase < location.start\n            )\n          )\n            {this._hideBlock(i)}}\n\n        this._adjustBlanks()\n      },\n\n      /**\n       *   _changeCallback invoked here is passed in constructor,\n       *         and typically is GenomeView.showVisibleBlocks()\n       */\n      changed: function () {\n        this.hideAll()\n        if (this._changedCallback) {this._changedCallback()}\n      },\n\n      _makeLoadingMessage: function () {\n        var msgDiv = dojo.create('div', {\n          className: 'loading',\n          innerHTML: '<div class=\"text\">Loading</span>',\n          title: 'Loading data...',\n          style: { visibility: 'hidden' },\n        })\n        window.setTimeout(function () {\n          msgDiv.style.visibility = 'visible'\n        }, 200)\n        return msgDiv\n      },\n\n      showFatalError: function (error) {\n        query('.block', this.div)\n          .concat(query('.blank-block', this.div))\n          .concat(query('.error', this.div))\n          .orphan()\n        this.blocks = []\n        this.blockHeights = []\n\n        this.fatalErrorMessageElement = this._renderErrorMessage(\n          error || this.fatalError,\n          this.div,\n        )\n        this.heightUpdate(domGeom.position(this.fatalErrorMessageElement).h)\n        this.updateStaticElements(this.genomeView.getPosition())\n      },\n\n      // generic handler for all types of errors\n      _handleError: function (error, viewArgs) {\n        var errorContext = dojo.mixin({}, error)\n        dojo.mixin(errorContext, viewArgs)\n\n        var isObject = typeof error == 'object'\n\n        if (isObject && error instanceof Errors.TimeOut && errorContext.block)\n          {this.fillBlockTimeout(\n            errorContext.blockIndex,\n            errorContext.block,\n            error,\n          )}\n        else if (isObject && error instanceof Errors.DataOverflow) {\n          if (errorContext.block)\n            {this.fillTooManyFeaturesMessage(\n              errorContext.blockIndex,\n              errorContext.block,\n              viewArgs.scale,\n              error,\n            )}\n          else\n            {array.forEach(\n              this.blocks,\n              function (block, blockIndex) {\n                if (block)\n                  {this.fillTooManyFeaturesMessage(\n                    blockIndex,\n                    block,\n                    viewArgs.scale,\n                    error,\n                  )}\n              },\n              this,\n            )}\n        } else {\n          console.error(error.stack || '' + error, error)\n          this.fatalError = error\n          this.showFatalError(error)\n        }\n      },\n\n      fillBlockError: function (blockIndex, block, error) {\n        error = error || this.fatalError || this.error\n\n        domConstruct.empty(block.domNode)\n        var msgDiv = this._renderErrorMessage(error, block.domNode)\n        this.heightUpdate(dojo.position(msgDiv).h, blockIndex)\n      },\n\n      _renderErrorMessage: function (message, parent) {\n        return domConstruct.create(\n          'div',\n          {\n            className: 'error',\n            innerHTML:\n              '<h2>Error</h2><div class=\"text\">An error was encountered when displaying this track.</div>' +\n              (message\n                ? '<div class=\"codecaption\">Diagnostic message</div><code>' +\n                  message +\n                  '</code>'\n                : ''),\n            title: 'An error occurred',\n          },\n          parent,\n        )\n      },\n\n      fillTooManyFeaturesMessage: function (blockIndex, block, scale, error) {\n        var message = (\n          (error && error.message) ||\n          'Too much data to show'\n        ).replace(/\\.$/, '')\n\n        this.fillMessage(\n          blockIndex,\n          block,\n          message +\n            (scale >= this.browser.view.maxPxPerBp\n              ? ''\n              : '; zoom in to see detail') +\n            '.',\n        )\n      },\n\n      redraw: function () {\n        this.clear()\n        this.genomeView.showVisibleBlocks(true)\n      },\n\n      markBlockHeightOverflow: function (block) {\n        if (block.heightOverflowed) {return}\n\n        block.heightOverflowed = true\n        domClass.add(block.domNode, 'height_overflow')\n        domConstruct.create(\n          'div',\n          {\n            className: 'height_overflow_message',\n            innerHTML: 'Max height reached',\n            style: {\n              top: this.height - 16 + 'px',\n              height: '16px',\n            },\n          },\n          block.domNode,\n        )\n      },\n\n      _showBlock: function (\n        blockIndex,\n        startBase,\n        endBase,\n        scale,\n        containerStart,\n        containerEnd,\n        finishCallback,\n      ) {\n        if (this.empty || this.fatalError) {\n          this.heightUpdate(this.labelHeight)\n          if (finishCallback) {finishCallback()}\n          return\n        }\n\n        if (this.blocks[blockIndex]) {\n          this.heightUpdate(this.blockHeights[blockIndex], blockIndex)\n          if (finishCallback) {finishCallback()}\n          return\n        }\n\n        var block = new Block({\n          startBase: startBase,\n          endBase: endBase,\n          scale: scale,\n          node: {\n            className: 'block',\n            style: {\n              left: blockIndex * this.widthPct + '%',\n              width: this.widthPct + '%',\n            },\n          },\n        })\n        this.blocks[blockIndex] = block\n        this.div.appendChild(block.domNode)\n\n        var args = [\n          blockIndex,\n          block,\n          this.blocks[blockIndex - 1],\n          this.blocks[blockIndex + 1],\n          startBase,\n          endBase,\n          scale,\n          this.widthPx,\n          containerStart,\n          containerEnd,\n        ]\n\n        if (this.fatalError) {\n          this.fillBlockError(blockIndex, block)\n          if (finishCallback) {finishCallback()}\n          return\n        }\n\n        // loadMessage is an opaque mask div that we place over the\n        // block until the fillBlock finishes\n        var loadMessage = this._makeLoadingMessage()\n        block.domNode.appendChild(loadMessage)\n\n        var finish = function () {\n          if (block && loadMessage.parentNode)\n            {block.domNode.removeChild(loadMessage)}\n          if (finishCallback) {finishCallback()}\n        }\n\n        var viewargs = {\n          blockIndex: blockIndex,\n          block: block,\n          leftBlock: this.blocks[blockIndex - 1],\n          rightBlock: this.blocks[blockIndex + 1],\n          leftBase: startBase,\n          rightBase: endBase,\n          scale: scale,\n          stripeWidth: this.widthPx,\n          containerStart: containerStart,\n          containerEnd: containerEnd,\n          finishCallback: finish,\n        }\n        try {\n          this.fillBlock(viewargs)\n        } catch (e) {\n          this._handleError(e, viewargs)\n          finish()\n        }\n      },\n\n      moveBlocks: function (delta) {\n        var newBlocks = new Array(this.numBlocks)\n        var newHeights = new Array(this.numBlocks)\n        var i\n        for (i = 0; i < this.numBlocks; i++) {newHeights[i] = 0}\n\n        var destBlock\n        if (\n          this.lastAttached + delta < 0 ||\n          this.firstAttached + delta >= this.numBlocks\n        ) {\n          this.firstAttached = null\n          this.lastAttached = null\n        } else {\n          this.firstAttached = Math.max(\n            0,\n            Math.min(this.numBlocks - 1, this.firstAttached + delta),\n          )\n          this.lastAttached = Math.max(\n            0,\n            Math.min(this.numBlocks - 1, this.lastAttached + delta),\n          )\n          if (delta < 0) {destBlock = this.blocks[this.firstAttached - delta]}\n          else {destBlock = this.blocks[this.lastAttached - delta]}\n        }\n\n        for (i = 0; i < this.blocks.length; i++) {\n          var newIndex = i + delta\n          if (newIndex < 0 || newIndex >= this.numBlocks) {\n            //We're not keeping this block around, so delete\n            //the old one.\n            if (destBlock && this.blocks[i])\n              {this.transfer(this.blocks[i], destBlock)}\n            this._hideBlock(i)\n          } else {\n            //move block\n            newBlocks[newIndex] = this.blocks[i]\n            if (newBlocks[newIndex])\n              {newBlocks[newIndex].domNode.style.left =\n                newIndex * this.widthPct + '%'}\n\n            newHeights[newIndex] = this.blockHeights[i]\n          }\n        }\n        this.blocks = newBlocks\n        this.blockHeights = newHeights\n        this._adjustBlanks()\n      },\n\n      sizeInit: function (numBlocks, widthPct, blockDelta) {\n        var i, oldLast\n        this.numBlocks = numBlocks\n        this.widthPct = widthPct\n        if (blockDelta) {this.moveBlocks(-blockDelta)}\n        if (this.blocks && this.blocks.length > 0) {\n          //if we're shrinking, clear out the end blocks\n          var destBlock = this.blocks[numBlocks - 1]\n          for (i = numBlocks; i < this.blocks.length; i++) {\n            if (destBlock && this.blocks[i])\n              {this.transfer(this.blocks[i], destBlock)}\n            this._hideBlock(i)\n          }\n          oldLast = this.blocks.length\n          this.blocks.length = numBlocks\n          this.blockHeights.length = numBlocks\n          //if we're expanding, set new blocks to be not there\n          for (i = oldLast; i < numBlocks; i++) {\n            this.blocks[i] = undefined\n            this.blockHeights[i] = 0\n          }\n          this.lastAttached = Math.min(this.lastAttached, numBlocks - 1)\n          if (this.firstAttached > this.lastAttached) {\n            //not sure if this can happen\n            this.firstAttached = null\n            this.lastAttached = null\n          }\n\n          if (this.blocks.length != numBlocks)\n            {throw new Error(\n              'block number mismatch: should be ' +\n                numBlocks +\n                '; blocks.length: ' +\n                this.blocks.length,\n            )}\n\n          for (i = 0; i < numBlocks; i++) {\n            if (this.blocks[i]) {\n              //if (!this.blocks[i].style) console.log(this.blocks);\n              this.blocks[i].domNode.style.left = i * widthPct + '%'\n              this.blocks[i].domNode.style.width = widthPct + '%'\n            }\n          }\n        } else {\n          this.initBlocks()\n        }\n\n        this.makeTrackMenu()\n      },\n\n      fillMessage: function (blockIndex, block, message, class_) {\n        domConstruct.empty(block.domNode)\n        var msgDiv = dojo.create(\n          'div',\n          {\n            className: class_ || 'message',\n            innerHTML: message,\n          },\n          block.domNode,\n        )\n        this.heightUpdate(\n          domGeom.getMarginBox(msgDiv, domStyle.getComputedStyle(msgDiv)).h,\n          blockIndex,\n        )\n      },\n\n      /**\n       * Called by GenomeView when the view is scrolled: communicates the\n       * new x, y, width, and height of the view.  This is needed by tracks\n       * for positioning stationary things like axis labels.\n       */\n      updateStaticElements: function (/**Object*/ coords) {\n        this.window_info = dojo.mixin(this.window_info || {}, coords)\n        if (this.fatalErrorMessageElement) {\n          this.fatalErrorMessageElement.style.width =\n            this.window_info.width * 0.6 + 'px'\n          if ('x' in coords)\n            {this.fatalErrorMessageElement.style.left =\n              coords.x + this.window_info.width * 0.2 + 'px'}\n        }\n\n        if (this.label && 'x' in coords) {this.label.style.left = coords.x + 'px'}\n      },\n\n      /**\n       * Render a dijit menu from a specification object.\n       *\n       * @param menuTemplate definition of the menu's structure\n       * @param context {Object} optional object containing the context\n       *   in which any click handlers defined in the menu should be\n       *   invoked, containing thing like what feature is being operated\n       *   upon, the track object that is involved, etc.\n       * @param parent {dijit.Menu|...} parent menu, if this is a submenu\n       */\n      _renderContextMenu: function (\n        /**Object*/ menuStructure,\n        /** Object */ context,\n        /** dijit.Menu */ parent,\n      ) {\n        if (!parent) {\n          parent = new dijitMenu()\n          this.own(parent)\n        }\n\n        for (var key in menuStructure) {\n          var spec = menuStructure[key]\n          try {\n            if (spec.children) {\n              var child = new dijitMenu()\n              parent.addChild(child)\n              parent.addChild(\n                new dijitPopupMenuItem({\n                  popup: child,\n                  label: spec.label,\n                }),\n              )\n              this._renderContextMenu(spec.children, context, child)\n            } else {\n              var menuConf = dojo.clone(spec)\n              if (menuConf.action || menuConf.url || menuConf.href) {\n                menuConf.onClick = this._makeClickHandler(spec, context)\n              }\n              // only draw other menu items if they do something when clicked.\n              // drawing menu items that do nothing when clicked\n              // would frustrate users.\n              if (menuConf.label && !menuConf.onClick) {menuConf.disabled = true}\n\n              // currently can only use preloaded types\n              var class_ =\n                {\n                  'dijit/MenuItem': dijitMenuItem,\n                  'dijit/CheckedMenuItem': dijitCheckedMenuItem,\n                  'dijit/RadioMenuItem': dijitRadioMenuItem,\n                  'dijit/MenuSeparator': dijitMenuSeparator,\n                }[spec.type] || dijitMenuItem\n\n              parent.addChild(new class_(menuConf))\n            }\n          } catch (e) {\n            console.error('failed to render menu item ' + key, e)\n          }\n        }\n        return parent\n      },\n\n      _makeClickHandler: function (inputSpec, context) {\n        var track = this\n\n        if (typeof inputSpec == 'function') {\n          inputSpec = { action: inputSpec }\n        } else if (typeof inputSpec == 'undefined') {\n          console.error(\n            'Undefined click specification, cannot make click handler',\n          )\n          return function () {}\n        } else if (inputSpec.action == 'defaultDialog') {\n          inputSpec.action = 'contentDialog'\n          inputSpec.content = dojo.hitch(this, 'defaultFeatureDetail')\n        }\n\n        var handler = function (evt) {\n          if (track.genomeView.dragging) {return}\n\n          var ctx = context || this\n          var spec = track._processMenuSpec(dojo.clone(inputSpec), ctx)\n          var url = spec.url || spec.href\n          spec.url = url\n          var style = dojo.clone(spec.style || {})\n\n          // try to understand the `action` setting\n          spec.action =\n            spec.action ||\n            (url ? 'iframeDialog' : spec.content ? 'contentDialog' : false)\n          spec.title = spec.title || spec.label\n\n          if (typeof spec.action == 'string') {\n            // treat `action` case-insensitively\n            spec.action = {\n              iframedialog: 'iframeDialog',\n              iframe: 'iframeDialog',\n              contentdialog: 'contentDialog',\n              content: 'contentDialog',\n              baredialog: 'bareDialog',\n              bare: 'bareDialog',\n              xhrdialog: 'xhrDialog',\n              xhr: 'xhrDialog',\n              newwindow: 'newWindow',\n              _blank: 'newWindow',\n              thiswindow: 'navigateTo',\n              navigateto: 'navigateTo',\n            }[('' + spec.action).toLowerCase()]\n\n            if (spec.action == 'newWindow') {window.open(url, '_blank')}\n            else if (spec.action == 'navigateTo') {window.location = url}\n            else if (\n              spec.action in\n              {\n                iframeDialog: 1,\n                contentDialog: 1,\n                xhrDialog: 1,\n                bareDialog: 1,\n              }\n            )\n              {track._openDialog(spec, evt, ctx)}\n          } else if (typeof spec.action == 'function') {\n            spec.action.call(ctx, evt)\n          } else {\n            return\n          }\n        }\n\n        // if there is a label, set it on the handler so that it's\n        // accessible for tooltips or whatever.\n        if (inputSpec.label) {handler.label = inputSpec.label}\n\n        return handler\n      },\n\n      /**\n       * @returns {Object} DOM element containing a rendering of the\n       *                   detailed metadata about this track\n       */\n      _trackDetailsContent: function (additional) {\n        var details = domConstruct.create('div', {\n          className: 'detail',\n        })\n        var fmt = lang.hitch(this, 'renderDetailField', details)\n        fmt('Name', this.key || this.name)\n        var metadata = lang.clone(this.getMetadata())\n        delete metadata.key\n        delete metadata.label\n        if (typeof metadata.conf == 'object') {delete metadata.conf}\n        if (\n          this.browser &&\n          this.browser.config &&\n          this.browser.config.trackSelector &&\n          this.browser.config.trackSelector.renameFacets\n        ) {\n          var metadataCopy = {}\n          for (var k in metadata) {\n            var key = this.browser.config.trackSelector.renameFacets[k] || k\n            metadataCopy[key] = metadata[k]\n          }\n          metadata = metadataCopy\n        }\n        var md_keys = []\n        for (var k in metadata) {\n          md_keys.push(k)\n        }\n        md_keys.sort(function (a, b) {\n          return a.toLowerCase().localeCompare(b.toLowerCase())\n        })\n        for (var i = 0; i < md_keys.length; i++) {\n          var k = md_keys[i]\n          fmt(this.camelToTitleCase(k), metadata[k])\n        }\n        for (var k in additional) {\n          fmt(k, additional[k])\n        }\n        return details\n      },\n\n      camelToTitleCase: function (str) {\n        if (str === str.toLowerCase()) {\n          return Util.ucFirst(str.replace(/_/g, ' '))\n        } else {\n          return str\n        }\n      },\n\n      getMetadata: function () {\n        return (\n          this.config.metadata ||\n          (this.browser &&\n            this.browser.trackMetaDataStore &&\n            this.browser.trackMetaDataStore.getItem(this.name)) ||\n          {}\n        )\n      },\n\n      setPinned: function (p) {\n        this.config.pinned = !!p\n\n        if (this.config.pinned) {domClass.add(this.div, 'pinned')}\n        else {domClass.remove(this.div, 'pinned')}\n\n        return this.config.pinned\n      },\n      isPinned: function () {\n        return !!this.config.pinned\n      },\n\n      /**\n       * @returns {Array} menu options for this track's menu (usually contains save as, etc)\n       */\n      _trackMenuOptions: function () {\n        var that = this\n        return [\n          {\n            label: 'About this track',\n            title: 'About track: ' + (this.key || this.name),\n            iconClass: 'jbrowseIconHelp',\n            action: 'contentDialog',\n            content: dojo.hitch(this, '_trackDetailsContent'),\n          },\n          {\n            label: 'Pin to top',\n            type: 'dijit/CheckedMenuItem',\n            title: 'make this track always visible at the top of the view',\n            checked: that.isPinned(),\n            //iconClass: 'dijitIconDelete',\n            onClick: function () {\n              that.browser.publish(\n                '/jbrowse/v1/v/tracks/' + (this.checked ? 'pin' : 'unpin'),\n                [that.name],\n              )\n            },\n          },\n          {\n            label: 'Edit config',\n            title: \"edit this track's configuration\",\n            iconClass: 'dijitIconConfigure',\n            action: function () {\n              new TrackConfigEditor(that.config).show(function (result) {\n                // replace this track's configuration\n                that.browser.publish('/jbrowse/v1/v/tracks/replace', [\n                  result.conf,\n                ])\n              })\n            },\n          },\n          {\n            label: 'Delete track',\n            title: 'delete this track',\n            iconClass: 'dijitIconDelete',\n            action: function () {\n              new ConfirmDialog({\n                title: 'Delete track?',\n                message: 'Really delete this track?',\n              }).show(function (confirmed) {\n                if (confirmed)\n                  {that.browser.publish('/jbrowse/v1/v/tracks/delete', [\n                    that.config,\n                  ])}\n              })\n            },\n          },\n        ]\n      },\n\n      _processMenuSpec: function (spec, context) {\n        for (var x in spec) {\n          if (spec.hasOwnProperty(x)) {\n            if (typeof spec[x] == 'object')\n              {spec[x] = this._processMenuSpec(spec[x], context)}\n            else\n              {spec[x] = this.template(\n                context.feature,\n                this._evalConf(context, spec[x], x),\n              )}\n          }\n        }\n        return spec\n      },\n\n      /**\n       * Get the value of a conf variable, evaluating it if it is a\n       * function.  Note: does not template it, that is a separate step.\n       *\n       * @private\n       */\n      _evalConf: function (context, confVal, confKey) {\n        // list of conf vals that should not be run immediately on the\n        // feature data if they are functions\n        var dontRunImmediately = {\n          action: 1,\n          click: 1,\n          content: 1,\n        }\n\n        return typeof confVal == 'function' && !dontRunImmediately[confKey]\n          ? confVal.apply(context, context.callbackArgs || [])\n          : confVal\n      },\n\n      /**\n       * Like getConf, but get a conf value that explicitly can vary\n       * feature by feature.  Provides a uniform function signature for\n       * user-defined callbacks.\n       */\n      getConfForFeature: function (path, feature) {\n        return this.getConf(path, [feature, path, null, null, this])\n      },\n\n      isFeatureHighlighted: function (feature, name) {\n        var highlight = this.browser.getHighlight()\n        return (\n          highlight &&\n          highlight.objectName &&\n          highlight.objectName == name &&\n          highlight.ref == this.refSeq.name &&\n          !(\n            feature.get('start') > highlight.end ||\n            feature.get('end') < highlight.start\n          )\n        )\n      },\n\n      _openDialog: function (spec, evt, context) {\n        context = context || {}\n        var type = spec.action\n        type = type.replace(/Dialog/, '')\n        var featureName =\n          context.feature &&\n          (context.feature.get('name') || context.feature.get('id'))\n        var dialogOpts = {\n          class: 'popup-dialog popup-dialog-' + type,\n          title:\n            spec.title ||\n            spec.label ||\n            (featureName ? featureName + ' details' : 'Details'),\n          style: dojo.clone(spec.style || {}),\n        }\n        if (spec.dialog) {declare.safeMixin(dialogOpts, spec.dialog)}\n\n        var dialog\n\n        function setContent(dialog, content) {\n          // content can be a promise or Deferred\n          if (typeof content.then == 'function')\n            {content.then(function (c) {\n              dialog.set('content', c)\n            })}\n          // or maybe it's just a regular object\n          else {dialog.set('content', content)}\n        }\n\n        // if dialog == xhr, open the link in a dialog\n        // with the html from the URL just shoved in it\n        if (type == 'xhr' || type == 'content') {\n          if (type == 'xhr') {dialogOpts.href = spec.url}\n\n          dialog = new InfoDialog(dialogOpts)\n          context.dialog = dialog\n\n          if (type == 'content')\n            {setContent(dialog, this._evalConf(context, spec.content, null))}\n\n          Util.removeAttribute(context, 'dialog')\n        } else if (type == 'bare') {\n          dialog = new Dialog(dialogOpts)\n          context.dialog = dialog\n\n          setContent(dialog, this._evalConf(context, spec.content, null))\n\n          Util.removeAttribute(context, 'dialog')\n        }\n        // open the link in a dialog with an iframe\n        else if (type == 'iframe') {\n          var iframeDims = function () {\n            var d = domGeom.position(this.browser.container)\n            return {\n              h: Math.round(d.h * 0.8),\n              w: Math.round(d.w * 0.8),\n            }\n          }.call(this)\n\n          dialog = new Dialog(dialogOpts)\n\n          var iframe = dojo.create('iframe', {\n            tabindex: '0',\n            width: iframeDims.w,\n            height: iframeDims.h,\n            style: { border: 'none' },\n            src: spec.url,\n          })\n\n          dialog.set('content', iframe)\n          if (!spec.hideIframeDialogUrl) {\n            dojo.create(\n              'a',\n              {\n                href: spec.url,\n                target: '_blank',\n                className: 'dialog-new-window',\n                title: 'open in new window',\n                onclick: dojo.hitch(dialog, 'hide'),\n                innerHTML: spec.url,\n              },\n              dialog.titleBar,\n            )\n          }\n          var updateIframeSize = function () {\n            // hitch a ride on the dialog box's\n            // layout function, which is called on\n            // initial display, and when the window\n            // is resized, to keep the iframe\n            // sized to fit exactly in it.\n            var cDims = domGeom.position(dialog.containerNode)\n            var width = cDims.w\n            var height = cDims.h - domGeom.position(dialog.titleBar).h\n            iframe.width = width\n            iframe.height = height\n          }\n          aspect.after(dialog, 'layout', updateIframeSize)\n          aspect.after(dialog, 'show', updateIframeSize)\n        }\n\n        // destroy the dialog after it is hidden\n        aspect.after(dialog, 'hide', function () {\n          setTimeout(function () {\n            dialog.destroyRecursive()\n          }, 500)\n        })\n\n        // show the dialog\n        dialog.show()\n      },\n\n      /**\n       * Given a string with template callouts, interpolate them with\n       * data from the given object.  For example, \"{foo}\" is replaced\n       * with whatever is returned by obj.get('foo')\n       */\n      template: function (/** Object */ obj, /** String */ template) {\n        if (typeof template != 'string' || !obj) {return template}\n\n        var valid = true\n        if (template) {\n          return template.replace(/\\{([^}]+)\\}/g, function (match, group) {\n            var val = obj ? obj.get(group.toLowerCase()) : undefined\n            if (val !== undefined) {return val}\n            else {\n              return ''\n            }\n          })\n        }\n        return undefined\n      },\n\n      /**\n       * Makes and installs the dropdown menu showing operations available for this track.\n       * @private\n       */\n      makeTrackMenu: function () {\n        var thisB = this\n        when(this._trackMenuOptions()).then(function (options) {\n          if (\n            options &&\n            options.length &&\n            thisB.label &&\n            thisB.labelMenuButton\n          ) {\n            // remove our old track menu if we have one\n            if (thisB.trackMenu) {thisB.trackMenu.destroyRecursive()}\n\n            // render and bind our track menu\n            var menu = thisB._renderContextMenu(options, {\n              menuButton: thisB.labelMenuButton,\n              track: thisB,\n              browser: thisB.browser,\n              refSeq: thisB.refSeq,\n            })\n            menu.startup()\n            menu.set('leftClickToOpen', true)\n            menu.bindDomNode(thisB.labelMenuButton)\n            menu.set('leftClickToOpen', false)\n            menu.bindDomNode(thisB.label)\n            thisB.trackMenu = menu\n            thisB.own(thisB.trackMenu)\n          }\n        })\n      },\n\n      // display a rendering-timeout message\n      fillBlockTimeout: function (blockIndex, block) {\n        domConstruct.empty(block.domNode)\n        domClass.add(block.domNode, 'timed_out')\n        this.fillMessage(\n          blockIndex,\n          block,\n          'This region took too long' +\n            ' to display, possibly because' +\n            ' it contains too much data.' +\n            ' Try zooming in to show a smaller region.',\n        )\n      },\n\n      renderRegionBookmark: function (args, bookmarks, renderLabels) {\n        var thisB = this\n        if (bookmarks.then) {\n          bookmarks.then(\n            function (books) {\n              array.forEach(\n                books.features,\n                function (bookmark) {\n                  if (bookmark.ref != this.refSeq.name) {return}\n                  var loc = new Location(\n                    bookmark.refseq +\n                      ':' +\n                      bookmark.start +\n                      '..' +\n                      bookmark.end,\n                  )\n                  this.renderRegionHighlight(\n                    args,\n                    loc,\n                    bookmark.color,\n                    renderLabels ? bookmark.label : null,\n                    renderLabels ? bookmark.rlabel : null,\n                  )\n                },\n                thisB,\n              )\n            },\n            function (error) {\n              console.log(\"Couldn't get bookmarks\")\n            },\n          )\n        } else {\n          array.forEach(\n            bookmarks.features,\n            function (bookmark) {\n              if (bookmark.ref != this.refSeq.name) {return}\n              var loc = new Location(\n                bookmark.refseq + ':' + bookmark.start + '..' + bookmark.end,\n              )\n              this.renderRegionHighlight(\n                args,\n                loc,\n                bookmark.color,\n                renderLabels ? bookmark.label : null,\n                renderLabels ? bookmark.rlabel : null,\n              )\n            },\n            this,\n          )\n        }\n      },\n\n      renderRegionHighlight: function (args, highlight, color, label, rlabel) {\n        // do nothing if the highlight does not overlap this region\n        if (highlight.start > args.rightBase || highlight.end < args.leftBase)\n          {return}\n\n        var block_span = args.rightBase - args.leftBase\n\n        var left = highlight.start\n        var right = highlight.end\n\n        // trim left and right to avoid making a huge element that can cause problems\n        var trimLeft = args.leftBase - left\n        if (trimLeft > 0) {\n          left += trimLeft\n        }\n        var trimRight = right - args.rightBase\n        if (trimRight > 0) {\n          right -= trimRight\n        }\n\n        var width = ((right - left) * 100) / block_span\n        left = ((left - args.leftBase) * 100) / block_span\n        var highlight = domConstruct.create(\n          'div',\n          {\n            className:\n              (color ? 'global_highlight_mod' : 'global_highlight') +\n              (trimLeft <= 0 ? ' left' : '') +\n              (trimRight <= 0 ? ' right' : ''),\n            style: {\n              left: left + '%',\n              width: width + '%',\n              height: '100%',\n              background: color,\n            },\n          },\n          args.block.domNode,\n        )\n\n        this.postRenderHighlight(highlight)\n\n        if (label) {\n          /*\n            //  vertical text, has bugs\n            if( trimLeft <= 0 ) {\n                domConstruct.create('div', { className:'verticaltext', style: { top: '50px', left: left+'%',transformOrigin: left+'%'+' top' }, innerHTML: label }, args.block.domNode);\n            }\n            if( trimRight <= 0 ) {\n                domConstruct.create('div', { className:'verticaltext', style: { top: '50px', left: left+width+'%',transformOrigin: left+width+'%'+' top' }, innerHTML: rlabel }, args.block.domNode);\n            }*/\n          if (trimLeft <= 0) {\n            var d1 = domConstruct.create(\n              'div',\n              {\n                className: 'horizontaltext',\n                style: {\n                  background: 'white',\n                  zIndex: 1000,\n                  left: left + '%',\n                },\n                innerHTML: label,\n              },\n              args.block.domNode,\n            )\n          }\n          if (trimRight <= 0) {\n            var d2 = domConstruct.create(\n              'div',\n              {\n                className: 'horizontaltext',\n                style: {\n                  background: 'white',\n                  zIndex: 1000,\n                  left: left + width + '%',\n                },\n                innerHTML: rlabel,\n              },\n              args.block.domNode,\n            )\n          }\n\n          var textWidth = d1.clientWidth + 1 + 'px'\n          d1.style.left = 'calc(' + left + '% - ' + textWidth + ')'\n        }\n      },\n      postRenderHighlight: function (node) {},\n    },\n  )\n})\n\n/*\n\nCopyright (c) 2007-2009 The Evolutionary Software Foundation\n\nCreated by Mitchell Skinner <mitch_skinner@berkeley.edu>\n\nThis package and its accompanying libraries are free software; you can\nredistribute it and/or modify it under the terms of the LGPL (either\nversion 2.1, or at your option, any later version) or the Artistic\nLicense 2.0.  Refer to LICENSE for the full license text.\n\n*/\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/Track/BlockBased/Block.js":{"size":876,"mtime":1738905962973,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/Track/BlockBased/Block.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define(['dojo/_base/declare', 'dijit/Destroyable', 'JBrowse/Util'], function (\n  declare,\n  Destroyable,\n  Util,\n) {\n  return declare(Destroyable, {\n    constructor: function (args) {\n      dojo.mixin(this, args)\n      var nodeArgs = this.node || {}\n      delete this.node\n      this.domNode = dojo.create('div', nodeArgs)\n      this.domNode.block = this\n    },\n\n    containsBp: function (bp) {\n      return this.startBase <= bp && this.endBase >= bp\n    },\n\n    bpToX: function (coord) {\n      //console.log(coord+\" \"+this.startBase+\" \"+this.scale+\" \"+(coord-this.startBase)*this.scale);\n      return (coord - this.startBase) * this.scale\n    },\n\n    toString: function () {\n      return this.startBase + '..' + this.endBase\n    },\n\n    destroy: function () {\n      if (this.domNode) {Util.removeAttribute(this.domNode, 'block')}\n      this.inherited(arguments)\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/Track/CanvasFeatures.js":{"size":39007,"mtime":1738905963008,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/Track/CanvasFeatures.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"/**\n * Feature track that draws features using HTML5 canvas elements.\n */\n\ndefine([\n  'dojo/_base/declare',\n  'dojo/_base/array',\n  'dojo/_base/lang',\n  'dojo/_base/event',\n  'dojo/mouse',\n  'dojo/dom-construct',\n  'dojo/Deferred',\n  'dojo/on',\n  'JBrowse/has',\n  'JBrowse/Util',\n  'JBrowse/View/GranularRectLayout',\n  'JBrowse/View/Track/BlockBased',\n  'JBrowse/View/Track/_ExportMixin',\n  'JBrowse/Errors',\n  'JBrowse/View/Track/_FeatureDetailMixin',\n  'JBrowse/View/Track/_FeatureContextMenusMixin',\n  'JBrowse/View/Track/_YScaleMixin',\n  'JBrowse/Model/Location',\n  'JBrowse/Model/SimpleFeature',\n], function (\n  declare,\n  array,\n  lang,\n  domEvent,\n  mouse,\n  domConstruct,\n  Deferred,\n  on,\n  has,\n  Util,\n  Layout,\n  BlockBasedTrack,\n  ExportMixin,\n  Errors,\n  FeatureDetailMixin,\n  FeatureContextMenuMixin,\n  YScaleMixin,\n  Location,\n  SimpleFeature,\n) {\n  /**\n   *  inner class that indexes feature layout rectangles (fRects) (which\n   *  include features) by unique ID.\n   *\n   *  We have one of these indexes in each block.\n   */\n  var FRectIndex = declare(null, {\n    constructor: function (args) {\n      var height = args.h\n      var width = args.w\n\n      this.dims = { h: height, w: width }\n\n      this.byID = {}\n    },\n\n    getByID: function (id) {\n      return this.byID[id]\n    },\n\n    addAll: function (fRects) {\n      var byID = this.byID\n      var cW = this.dims.w\n      var cH = this.dims.h\n      array.forEach(\n        fRects,\n        function (fRect) {\n          if (!fRect) {return}\n\n          // by ID\n          byID[fRect.f.id()] = fRect\n        },\n        this,\n      )\n    },\n\n    getAll: function () {\n      var fRects = []\n      for (var id in this.byID) {\n        fRects.push(this.byID[id])\n      }\n      return fRects\n    },\n  })\n\n  return declare(\n    [\n      BlockBasedTrack,\n      FeatureDetailMixin,\n      ExportMixin,\n      FeatureContextMenuMixin,\n      YScaleMixin,\n    ],\n    {\n      constructor: function (args) {\n        this.glyphsLoaded = {}\n        this.glyphsBeingLoaded = {}\n        this.regionStats = {}\n        this.showLabels = this.config.style.showLabels\n        this.showTooltips = this.config.style.showTooltips\n        this.displayMode = this.config.displayMode\n        //setup displayMode style cookie\n        var cookie = this.browser.cookie('track-' + this.name)\n        if (cookie) {\n          this.displayMode = cookie\n        }\n\n        this._setupEventHandlers()\n      },\n\n      _defaultConfig: function () {\n        return Util.deepUpdate(lang.clone(this.inherited(arguments)), {\n          maxFeatureScreenDensity: 0.5,\n          enableCollapsedMouseover: false,\n          disableCollapsedClick: false,\n\n          // default glyph class to use\n          glyph: lang.hitch(this, 'guessGlyphType'),\n\n          // maximum number of pixels on each side of a\n          // feature's bounding coordinates that a glyph is\n          // allowed to use\n          maxFeatureGlyphExpansion: 500,\n\n          // maximum height of the track, in pixels\n          maxHeight: 600,\n\n          histograms: {\n            description: 'feature density',\n            min: 0,\n            height: 100,\n            color: 'goldenrod',\n            clip_marker_color: 'red',\n          },\n\n          style: {\n            // not configured by users\n            _defaultHistScale: 4,\n            _defaultLabelScale: 30,\n            _defaultDescriptionScale: 120,\n\n            showLabels: true,\n            showTooltips: true,\n            label: 'name,id',\n            description: 'note, description',\n          },\n\n          displayMode: 'normal',\n\n          events: {\n            contextmenu: function (feature, fRect, block, track, evt) {\n              evt = domEvent.fix(evt)\n              if (fRect && fRect.contextMenu)\n                {fRect.contextMenu._openMyself({\n                  target: block.featureCanvas,\n                  coords: { x: evt.pageX, y: evt.pageY },\n                })}\n              domEvent.stop(evt)\n            },\n          },\n\n          menuTemplate: [\n            {\n              label: 'View details',\n              title: '{type} {name}',\n              action: 'contentDialog',\n              iconClass: 'dijitIconTask',\n              content: dojo.hitch(this, 'defaultFeatureDetail'),\n            },\n            {\n              label: function () {\n                return 'Zoom to this ' + (this.feature.get('type') || 'feature')\n              },\n              action: function () {\n                var ref = this.track.refSeq\n                var paddingBp = Math.round(\n                  10 /*pixels*/ / this.viewInfo.scale /* px/bp */,\n                )\n                var start = Math.max(\n                  ref.start,\n                  this.feature.get('start') - paddingBp,\n                )\n                var end = Math.min(ref.end, this.feature.get('end') + paddingBp)\n                this.track.genomeView.setLocation(ref, start, end)\n              },\n              iconClass: 'dijitIconConnector',\n            },\n            {\n              label: function () {\n                return (\n                  'Highlight this ' + (this.feature.get('type') || 'feature')\n                )\n              },\n              action: function () {\n                var loc = new Location({\n                  feature: this.feature,\n                  tracks: [this.track],\n                })\n                this.track.browser.setHighlightAndRedraw(loc)\n              },\n              iconClass: 'dijitIconFilter',\n            },\n          ],\n        })\n      },\n\n      setViewInfo: function (\n        genomeView,\n        heightUpdate,\n        numBlocks,\n        trackDiv,\n        widthPct,\n        widthPx,\n        scale,\n      ) {\n        this.inherited(arguments)\n        this.staticCanvas = domConstruct.create(\n          'canvas',\n          {\n            className: 'static-canvas',\n            style: {\n              height: '100%',\n              cursor: 'default',\n              position: 'absolute',\n              zIndex: 15,\n            },\n          },\n          trackDiv,\n        )\n        let ctx = this.staticCanvas.getContext('2d')\n        let ratio = Util.getResolution(\n          ctx,\n          this.browser.config.highResolutionMode,\n        )\n        this.staticCanvas.height = this.staticCanvas.offsetHeight * ratio\n\n        this._makeLabelTooltip()\n      },\n\n      guessGlyphType: function (feature) {\n        // first try to guess by its SO type\n        let guess = {\n          gene: 'Gene',\n          mRNA: 'ProcessedTranscript',\n          transcript: 'ProcessedTranscript',\n          ncRNA: 'UnprocessedTranscript',\n          lncRNA: 'UnprocessedTranscript',\n          lnc_RNA: 'UnprocessedTranscript',\n          miRNA: 'UnprocessedTranscript',\n        }[feature.get('type')]\n\n        // otherwise, make it Segments if it has children,\n        // a BED if it has block_count/thick_start,\n        // or a Box otherwise\n        if (!guess) {\n          let children = feature.children()\n          if (children && children.length) {guess = 'Segments'}\n          else if (feature.get('block_count') || feature.get('thick_start'))\n            {guess = 'UCSC/BED'}\n          else {guess = 'Box'}\n        }\n\n        return 'JBrowse/View/FeatureGlyph/' + guess\n      },\n\n      fillBlock: function (args) {\n        var blockIndex = args.blockIndex\n        var block = args.block\n        var leftBase = args.leftBase\n        var rightBase = args.rightBase\n        var scale = args.scale\n\n        if (!has('canvas')) {\n          this.fatalError =\n            'This browser does not support HTML canvas elements.'\n          this.fillBlockError(blockIndex, block, this.fatalError)\n          return\n        }\n\n        var fill = lang.hitch(this, function (stats) {\n          // calculate some additional view parameters that\n          // might depend on the feature stats and add them to\n          // the view args we pass down\n          var renderArgs = lang.mixin(\n            {\n              stats: stats,\n              displayMode: this.displayMode,\n              showFeatures:\n                scale >=\n                (this.config.style.featureScale ||\n                  (stats.featureDensity || 0) /\n                    this.config.maxFeatureScreenDensity),\n              showLabels:\n                this.showLabels &&\n                this.displayMode == 'normal' &&\n                scale >=\n                  (this.config.style.labelScale ||\n                    (stats.featureDensity || 0) *\n                      this.config.style._defaultLabelScale),\n              showDescriptions:\n                this.showLabels &&\n                this.displayMode == 'normal' &&\n                scale >=\n                  (this.config.style.descriptionScale ||\n                    (stats.featureDensity || 0) *\n                      this.config.style._defaultDescriptionScale),\n            },\n            args,\n          )\n\n          if (renderArgs.showFeatures) {\n            this.setLabel(this.key)\n            this.removeYScale()\n            this.noYScale = true\n            this.fillFeatures(renderArgs)\n          } else if (\n            this.config.histograms.store ||\n            this.store.getRegionFeatureDensities\n          ) {\n            this.noYScale = false\n            this.fillHistograms(renderArgs)\n          } else {\n            this.setLabel(this.key)\n            this.fillTooManyFeaturesMessage(blockIndex, block, scale)\n            args.finishCallback()\n          }\n        })\n\n        this.store.getGlobalStats(\n          fill,\n          dojo.hitch(this, function (e) {\n            this._handleError(e, args)\n            args.finishCallback(e)\n          }),\n        )\n      },\n\n      // override the base error handler to try to draw histograms if\n      // it's a data overflow error and we know how to draw histograms\n      _handleError: function (error, viewArgs) {\n        if (\n          typeof error == 'object' &&\n          error instanceof Errors.DataOverflow &&\n          (this.config.histograms.store || this.store.getRegionFeatureDensities)\n        ) {\n          this.fillHistograms(viewArgs)\n        } else {this.inherited(arguments)}\n      },\n\n      // create the layout if we need to, and if we can\n      _getLayout: function (scale) {\n        if (!this.layout || this._layoutpitchX != 1 / scale) {\n          // if no layoutPitchY configured, calculate it from the\n          // height and marginBottom (parseInt in case one or both are functions), or default to 3 if the\n          // calculation didn't result in anything sensible.\n          var pitchY = this.getConf('layoutPitchY') || 4\n          this.layout = new Layout({\n            pitchX: 1 / scale,\n            pitchY: pitchY,\n            maxHeight: this.getConf('maxHeight'),\n            displayMode: this.displayMode,\n          })\n          this._layoutpitchX = 1 / scale\n        }\n\n        return this.layout\n      },\n\n      _clearLayout: function () {\n        delete this.layout\n      },\n\n      hideAll: function () {\n        this._clearLayout()\n        return this.inherited(arguments)\n      },\n\n      /**\n       * Returns a promise for the appropriate glyph for the given\n       * feature and args.\n       */\n      getGlyph: function (viewArgs, feature, callback, errorCallback) {\n        var glyphClassName = this.getConfForFeature('glyph', feature)\n        var glyph, interestedParties\n        if ((glyph = this.glyphsLoaded[glyphClassName])) {\n          callback(glyph)\n        } else if (\n          (interestedParties = this.glyphsBeingLoaded[glyphClassName])\n        ) {\n          interestedParties.push(callback)\n        } else {\n          var thisB = this\n          this.glyphsBeingLoaded[glyphClassName] = [callback]\n\n          dojo.global.require([glyphClassName], function (GlyphClass) {\n            if (typeof GlyphClass == 'string') {\n              thisB.fatalError = 'could not load glyph ' + glyphClassName\n              thisB.redraw()\n              return\n            }\n            // if this require came back after we are already destroyed, just ignore it\n            if (thisB.destroyed) {return}\n\n            glyph = thisB.glyphsLoaded[glyphClassName] = new GlyphClass({\n              track: thisB,\n              config: thisB.config,\n              browser: thisB.browser,\n            })\n\n            array.forEach(\n              thisB.glyphsBeingLoaded[glyphClassName],\n              function (cb) {\n                cb(glyph)\n              },\n            )\n\n            delete thisB.glyphsBeingLoaded[glyphClassName]\n          })\n        }\n      },\n\n      fillHistograms: function (args) {\n        // set the track label if we have a description\n        if (this.config.histograms.description) {\n          this.setLabel(\n            this.key +\n              ' <span class=\"feature-density\">(' +\n              this.config.histograms.description +\n              ')</span>',\n          )\n        } else {\n          this.setLabel(this.key)\n        }\n\n        const numBins = this.config.histograms.binsPerBlock || 25\n        const blockSizeBp = Math.abs(args.rightBase - args.leftBase)\n        const basesPerBin = blockSizeBp / numBins\n        const query = {\n          ref: this.refSeq.name,\n          start: args.leftBase,\n          end: args.rightBase,\n          basesPerSpan: basesPerBin,\n          basesPerBin: basesPerBin,\n          viewAsPairs: this.config.viewAsPairs,\n          viewAsSpans: this.config.viewAsSpans,\n          maxInsertSize: this.config.maxInsertSize,\n        }\n\n        const handleError = this._handleError.bind(this)\n        if (\n          !this.config.histograms.store &&\n          this.store.getRegionFeatureDensities\n        ) {\n          this.store.getRegionFeatureDensities(\n            query,\n            this._drawHistograms.bind(this, args),\n            e => {\n              console.log(e)\n              this._handleError(new Error(e.message), args)\n            },\n          )\n        } else {\n          const histData = { features: [], stats: {} }\n          this.browser.getStore(this.config.histograms.store, histStore => {\n            histStore.getGlobalStats(stats => {\n              histData.stats.max = stats.scoreMax\n              histStore.getFeatures(\n                query,\n                feature => {\n                  histData.features.push(feature)\n                },\n                () => {\n                  this._drawHistograms(args, histData)\n                  args.finishCallback()\n                },\n                handleError,\n              )\n            }, handleError)\n          })\n        }\n      },\n\n      _scaleCanvas(c, pxWidth = c.width, pxHeight = c.height) {\n        let ctx = c.getContext('2d')\n\n        let ratio = Util.getResolution(\n          ctx,\n          this.browser.config.highResolutionMode,\n        )\n\n        c.width = pxWidth * ratio\n        c.height = pxHeight * ratio\n\n        c.style.width = pxWidth + 'px'\n        c.style.height = pxHeight + 'px'\n\n        // now scale the context to counter\n        // the fact that we've manually scaled\n        // our canvas element\n        ctx.setTransform(1, 0, 0, 1, 0, 0)\n        ctx.scale(ratio, ratio)\n      },\n\n      _drawHistograms: function (viewArgs, histData) {\n        if (this.noYScale) {\n          return\n        }\n\n        var maxScore =\n          'max' in this.config.histograms\n            ? this.config.histograms.max\n            : (histData.stats || {}).max\n\n        // don't do anything if we don't know the score max\n        if (maxScore === undefined) {\n          console.warn(\n            'no stats.max in hist data, not drawing histogram for block ' +\n              viewArgs.blockIndex,\n          )\n          return\n        }\n\n        // don't do anything if we have no hist features\n        var features\n        if (\n          !(\n            (features = histData.features) ||\n            (histData.bins &&\n              (features = this._histBinsToFeatures(viewArgs, histData)))\n          )\n        )\n          {return}\n\n        var block = viewArgs.block\n        var height = this.config.histograms.height\n        var scale = viewArgs.scale\n        var leftBase = viewArgs.leftBase\n        var minVal = this.config.histograms.min\n\n        domConstruct.empty(block.domNode)\n        var c = (block.featureCanvas = domConstruct.create(\n          'canvas',\n          {\n            height: height,\n            width: block.domNode.offsetWidth + 1,\n            style: {\n              cursor: 'default',\n              height: height + 'px',\n              position: 'absolute',\n            },\n            innerHTML: 'Your web browser cannot display this type of track.',\n            className: 'canvas-track canvas-track-histograms',\n          },\n          block.domNode,\n        ))\n        this.heightUpdate(height, viewArgs.blockIndex)\n        var ctx = c.getContext('2d')\n\n        // scale the canvas to work well with the various device pixel ratios\n        this._scaleCanvas(c)\n\n        ctx.fillStyle = this.config.histograms.color\n        for (var i = 0; i < features.length; i++) {\n          var feature = features[i]\n          var barHeight = (feature.get('score') / maxScore) * height\n          var barWidth = Math.ceil(\n            (feature.get('end') - feature.get('start')) * scale,\n          )\n          var barLeft = Math.round((feature.get('start') - leftBase) * scale)\n          ctx.fillRect(barLeft, height - barHeight, barWidth, barHeight)\n          if (barHeight > height) {\n            ctx.fillStyle = this.config.histograms.clip_marker_color\n            ctx.fillRect(barLeft, 0, barWidth, 3)\n            ctx.fillStyle = this.config.histograms.color\n          }\n        }\n\n        // make the y-axis scale for our histograms\n        this.makeHistogramYScale(height, minVal, maxScore)\n      },\n\n      _histBinsToFeatures: function (viewArgs, histData) {\n        var bpPerBin = parseFloat(histData.stats.basesPerBin)\n        var leftBase = viewArgs.leftBase\n\n        return array.map(histData.bins, function (bin, i) {\n          return new SimpleFeature({\n            data: {\n              start: leftBase + i * bpPerBin,\n              end: leftBase + (i + 1) * bpPerBin,\n              score: bin,\n            },\n          })\n        })\n      },\n\n      makeHistogramYScale: function (height, minVal, maxVal) {\n        if (\n          this.yscale_params &&\n          this.yscale_params.height == height &&\n          this.yscale_params.max == maxVal &&\n          this.yscale_params.min == minVal\n        )\n          {return}\n\n        this.yscale_params = {\n          height: height,\n          min: minVal,\n          max: maxVal,\n        }\n        this.makeYScale({ min: minVal, max: maxVal })\n      },\n\n      fillFeatures: function (args) {\n        var blockIndex = args.blockIndex\n        var block = args.block\n        var blockWidthPx = block.domNode.offsetWidth\n        var scale = args.scale\n        var leftBase = args.leftBase\n        var rightBase = args.rightBase\n        var finishCallback = args.finishCallback\n\n        const fRects = []\n\n        // count of how many features are queued up to be laid out\n        let featuresInProgress = 0\n        // promise that resolved when all the features have gotten laid out by their glyphs\n        const featuresLaidOut = new Deferred()\n        // flag that tells when all features have been read from the\n        // store (not necessarily laid out yet)\n        let allFeaturesRead = false\n\n        const errorCallback = e => {\n          this._handleError(e, args)\n          finishCallback(e)\n        }\n\n        const layout = this._getLayout(scale)\n\n        // query for a slightly larger region than the block, so that\n        // we can draw any pieces of glyphs that overlap this block,\n        // but the feature of which does not actually lie in the block\n        // (long labels that extend outside the feature's bounds, for\n        // example)\n        const bpExpansion = Math.round(\n          this.config.maxFeatureGlyphExpansion / scale,\n        )\n\n        const region = {\n          ref: this.refSeq.name,\n          start: Math.max(0, leftBase - bpExpansion),\n          end: rightBase + bpExpansion,\n          viewAsPairs: this.config.viewAsPairs,\n          viewAsSpans: this.config.viewAsSpans,\n          maxInsertSize: this.config.maxInsertSize,\n        }\n\n        const featCallback = feature => {\n          if (this.destroyed || !this.filterFeature(feature)) {return}\n          fRects.push(null) // put a placeholder in the fRects array\n          featuresInProgress++\n          var rectNumber = fRects.length - 1\n\n          // get the appropriate glyph object to render this feature\n          this.getGlyph(\n            args,\n            feature,\n            glyph => {\n              // have the glyph attempt\n              // to add a rendering of\n              // this feature to the\n              // layout\n              var fRect = glyph.layoutFeature(args, layout, feature)\n              if (fRect === null) {\n                // could not lay out, would exceed our configured maxHeight\n                // mark the block as exceeding the max height\n                block.maxHeightExceeded = true\n              } else {\n                // laid out successfully\n                if (!(fRect.l >= blockWidthPx || fRect.l + fRect.w < 0))\n                  {fRects[rectNumber] = fRect}\n              }\n\n              // this might happen after all the features have been sent from the store\n              if (!--featuresInProgress && allFeaturesRead) {\n                featuresLaidOut.resolve()\n              }\n            },\n            errorCallback,\n          )\n        }\n\n        this.store.getFeatures(\n          region,\n          featCallback,\n          // callback when all features sent\n          () => {\n            if (this.destroyed) {return}\n\n            allFeaturesRead = true\n            if (!featuresInProgress && !featuresLaidOut.isFulfilled()) {\n              featuresLaidOut.resolve()\n            }\n\n            featuresLaidOut.then(() => {\n              const totalHeight = layout.getTotalHeight()\n              const c = (block.featureCanvas = domConstruct.create(\n                'canvas',\n                {\n                  height: totalHeight,\n                  width: block.domNode.offsetWidth + 1,\n                  style: {\n                    cursor: 'default',\n                    height: totalHeight + 'px',\n                    position: 'absolute',\n                  },\n                  innerHTML:\n                    'Your web browser cannot display this type of track.',\n                  className: 'canvas-track',\n                },\n                block.domNode,\n              ))\n              const ctx = c.getContext('2d')\n              // scale the canvas to work well with the various device pixel ratios\n              this._scaleCanvas(c)\n\n              if (block.maxHeightExceeded) {this.markBlockHeightOverflow(block)}\n\n              this.heightUpdate(totalHeight, blockIndex)\n\n              this.renderFeatures(args, fRects)\n\n              this.renderClickMap(args, fRects)\n\n              finishCallback()\n            })\n          },\n          errorCallback,\n        )\n      },\n\n      startZoom: function () {\n        this.zooming = true\n        this.inherited(arguments)\n\n        array.forEach(this.blocks, function (b) {\n          try {\n            b.featureCanvas.style.width = '100%'\n          } catch (e) {}\n        })\n      },\n\n      endZoom: function () {\n        array.forEach(this.blocks, function (b) {\n          try {\n            delete b.featureCanvas.style.width\n          } catch (e) {}\n        })\n\n        this.clear()\n        this.inherited(arguments)\n        this.zooming = false\n      },\n\n      renderClickMap: function (args, fRects) {\n        var block = args.block\n\n        // make an index of the fRects by ID, and by coordinate, and\n        // store it in the block\n        var index = new FRectIndex({\n          h: block.featureCanvas.height,\n          w: block.featureCanvas.width,\n        })\n        block.fRectIndex = index\n        index.addAll(fRects)\n\n        if (!block.featureCanvas || !block.featureCanvas.getContext('2d')) {\n          console.warn('No 2d context available from canvas')\n          return\n        }\n\n        this._attachMouseOverEvents()\n        if (\n          this.displayMode != 'collapsed' ||\n          !this.config.disableCollapsedClick\n        ) {\n          // connect up the event handlers\n          this._connectEventHandlers(block)\n        }\n\n        this.updateStaticElements({ x: this.browser.view.getX() })\n      },\n\n      _attachMouseOverEvents: function () {\n        var gv = this.browser.view\n        var thisB = this\n\n        if (\n          this.displayMode == 'collapsed' &&\n          !this.config.enableCollapsedMouseover\n        ) {\n          if (this._mouseoverEvent) {\n            this._mouseoverEvent.remove()\n            delete this._mouseoverEvent\n          }\n\n          if (this._mouseoutEvent) {\n            this._mouseoutEvent.remove()\n            delete this._mouseoutEvent\n          }\n        } else if (\n          this.displayMode != 'collapsed' ||\n          this.config.enableCollapsedMouseover\n        ) {\n          if (!this._mouseoverEvent) {\n            this._mouseoverEvent = this.own(\n              on(this.staticCanvas, 'mousemove', function (evt) {\n                evt = domEvent.fix(evt)\n                var bpX = gv.absXtoBp(evt.clientX)\n                var feature = thisB.layout.getByCoord(\n                  bpX,\n                  evt.offsetY === undefined ? evt.layerY : evt.offsetY,\n                )\n                thisB.mouseoverFeature(feature, evt)\n              }),\n            )[0]\n          }\n\n          if (!this._mouseoutEvent) {\n            this._mouseoutEvent = this.own(\n              on(this.staticCanvas, 'mouseout', function (evt) {\n                thisB.mouseoverFeature(undefined)\n              }),\n            )[0]\n          }\n        }\n      },\n\n      _makeLabelTooltip: function () {\n        if (!this.showTooltips || this.labelTooltip) {return}\n\n        var labelTooltip = (this.labelTooltip = domConstruct.create(\n          'div',\n          {\n            className: 'featureTooltip',\n            style: {\n              position: 'fixed',\n              display: 'none',\n              zIndex: 19,\n            },\n          },\n          this.browser.container,\n        ))\n        domConstruct.create(\n          'span',\n          {\n            className: 'tooltipLabel',\n            style: {\n              display: 'block',\n            },\n          },\n          labelTooltip,\n        )\n        domConstruct.create(\n          'span',\n          {\n            className: 'tooltipDescription',\n            style: {\n              display: 'block',\n            },\n          },\n          labelTooltip,\n        )\n      },\n\n      _connectEventHandlers: function (block) {\n        for (var event in this.eventHandlers) {\n          var handler = this.eventHandlers[event]\n          ;(function (event, handler) {\n            var thisB = this\n            block.own(\n              on(this.staticCanvas, event, function (evt) {\n                evt = domEvent.fix(evt)\n                var bpX = thisB.browser.view.absXtoBp(evt.clientX)\n                if (block.containsBp(bpX)) {\n                  var feature = thisB.layout.getByCoord(\n                    bpX,\n                    evt.offsetY === undefined ? evt.layerY : evt.offsetY,\n                  )\n                  if (feature) {\n                    var fRect = block.fRectIndex.getByID(feature.id())\n                    handler.call(\n                      {\n                        track: thisB,\n                        feature: feature,\n                        fRect: fRect,\n                        block: block,\n                        callbackArgs: [thisB, feature, fRect],\n                      },\n                      feature,\n                      fRect,\n                      block,\n                      thisB,\n                      evt,\n                    )\n                  }\n                }\n              }),\n            )\n          }).call(this, event, handler)\n        }\n      },\n\n      getRenderingContext: function (viewArgs) {\n        if (!viewArgs.block || !viewArgs.block.featureCanvas) {return null}\n        try {\n          var ctx = viewArgs.block.featureCanvas.getContext('2d')\n          // ctx.translate( viewArgs.block.offsetLeft - this.featureCanvas.offsetLeft, 0 );\n          // console.log( viewArgs.blockIndex, 'block offset', viewArgs.block.offsetLeft - this.featureCanvas.offsetLeft );\n          return ctx\n        } catch (e) {\n          console.error(e, e.stack)\n          return null\n        }\n      },\n\n      // draw the features on the canvas\n      renderFeatures: function (args, fRects) {\n        var context = this.getRenderingContext(args)\n        if (context) {\n          var thisB = this\n          array.forEach(fRects, function (fRect) {\n            if (fRect) {thisB.renderFeature(context, fRect)}\n          })\n        }\n      },\n\n      // given viewargs and a feature object, highlight that feature in\n      // all blocks.  if feature is undefined or null, unhighlight any currently\n      // highlighted feature\n      mouseoverFeature: function (feature, evt) {\n        if (this.lastMouseover == feature) {return}\n\n        if (evt) {var bpX = this.browser.view.absXtoBp(evt.clientX)}\n\n        if (this.labelTooltip) {this.labelTooltip.style.display = 'none'}\n\n        array.forEach(\n          this.blocks,\n          function (block, i) {\n            if (!block) {return}\n            var context = this.getRenderingContext({\n              block: block,\n              leftBase: block.startBase,\n              scale: block.scale,\n            })\n            if (!context) {return}\n\n            if (this.lastMouseover && block.fRectIndex) {\n              var r = block.fRectIndex.getByID(this.lastMouseover.id())\n              if (r) {this.renderFeature(context, r)}\n            }\n\n            if (block.tooltipTimeout) {window.clearTimeout(block.tooltipTimeout)}\n\n            if (feature) {\n              var fRect =\n                block.fRectIndex && block.fRectIndex.getByID(feature.id())\n              if (!fRect) {return}\n\n              if (block.containsBp(bpX)) {\n                var renderTooltip = dojo.hitch(this, function () {\n                  if (!this.labelTooltip) {return}\n\n                  var context = lang.mixin({\n                    track: this,\n                    feature: feature,\n                    callbackArgs: [this, feature],\n                  })\n                  var text\n                  text = this.template(\n                    feature,\n                    this._evalConf(\n                      context,\n                      (this.config.onClick || {}).label,\n                      'label',\n                    ),\n                  )\n                  var label =\n                    fRect.label ||\n                    fRect.glyph.makeFeatureLabel(feature, undefined, text)\n                  text = this.template(\n                    feature,\n                    this._evalConf(\n                      context,\n                      (this.config.onClick || {}).label,\n                      'description',\n                    ),\n                  )\n                  var description =\n                    fRect.description ||\n                    fRect.glyph.makeFeatureDescriptionLabel(\n                      feature,\n                      undefined,\n                      text,\n                    )\n\n                  if (!label && !description) {return}\n\n                  if (!this.ignoreTooltipTimeout) {\n                    this.labelTooltip.style.left = evt.clientX + 'px'\n                    this.labelTooltip.style.top = evt.clientY + 15 + 'px'\n                  }\n                  this.ignoreTooltipTimeout = true\n                  this.labelTooltip.style.display = 'block'\n                  var labelSpan = this.labelTooltip.childNodes[0]\n                  var descriptionSpan = this.labelTooltip.childNodes[1]\n\n                  if (this.config.onClick && this.config.onClick.label) {\n                    labelSpan.style.display = 'block'\n                    labelSpan.style.font = label.font\n                    labelSpan.style.color = label.fill\n                    var t = this.template(\n                      feature,\n                      this._evalConf(\n                        context,\n                        this.config.onClick.label,\n                        'label',\n                      ),\n                    )\n                    labelSpan.innerHTML = this.config.unsafeMouseover\n                      ? t\n                      : Util.escapeHTML(t)\n                    return\n                  }\n                  if (label) {\n                    labelSpan.style.display = 'block'\n                    labelSpan.style.font = label.font\n                    labelSpan.style.color = label.fill\n                    labelSpan.innerHTML = this.config.unsafeMouseover\n                      ? label.text\n                      : Util.escapeHTML(label.text)\n                  } else {\n                    labelSpan.style.display = 'none'\n                    labelSpan.innerHTML = '(no label)'\n                  }\n                  if (description) {\n                    descriptionSpan.style.display = 'block'\n                    descriptionSpan.style.font = description.font\n                    descriptionSpan.style.color = description.fill\n                    descriptionSpan.innerHTML = this.config.unsafeMouseover\n                      ? description.text\n                      : Util.escapeHTML(description.text)\n                  } else {\n                    descriptionSpan.style.display = 'none'\n                    descriptionSpan.innerHTML = '(no description)'\n                  }\n                })\n                if (this.ignoreTooltipTimeout) {renderTooltip()}\n                else\n                  {block.tooltipTimeout = window.setTimeout(renderTooltip, 600)}\n              }\n\n              fRect.glyph.mouseoverFeature(context, fRect)\n              this._refreshContextMenu(fRect)\n            } else {\n              block.tooltipTimeout = window.setTimeout(\n                dojo.hitch(this, function () {\n                  this.ignoreTooltipTimeout = false\n                }),\n                200,\n              )\n            }\n          },\n          this,\n        )\n\n        this.lastMouseover = feature\n      },\n\n      cleanupBlock: function (block) {\n        this.inherited(arguments)\n\n        // garbage collect the layout\n        if (block && this.layout)\n          {this.layout.discardRange(block.startBase, block.endBase)}\n      },\n\n      // draw each feature\n      renderFeature: function (context, fRect) {\n        fRect.glyph.renderFeature(context, fRect)\n      },\n\n      _trackMenuOptions: function () {\n        var opts = this.inherited(arguments)\n        var thisB = this\n\n        var displayModeList = ['normal', 'compact', 'collapsed']\n        this.displayModeMenuItems = displayModeList.map(function (displayMode) {\n          return {\n            label: displayMode,\n            type: 'dijit/CheckedMenuItem',\n            title: 'Render this track in ' + displayMode + ' mode',\n            checked: thisB.displayMode == displayMode,\n            onClick: function () {\n              thisB.displayMode = displayMode\n              thisB._clearLayout()\n              thisB.hideAll()\n              thisB.genomeView.showVisibleBlocks(true)\n              thisB.makeTrackMenu()\n              // set cookie for displayMode\n              thisB.browser.cookie('track-' + thisB.name, thisB.displayMode)\n            },\n          }\n        })\n\n        var updateMenuItems = dojo.hitch(this, function () {\n          for (var index in this.displayModeMenuItems) {\n            this.displayModeMenuItems[index].checked =\n              this.displayMode == this.displayModeMenuItems[index].label\n          }\n        })\n\n        opts.push.apply(opts, [\n          { type: 'dijit/MenuSeparator' },\n          {\n            label: 'Display mode',\n            iconClass: 'dijitIconPackage',\n            title: 'Make features take up more or less space',\n            children: this.displayModeMenuItems,\n          },\n          {\n            label: 'Show labels',\n            type: 'dijit/CheckedMenuItem',\n            checked: !!('showLabels' in this\n              ? this.showLabels\n              : this.config.style.showLabels),\n            onClick: function (event) {\n              thisB.showLabels = this.checked\n              thisB.changed()\n            },\n          },\n        ])\n\n        return opts\n      },\n\n      _exportFormats: function () {\n        return [\n          { name: 'GFF3', label: 'GFF3', fileExt: 'gff3' },\n          { name: 'BED', label: 'BED', fileExt: 'bed' },\n          {\n            name: 'SequinTable',\n            label: 'Sequin Table',\n            fileExt: 'sqn',\n          },\n        ]\n      },\n\n      updateStaticElements: function (coords) {\n        this.inherited(arguments)\n\n        this.updateYScaleFromViewDimensions(coords)\n\n        if (coords.hasOwnProperty('x')) {\n          var context = this.staticCanvas.getContext('2d')\n          let ratio = Util.getResolution(\n            context,\n            this.browser.config.highResolutionMode,\n          )\n          this.staticCanvas.width = this.browser.view.elem.clientWidth * ratio\n          this.staticCanvas.style.width =\n            this.browser.view.elem.clientWidth + 'px'\n          this.staticCanvas.style.left = coords.x + 'px'\n          context.setTransform(1, 0, 0, 1, 0, 0)\n          context.scale(ratio, ratio)\n          context.clearRect(\n            0,\n            0,\n            this.staticCanvas.width,\n            this.staticCanvas.height,\n          )\n\n          var minVisible = this.browser.view.minVisible()\n          var maxVisible = this.browser.view.maxVisible()\n          var viewArgs = {\n            minVisible: minVisible,\n            maxVisible: maxVisible,\n            bpToPx: dojo.hitch(this.browser.view, 'bpToPx'),\n            lWidth: this.label.offsetWidth,\n          }\n\n          this.blocks.forEach(block => {\n            if (!block || !block.fRectIndex || this.zooming) {return}\n\n            var idx = block.fRectIndex.byID\n            for (var id in idx) {\n              var fRect = idx[id]\n              fRect.glyph.updateStaticElements(context, fRect, viewArgs)\n            }\n          })\n        }\n      },\n\n      heightUpdate: function (height, blockIndex) {\n        this.inherited(arguments)\n        if (this.staticCanvas) {\n          let ratio = Util.getResolution(\n            this.staticCanvas.getContext('2d'),\n            this.browser.config.highResolutionMode,\n          )\n          this.staticCanvas.height = this.staticCanvas.offsetHeight * ratio\n        }\n      },\n\n      destroy: function () {\n        this.destroyed = true\n\n        domConstruct.destroy(this.staticCanvas)\n        delete this.staticCanvas\n\n        delete this.layout\n        delete this.glyphsLoaded\n        this.inherited(arguments)\n      },\n    },\n  )\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/Track/CanvasVariants.js":{"size":900,"mtime":1738905963011,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/Track/CanvasVariants.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/Track/Combination.js":{"size":40880,"mtime":1738905963045,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/Track/Combination.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'dojo/_base/lang',\n  'dojo/on',\n  'dojo/dom-construct',\n  'dojo/dom-class',\n  'dojo/Deferred',\n  'dojo/promise/all',\n  'dojo/when',\n  './Combination/CombinationDialog',\n  'dijit/Dialog',\n  'JBrowse/View/Track/BlockBased',\n  'JBrowse/Model/BinaryTreeNode',\n  'dojo/dnd/move',\n  'dojo/dnd/Source',\n  'dojo/dnd/Manager',\n  'JBrowse/Util',\n  'JBrowse/View/TrackConfigEditor',\n  'JBrowse/View/Track/_ExportMixin',\n], function (\n  declare,\n  lang,\n  on,\n  dom,\n  domClass,\n  Deferred,\n  all,\n  when,\n  CombinationDialog,\n  Dialog,\n  BlockBased,\n  TreeNode,\n  dndMove,\n  dndSource,\n  dndManager,\n  Util,\n  TrackConfigEditor,\n  ExportMixin,\n) {\n  return declare([BlockBased, ExportMixin], {\n    /**\n     * Creates a track with a drag-and-drop interface allowing users to drag other tracks into it.\n     * Users select (using a dialog) a way to combine these tracks, and they are combined.\n     * Certain tracks (e.g. HTMLFeatures tracks) may be combined set-theoretically (union, intersection,etc ),\n     * while others (e.g. BigWig tracks) may be combined quantitatively (add scores, subtract scores, etc...).\n     * If one of the tracks is a set-based track and the other is not, track masking operations may be applied.\n     * @constructs\n     */\n    constructor: function (args) {\n      // The \"default\" track of each type is the one at\n      // index 0 of the resultsTypes array.\n      // Many different kinds of tracks can be added.\n      // Each is supported by a different store, and\n      // some can be rendered in several ways.\n      // The trackClasses object stores information about what can be done with each of these types.\n      this.trackClasses = {\n        set: {\n          resultsTypes: [\n            {\n              name: 'HTMLFeatures',\n              path: 'JBrowse/View/Track/HTMLFeatures',\n            },\n          ],\n          store: 'JBrowse/Store/SeqFeature/Combination',\n          allowedOps: ['&', 'U', 'X', 'S'],\n          defaultOp: '&',\n        },\n        quantitative: {\n          resultsTypes: [\n            {\n              name: 'XYPlot',\n              path: 'JBrowse/View/Track/Wiggle/XYPlot',\n            },\n            {\n              name: 'Density',\n              path: 'JBrowse/View/Track/Wiggle/Density',\n            },\n          ],\n          store: 'JBrowse/Store/SeqFeature/QuantitativeCombination',\n          allowedOps: ['+', '-', '*', '/'],\n          defaultOp: '+',\n        },\n        mask: {\n          resultsTypes: [\n            {\n              name: 'XYPlot',\n              path: 'JBrowse/View/Track/Wiggle/XYPlot',\n            },\n            {\n              name: 'Density',\n              path: 'JBrowse/View/Track/Wiggle/Density',\n            },\n          ],\n          store: 'JBrowse/Store/SeqFeature/Mask',\n          allowedOps: ['M', 'N'],\n          defaultOp: 'M',\n        },\n        BAM: {\n          resultsTypes: [\n            {\n              name: 'Detail',\n              path: 'JBrowse/View/Track/Alignments2',\n            },\n            {\n              name: 'Summary',\n              path: 'JBrowse/View/Track/SNPCoverage', //For now\n            },\n          ],\n          store: 'JBrowse/Store/SeqFeature/BAMCombination',\n          allowedOps: ['U'],\n          defaultOp: 'U',\n        },\n      }\n\n      this.errorCallback = dojo.hitch(this, function (error) {\n        this._handleError(error, {})\n      })\n\n      // inWords just stores, in words, what each possible operation does.  This is helpful for dialogs and menus that\n      // allow selection of different operations.\n      this.inWords = {\n        // These one-character codes symbolize operations between stores.\n        '+': 'addition',\n        '-': 'subtraction',\n        '*': 'multiplication',\n        '/': 'division',\n        '&': 'intersection',\n        U: 'union',\n        X: 'XOR',\n        S: 'set subtraction',\n        M: 'regular mask',\n        N: 'inverse mask',\n        // These four-digit codes are used by the CombinationDialog object to differentiate different types of masking operations.\n        '0000': 'combine without masking',\n        '0020': 'use new track as mask',\n        '0002': 'use old track as mask',\n        1111: 'merge tracks',\n        1001: \"add new track to old track's displayed data\",\n        1010: \"add new track to old track's mask\",\n        '0101': \"add old track to new track's displayed data\",\n        '0110': \"add old track to new track's mask\",\n      }\n\n      // Each store becomes associated with the name of a track that uses that store, so that users can read more easily.\n      if (!this.config.storeToKey) {this.config.storeToKey = {}}\n\n      // Shows which track or store types qualify as set-based, quantitative, etc.\n      this.supportedBy = {\n        'JBrowse/View/Track/HTMLFeatures': 'set',\n        'JBrowse/View/Track/HTMLVariants': 'set',\n        'JBrowse/View/Track/CanvasFeatures': 'set',\n        'JBrowse/View/Track/CanvasVariants': 'set',\n        CanvasFeatures: 'set',\n        HTMLFeatures: 'set',\n        HTMLVariants: 'set',\n        CanvasVariants: 'set',\n        'NeatCanvasFeatures/View/Track/NeatFeatures': 'set',\n        'NeatHTMLFeatures/View/Track/NeatFeatures': 'set',\n        'JBrowse/View/Track/Alignments2': 'BAM',\n        'JBrowse/View/Track/SNPCoverage': 'BAM',\n        'JBrowse/Store/BigWig': 'quantitative',\n        'JBrowse/Store/SeqFeature/BigWig': 'quantitative',\n        'JBrowse/Store/SeqFeature/BAM': 'BAM',\n        'JBrowse/Store/SeqFeature/BAMCombination': 'BAM',\n        'JBrowse/Store/SeqFeature/Combination': 'set',\n        'JBrowse/Store/SeqFeature/QuantitativeCombination': 'quantitative',\n        'JBrowse/Store/SeqFeature/Mask': 'mask',\n      }\n\n      this.loaded = true\n\n      // For CSS customization of the outer\n      this.divClass = args.divClass || 'combination'\n\n      // Sets a bunch of variables to their initial values\n      this.reinitialize()\n\n      // When other tracks are dragged onto the combination, they don't disappear from their respective sources\n      // (in case the user wants to add the track separately, by itself).  These variables will be used in the DnD\n      // methods to support this functionality\n      this.currentDndSource = undefined\n      this.sourceWasCopyOnly = undefined\n\n      // This is used to avoid creating a feedback loop in the height-updating process.\n      this.onlyRefreshOuter = false\n\n      this.heightResults = 0\n\n      this.height = args.height || 0\n\n      // This variable (which will later be a deferred) ensures that when multiple tracks are added simultaneously,\n      // The dialogs for each one don't render all at once.\n      this.lastDialogDone = [true]\n    },\n\n    setViewInfo: function (\n      genomeView,\n      heightUpdate,\n      numBlocks,\n      trackDiv,\n      widthPct,\n      widthPx,\n      scale,\n    ) {\n      this.inherited(arguments)\n      domClass.add(this.div, 'combination_track empty')\n\n      this.scale = scale\n\n      // This track has a dnd source (to support dragging tracks into and out of it).\n      this.dnd = new dndSource(this.div, {\n        accept: ['track'], //Accepts only tracks\n        isSource: false,\n        withHandles: true,\n        creator: dojo.hitch(this, function (trackConfig, hint) {\n          // Renders the results track div (or avatar, depending).\n          // Code for ensuring that we don't have several results tracks\n          // is handled later in the file.\n          var data = trackConfig\n          if (trackConfig.resultsTrack) {\n            data = trackConfig.resultsTrack\n            data.storeToKey = trackConfig.storeToKey\n          }\n          return {\n            data: data,\n            type: ['track'],\n            node: this.addTrack(data),\n          }\n        }),\n      })\n\n      // Attach dnd events\n      this._attachDndEvents()\n\n      // If config contains a config for the results track, use it. (This allows reloading when the track config is edited. )\n      if (this.config.resultsTrack) {\n        this.reloadStoreNames = true\n        this.dnd.insertNodes(false, [this.config.resultsTrack])\n      }\n    },\n\n    // This function ensure that the combination track's drag-and-drop interface works correctly.\n    _attachDndEvents: function () {\n      var thisB = this\n\n      // What to do at the beginning of dnd process\n      on(thisB.dnd, 'DndStart', function (source, nodes, copy) {\n        // Stores the information about whether the source was copy-only, for future reference\n        thisB.currentDndSource = source\n        thisB.sourceWasCopyOnly = source.copyOnly\n      })\n\n      // When other tracks are dragged onto the combination, they don't disappear from their respective sources\n      on(thisB.dnd, 'DraggingOver', function () {\n        if (thisB.currentDndSource) {\n          // Tracks being dragged onto this track are copied, not moved.\n          thisB.currentDndSource.copyOnly = true\n        }\n        this.currentlyOver = true\n      })\n\n      var dragEndingEvents = ['DraggingOut', 'DndDrop', 'DndCancel']\n\n      for (var eventName in dragEndingEvents)\n        {on(thisB.dnd, dragEndingEvents[eventName], function () {\n          if (thisB.currentDndSource) {\n            // Makes sure that the dndSource isn't permanently set to CopyOnly\n            thisB.currentDndSource.copyOnly = thisB.sourceWasCopyOnly\n          }\n          this.currentlyOver = false\n        })}\n\n      // Bug fixer\n      dojo.subscribe(\n        '/dnd/drop/before',\n        function (source, nodes, copy, target) {\n          if (target == thisB.dnd && nodes[0]) {\n            thisB.dnd.current = null\n          }\n        },\n      )\n\n      on(thisB.dnd, 'OutEvent', function () {\n        // Fixes a glitch wherein the trackContainer is disabled when the track we're dragging leaves the combination track\n        dndManager.manager().overSource(thisB.genomeView.trackDndWidget)\n      })\n\n      on(thisB.dnd, 'DndSourceOver', function (source) {\n        // Fixes a glitch wherein tracks dragged into the combination track sometimes go to the trackContainer instead.\n        if (source != this && this.currentlyOver) {\n          dndManager.manager().overSource(this)\n        }\n      })\n\n      // Further restricts what categories of tracks may be added to this track\n      // Should re-examine this\n\n      var oldCheckAcceptance = this.dnd.checkAcceptance\n      this.dnd.checkAcceptance = function (source, nodes) {\n        // If the original acceptance checker fails, this one will too.\n        var accept = oldCheckAcceptance.call(thisB.dnd, source, nodes)\n\n        // Additional logic to disqualify bad tracks - if one node is unacceptable, the whole group is disqualified\n        for (var i = 0; accept && nodes[i]; i++) {\n          var trackConfig = source.getItem(nodes[i].id).data\n          accept =\n            accept &&\n            (trackConfig.resultsTrack ||\n              thisB.supportedBy[trackConfig.storeClass] ||\n              thisB.supportedBy[trackConfig.type])\n        }\n\n        return accept\n      }\n    },\n\n    // Reset a bunch of variables\n    reinitialize: function () {\n      if (this.dnd) {\n        this.dnd.selectAll().deleteSelectedNodes()\n      }\n\n      // While there is no results track, we cannot export.\n      this.config.noExport = true\n      this.exportFormats = []\n\n      this.resultsDiv = undefined\n      this.resultsTrack = undefined\n      this.storeType = undefined\n      this.oldType = undefined\n      this.classIndex = {}\n      this.storeToShow = 0\n      this.displayStore = undefined\n      this.maskStore = undefined\n      this.store = undefined\n      this.opTree = undefined\n    },\n\n    // Modifies the results track when a new track is added\n    addTrack: function (trackConfig) {\n      // Connect the track's name to its store for easy reading by user\n      if (trackConfig && trackConfig.key && trackConfig.store) {\n        this.config.storeToKey[trackConfig.store] = trackConfig.key\n      }\n\n      if (trackConfig && trackConfig.storeToKey) {\n        lang.mixin(this.config.storeToKey, trackConfig.storeToKey)\n      }\n\n      // Creates the results div, if it hasn't already been created\n      if (!this.resultsDiv) {\n        this.resultsDiv = dom.create('div')\n        this.resultsDiv.className = 'track'\n        this.resultsDiv.id = this.name + '_resultsDiv'\n        domClass.remove(this.div, 'empty')\n      }\n\n      // Carry on the process of adding the track\n      this._addTrackStore(trackConfig)\n\n      // Because _addTrackStore has deferreds, the dnd node must be returned before it is filled\n      return this.resultsDiv\n    },\n\n    // Obtains the store of the track that was just added.\n    _addTrackStore: function (trackConfig) {\n      var storeName = trackConfig.store\n      var thisB = this\n      var haveStore = (function () {\n        var d = new Deferred()\n        thisB.browser.getStore(storeName, function (store) {\n          if (store) {\n            d.resolve(store, true)\n          } else {\n            d.reject('store ' + storeName + ' not found', true)\n          }\n        })\n        return d.promise\n      })()\n      // Once we have the store, it's time to open the dialog.\n      haveStore.then(function (store) {\n        thisB.runDialog(trackConfig, store)\n      })\n    },\n\n    // Runs the dialog that asks the user how to combine the track.\n    runDialog: function (trackConfig, store) {\n      // If this is the first track being added, it's not being combined with anything, so we don't need to ask - just adds the track alone\n      if (this.storeType === undefined) {\n        // Figure out which type of track (set, quant, etc) the user is adding\n        this.currType =\n          this.supportedBy[trackConfig.storeClass] ||\n          this.supportedBy[trackConfig.type]\n        this.storeType = this.currType\n        // What type of Combination store corresponds to the track just added\n        this.storeClass = this.trackClasses[this.currType].store\n\n        // opTree can be directly reloaded from track config.  This is important (e.g.) when changing reference sequences\n        // to make sure that the right combinations of tracks are still included in this track.\n        if (store.isCombinationStore && !store.opTree && this.config.opTree) {\n          this.loadTree(this.config.opTree).then(\n            dojo.hitch(this, function (tree) {\n              this.opTree = tree\n              this.displayType = this.config.displayType\n              if (\n                this.getClassIndex(this.displayType || this.storeType) ==\n                undefined\n              ) {\n                this.setTrackClass(\n                  trackConfig.type,\n                  this.displayType || this.storeType,\n                )\n              }\n              this._adjustStores(\n                store,\n                this.oldType,\n                this.currType,\n                this.config.store,\n                this.config.maskStore,\n                this.config.displayStore,\n              )\n            }),\n          )\n          return\n        }\n        var opTree = store.isCombinationStore\n          ? store.opTree.clone()\n          : new TreeNode({ Value: store, leaf: true })\n        this.displayType =\n          this.currType == 'mask'\n            ? this.supportedBy[store.stores.display.config.type]\n            : undefined\n        if (\n          this.getClassIndex(this.displayType || this.storeType) == undefined\n        ) {\n          this.setTrackClass(\n            trackConfig.type,\n            this.displayType || this.storeType,\n          )\n        }\n        this.opTree = opTree\n        if (this.reloadStoreNames) {\n          this.reloadStoreNames = false\n          this._adjustStores(\n            store,\n            this.oldType,\n            this.currType,\n            this.config.store,\n            this.config.maskStore,\n            this.config.displayStore,\n          )\n          return\n        }\n        this._adjustStores(store, this.oldType, this.currType)\n        return\n      }\n      var d = new Deferred()\n\n      this.lastDialogDone.push(d)\n      // Once the last dialog has closed, opens a new one\n      when(\n        this.lastDialogDone.shift(),\n        dojo.hitch(this, function () {\n          if (this.preferencesDialog) {this.preferencesDialog.destroyRecursive()}\n          // Figure out which type of track (set, quant, etc) the user is adding\n          this.currType =\n            this.supportedBy[trackConfig.storeClass] ||\n            this.supportedBy[trackConfig.type]\n          this.oldType = this.storeType\n          // What type of Combination store corresponds to the track just added\n          this.storeClass = this.trackClasses[this.currType].store\n          this.preferencesDialog = new CombinationDialog({\n            trackConfig: trackConfig,\n            store: store,\n            track: this,\n          })\n          // Once the results of the dialog are back, uses them to continue the process of rendering the results track\n          this.preferencesDialog.run(\n            dojo.hitch(this, function (opTree, newstore, displayType) {\n              this.opTree = opTree\n              this.displayType = displayType\n              this.storeType =\n                this.oldType == 'mask' ||\n                this.opTree.get() == 'M' ||\n                this.opTree.get() == 'N'\n                  ? 'mask'\n                  : this.currType\n              if (\n                this.getClassIndex(this.displayType || this.storeType) ==\n                undefined\n              ) {\n                this.setTrackClass(\n                  trackConfig.type,\n                  this.displayType || this.storeType,\n                )\n              }\n              this._adjustStores(newstore, this.oldType, this.currType)\n              d.resolve(true)\n            }),\n            dojo.hitch(this, function () {\n              d.resolve(true)\n            }),\n          )\n        }),\n      )\n    },\n\n    // If this track contains masked data, it uses three stores.  Otherwise, it uses one.\n    // This function ensures that all secondary stores (one for the mask, one for the display) have been loaded.\n    // If not, it loads them itself.  This function tries not to waste stores - if a store of a certain type already exists,\n    // it uses it rather than creating a new one.\n    _adjustStores: function (\n      store,\n      oldType,\n      currType,\n      storeName,\n      maskStoreName,\n      displayStoreName,\n    ) {\n      var d = new Deferred()\n      if (oldType == 'mask') {\n        this.maskStore.reload(this.opTree.leftChild)\n        this.displayStore.reload(this.opTree.rightChild)\n        this.store.reload(this.opTree, this.maskStore, this.displayStore)\n        d.resolve(true)\n      } else if (\n        currType == 'mask' ||\n        this.opTree.get() == 'M' ||\n        this.opTree.get() == 'N'\n      ) {\n        var haveMaskStore = this._createStore('set', maskStoreName)\n        haveMaskStore.then(\n          dojo.hitch(this, function (newstore) {\n            this.maskStore = newstore\n            this.maskStore.reload(this.opTree.leftChild)\n          }),\n        )\n        var haveDisplayStore = this._createStore(\n          this.displayType,\n          displayStoreName,\n        )\n\n        haveDisplayStore.then(\n          dojo.hitch(this, function (newStore) {\n            this.displayStore = newStore\n            this.displayStore.reload(this.opTree.rightChild)\n          }),\n        )\n        this.store = undefined\n        d = all([haveMaskStore, haveDisplayStore])\n      } else {\n        d.resolve(true)\n      }\n      d.then(\n        dojo.hitch(this, function () {\n          this.createStore(storeName)\n        }),\n      )\n    },\n\n    // Checks if the primary store has been created yet.  If it hasn't, calls \"_createStore\" and makes it.\n    createStore: function (storeName) {\n      var d = new Deferred()\n      var thisB = this\n\n      if (!this.store) {\n        d = this._createStore(undefined, storeName)\n      } else {\n        d.resolve(this.store, true)\n      }\n      d.then(function (store) {\n        // All stores are now in place.  Make sure the operation tree of the store matches that of this track,\n        // and then we can render the results track.\n        thisB.store = store\n        thisB.store.reload(thisB.opTree, thisB.maskStore, thisB.displayStore)\n        thisB.renderResultsTrack()\n      })\n    },\n\n    // Creates a store config and passes it to the browser, which creates the store and returns its name.\n    _createStore: function (storeType, storeName) {\n      var d = new Deferred()\n      if (!storeName) {\n        var storeConf = this._storeConfig(storeType)\n        storeName = this.browser.addStoreConfig(undefined, storeConf)\n        storeConf.name = storeName\n      }\n\n      this.browser.getStore(storeName, function (store) {\n        d.resolve(store, true)\n      })\n      return d.promise\n    },\n\n    // Uses the current settings of the combination track to create a store\n    _storeConfig: function (storeType) {\n      if (!storeType) {storeType = this.storeType}\n      var storeClass = this.trackClasses[storeType].store\n      this.config.storeClass = storeClass\n\n      var op = this.trackClasses[storeType].defaultOp\n      return {\n        browser: this.browser,\n        refSeq: this.browser.refSeq.name,\n        type: storeClass,\n        op: op,\n      }\n    },\n\n    // This method is particularly useful when masked data is being displayed, and returns data which depends on\n    // which of (data, mask, masked data) is being currently displayed.\n    _visible: function () {\n      var which = [this.displayType || this.storeType, 'set', this.displayType]\n\n      var allTypes = [\n        { store: this.store, tree: this.opTree },\n        {\n          store: this.maskStore,\n          tree: this.opTree ? this.opTree.leftChild : undefined,\n        },\n        {\n          store: this.displayStore,\n          tree: this.opTree ? this.opTree.rightChild : undefined,\n        },\n      ]\n      for (var i in which) {\n        allTypes[i].which = which[i]\n        if (which[i]) {\n          var storeType = i == 0 && this.storeType == 'mask' ? 'mask' : which[i]\n          allTypes[i].allowedOps = this.trackClasses[storeType].allowedOps\n          allTypes[i].trackType =\n            this.trackClasses[which[i]].resultsTypes[\n              this.getClassIndex(which[i]) || 0\n            ].path\n        }\n      }\n      if (this.storeType != 'mask') {return allTypes[0]}\n      return allTypes[this.storeToShow]\n    },\n\n    // Time to actually render the results track.\n    renderResultsTrack: function () {\n      if (this.resultsTrack) {\n        // Destroys the results track currently in place if it exists. We're going to create a new one.\n        this.resultsTrack.clear()\n        this.resultsTrack.destroy()\n        while (this.resultsDiv.firstChild) {\n          // Use dojo.empty instead?\n          this.resultsDiv.removeChild(this.resultsDiv.firstChild)\n        }\n      }\n      // Checks one last time to ensure we have a store before proceeding\n      if (this._visible().store) {\n        // Gets the path of the track to create\n        var trackClassName = this._visible().trackType\n        var trackClass\n\n        var thisB = this\n        var config = this._resultsTrackConfig(trackClassName)\n\n        trackClassName = config.type\n\n        // Once we have the object for the type of track we're creating, call this.\n        var makeTrack = function () {\n          // Construct a track with the relevant parameters\n          thisB.resultsTrack = new trackClass({\n            config: config,\n            browser: thisB.browser,\n            changeCallback: thisB._changedCallback,\n            refSeq: thisB.refSeq,\n            store: thisB._visible().store,\n            trackPadding: 0,\n          })\n\n          // Removes all options from the results track's context menu.\n          thisB.resultsTrackMenuOptions = thisB.resultsTrack._trackMenuOptions\n\n          thisB.resultsTrack._trackMenuOptions = function () {\n            return []\n          }\n\n          // This will be what happens when the results track updates its height - makes necessary changes to\n          // outer track's height and then passes up to the heightUpdate callback specified as a parameter to this object\n          var resultsHeightUpdate = function (height) {\n            thisB.resultsDiv.style.height = height + 'px'\n            thisB.heightResults = height\n            thisB.height = height\n            thisB.onlyRefreshOuter = true\n            thisB.refresh()\n            thisB.onlyRefreshOuter = false\n            thisB.heightUpdate(thisB.height)\n            thisB.div.style.height = thisB.height + 'px'\n          }\n\n          // setViewInfo on results track\n          thisB.resultsTrack.setViewInfo(\n            thisB.genomeView,\n            resultsHeightUpdate,\n            thisB.numBlocks,\n            thisB.resultsDiv,\n            thisB.widthPct,\n            thisB.widthPx,\n            thisB.scale,\n          )\n\n          // Only do this when the masked data is selected\n          // (we don't want editing the config to suddenly remove the data or the mask)\n          thisB.config.opTree = thisB.flatten(thisB.opTree)\n          thisB.config.store = thisB.store.name\n          thisB.config.maskStore = thisB.maskStore\n            ? thisB.maskStore.name\n            : undefined\n          thisB.config.displayStore = thisB.displayStore\n            ? thisB.displayStore.name\n            : undefined\n\n          if (thisB._visible().store == thisB.store) {\n            // Refresh results track config, so that the track can be recreated when the config is edited\n            thisB.config.resultsTrack = thisB.resultsTrack.config\n            thisB.config.displayType = thisB.displayType\n\n            thisB.browser.replaceTracks([thisB.config])\n\n            if (typeof thisB.resultsTrack._exportFormats == 'function') {\n              thisB.config.noExport = false\n              thisB.exportFormats = thisB.resultsTrack._exportFormats()\n            } else {\n              thisB.config.noExport = true\n            }\n          }\n\n          thisB.refresh()\n        }\n\n        // Loads the track class from the specified path\n        dojo.global.require([trackClassName], function (tc) {\n          trackClass = tc\n          if (trackClass) {makeTrack()}\n        })\n      }\n    },\n\n    // Generate the config of the results track\n    _resultsTrackConfig: function (trackClass) {\n      var config = {\n        store: this.store.name,\n        storeClass: this.store.config.type,\n        feature: ['match'],\n        key: 'Results',\n        label: this.name + '_results',\n        metadata: {\n          description: 'This track was created from a combination track.',\n        },\n        type: trackClass,\n        autoscale: 'local',\n      }\n\n      if (this.config.resultsTrack) {\n        if (\n          (this.config.resultsTrack.storeClass == config.storeClass ||\n            this.supportedBy[this.config.resultsTrack.storeClass] ==\n              this.displayType) &&\n          this._visible().store != this.maskStore\n        ) {\n          config = this.config.resultsTrack\n          config.store = this.store.name\n          config.storeClass = this.store.config.type\n          return config\n        }\n        config.key = this.config.resultsTrack.key\n        config.label = this.config.resultsTrack.label\n        config.metadata = this.config.resultsTrack.metadata\n      }\n      return config\n    },\n\n    // Refresh what the user sees on the screen for this track\n    refresh: function (track) {\n      if (!track) {\n        track = this\n      }\n      if (this._visible().store && !this.onlyRefreshOuter) {\n        // Reload the store if it's not too much trouble\n        this._visible().store.reload(\n          this._visible().tree,\n          this.maskStore,\n          this.displayStore,\n        )\n      } else {\n        if (!this.onlyRefreshOuter) {\n          // Causes the resultsTrack to be removed from the config when it has been removed\n          delete this.config.resultsTrack\n          delete this.config.opTree\n        }\n      }\n\n      // once the store is properly reloaded, make sure the track is showing data correctly\n      if (this.range) {\n        track.clear()\n        track.showRange(\n          this.range.f,\n          this.range.l,\n          this.range.st,\n          this.range.b,\n          this.range.sc,\n          this.range.cs,\n          this.range.ce,\n        )\n      }\n      this.makeTrackMenu()\n    },\n\n    clear: function () {\n      this.inherited(arguments)\n      if (this.resultsTrack && !this.onlyRefreshOuter) {\n        this.resultsTrack.clear()\n      }\n    },\n\n    hideAll: function () {\n      this.inherited(arguments)\n      if (this.resultsTrack && !this.onlyRefreshOuter) {\n        this.resultsTrack.hideAll()\n      }\n    },\n\n    hideRegion: function (location) {\n      this.inherited(arguments)\n      if (this.resultsTrack && !this.onlyRefreshOuter) {\n        this.resultsTrack.hideRegion(location)\n      }\n    },\n\n    sizeInit: function (numBlocks, widthPct, blockDelta) {\n      this.inherited(arguments)\n      if (this.resultsTrack && !this.onlyRefreshOuter) {\n        this.resultsTrack.sizeInit(numBlocks, widthPct, blockDelta)\n      }\n    },\n\n    // Extends the BlockBased track's showRange function.\n    showRange: function (\n      first,\n      last,\n      startBase,\n      bpPerBlock,\n      scale,\n      containerStart,\n      containerEnd,\n      finishCallback,\n    ) {\n      this.range = {\n        f: first,\n        l: last,\n        st: startBase,\n        b: bpPerBlock,\n        sc: scale,\n        cs: containerStart,\n        ce: containerEnd,\n      }\n      if (this.resultsTrack && !this.onlyRefreshOuter) {\n        // This is a workaround to a glitch that causes an opaque white rectangle to appear sometimes when a quantitative\n        // track is loaded.\n        var needsDiv = !this.resultsDiv.parentNode\n        if (needsDiv) {\n          this.div.appendChild(this.resultsDiv)\n        }\n\n        var loadedRegions = []\n        var stores = [this.store, this.maskStore, this.displayStore]\n        for (var i in stores) {\n          if (stores[i] && typeof stores[i].loadRegion == 'function') {\n            var start = startBase\n            var end = startBase + (last + 1 - first) * bpPerBlock\n            var loadedRegion = stores[i].loadRegion({\n              ref: this.refSeq.name,\n              start: start,\n              end: end,\n            })\n            loadedRegions.push(loadedRegion)\n            loadedRegion.then(function () {}, this.errorCallback) // Add error callbacks to all deferred rejections\n          }\n        }\n        when(\n          all(loadedRegions),\n          dojo.hitch(this, function (reloadedStores) {\n            if (\n              reloadedStores.length &&\n              reloadedStores.indexOf(this._visible().store) != -1\n            ) {\n              this.resultsTrack.clear()\n            }\n            this.resultsTrack.showRange(\n              first,\n              last,\n              startBase,\n              bpPerBlock,\n              scale,\n              containerStart,\n              containerEnd,\n              finishCallback,\n            )\n          }),\n          this.errorCallback,\n        )\n\n        if (needsDiv) {\n          this.div.removeChild(this.resultsDiv)\n        }\n      }\n      // Run the method from BlockBased.js\n      this.inherited(arguments)\n      // Make sure the height of this track is right\n      this.heightUpdate(this.height)\n      this.div.style.height = this.height + 'px'\n    },\n\n    // If moveBlocks is called on this track, should be called on the results track as well\n    moveBlocks: function (delta) {\n      this.inherited(arguments)\n      if (this.resultsTrack) {this.resultsTrack.moveBlocks(delta)}\n    },\n\n    // fillBlock in this renders all the relevant borders etc that surround the results track and let the user know\n    // that this is a combination track\n    fillBlock: function (args) {\n      var blockIndex = args.blockIndex\n      var block = args.block\n      var leftBase = args.leftBase\n\n      if (!this.resultsTrack) {\n        this.fillMessage(blockIndex, block, 'Drag tracks here to combine them.')\n      } else {\n        this.heightUpdate(this.heightResults, blockIndex)\n      }\n      args.finishCallback()\n    },\n\n    // endZoom is passed down to resultsTrack\n    endZoom: function (destScale, destBlockBases) {\n      this.clear() // Necessary?\n      if (this.resultsTrack) {this.resultsTrack.endZoom()}\n    },\n\n    //  updateStaticElements passed down to resultsTrack\n    updateStaticElements: function (args) {\n      this.inherited(arguments)\n      if (this.resultsTrack) {this.resultsTrack.updateStaticElements(args)}\n    },\n\n    // When the results track can be shown in multiple different classes\n    // (e.g. XYPlot or Density), this allows users to choose between them\n    setClassIndex: function (index, type) {\n      if (!type) {type = this._visible().which}\n      if (type == 'mask' && this.displayStore)\n        {type = this.supportedBy[this.displayStore.config.type]}\n      this.classIndex[type] = index\n    },\n\n    // Like the setClassIndex function, but accepts the actual file path of the track in question\n    setTrackClass: function (tclass, type) {\n      var allPaths = this.trackClasses[type].resultsTypes.map(function (item) {\n        return item.path\n      })\n      var index = allPaths.indexOf(tclass)\n      if (index >= 0) {\n        this.setClassIndex(index, type)\n      }\n    },\n\n    // When the results track can be shown in multiple different classes\n    // (e.g. XYPlot or Density), this tells us which one is currently\n    // chosen\n    getClassIndex: function (type) {\n      if (type == 'mask' && this.displayStore)\n        {type = this.supportedBy[this.displayStore.config.type]}\n      return this.classIndex[type]\n    },\n\n    // Adds options to the track context menu\n    _trackMenuOptions: function () {\n      // Allows the combination track to \"mimic\" the menu options of its results track\n      var resultsTrackOptions = (\n        this.resultsTrackMenuOptions ||\n        function () {\n          return undefined\n        }\n      ).call(this.resultsTrack)\n      resultsTrackOptions = resultsTrackOptions || []\n\n      var inheritedOptions = this.inherited(arguments)\n      var inheritedLabels = inheritedOptions.map(function (menuItem) {\n        return menuItem.label\n      })\n\n      for (var i = 0; i < resultsTrackOptions.length; i++) {\n        if (\n          resultsTrackOptions[i].label &&\n          inheritedLabels.indexOf(resultsTrackOptions[i].label) != -1\n        ) {\n          resultsTrackOptions.splice(i--, 1)\n        }\n      }\n      var o = inheritedOptions.concat(resultsTrackOptions)\n\n      //var o = this.inherited(arguments);\n\n      var combTrack = this\n\n      // If no tracks are added, we don't need to add any more options\n      if (!this.storeType) {return o}\n\n      if (this.storeType == 'mask') {\n        // If a masking track, enables users to toggle between viewing data, mask, and masked data\n        var maskOrDisplay = ['masked data', 'mask', 'data only']\n        var maskOrDisplayItems = Object.keys(maskOrDisplay).map(function (i) {\n          return {\n            type: 'dijit/CheckedMenuItem',\n            checked: combTrack.storeToShow == i,\n            label: maskOrDisplay[i],\n            title: 'View ' + maskOrDisplay[i],\n            action: function () {\n              combTrack.storeToShow = i\n              combTrack.renderResultsTrack()\n            },\n          }\n        })\n        o.push.apply(o, [\n          {\n            type: 'dijit/MenuSeparator',\n          },\n          {\n            children: maskOrDisplayItems,\n            label: 'View',\n            title:\n              'switch between the mask, display data and masked data for this masking track',\n          },\n        ])\n      }\n\n      // User may choose which class to render results track (e.g. XYPlot or Density) if multiple options exist\n      var classes = this.trackClasses[this._visible().which].resultsTypes\n\n      var classItems = Object.keys(classes).map(function (i) {\n        return {\n          type: 'dijit/CheckedMenuItem',\n          label: classes[i].name,\n          checked: combTrack.classIndex[combTrack._visible().which] == i,\n          title: 'Display as ' + classes[i].name + ' track',\n          action: function () {\n            combTrack.setClassIndex(i)\n            delete combTrack.config.resultsTrack\n            combTrack.renderResultsTrack()\n          },\n        }\n      })\n      o.push.apply(o, [\n        { type: 'dijit/MenuSeparator' },\n        {\n          children: classItems,\n          label: 'Track display',\n          title: 'Change what type of track is being displayed',\n        },\n      ])\n\n      // Allow user to view the current track formula.\n      if (this.opTree) {\n        o.push.apply(o, [\n          {\n            label: 'View formula',\n            title: 'View the formula specifying this combination track',\n            action: function () {\n              var formulaDialog = new Dialog({\n                title: 'View Formula',\n              })\n              var content = []\n              var formulaDiv = dom.create('div', {\n                innerHTML: 'No operation formula defined',\n                className: 'formulaPreview',\n              })\n              content.push(formulaDiv)\n              if (combTrack.opTree) {\n                formulaDiv.innerHTML = combTrack._generateTreeFormula(\n                  combTrack.opTree,\n                )\n              }\n              formulaDialog.set('content', content)\n              formulaDialog.show()\n            },\n          },\n        ])\n      }\n\n      // If the current view contains more than one track combined, user may change the last operation applied\n      if (this._visible().tree && this._visible().tree.getLeaves().length > 1) {\n        var operationItems = this._visible().allowedOps.map(function (op) {\n          return {\n            type: 'dijit/CheckedMenuItem',\n            checked: combTrack._visible().tree.get() == op,\n            label: combTrack.inWords[op],\n            title: 'change operation of last track to ' + combTrack.inWords[op],\n            action: function () {\n              if (combTrack.opTree) {\n                combTrack._visible().tree.set(op)\n                combTrack.refresh()\n              }\n            },\n          }\n        })\n        o.push.apply(o, [\n          {\n            children: operationItems,\n            label: 'Change last operation',\n            title: 'change the operation applied to the last track added',\n          },\n        ])\n      }\n\n      return o\n    },\n\n    // Turns an opTree into a formula to be better understood by the user.\n    _generateTreeFormula: function (tree) {\n      if (!tree || tree === undefined) {\n        return '<span class=\"null\">NULL</span>'\n      }\n      if (tree.isLeaf()) {\n        return (\n          '<span class=\"leaf' +\n          (tree.highlighted ? ' highlighted' : '') +\n          '\">' +\n          (tree.get().name\n            ? this.config.storeToKey[tree.get().name]\n              ? this.config.storeToKey[tree.get().name]\n              : tree.get().name\n            : tree.get()) +\n          '</span>'\n        )\n      }\n      return (\n        '<span class=\"tree\">(' +\n        this._generateTreeFormula(tree.left()) +\n        ' <span class=\"op\" title=\"' +\n        this.inWords[tree.get()] +\n        '\">' +\n        tree.get() +\n        '</span> ' +\n        this._generateTreeFormula(tree.right()) +\n        ')</span>'\n      )\n    },\n\n    _exportFormats: function () {\n      return this.exportFormats || []\n    },\n\n    // These methods are not currently in use, but they allow direct loading of the opTree into the config.\n\n    flatten: function (tree) {\n      var newTree = {\n        leaf: tree.leaf,\n      }\n      if (tree.leftChild) {newTree.leftChild = this.flatten(tree.leftChild)}\n      if (tree.rightChild) {newTree.rightChild = this.flatten(tree.rightChild)}\n      if (tree.get().name) {newTree.store = tree.get().name}\n      else {newTree.op = tree.get()}\n      return newTree\n    },\n\n    loadTree: function (tree) {\n      var d = new Deferred()\n      var haveLeft\n      var haveRight\n      var thisB = this\n\n      if (!tree) {\n        d.resolve(undefined, true)\n        return d.promise\n      }\n\n      if (tree.leftChild) {\n        haveLeft = this.loadTree(tree.leftChild)\n      }\n      if (tree.rightChild) {\n        haveRight = this.loadTree(tree.rightChild)\n      }\n      when(all([haveLeft, haveRight]), function (results) {\n        var newTree = new TreeNode({\n          leftChild: results[0],\n          rightChild: results[1],\n          leaf: tree.leaf,\n        })\n        if (tree.store) {\n          thisB.browser.getStore(tree.store, function (store) {\n            newTree.set(store)\n          })\n          d.resolve(newTree, true)\n        } else {\n          newTree.set(tree.op)\n          d.resolve(newTree, true)\n        }\n      })\n      return d.promise\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/Track/Combination/CombinationDialog.js":{"size":17774,"mtime":1738905963064,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/Track/Combination/CombinationDialog.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'dijit/Dialog',\n  'dijit/form/RadioButton',\n  'dijit/form/Button',\n  'dojo/dom-construct',\n  'JBrowse/Model/BinaryTreeNode',\n], function (declare, Dialog, RadioButton, Button, dom, TreeNode) {\n  return declare(null, {\n    // Produces a dialog box in which a user may enter settings for how they would like to combine tracks in a Combination Track.\n    constructor: function (args) {\n      this.newTrackKey = args.trackConfig ? args.trackConfig.key : args.key\n      this.track = args.track\n      this.newStore = args.store\n      this.opTree = this.track.opTree\n\n      this.currType = this.track.currType\n      this.oldType = this.track.oldType\n      this.supportedBy = this.track.supportedBy\n      this.displayType = this.track.displayType\n\n      this.storeToKey = this.track.config.storeToKey\n\n      this.newDisplayType = this.displayType\n\n      this.inWords = this.track.inWords\n\n      this.trackClasses = this.track.trackClasses\n\n      this.dialog = new Dialog({\n        title: 'Combine with ' + this.newTrackKey,\n        style: 'width: 475px;',\n        className: 'combinationDialog',\n      })\n      var content = this._dialogContent(this.newStore)\n      this.dialog.set('content', content)\n    },\n\n    _dialogContent: function (store) {\n      var nodesToAdd = []\n\n      var opList = this._allAllowedOperations(store)\n      if (!opList.length) {\n        nodesToAdd.push(\n          dom.create('div', {\n            innerHTML: 'No operations are possible for this track.',\n          }),\n        )\n        var actionBar = this._createActionBar(false)\n        nodesToAdd.push(actionBar)\n        return nodesToAdd\n      }\n\n      nodesToAdd.push(\n        dom.create('div', {\n          className: 'intro',\n          innerHTML:\n            'Adding ' +\n            this.currType +\n            ' track ' +\n            this.newTrackKey +\n            ' to the combination.',\n        }),\n      )\n\n      var maskOpListDiv = dom.create('div', {\n        id: this.track.name + '_maskOpList',\n      })\n\n      var thisB = this\n\n      var maskOps = this._makeUnique(\n        opList.map(function (item) {\n          return item.substring(0, 4)\n        }),\n      )\n      nodesToAdd.push(maskOpListDiv)\n\n      this.changingOpPanel = dom.create('div', {\n        id: this.track.name + '_suffixLists',\n      })\n      nodesToAdd.push(this.changingOpPanel)\n\n      nodesToAdd.push(dom.create('h2', { innerHTML: 'Combination formula' }))\n\n      this.formulaPreview = dom.create('div', {\n        innerHTML: '(nothing currently selected)',\n        className: 'formulaPreview',\n      })\n      nodesToAdd.push(this.formulaPreview)\n\n      this.maskOpButtons = []\n\n      for (var i in maskOps) {\n        var opButton = this._renderRadioButton(\n          maskOpListDiv,\n          maskOps[i],\n          this.inWords[maskOps[i]],\n        )\n        this.maskOpButtons.push(opButton)\n\n        opButton.on('change', function (isSelected) {\n          if (isSelected) {\n            delete this.whichArg\n            delete this.opValue\n\n            thisB.maskOpValue = this.value\n\n            var numOpLists = thisB.maskOpValue == '1111' ? 3 : 1\n            thisB.opListDivs = []\n            thisB.whichArgDivs = []\n\n            thisB.opValue = []\n            thisB.whichArg = []\n\n            thisB.changingOpPanel.innerHTML = ''\n\n            for (var i = 0; i < numOpLists; i++) {\n              var opDiv = dom.create(\n                'div',\n                {\n                  id: thisB.track.name + '_suffix' + i,\n                  style: {\n                    display: 'inline-block',\n                    'padding-left': '15px',\n                    'vertical-align': 'top',\n                  },\n                },\n                thisB.changingOpPanel,\n              )\n              if (numOpLists == 3) {\n                var text = ['Main', 'Mask', 'Display']\n                dom.create('h2', { innerHTML: text[i] }, opDiv)\n              }\n\n              var whichOpSpan = dom.create(\n                'h3',\n                {\n                  innerHTML: 'Combining operation',\n                  style: { display: 'none' },\n                },\n                opDiv,\n              )\n\n              thisB.opListDivs[i] = dom.create(\n                'div',\n                { id: thisB.track.name + '_OpList' + i },\n                opDiv,\n              )\n\n              var leftRightSpan = dom.create(\n                'h3',\n                {\n                  innerHTML: 'Left or right?',\n                  style: { display: 'none' },\n                },\n                opDiv,\n              )\n              thisB.whichArgDivs[i] = dom.create(\n                'div',\n                { id: thisB.track.name + '_whichArg' + i },\n                opDiv,\n              )\n\n              var opButtons = thisB._generateSuffixRadioButtons(\n                this.value,\n                opList,\n                store,\n                thisB.opListDivs[i],\n                i,\n              )\n              var leftRightButtons = thisB._maybeRenderWhichArgDiv(\n                this.value,\n                store,\n                thisB.whichArgDivs[i],\n                i,\n              )\n\n              if (leftRightButtons.length && !thisB.whichOpArg) {\n                leftRightButtons[0].set('checked', 'checked')\n              }\n              if (opButtons.length) {\n                opButtons[0].set('checked', 'checked')\n              }\n\n              whichOpSpan.style.display = opButtons.length ? '' : 'none'\n              leftRightSpan.style.display = leftRightButtons.length\n                ? ''\n                : 'none'\n            }\n          }\n        })\n      }\n\n      if (maskOps[0]) {this.maskOpButtons[0].set('checked', 'checked')}\n\n      if (maskOps.length <= 1) {\n        if (!maskOps.length || maskOps[0] == '0000') {\n          maskOpListDiv.style.display = 'none'\n        }\n        this.maskOpButtons[0].set('disabled', 'disabled')\n      }\n\n      var actionBar = this._createActionBar()\n\n      nodesToAdd.push(actionBar)\n\n      return nodesToAdd\n    },\n\n    _createActionBar: function (addingEnabled) {\n      if (addingEnabled === undefined) {addingEnabled = true}\n      var actionBar = dom.create('div', {\n        className: 'dijitDialogPaneActionBar',\n      })\n      new Button({\n        iconClass: 'dijitIconDelete',\n        label: 'Cancel',\n        onClick: dojo.hitch(this, function () {\n          this.shouldCombine = false\n          this.dialog.hide()\n        }),\n      }).placeAt(actionBar)\n\n      var btnCombine = new Button({\n        label: 'Combine tracks',\n        onClick: dojo.hitch(this, function () {\n          this.shouldCombine = true\n          this.dialog.hide()\n        }),\n      })\n\n      btnCombine.placeAt(actionBar)\n\n      if (!addingEnabled) {btnCombine.set('disabled', 'disabled')}\n      return actionBar\n    },\n\n    _generateSuffixRadioButtons: function (\n      prefix,\n      stringlist,\n      store,\n      parent,\n      offset,\n    ) {\n      offset = offset || 0\n      while (parent.firstChild) {\n        if (dijit.byId(parent.firstChild.id))\n          {dijit.byId(parent.firstChild.id).destroy()}\n        dom.destroy(parent.firstChild)\n      }\n      var buttons = []\n\n      var thisB = this\n      var allowedOps = this._generateSuffixList(prefix, stringlist, offset)\n      for (var i in allowedOps) {\n        var opButton = this._renderRadioButton(\n          parent,\n          allowedOps[i],\n          this.inWords[allowedOps[i]],\n        )\n        buttons.push(opButton)\n        opButton.on('change', function (isSelected) {\n          if (isSelected) {\n            thisB.opValue[offset] = this.value\n            var operation = thisB._getOperation()\n            thisB.previewTree = thisB._createPreviewTree(operation, store)\n            thisB.formulaPreview.innerHTML = thisB._generateTreeFormula(\n              thisB.previewTree,\n            )\n          }\n        })\n      }\n      return buttons\n    },\n\n    _getOperation: function () {\n      var retString = this.maskOpValue\n      for (var i = 0; i < this.opListDivs.length; i++) {\n        retString = retString + this.opValue[i] + this.whichArg[i]\n      }\n      return retString\n    },\n\n    //Type checking necessary?\n    _generateSuffixList: function (prefix, stringlist, offset) {\n      if (offset === undefined) {offset = 0}\n      return this._makeUnique(\n        stringlist\n          .filter(function (value) {\n            return value.indexOf(prefix) != -1\n          })\n          .map(function (item) {\n            return item.substring(\n              prefix.length + offset,\n              prefix.length + offset + 1,\n            )\n          }),\n      )\n    },\n\n    _maybeRenderWhichArgDiv: function (prefix, store, parent, offset) {\n      offset = offset || 0\n      while (parent.firstChild) {\n        if (dijit.byId(parent.firstChild.id)) {\n          dijit.byId(parent.firstChild.id).destroy()\n        }\n        dom.destroy(parent.firstChild)\n      }\n      var leftRightButtons = []\n      var thisB = this\n\n      var whichArgChange = function (isSelected, value) {\n        if (isSelected) {\n          thisB.whichArg[offset] = value === undefined ? this.value : value\n          var operation = thisB._getOperation()\n          thisB.previewTree = thisB._createPreviewTree(operation, store)\n          thisB.formulaPreview.innerHTML = thisB._generateTreeFormula(\n            thisB.previewTree,\n          )\n        }\n      }\n\n      if (prefix == '0020') {whichArgChange(true, 'L')}\n      else if (prefix == '0002') {whichArgChange(true, 'R')}\n      else if (prefix == '1111' && offset == 0) {whichArgChange(true, '?')}\n      else {\n        var rbLeft = this._renderRadioButton(parent, 'L', 'left')\n        var rbRight = this._renderRadioButton(parent, 'R', 'right')\n        leftRightButtons.push(rbLeft)\n        leftRightButtons.push(rbRight)\n        rbLeft.on('change', whichArgChange)\n        rbRight.on('change', whichArgChange)\n      }\n\n      return leftRightButtons\n    },\n\n    _makeUnique: function (stringArray) {\n      var unique = {}\n      return stringArray.filter(function (value) {\n        if (!unique[value]) {\n          unique[value] = true\n          return true\n        }\n        return false\n      })\n    },\n\n    _createPreviewTree: function (opString, store) {\n      // Recursive cloning would probably be safer, but this seems to be working okay\n      var newOpTree = store.opTree\n        ? store.opTree.clone()\n        : new TreeNode({ Value: store })\n      if (newOpTree) {\n        newOpTree.recursivelyCall(function (node) {\n          node.highlighted = true\n        })\n      }\n      var superior = new TreeNode(this.opTree)\n      var firstChars = opString.substring(0, 2)\n      var inferior = newOpTree\n      if (firstChars == '01') {\n        superior = newOpTree\n        inferior = this.opTree\n      }\n      return this._applyTreeTransform(opString.substring(2), superior, inferior)\n    },\n\n    _applyTreeTransform: function (opString, superior, inferior) {\n      var retTree = superior\n      var firstChars = opString.substring(0, 2)\n      var childToUse\n      var opTree1 = superior\n      var opTree2 = inferior\n      switch (firstChars) {\n        case '10':\n          opTree1 = superior.leftChild\n          childToUse = 'leftChild'\n          opTree2 = inferior\n          break\n        case '01':\n          opTree1 = superior.rightChild\n          childToUse = 'rightChild'\n          opTree2 = inferior\n          break\n        case '11':\n          retTree = new TreeNode({ Value: opString.substring(2, 3) })\n          retTree['leftChild'] = this._transformTree(\n            opString.substring(4),\n            superior.leftChild,\n            inferior.leftChild,\n          )\n          opString = opString.substring(4)\n          childToUse = 'rightChild'\n          opTree1 = superior.rightChild\n          opTree2 = inferior.rightChild\n          break\n        case '20':\n          this.newDisplayType = this.oldType\n          break\n        case '02':\n          this.newDisplayType = this.currType\n          break\n      }\n      var opNode = this._transformTree(opString.substring(2), opTree1, opTree2)\n      if (childToUse == undefined) {return opNode}\n\n      retTree[childToUse] = opNode\n      return retTree\n    },\n\n    _transformTree: function (opString, opTree1, opTree2) {\n      var op = opString.substring(0, 1)\n      var opNode = new TreeNode({ Value: op })\n      if (opString.substring(1, 2) == 'L') {\n        opNode.add(opTree2)\n        opNode.add(opTree1)\n      } else {\n        opNode.add(opTree1)\n        opNode.add(opTree2)\n      }\n\n      return opNode\n    },\n\n    // This mess constructs a complete list of all operations that can be performed\n    _allAllowedOperations: function (store) {\n      var allowedList = []\n      var candidate = ''\n      var allowedOps\n      candidate = candidate + (this.oldType == 'mask' ? '1' : '0')\n      candidate = candidate + (this.currType == 'mask' ? '1' : '0')\n      if (candidate == '00') {\n        if (this.oldType == this.currType) {\n          var candidate2 = candidate + '00'\n          allowedOps = this.trackClasses[this.currType].allowedOps\n          for (var i in allowedOps) {\n            allowedList.push(candidate2 + allowedOps[i])\n          }\n        }\n        allowedOps = this.trackClasses['mask'].allowedOps\n        if (this.currType == 'set') {\n          var candidate2 = candidate + '20'\n          for (var i in allowedOps) {allowedList.push(candidate2 + allowedOps[i])}\n        }\n        if (this.oldType == 'set') {\n          var candidate2 = candidate + '02'\n          for (var i in allowedOps) {allowedList.push(candidate2 + allowedOps[i])}\n        }\n      } else if (candidate == '10') {\n        if (this.currType == 'set') {\n          allowedOps = this.trackClasses[this.currType].allowedOps\n          var candidate2 = candidate + '10'\n          for (var i in allowedOps) {\n            allowedList.push(candidate2 + allowedOps[i])\n          }\n        }\n        if (this.currType == this.displayType) {\n          var candidate2 = candidate + '01'\n          allowedOps = this.trackClasses[this.currType].allowedOps\n          for (var i in allowedOps) {\n            allowedList.push(candidate2 + allowedOps[i])\n          }\n        }\n      } else if (candidate == '01') {\n        if (this.oldType == 'set') {\n          allowedOps = this.trackClasses[this.oldType].allowedOps\n          var candidate2 = candidate + '10'\n          for (var i in allowedOps) {\n            allowedList.push(candidate2 + allowedOps[i])\n          }\n        }\n        var displayType = this.supportedBy[store.stores.display.config.type]\n        if (this.oldType == displayType) {\n          candidate = candidate + '01'\n          var allowedOps = this.trackClasses[displayType].allowedOps\n          for (var i in allowedOps) {\n            allowedList.push(candidate + allowedOps[i])\n          }\n        }\n      } else if (candidate == '11') {\n        // Fix the logic of the tree manipulation to work with out the last L's and R's\n        candidate = candidate + '11'\n        allowedOps = this.trackClasses['set'].allowedOps\n        for (var i in allowedOps) {\n          var displayType = this.supportedBy[store.stores.display.config.type]\n          var oldType = this.displayType\n          if (displayType == oldType) {\n            var allowedOps2 = this.trackClasses[displayType].allowedOps\n            for (var j in allowedOps2) {\n              var allowedMaskOps = this.trackClasses['mask'].allowedOps\n              for (var k in allowedMaskOps) {\n                allowedList.push(\n                  candidate +\n                    allowedMaskOps[k] +\n                    allowedOps[i] +\n                    allowedOps2[j],\n                )\n              }\n            }\n          }\n        }\n      }\n\n      return allowedList\n    },\n\n    _renderRadioButton: function (parent, value, label) {\n      var id = parent.id + '_rb_' + value\n      if (dijit.byId(id)) {\n        dom.destroy(dijit.byId(id).domNode)\n        dijit.byId(id).destroy()\n      }\n\n      label = label || value\n      var radioButton = new RadioButton({\n        name: parent.id + '_rb',\n        id: id,\n        value: value,\n      })\n      parent.appendChild(radioButton.domNode)\n      var radioButtonLabel = dom.create(\n        'label',\n        { for: radioButton.id, innerHTML: label },\n        parent,\n      )\n      parent.appendChild(dom.create('br'))\n      return radioButton\n    },\n\n    run: function (callback, cancelCallback, errorCallback) {\n      this.dialog.show()\n      var thisB = this\n      this.dialog.on('Hide', function () {\n        if (thisB.previewTree) {\n          thisB.previewTree.recursivelyCall(function (node) {\n            if (node.highlighted) {delete node.highlighted}\n          })\n        }\n        if (thisB.shouldCombine)\n          {callback(thisB.previewTree, thisB.newStore, thisB.newDisplayType)}\n        else {cancelCallback()}\n      })\n    },\n\n    _generateTreeFormula: function (tree) {\n      if (!tree || tree === undefined) {\n        return '<span class=\"null\">NULL</span>'\n      }\n      if (tree.isLeaf()) {\n        return (\n          '<span class=\"leaf' +\n          (tree.highlighted ? ' highlighted' : '') +\n          '\">' +\n          (tree.get().name\n            ? this.storeToKey[tree.get().name]\n              ? this.storeToKey[tree.get().name]\n              : tree.get().name\n            : tree.get()) +\n          '</span>'\n        )\n      }\n      return (\n        '<span class=\"tree\">(' +\n        this._generateTreeFormula(tree.left()) +\n        ' <span class=\"op\" title=\"' +\n        this.inWords[tree.get()] +\n        '\">' +\n        tree.get() +\n        '</span> ' +\n        this._generateTreeFormula(tree.right()) +\n        ')</span>'\n      )\n    },\n\n    destroyRecursive: function () {\n      this.dialog.destroyRecursive()\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/Track/FeatureCoverage.js":{"size":554,"mtime":1738905963068,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/Track/FeatureCoverage.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/Track/FixedImage.js":{"size":4916,"mtime":1738905963074,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/Track/FixedImage.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'JBrowse/has',\n  'JBrowse/View/Track/BlockBased',\n], function (declare, has, BlockBased) {\n  return declare(\n    BlockBased,\n    /**\n     * @lends JBrowse.View.Track.FixedImage.prototype\n     */\n    {\n      /**\n       * A track that displays tiled images (PNGs, or other images) at fixed\n       * intervals along the reference sequence.\n       * @constructs\n       * @extends JBrowse.View.Track.BlockBased\n       */\n      constructor: function (args) {\n        this.trackPadding = args.trackPadding || 0\n      },\n\n      handleImageError: function (ev) {\n        var img = ev.currentTarget || ev.srcElement\n        img.style.display = 'none'\n        dojo.stopEvent(ev)\n      },\n\n      /**\n       * @private\n       */\n      makeImageLoadHandler: function (\n        img,\n        blockIndex,\n        blockWidth,\n        composeCallback,\n      ) {\n        var handler = dojo.hitch(this, function () {\n          this.imageHeight = img.height\n          img.style.height = img.height + 'px'\n          img.style.width = 100 * (img.baseWidth / blockWidth) + '%'\n          this.heightUpdate(img.height, blockIndex)\n          if (composeCallback) {composeCallback()}\n          return true\n        })\n\n        if (has('ie'))\n          // in IE, have to delay calling it for a (arbitrary) 1/4\n          // second because the image's height is not always\n          // available when the onload event fires.  >:-{\n          {return function () {\n            window.setTimeout(handler, 250)\n          }}\n        else {return handler}\n      },\n\n      fillBlock: function (args) {\n        var blockIndex = args.blockIndex\n        var block = args.block\n        var leftBase = args.leftBase\n        var rightBase = args.rightBase\n        var scale = args.scale\n        var finishCallback = args.finishCallback || function () {}\n\n        var blockWidth = rightBase - leftBase\n\n        this.store.getImages(\n          { scale: scale, start: leftBase, end: rightBase },\n          dojo.hitch(this, function (images) {\n            dojo.forEach(\n              images,\n              function (im) {\n                im.className = 'image-track'\n                if (!(im.parentNode && im.parentNode.parentNode)) {\n                  im.style.position = 'absolute'\n                  im.style.left =\n                    100 * ((im.startBase - leftBase) / blockWidth) + '%'\n                  switch (this.config.align) {\n                    case 'top':\n                      im.style.top = '0px'\n                      break\n                    case 'bottom':\n                    /* fall through */\n                    default:\n                      im.style.bottom = this.trackPadding + 'px'\n                      break\n                  }\n                  block.domNode.appendChild(im)\n                }\n\n                // make an onload handler for when the image is fetched that\n                // will update the height and width of the track\n                var loadhandler = this.makeImageLoadHandler(\n                  im,\n                  blockIndex,\n                  blockWidth,\n                )\n                if (im.complete)\n                  // just call the handler ourselves if the image is already loaded\n                  {loadhandler()}\n                else\n                  // otherwise schedule it\n                  {im.onload = loadhandler}\n              },\n              this,\n            )\n            finishCallback()\n          }),\n          dojo.hitch(this, function (error) {\n            if (error.status == 404) {\n              finishCallback()\n            } else {\n              this.fillBlockError(blockIndex, block, error)\n            }\n            finishCallback()\n          }),\n        )\n      },\n\n      startZoom: function (destScale, destStart, destEnd) {\n        if (this.empty) {return}\n      },\n\n      endZoom: function (destScale, destBlockBases) {\n        this.clear()\n      },\n\n      clear: function () {\n        this.inherited(arguments)\n      },\n\n      transfer: function (\n        sourceBlock,\n        destBlock,\n        scale,\n        containerStart,\n        containerEnd,\n      ) {\n        if (!(sourceBlock && destBlock)) {return}\n\n        var children = sourceBlock.domNode.childNodes\n        var destLeft = destBlock.startBase\n        var destRight = destBlock.endBase\n        var im\n        for (var i = 0; i < children.length; i++) {\n          im = children[i]\n          if ('startBase' in im) {\n            //if sourceBlock contains an image that overlaps destBlock,\n            if (\n              im.startBase < destRight &&\n              im.startBase + im.baseWidth > destLeft\n            ) {\n              //move image from sourceBlock to destBlock\n              im.style.left =\n                100 * ((im.startBase - destLeft) / (destRight - destLeft)) + '%'\n              destBlock.domNode.appendChild(im)\n            }\n          }\n        }\n      },\n    },\n  )\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/Track/FixedImage/Wiggle.js":{"size":1373,"mtime":1738905963078,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/Track/FixedImage/Wiggle.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'JBrowse/View/Track/FixedImage',\n  'JBrowse/View/Track/_YScaleMixin',\n], function (declare, FixedImage, YScaleMixin) {\n  var Wiggle = declare(\n    [FixedImage, YScaleMixin],\n    /**\n     * @lends JBrowse.View.Track.FixedImage.Wiggle.prototype\n     */\n    {\n      /**\n       * Tiled-image track subclass that displays images calculated from\n       * wiggle data.  Has a scale bar in addition to the images.\n       * @class\n       * @constructor\n       */\n      constructor: function () {},\n\n      updateStaticElements: function (coords) {\n        this.inherited(arguments)\n        this.updateYScaleFromViewDimensions(coords)\n      },\n\n      makeImageLoadHandler: function (\n        img,\n        blockIndex,\n        blockWidth,\n        composeCallback,\n      ) {\n        return this.inherited(arguments, [\n          img,\n          blockIndex,\n          blockWidth,\n          dojo.hitch(this, function () {\n            this.makeWiggleYScale()\n            if (composeCallback) {composeCallback()}\n          }),\n        ])\n      },\n\n      makeWiggleYScale: function () {\n        var thisB = this\n        this.store.getGlobalStats(function (stats) {\n          if (!thisB.yscale)\n            {thisB.makeYScale({\n              min: stats.scoreMin,\n              max: stats.scoreMax,\n            })}\n        })\n      },\n    },\n  )\n\n  return Wiggle\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/Track/GridLines.js":{"size":2290,"mtime":1738905963082,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/Track/GridLines.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'dojo/dom-construct',\n  'JBrowse/View/Track/BlockBased',\n], function (declare, dom, BlockBased) {\n  return dojo.declare(\n    BlockBased,\n    /**\n     * @lends JBrowse.View.Track.GridLines.prototype\n     */\n    {\n      /**\n       * This track draws vertical gridlines, which are divs with height\n       * 100%, absolutely positioned at the very top of all the tracks.\n       * @constructs\n       * @extends JBrowse.View.Track.BlockBased\n       */\n      constructor: function (args) {\n        this.loaded = true\n        this.name = 'gridlines'\n      },\n\n      // this track has no track label or track menu, stub them out\n      makeTrackLabel: function () {},\n      makeTrackMenu: function () {},\n\n      fillBlock: function (args) {\n        this.renderGridlines(args.block, args.leftBase, args.rightBase)\n\n        var highlight = this.browser.getHighlight()\n        if (highlight && highlight.ref == this.refSeq.name)\n          {this.renderRegionHighlight(args, highlight)}\n\n        var bookmarks = this.browser.getBookmarks()\n        if (bookmarks) {\n          this.renderRegionBookmark(args, bookmarks)\n        }\n\n        args.finishCallback()\n        this.heightUpdate(100, args.blockIndex)\n      },\n\n      renderGridlines: function (block, leftBase, rightBase) {\n        var base_span = rightBase - leftBase\n        var minor_count = !(base_span % 20)\n          ? 20\n          : !(base_span % 10)\n            ? 10\n            : !(base_span % 5)\n              ? 5\n              : !(base_span % 2)\n                ? 2\n                : 5 // can happen at weird zoom levels (i.e. 13)\n        var major_count = base_span == 20 ? 2 : base_span > 0 ? 1 : 0\n\n        var new_gridline = function (glclass, position) {\n          var gridline = document.createElement('div')\n          gridline.style.cssText = 'left: ' + position + '%; width: 0px'\n          gridline.className = 'gridline ' + glclass\n          return gridline\n        }\n\n        for (var i = 0; i < minor_count; i++) {\n          var pos = (100 / minor_count) * i\n          var cls =\n            pos == 0 || (minor_count == 20 && i == 10)\n              ? 'gridline_major'\n              : 'gridline_minor'\n\n          block.domNode.appendChild(new_gridline(cls, pos))\n        }\n      },\n    },\n  )\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/Track/HTMLFeatures.js":{"size":60705,"mtime":1738905963128,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/Track/HTMLFeatures.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'dojo/_base/lang',\n  'dojo/_base/array',\n  'dojo/dom-construct',\n  'dojo/dom-geometry',\n  'dojo/on',\n  'dojo/query',\n  'JBrowse/has',\n  'dijit/Dialog',\n  'dijit/form/Select',\n  'dijit/form/RadioButton',\n  'dijit/form/Button',\n  'JBrowse/View/Track/BlockBased',\n  'JBrowse/View/Track/_YScaleMixin',\n  'JBrowse/View/Track/_ExportMixin',\n  'JBrowse/View/Track/_FeatureDetailMixin',\n  'JBrowse/View/Track/_TrackDetailsStatsMixin',\n  'JBrowse/Util',\n  'JBrowse/View/GranularRectLayout',\n  'JBrowse/Model/Location',\n], function (\n  declare,\n  lang,\n  array,\n  dom,\n  domGeom,\n  on,\n  query,\n  has,\n  dijitDialog,\n  dijitSelect,\n  dijitRadioButton,\n  dijitButton,\n  BlockBased,\n  YScaleMixin,\n  ExportMixin,\n  FeatureDetailMixin,\n  TrackDetailsStatsMixin,\n  Util,\n  Layout,\n  Location,\n) {\n  var HTMLFeatures = declare(\n    [\n      BlockBased,\n      YScaleMixin,\n      ExportMixin,\n      FeatureDetailMixin,\n      TrackDetailsStatsMixin,\n    ],\n    {\n      /**\n       * A track that draws discrete features using `div` elements.\n       * @constructs\n       * @extends JBrowse.View.Track.BlockBased\n       * @param args.config {Object} track configuration. Must include key, label\n       * @param args.refSeq {Object} reference sequence object with name, start,\n       *   and end members.\n       * @param args.changeCallback {Function} optional callback for\n       *   when the track's data is loaded and ready\n       * @param args.trackPadding {Number} distance in px between tracks\n       */\n      constructor: function (args) {\n        //number of histogram bins per block\n        this.numBins =\n          lang.getObject('histogram.binsPerBlock', false, this.config) || 25\n\n        this.defaultPadding = 5\n        this.padding = this.defaultPadding\n\n        this.glyphHeightPad = 1\n        this.levelHeightPad = 2\n        this.labelPad = 1\n\n        // if calculated feature % width would be less than minFeatWidth, then set width to minFeatWidth instead\n        this.minFeatWidth = 1\n\n        this.trackPadding = args.trackPadding\n\n        this.heightCache = {} // cache for the heights of some\n        // feature elements, indexed by the\n        // complete cassName of the feature\n\n        this.showLabels = this.config.style.showLabels\n\n        this._setupEventHandlers()\n\n        // hook point\n        if (typeof this.extendedInit === 'function') {this.extendedInit()}\n      },\n\n      /**\n       * Returns object holding the default configuration for HTML-based feature tracks.\n       * @private\n       */\n      _defaultConfig: function () {\n        return Util.deepUpdate(lang.clone(this.inherited(arguments)), {\n          maxFeatureScreenDensity: 0.5,\n\n          // maximum height of the track, in pixels\n          maxHeight: 1000,\n\n          style: {\n            arrowheadClass: 'arrowhead',\n\n            className: 'feature2',\n\n            // not configured by users\n            _defaultHistScale: 4,\n            _defaultLabelScale: 30,\n            _defaultDescriptionScale: 120,\n\n            minSubfeatureWidth: 6,\n            maxDescriptionLength: 70,\n            showLabels: true,\n\n            label: 'name,id',\n            description: 'note, description',\n\n            centerChildrenVertically: true, // by default use feature child centering\n          },\n          hooks: {\n            create: function (track, feat) {\n              return document.createElement('div')\n            },\n          },\n          events: {},\n          menuTemplate: [\n            {\n              label: 'View details',\n              title: '{type} {name}',\n              action: 'contentDialog',\n              iconClass: 'dijitIconTask',\n              content: dojo.hitch(this, 'defaultFeatureDetail'),\n            },\n            {\n              label: function () {\n                return (\n                  'Highlight this ' +\n                  (this.feature && this.feature.get('type')\n                    ? this.feature.get('type')\n                    : 'feature')\n                )\n              },\n              action: function () {\n                var loc = new Location({\n                  feature: this.feature,\n                  tracks: [this.track],\n                })\n                this.track.browser.setHighlightAndRedraw(loc)\n              },\n              iconClass: 'dijitIconFilter',\n            },\n          ],\n        })\n      },\n\n      /**\n       * Make life easier for event handlers by handing them some things\n       */\n      wrapHandler: function (handler) {\n        var track = this\n        return function (event) {\n          event = event || window.event\n          if (event.shiftKey) {return}\n          var elem = event.currentTarget || event.srcElement\n          //depending on bubbling, we might get the subfeature here\n          //instead of the parent feature\n          if (!elem.feature) {elem = elem.parentElement}\n          if (!elem.feature) {return} //shouldn't happen; just bail if it does\n          handler(track, elem, elem.feature, event)\n        }\n      },\n\n      fillHistograms: function (args) {\n        var blockIndex = args.blockIndex\n        var block = args.block\n        var leftBase = args.leftBase\n        var rightBase = args.rightBase\n        var stripeWidth = args.stripeWidth\n\n        var blockSizeBp = Math.abs(rightBase - leftBase)\n\n        // bases in each histogram bin that we're currently rendering\n        var basesPerBin = blockSizeBp / this.numBins\n\n        var track = this\n        this.store.getRegionFeatureDensities(\n          {\n            ref: this.refSeq.name,\n            start: args.leftBase,\n            end: args.rightBase,\n            basesPerBin: basesPerBin,\n          },\n          function (histData) {\n            if (track._fillType != 'histograms') {return} // we must have moved on\n\n            var hist = histData.bins\n            var maxBin = 0\n            for (var bin = 0; bin < track.numBins; bin++) {\n              if (typeof hist[bin] == 'number' && isFinite(hist[bin])) {\n                maxBin = Math.max(maxBin, hist[bin])\n              }\n            }\n\n            var logScale = histData.stats\n              ? histData.stats.mean / histData.stats.max < 0.01\n              : false\n            var pxPerCount = histData.stats\n              ? 100 /\n                (logScale ? Math.log(histData.stats.max) : histData.stats.max)\n              : 2\n            var dims = {\n              basesPerBin: basesPerBin,\n              pxPerCount: pxPerCount,\n              logScale: logScale,\n              stats: histData.stats,\n            }\n\n            var binDiv\n            for (bin = 0; bin < track.numBins; bin++) {\n              if (!(typeof hist[bin] == 'number' && isFinite(hist[bin])))\n                {continue}\n              binDiv = document.createElement('div')\n              binDiv.className =\n                'hist feature-hist ' + track.config.style.className + '-hist'\n              binDiv.style.cssText =\n                'left: ' +\n                (bin / track.numBins) * 100 +\n                '%; ' +\n                'height: ' +\n                dims.pxPerCount *\n                  (dims.logScale ? Math.log(hist[bin]) : hist[bin]) +\n                'px;' +\n                'bottom: ' +\n                track.trackPadding +\n                'px;' +\n                'width: ' +\n                (100 / track.numBins - 100 / stripeWidth) +\n                '%;' +\n                (track.config.style.histCss ? track.config.style.histCss : '')\n              binDiv.setAttribute('value', hist[bin])\n              if (Util.is_ie6) {binDiv.appendChild(document.createComment())}\n              block.domNode.appendChild(binDiv)\n            }\n\n            track.heightUpdate(\n              dims.pxPerCount * (dims.logScale ? Math.log(maxBin) : maxBin),\n              blockIndex,\n            )\n            track.makeHistogramYScale(blockSizeBp, dims, histData)\n          },\n          dojo.hitch(this, 'fillBlockError', blockIndex, block),\n        )\n\n        args.finishCallback()\n      },\n\n      endZoom: function (destScale, destBlockBases) {\n        this.clear()\n      },\n\n      updateStaticElements: function (coords) {\n        this.inherited(arguments)\n        this.updateYScaleFromViewDimensions(coords)\n        this.updateFeatureLabelPositions(coords)\n        this.updateFeatureArrowPositions(coords)\n      },\n\n      updateFeatureArrowPositions: function (coords) {\n        if (!('x' in coords)) {return}\n\n        var viewmin = this.browser.view.minVisible()\n        var viewmax = this.browser.view.maxVisible()\n\n        var blocks = this.blocks\n\n        for (var blockIndex = 0; blockIndex < blocks.length; blockIndex++) {\n          var block = blocks[blockIndex]\n          if (!block) {continue}\n          var childNodes = block.domNode.childNodes\n          for (var i = 0; i < childNodes.length; i++) {\n            var featDiv = childNodes[i]\n            if (!featDiv.feature) {continue}\n            var feature = featDiv.feature\n\n            // Retrieve containerStart/End to resolve div truncation from renderFeature\n            var containerStart = featDiv._containerStart\n            var containerEnd = featDiv._containerEnd\n\n            var strand = feature.get('strand')\n            if (!strand) {continue}\n\n            var fmin = feature.get('start')\n            var fmax = feature.get('end')\n            var arrowhead\n            var featDivChildren\n            //borrow displayStart,displayEnd for arrowhead calculations because of truncations in renderFeat\n            var displayStart = Math.max(fmin, containerStart)\n            var displayEnd = Math.min(fmax, containerEnd)\n\n            // minus strand\n            if (strand < 0 && fmax > viewmin) {\n              var minusArrowClass = 'minus-' + this.config.style.arrowheadClass\n              featDivChildren = featDiv.childNodes\n              for (var j = 0; j < featDivChildren.length; j++) {\n                arrowhead = featDivChildren[j]\n                if (typeof arrowhead.className === 'string') {\n                  if (\n                    arrowhead &&\n                    arrowhead.className &&\n                    arrowhead.className.indexOf(minusArrowClass) >= 0\n                  ) {\n                    arrowhead.style.left =\n                      (fmin < viewmin\n                        ? block.bpToX(viewmin) - block.bpToX(displayStart)\n                        : -this.minusArrowWidth) + 'px'\n                  }\n                }\n              }\n            }\n            // plus strand\n            else if (strand > 0 && fmin < viewmax) {\n              var plusArrowClass = 'plus-' + this.config.style.arrowheadClass\n              featDivChildren = featDiv.childNodes\n              for (var j = 0; j < featDivChildren.length; j++) {\n                arrowhead = featDivChildren[j]\n                if (typeof arrowhead.className === 'string') {\n                  if (\n                    arrowhead &&\n                    arrowhead.className &&\n                    arrowhead.className.indexOf(plusArrowClass) >= 0\n                  ) {\n                    arrowhead.style.right =\n                      (fmax > viewmax\n                        ? block.bpToX(displayEnd) - block.bpToX(viewmax - 2)\n                        : -this.plusArrowWidth) + 'px'\n                  }\n                }\n              }\n            }\n          }\n        }\n      },\n\n      updateFeatureLabelPositions: function (coords) {\n        var showLabels = this.browser._showLabels\n        if (!('x' in coords)) {return}\n\n        array.forEach(\n          this.blocks,\n          function (block, blockIndex) {\n            // calculate the view left coord relative to the\n            // block left coord in units of pct of the block\n            // width\n            if (!block || !this.label) {return}\n            var viewLeft =\n              (100 *\n                (this.label.offsetLeft +\n                  (showLabels ? this.label.offsetWidth : 0) -\n                  block.domNode.offsetLeft)) /\n                block.domNode.offsetWidth +\n              2\n\n            // if the view start is unknown, or is to the\n            // left of this block, we don't have to worry\n            // about adjusting the feature labels\n            if (!viewLeft) {return}\n\n            var blockWidth = block.endBase - block.startBase\n\n            array.forEach(\n              block.domNode.childNodes,\n              function (featDiv) {\n                if (!featDiv.label) {return}\n                var labelDiv = featDiv.label\n                var feature = featDiv.feature\n\n                // get the feature start and end in terms of block width pct\n                var minLeft = parseInt(feature.get('start'))\n                minLeft = (100 * (minLeft - block.startBase)) / blockWidth\n                var maxLeft = parseInt(feature.get('end'))\n                maxLeft =\n                  100 *\n                  ((maxLeft - block.startBase) / blockWidth -\n                    labelDiv.offsetWidth / block.domNode.offsetWidth)\n\n                // move our label div to the view start if the start is between the feature start and end\n                labelDiv.style.left =\n                  Math.max(minLeft, Math.min(viewLeft, maxLeft)) + '%'\n              },\n              this,\n            )\n          },\n          this,\n        )\n      },\n\n      fillBlock: function (args) {\n        var blockIndex = args.blockIndex\n        var block = args.block\n        var leftBase = args.leftBase\n        var rightBase = args.rightBase\n        var scale = args.scale\n        var containerStart = args.containerStart\n        var containerEnd = args.containerEnd\n\n        var region = {\n          ref: this.refSeq.name,\n          start: leftBase,\n          end: rightBase,\n        }\n\n        this.store.getGlobalStats(\n          dojo.hitch(this, function (stats) {\n            var density = stats.featureDensity\n            var histScale =\n              this.config.style.histScale ||\n              density * this.config.style._defaultHistScale\n            var featureScale =\n              this.config.style.featureScale ||\n              density / this.config.maxFeatureScreenDensity // (feat/bp) / ( feat/px ) = px/bp )\n\n            // only update the label once for each block size\n            var blockBases = Math.abs(leftBase - rightBase)\n            if (this._updatedLabelForBlockSize != blockBases) {\n              if (this.store.getRegionFeatureDensities && scale < histScale) {\n                this.setLabel(\n                  this.key +\n                    ' <span class=\"feature-density\">per ' +\n                    Util.addCommas(Math.round(blockBases / this.numBins)) +\n                    ' bp</span>',\n                )\n              } else {\n                this.setLabel(this.key)\n              }\n              this._updatedLabelForBlockSize = blockBases\n            }\n\n            // if our store offers density histograms, and we are zoomed out far enough, draw them\n            if (this.store.getRegionFeatureDensities && scale < histScale) {\n              this._fillType = 'histograms'\n              this.fillHistograms(args)\n            }\n            // if we have no histograms, check the predicted density of\n            // features on the screen, and display a message if it's\n            // bigger than maxFeatureScreenDensity\n            else if (scale < featureScale) {\n              this.fillTooManyFeaturesMessage(blockIndex, block, scale)\n              args.finishCallback()\n            } else {\n              // if we have transitioned to viewing features, delete the\n              // y-scale used for the histograms\n              this.removeYScale()\n              this._fillType = 'features'\n              this.fillFeatures(dojo.mixin({ stats: stats }, args))\n            }\n          }),\n          dojo.hitch(this, 'fillBlockError', blockIndex, block),\n        )\n      },\n\n      /**\n       * Creates a Y-axis scale for the feature histogram.  Must be run after\n       * the histogram bars are drawn, because it sometimes must use the\n       * track height to calculate the max value if there are no explicit\n       * histogram stats.\n       */\n      makeHistogramYScale: function (blockSizeBp, dims, histData) {\n        if (dims.logScale) {\n          console.error('Log histogram scale axis labels not yet implemented.')\n          return\n        }\n        var maxval = this.height / dims.pxPerCount\n        maxval = dims.logScale ? Math.log(maxval) : maxval\n\n        // if we have a scale, and it has the same characteristics\n        // (including pixel height), don't redraw it.\n        if (\n          this.yscale &&\n          this.yscale_params &&\n          this.yscale_params.maxval == maxval &&\n          this.yscale_params.height == this.height &&\n          this.yscale_params.blockbp == blockSizeBp\n        ) {\n          return\n        } else {\n          this.removeYScale()\n          this.makeYScale({ min: 0, max: maxval })\n          this.yscale_params = {\n            height: this.height,\n            blockbp: blockSizeBp,\n            maxval: maxval,\n          }\n        }\n      },\n\n      destroy: function () {\n        this._clearLayout()\n        this.inherited(arguments)\n      },\n\n      cleanupBlock: function (block) {\n        if (block) {\n          // discard the layout for this range\n          if (this.layout)\n            {this.layout.discardRange(block.startBase, block.endBase)}\n\n          if (block.featureNodes)\n            {for (var name in block.featureNodes) {\n              var featDiv = block.featureNodes[name]\n              array.forEach(\n                'track,feature,callbackArgs,_labelScale,_descriptionScale'.split(\n                  ',',\n                ),\n                function (a) {\n                  Util.removeAttribute(featDiv, a)\n                },\n              )\n              if ('label' in featDiv) {\n                array.forEach(\n                  'track,feature,callbackArgs'.split(','),\n                  function (a) {\n                    Util.removeAttribute(featDiv.label, a)\n                  },\n                )\n                Util.removeAttribute(featDiv, 'label')\n              }\n            }}\n        }\n\n        this.inherited(arguments)\n      },\n\n      /**\n       * Called when sourceBlock gets deleted.  Any child features of\n       * sourceBlock that extend onto destBlock should get moved onto\n       * destBlock.\n       */\n      transfer: function (\n        sourceBlock,\n        destBlock,\n        scale,\n        containerStart,\n        containerEnd,\n      ) {\n        if (!(sourceBlock && destBlock)) {return}\n\n        var destLeft = destBlock.startBase\n        var destRight = destBlock.endBase\n        var blockWidth = destRight - destLeft\n        var sourceSlot\n\n        var overlaps =\n          sourceBlock.startBase < destBlock.startBase\n            ? sourceBlock.rightOverlaps\n            : sourceBlock.leftOverlaps\n        overlaps = overlaps || []\n\n        for (var i = 0; i < overlaps.length; i++) {\n          //if the feature overlaps destBlock,\n          //move to destBlock & re-position\n          sourceSlot = sourceBlock.featureNodes[overlaps[i]]\n          if (sourceSlot && sourceSlot.label && sourceSlot.label.parentNode) {\n            sourceSlot.label.parentNode.removeChild(sourceSlot.label)\n          }\n          if (sourceSlot && sourceSlot.feature) {\n            if (\n              sourceSlot.layoutEnd > destLeft &&\n              sourceSlot.feature.get('start') < destRight\n            ) {\n              sourceSlot.parentNode.removeChild(sourceSlot)\n\n              delete sourceBlock.featureNodes[overlaps[i]]\n\n              /* feature render, adding to block, centering refactored into addFeatureToBlock() */\n              var featDiv = this.addFeatureToBlock(\n                sourceSlot.feature,\n                overlaps[i],\n                destBlock,\n                scale,\n                sourceSlot._labelScale,\n                sourceSlot._descriptionScale,\n                containerStart,\n                containerEnd,\n              )\n              // if there are boolean coverage divs, modify feature accordingly.\n              if (sourceSlot.booleanCovs) {\n                this._maskTransfer(\n                  featDiv,\n                  sourceSlot,\n                  containerStart,\n                  containerEnd,\n                )\n              }\n            }\n          }\n        }\n      },\n\n      /**\n       * Called by \"tranfer\" when sourceBlock gets deleted.  Ensures that any child features of\n       * sourceBlock that extend onto destBlock will remain masked when moved onto\n       * destBlock.\n       */\n      _maskTransfer: function (\n        featDiv,\n        sourceSlot,\n        containerStart,\n        containerEnd,\n      ) {\n        var subfeatures = []\n        // remove subfeatures\n        while (featDiv.firstChild) {\n          subfeatures.push(featDiv.firstChild)\n          featDiv.removeChild(featDiv.firstChild)\n        }\n        var s = featDiv.featureEdges.s\n        var e = featDiv.featureEdges.e\n        for (var key in sourceSlot.booleanCovs) {\n          if (sourceSlot.booleanCovs.hasOwnProperty(key)) {\n            // dynamically resize the coverage divs.\n            var start = sourceSlot.booleanCovs[key].span.s\n            var end = sourceSlot.booleanCovs[key].span.e\n            if (end < containerStart || start > containerEnd) {continue}\n            // note: we should also remove it from booleanCovs at some point.\n            sourceSlot.booleanCovs[key].style.left =\n              (100 * (start - s)) / (e - s) + '%'\n            sourceSlot.booleanCovs[key].style.width =\n              (100 * (end - start)) / (e - s) + '%'\n            featDiv.appendChild(sourceSlot.booleanCovs[key])\n          }\n        }\n        // add the processed subfeatures, if in frame.\n        query('.basicSubfeature', sourceSlot).forEach(\n          function (node, idx, arr) {\n            var start = node.subfeatureEdges.s\n            var end = node.subfeatureEdges.e\n            if (end < containerStart || start > containerEnd) {return}\n            node.style.left = (100 * (start - s)) / (e - s) + '%'\n            node.style.width = (100 * (end - start)) / (e - s) + '%'\n            featDiv.appendChild(node)\n          },\n        )\n        if (this.config.style.arrowheadClass) {\n          // add arrowheads\n          var a = this.config.style.arrowheadClass\n          query('.minus-' + a + ', .plus-' + a, sourceSlot).forEach(\n            function (node, idx, arr) {\n              featDiv.appendChild(node)\n            },\n          )\n        }\n        featDiv.className = 'basic'\n        featDiv.oldClassName = sourceSlot.oldClassName\n        featDiv.booleanCovs = sourceSlot.booleanCovs\n      },\n\n      /**\n       * arguments:\n       * @param args.block div to be filled with info\n       * @param args.leftBlock div to the left of the block to be filled\n       * @param args.rightBlock div to the right of the block to be filled\n       * @param args.leftBase starting base of the block\n       * @param args.rightBase ending base of the block\n       * @param args.scale pixels per base at the current zoom level\n       * @param args.containerStart don't make HTML elements extend further left than this\n       * @param args.containerEnd don't make HTML elements extend further right than this. 0-based.\n       */\n      fillFeatures: function (args) {\n        var blockIndex = args.blockIndex\n        var block = args.block\n        var leftBase = args.leftBase\n        var rightBase = args.rightBase\n        var scale = args.scale\n        var stats = args.stats\n        var containerStart = args.containerStart\n        var containerEnd = args.containerEnd\n        var finishCallback = args.finishCallback\n        var browser = this.browser\n\n        this.scale = scale\n\n        block.featureNodes = {}\n\n        //determine the glyph height, arrowhead width, label text dimensions, etc.\n        if (!this.haveMeasurements) {\n          this.measureStyles()\n          this.haveMeasurements = true\n        }\n\n        var labelScale =\n          this.config.style.labelScale ||\n          stats.featureDensity * this.config.style._defaultLabelScale\n        var descriptionScale =\n          this.config.style.descriptionScale ||\n          stats.featureDensity * this.config.style._defaultDescriptionScale\n\n        var curTrack = this\n\n        var featCallback = feature => {\n          // feature rendering, adding to block, centering refactored into addFeatureToBlock()\n\n          const uniqueId = feature.id()\n\n          if (this._featureIsRendered(uniqueId)) {return}\n\n          if (!this.filterFeature(feature)) {return}\n\n          // deprecated Apollo hook point, need to schedule this block for removal\n          if (typeof this.renderFilter === 'function') {\n            // deprecation warning\n            if (!this._warnedAboutRenderFilterDeprecation) {\n              console.warn(\n                'the HTMLFeatures.renderFilter is deprecated, please use the existing feature filtering functionality (addFeatureFilter)',\n              )\n              this._warnedAboutRenderFilterDeprecation = true\n            }\n\n            let render = this.renderFilter(feature)\n            if (render === 1)\n              {this.addFeatureToBlock(\n                feature,\n                uniqueId,\n                block,\n                scale,\n                labelScale,\n                descriptionScale,\n                containerStart,\n                containerEnd,\n              )}\n            return\n          }\n\n          // normal case\n          this.addFeatureToBlock(\n            feature,\n            uniqueId,\n            block,\n            scale,\n            labelScale,\n            descriptionScale,\n            containerStart,\n            containerEnd,\n          )\n        }\n\n        this.store.getFeatures(\n          { ref: this.refSeq.name, start: leftBase, end: rightBase },\n          featCallback,\n          function (args) {\n            curTrack.heightUpdate(\n              curTrack._getLayout(scale).getTotalHeight(),\n              blockIndex,\n            )\n            if (args && args.maskingSpans) {\n              //note: spans have to be inverted\n              var invSpan = []\n              invSpan[0] = { start: leftBase }\n              var i = 0\n              for (var span in args.maskingSpans) {\n                if (args.maskingSpans.hasOwnProperty(span)) {\n                  span = args.maskingSpans[span]\n                  invSpan[i].end = span.start\n                  i++\n                  invSpan[i] = { start: span.end }\n                }\n              }\n              invSpan[i].end = rightBase\n              if (invSpan[i].end <= invSpan[i].start) {\n                invSpan.splice(i, 1)\n              }\n              if (invSpan[0].end <= invSpan[0].start) {\n                invSpan.splice(0, 1)\n              }\n              curTrack.maskBySpans(invSpan, args.maskingSpans)\n            }\n            finishCallback()\n          },\n          function (error) {\n            console.error(error, error.stack)\n            curTrack.fillBlockError(blockIndex, block, error)\n            finishCallback()\n          },\n        )\n      },\n      /**\n       * template for renderFilter\n       * This hook allows filtering of features to render.\n       * @param {type} feature\n       * @returns true if render feature, false if not\n       */\n      /*\n             renderFilter: function(feature) {\n             return 1;\n             },\n             */\n      /**\n       *  Creates feature div, adds to block, and centers subfeatures.\n       *  Overridable by subclasses that need more control over the substructure.\n       */\n      addFeatureToBlock: function (\n        feature,\n        uniqueId,\n        block,\n        scale,\n        labelScale,\n        descriptionScale,\n        containerStart,\n        containerEnd,\n      ) {\n        var thisB = this\n\n        if (\n          (typeof this.browser.config.inferHTMLSubfeatures === 'undefined' ||\n            this.browser.config.inferHTMLSubfeatures === true) &&\n          feature.get('type') == 'gene' &&\n          feature.get('subfeatures')\n        ) {\n          var d = dojo.create('div')\n          var feats = feature.get('subfeatures')\n          if (!feats) {\n            return null\n          }\n          feats.forEach(function (feat) {\n            if (!thisB._featureIsRendered(uniqueId + '_' + thisB.getId(feat))) {\n              featDiv = thisB.renderFeature(\n                feat,\n                uniqueId + '_' + thisB.getId(feat),\n                block,\n                scale,\n                labelScale,\n                descriptionScale,\n                containerStart,\n                containerEnd,\n              )\n              if (featDiv) {\n                // In case the feature was not rendered (too many)\n                d.appendChild(featDiv)\n              }\n            }\n          })\n          block.domNode.appendChild(d)\n          if (this.config.style.centerChildrenVertically) {\n            d.childNodes.forEach(function (featDiv) {\n              thisB._centerChildrenVertically(featDiv)\n            })\n          }\n          return d\n        } else {\n          var featDiv = this.renderFeature(\n            feature,\n            uniqueId,\n            block,\n            scale,\n            labelScale,\n            descriptionScale,\n            containerStart,\n            containerEnd,\n          )\n          if (!featDiv) {return null}\n\n          block.domNode.appendChild(featDiv)\n          if (this.config.style.centerChildrenVertically)\n            {this._centerChildrenVertically(featDiv)}\n        }\n        return featDiv\n      },\n\n      fillBlockTimeout: function (blockIndex, block) {\n        this.inherited(arguments)\n        block.featureNodes = {}\n      },\n\n      /**\n       * Returns true if a feature is visible and rendered someplace in the blocks of this track.\n       * @private\n       */\n      _featureIsRendered: function (uniqueId) {\n        var blocks = this.blocks\n        for (var i = 0; i < blocks.length; i++) {\n          if (\n            blocks[i] &&\n            blocks[i].featureNodes &&\n            blocks[i].featureNodes[uniqueId]\n          )\n            {return true}\n        }\n        return false\n      },\n\n      /**\n       * If spans are passed to the track (i.e. if it is a boolean track), mask features accordingly.\n       */\n      maskBySpans: function (invSpans, spans) {\n        var blocks = this.blocks\n        for (var i in blocks) {\n          if (blocks.hasOwnProperty(i)) {\n            // loop through all blocks\n            if (!blocks[i]) {continue}\n            var block = blocks[i]\n            var bs = block.startBase\n            var be = block.endBase\n\n            var overlaps = function (featStart, featEnd, spanStart, spanEnd) {\n              // outputs start and end points of overlap\n              var s = Math.max(featStart, spanStart)\n              var e = Math.min(featEnd, spanEnd)\n              if (s < e) {\n                return { s: s, e: e }\n              }\n              return false\n            }\n\n            var union = function (start1, end1, start2, end2) {\n              // outputs the endpoints of the union\n              if (overlaps(start1, end1, start2, end2)) {\n                return {\n                  s: Math.min(start1, start2),\n                  e: Math.max(end1, end2),\n                }\n              } else {\n                return false\n              }\n            }\n\n            var makeDiv = function (start, end, parentDiv, masked, voidClass) {\n              // make a coverage div\n              var coverageNode = dojo.create('div')\n              var s = parentDiv.featureEdges\n                ? parentDiv.featureEdges.s\n                : parentDiv.subfeatureEdges.s\n              var e = parentDiv.featureEdges\n                ? parentDiv.featureEdges.e\n                : parentDiv.subfeatureEdges.e\n              coverageNode.span = { s: start, e: end }\n              coverageNode.className = masked\n                ? feat.className == voidClass\n                  ? feat.oldClassName + ' Boolean-transparent'\n                  : feat.className + ' Boolean-transparent'\n                : feat.className == voidClass\n                  ? feat.oldClassName\n                  : feat.className\n              coverageNode.booleanDiv = true\n              coverageNode.style.left = (100 * (start - s)) / (e - s) + '%'\n              coverageNode.style.top = '0px'\n              coverageNode.style.width = (100 * (end - start)) / (e - s) + '%'\n              return coverageNode\n            }\n\n            var addDiv = function (\n              start,\n              end,\n              parentDiv,\n              masked,\n              voidClass,\n              isAdded,\n            ) {\n              // Loop through coverage Nodes, combining existing nodes so they don't overlap, and add new divs.\n              isAdded = isAdded || false\n              for (var key in parentDiv.childNodes) {\n                if (\n                  parentDiv.childNodes[key] &&\n                  parentDiv.childNodes[key].booleanDiv\n                ) {\n                  var divStart = parentDiv.childNodes[key].span.s\n                  var divEnd = parentDiv.childNodes[key].span.e\n                  if (divStart <= start && divEnd >= end) {\n                    isAdded = true\n                    break\n                  }\n                  var u = union(start, end, divStart, divEnd)\n                  if (u) {\n                    var coverageNode = makeDiv(\n                      u.s,\n                      u.e,\n                      parentDiv,\n                      masked,\n                      voidClass,\n                    )\n                    var tempIndex = parentDiv.booleanCovs.indexOf(\n                      parentDiv.childNodes[key],\n                    )\n                    parentDiv.removeChild(parentDiv.childNodes[key])\n                    parentDiv.booleanCovs.splice(tempIndex, 1)\n                    parentDiv.appendChild(coverageNode)\n                    parentDiv.booleanCovs.push(coverageNode)\n                    isAdded = true\n                    addDiv(u.s, u.e, parentDiv, masked, voidClass, true)\n                    break\n                  }\n                }\n              }\n              if (!isAdded) {\n                var coverageNode = makeDiv(\n                  start,\n                  end,\n                  parentDiv,\n                  masked,\n                  voidClass,\n                )\n                parentDiv.appendChild(coverageNode)\n                parentDiv.booleanCovs.push(coverageNode)\n              }\n            }\n\n            var addOverlaps = function (\n              s,\n              e,\n              feat,\n              spans,\n              invSpans,\n              voidClass,\n            ) {\n              if (!feat.booleanCovs) {\n                feat.booleanCovs = []\n              }\n              // add opaque divs\n              for (var index in invSpans) {\n                if (invSpans.hasOwnProperty(index)) {\n                  var ov = overlaps(\n                    s,\n                    e,\n                    invSpans[index].start,\n                    invSpans[index].end,\n                  )\n                  if (ov) {\n                    addDiv(ov.s, ov.e, feat, false, voidClass)\n                  }\n                }\n              }\n              // add masked divs\n              for (var index in spans) {\n                if (spans.hasOwnProperty(index)) {\n                  var ov = overlaps(s, e, spans[index].start, spans[index].end)\n                  if (ov) {\n                    addDiv(ov.s, ov.e, feat, true, voidClass)\n                  }\n                }\n              }\n\n              feat.oldClassName =\n                feat.className == voidClass ? feat.oldClassName : feat.className\n              feat.className = voidClass\n            }\n\n            for (var key in block.featureNodes) {\n              if (block.featureNodes.hasOwnProperty(key)) {\n                var feat = block.featureNodes[key]\n                if (!feat.feature) {\n                  // If there is no feature property, than it is a subfeature\n                  var s = feat.subfeatureEdges.s\n                  var e = feat.subfeatureEdges.e\n                  addOverlaps(s, e, feat, spans, invSpans, 'basicSubfeature')\n                  continue\n                }\n                var s = feat.feature.get('start')\n                var e = feat.feature.get('end')\n                addOverlaps(s, e, feat, spans, invSpans, 'basic')\n              }\n            }\n          }\n        }\n      },\n\n      measureStyles: function () {\n        let container = this.browser.container\n\n        //determine dimensions of labels (height, per-character width)\n        var heightTest = document.createElement('div')\n        heightTest.className = 'feature-label'\n        heightTest.style.height = 'auto'\n        heightTest.style.visibility = 'hidden'\n        heightTest.appendChild(document.createTextNode('1234567890'))\n        container.appendChild(heightTest)\n        this.labelHeight = heightTest.clientHeight\n        this.labelWidth = heightTest.clientWidth / 10\n        container.removeChild(heightTest)\n\n        //measure the height of glyphs\n        var glyphBox\n        heightTest = document.createElement('div')\n        //cover all the bases: stranded or not, phase or not\n        heightTest.className =\n          'feature ' +\n          this.config.style.className +\n          ' plus-' +\n          this.config.style.className +\n          ' plus-' +\n          this.config.style.className +\n          '1'\n        if (this.config.style.featureCss)\n          {heightTest.style.cssText = this.config.style.featureCss}\n        heightTest.style.visibility = 'hidden'\n        if (Util.is_ie6) {heightTest.appendChild(document.createComment('foo'))}\n        container.appendChild(heightTest)\n        glyphBox = domGeom.getMarginBox(heightTest)\n        this.glyphHeight = Math.round(glyphBox.h)\n        this.padding = this.defaultPadding + glyphBox.w\n        container.removeChild(heightTest)\n\n        //determine the width of the arrowhead, if any\n        if (this.config.style.arrowheadClass) {\n          var ah = document.createElement('div')\n          ah.className = 'plus-' + this.config.style.arrowheadClass\n          if (Util.is_ie6) {ah.appendChild(document.createComment('foo'))}\n          container.appendChild(ah)\n          glyphBox = domGeom.position(ah)\n          this.plusArrowWidth = glyphBox.w\n          this.plusArrowHeight = glyphBox.h\n          ah.className = 'minus-' + this.config.style.arrowheadClass\n          glyphBox = domGeom.position(ah)\n          this.minusArrowWidth = glyphBox.w\n          this.minusArrowHeight = glyphBox.h\n          container.removeChild(ah)\n        }\n      },\n\n      hideAll: function () {\n        this._clearLayout()\n        return this.inherited(arguments)\n      },\n\n      getFeatDiv: function (feature) {\n        var id = this.getId(feature)\n        var gene_id\n\n        if (\n          (typeof this.browser.config.inferHTMLSubfeatures === 'undefined' ||\n            this.browser.config.inferHTMLSubfeatures === true) &&\n          feature.parent() &&\n          feature.parent().get('type') == 'gene'\n        ) {\n          gene_id = this.getId(feature.parent()) + '_' + this.getId(feature)\n        }\n\n        if (!id && !gene_id) {return null}\n\n        for (var i = 0; i < this.blocks.length; i++) {\n          var b = this.blocks[i]\n          if (b && b.featureNodes) {\n            var f = b.featureNodes[id]\n            if (f) {return f}\n            f = b.featureNodes[gene_id]\n            if (f) {return f}\n          }\n        }\n\n        return null\n      },\n\n      getId: function (f) {\n        return f.id()\n      },\n\n      renderFeature: function (\n        feature,\n        uniqueId,\n        block,\n        scale,\n        labelScale,\n        descriptionScale,\n        containerStart,\n        containerEnd,\n      ) {\n        //featureStart and featureEnd indicate how far left or right\n        //the feature extends in bp space, including labels\n        //and arrowheads if applicable\n\n        var featureEnd = feature.get('end')\n        var featureStart = feature.get('start')\n        if (typeof featureEnd == 'string') {featureEnd = parseInt(featureEnd)}\n        if (typeof featureStart == 'string')\n          {featureStart = parseInt(featureStart)}\n        // layoutStart: start genome coord (at current scale) of horizontal space need to render feature,\n        //       including decorations (arrowhead, label, etc) and padding\n        var layoutStart = featureStart\n        // layoutEnd: end genome coord (at current scale) of horizontal space need to render feature,\n        //       including decorations (arrowhead, label, etc) and padding\n        var layoutEnd = featureEnd\n\n        //     JBrowse now draws arrowheads within feature genome coord bounds\n        //     For WebApollo we're keeping arrow outside of feature genome coord bounds,\n        //           because otherwise arrow can obscure edge-matching, CDS/UTR transitions, small inton/exons, etc.\n        //     Would like to implement arrowhead change in WebApollo plugin, but would need to refactor HTMLFeature more to allow for that\n        if (this.config.style.arrowheadClass) {\n          switch (feature.get('strand')) {\n            case 1:\n            case '+':\n              layoutEnd += this.plusArrowWidth / scale\n              break\n            case -1:\n            case '-':\n              layoutStart -= this.minusArrowWidth / scale\n              break\n          }\n        }\n\n        var levelHeight = this.glyphHeight + this.glyphHeightPad\n\n        // if the label extends beyond the feature, use the\n        // label end position as the end position for layout\n        var name = this.getFeatureLabel(feature)\n        var description =\n          scale > descriptionScale && this.getFeatureDescription(feature)\n        if (\n          description &&\n          description.length > this.config.style.maxDescriptionLength\n        )\n          {description =\n            description\n              .substr(0, this.config.style.maxDescriptionLength + 1)\n              .replace(/(\\s+\\S+|\\s*)$/, '') + String.fromCharCode(8230)}\n\n        // add the label div (which includes the description) to the\n        // calculated height of the feature if it will be displayed\n        if (this.showLabels && scale >= labelScale && name) {\n          layoutEnd = Math.max(\n            layoutEnd,\n            layoutStart + (('' + name).length * this.labelWidth) / scale,\n          )\n          levelHeight += this.labelHeight + this.labelPad\n        }\n        if (this.showLabels && description) {\n          layoutEnd = Math.max(\n            layoutEnd,\n            layoutStart + (('' + description).length * this.labelWidth) / scale,\n          )\n          levelHeight += this.labelHeight + this.labelPad\n        }\n\n        layoutEnd += Math.max(1, this.padding / scale)\n\n        var top = this._getLayout(scale).addRect(\n          uniqueId,\n          layoutStart,\n          layoutEnd,\n          levelHeight,\n        )\n\n        if (top === null) {\n          // could not lay out, would exceed our configured maxHeight\n          // mark the block as exceeding the max height\n          this.markBlockHeightOverflow(block)\n          return null\n        }\n\n        var featDiv = this.config.hooks.create(this, feature)\n        this._connectFeatDivHandlers(featDiv)\n        // NOTE ANY DATA SET ON THE FEATDIV DOM NODE NEEDS TO BE\n        // MANUALLY DELETED IN THE cleanupBlock METHOD BELOW\n        featDiv.track = this\n        featDiv.feature = feature\n        featDiv.layoutEnd = layoutEnd\n\n        // border values used in positioning boolean subfeatures, if any.\n        featDiv.featureEdges = {\n          s: Math.max(featDiv.feature.get('start'), containerStart),\n          e: Math.min(featDiv.feature.get('end'), containerEnd),\n        }\n\n        // (callbackArgs are the args that will be passed to callbacks\n        // in this feature's context menu or left-click handlers)\n        featDiv.callbackArgs = [this, featDiv.feature, featDiv]\n\n        // save the label scale and description scale in the featDiv\n        // so that we can use them later\n        featDiv._labelScale = labelScale\n        featDiv._descriptionScale = descriptionScale\n\n        block.featureNodes[uniqueId] = featDiv\n\n        // hook point\n        if (typeof this.featureHook1 === 'function')\n          {this.featureHook1(feature, featDiv)}\n\n        // record whether this feature protrudes beyond the left and/or right side of the block\n        if (layoutStart < block.startBase) {\n          if (!block.leftOverlaps) {block.leftOverlaps = []}\n          block.leftOverlaps.push(uniqueId)\n        }\n        if (layoutEnd > block.endBase) {\n          if (!block.rightOverlaps) {block.rightOverlaps = []}\n          block.rightOverlaps.push(uniqueId)\n        }\n\n        dojo.addClass(featDiv, 'feature')\n        var className = this.config.style.className\n        if (className == '{type}') {\n          className = feature.get('type')\n        }\n        var strand = feature.get('strand')\n        switch (strand) {\n          case 1:\n          case '+':\n            dojo.addClass(featDiv, 'plus-' + className)\n            break\n          case -1:\n          case '-':\n            dojo.addClass(featDiv, 'minus-' + className)\n            break\n          default:\n            dojo.addClass(featDiv, className)\n        }\n        var phase = feature.get('phase')\n        if (phase !== null && phase !== undefined)\n          //            featDiv.className = featDiv.className + \" \" + featDiv.className + \"_phase\" + phase;\n          {dojo.addClass(featDiv, className + '_phase' + phase)}\n\n        // check if this feature is highlighted\n        var highlighted = this.isFeatureHighlighted(feature, name)\n\n        // add 'highlighted' to the feature's class if its name\n        // matches the objectName of the global highlight and it's\n        // within the highlighted region\n        if (highlighted) {dojo.addClass(featDiv, 'highlighted')}\n\n        // Since some browsers don't deal well with the situation where\n        // the feature goes way, way offscreen, we truncate the feature\n        // to exist betwen containerStart and containerEnd.\n        // To make sure the truncated end of the feature never gets shown,\n        // we'll destroy and re-create the feature (with updated truncated\n        // boundaries) in the transfer method.\n        var displayStart = Math.max(featureStart, containerStart)\n        var displayEnd = Math.min(featureEnd, containerEnd)\n        var blockWidth = block.endBase - block.startBase\n        var featwidth = Math.max(\n          this.minFeatWidth,\n          100 * ((displayEnd - displayStart) / blockWidth),\n        )\n        featDiv.style.cssText =\n          'left:' +\n          (100 * (displayStart - block.startBase)) / blockWidth +\n          '%;' +\n          'top:' +\n          top +\n          'px;' +\n          ' width:' +\n          featwidth +\n          '%;' +\n          (this.config.style.featureCss ? this.config.style.featureCss : '')\n\n        // Store the containerStart/End so we can resolve the truncation\n        // when we are updating static elements\n        featDiv._containerStart = containerStart\n        featDiv._containerEnd = containerEnd\n\n        if (this.config.style.arrowheadClass) {\n          var ah = document.createElement('div')\n          var featwidth_px = (featwidth / 100) * blockWidth * scale\n\n          switch (strand) {\n            case 1:\n            case '+':\n              ah.className = 'plus-' + this.config.style.arrowheadClass\n              ah.style.cssText = 'right: ' + -this.plusArrowWidth + 'px'\n              featDiv.appendChild(ah)\n              break\n            case -1:\n            case '-':\n              ah.className = 'minus-' + this.config.style.arrowheadClass\n              ah.style.cssText = 'left: ' + -this.minusArrowWidth + 'px'\n              featDiv.appendChild(ah)\n              break\n          }\n        }\n\n        // fill in the template parameters in the featDiv and also for the labelDiv (see below)\n        var context = lang.mixin({\n          track: this,\n          feature: feature,\n          callbackArgs: [this, feature],\n        })\n        if (featDiv.title) {\n          featDiv.title = this.template(\n            feature,\n            this._evalConf(context, featDiv.title, 'label'),\n          )\n        }\n\n        if ((name || description) && this.showLabels && scale >= labelScale) {\n          var labelDiv = dojo.create(\n            'div',\n            {\n              className: 'feature-label' + (highlighted ? ' highlighted' : ''),\n              innerHTML:\n                (name\n                  ? '<div class=\"feature-name\">' +\n                    (this.config.unsafeHTMLFeatures\n                      ? name\n                      : Util.escapeHTML(name)) +\n                    '</div>'\n                  : '') +\n                (description\n                  ? ' <div class=\"feature-description\">' +\n                    (this.config.unsafeHTMLFeatures\n                      ? description\n                      : Util.escapeHTML(description)) +\n                    '</div>'\n                  : ''),\n              style: {\n                top: top + this.glyphHeight + 2 + 'px',\n                left:\n                  (100 * (layoutStart - block.startBase)) / blockWidth + '%',\n              },\n            },\n            block.domNode,\n          )\n\n          this._connectFeatDivHandlers(labelDiv)\n\n          if (featDiv.title) {labelDiv.title = featDiv.title}\n          featDiv.label = labelDiv\n\n          // NOTE: ANY DATA ADDED TO THE labelDiv MUST HAVE A\n          // CORRESPONDING DELETE STATMENT IN cleanupBlock BELOW\n          labelDiv.feature = feature\n          labelDiv.track = this\n          // (callbackArgs are the args that will be passed to callbacks\n          // in this feature's context menu or left-click handlers)\n          labelDiv.callbackArgs = [this, featDiv.feature, featDiv]\n        }\n\n        if (featwidth > this.config.style.minSubfeatureWidth) {\n          this.handleSubFeatures(\n            feature,\n            featDiv,\n            displayStart,\n            displayEnd,\n            block,\n          )\n        }\n\n        // render the popup menu if configured\n        if (this.config.menuTemplate) {\n          window.setTimeout(\n            dojo.hitch(this, '_connectMenus', featDiv),\n            50 + Math.random() * 150,\n          )\n        }\n\n        if (typeof this.config.hooks.modify == 'function') {\n          this.config.hooks.modify(this, feature, featDiv)\n        }\n\n        return featDiv\n      },\n\n      handleSubFeatures: function (\n        feature,\n        featDiv,\n        displayStart,\n        displayEnd,\n        block,\n      ) {\n        var subfeatures = feature.get('subfeatures')\n        if (subfeatures) {\n          for (var i = 0; i < subfeatures.length; i++) {\n            this.renderSubfeature(\n              feature,\n              featDiv,\n              subfeatures[i],\n              displayStart,\n              displayEnd,\n              block,\n            )\n            var subfeature = subfeatures[i]\n            var subtype = subfeature.get('type')\n            if (subtype == 'mRNA') {\n              this.handleSubFeatures(\n                subfeature,\n                featDiv,\n                displayStart,\n                displayEnd,\n                block,\n              )\n            }\n          }\n        }\n      },\n\n      /**\n       * Get the height of a div.  Caches div heights based on\n       * classname.\n       */\n      _getHeight: function (theDiv) {\n        if (this.config.disableHeightCache) {\n          return theDiv.offsetHeight || 0\n        } else {\n          var c = this.heightCache[theDiv.className]\n          if (c) {return c}\n          c = theDiv.offsetHeight || 0\n          this.heightCache[theDiv.className] = c\n          return c\n        }\n      },\n\n      /**\n       * Vertically centers all the child elements of a feature div.\n       * @private\n       */\n      _centerChildrenVertically: function (/**HTMLElement*/ featDiv) {\n        if (featDiv.childNodes.length > 0) {\n          var parentHeight = this._getHeight(featDiv)\n          for (var i = 0; i < featDiv.childNodes.length; i++) {\n            var child = featDiv.childNodes[i]\n            // only operate on child nodes that can be styled,\n            // i.e. HTML elements instead of text nodes or whatnot\n            if (child.style) {\n              // cache the height of elements, for speed.\n              var h = this._getHeight(child)\n              dojo.style(child, {\n                marginTop: '0',\n                top: (parentHeight - h) / 2 + 'px',\n              })\n              // recursively center any descendants\n              if (child.childNodes.length > 0) {\n                this._centerChildrenVertically(child)\n              }\n            }\n          }\n        }\n      },\n\n      /**\n       * Connect our configured event handlers to a given html element,\n       * usually a feature div or label div.\n       */\n      _connectFeatDivHandlers: function (/** HTMLElement */ div) {\n        for (var event in this.eventHandlers) {\n          this.own(on(div, event, this.eventHandlers[event]))\n        }\n        // if our click handler has a label, set that as a tooltip\n        if (this.eventHandlers.click && this.eventHandlers.click.label)\n          {div.setAttribute('title', this.eventHandlers.click.label)}\n      },\n\n      _connectMenus: function (featDiv) {\n        // don't actually make the menu until the feature is\n        // moused-over.  pre-generating menus for lots and lots of\n        // features at load time is way too slow.\n        var refreshMenu = lang.hitch(this, '_refreshMenu', featDiv)\n        this.own(on(featDiv, 'mouseover', refreshMenu))\n        if (featDiv.label) {\n          this.own(on(featDiv.label, 'mouseover', refreshMenu))\n        }\n      },\n\n      _refreshMenu: function (featDiv) {\n        // if we already have a menu generated for this feature,\n        // give it a new lease on life\n        if (!featDiv.contextMenu) {\n          featDiv.contextMenu = this._makeFeatureContextMenu(\n            featDiv,\n            this.config.menuTemplate,\n          )\n        }\n\n        // give the menu a timeout so that it's cleaned up if it's not used within a certain time\n        if (featDiv.contextMenuTimeout) {\n          window.clearTimeout(featDiv.contextMenuTimeout)\n        }\n        var timeToLive = 30000 // clean menus up after 30 seconds\n        featDiv.contextMenuTimeout = window.setTimeout(function () {\n          if (featDiv.contextMenu) {\n            featDiv.contextMenu.destroyRecursive()\n            Util.removeAttribute(featDiv, 'contextMenu')\n          }\n          Util.removeAttribute(featDiv, 'contextMenuTimeout')\n        }, timeToLive)\n      },\n\n      /**\n       * Make the right-click dijit menu for a feature.\n       */\n      _makeFeatureContextMenu: function (featDiv, menuTemplate) {\n        // interpolate template strings in the menuTemplate\n        menuTemplate = this._processMenuSpec(dojo.clone(menuTemplate), featDiv)\n\n        // render the menu, start it up, and bind it to right-clicks\n        // both on the feature div and on the label div\n        var menu = this._renderContextMenu(menuTemplate, featDiv)\n        menu.startup()\n        menu.bindDomNode(featDiv)\n        if (featDiv.label) {menu.bindDomNode(featDiv.label)}\n\n        return menu\n      },\n\n      renderSubfeature: function (\n        feature,\n        featDiv,\n        subfeature,\n        displayStart,\n        displayEnd,\n        block,\n      ) {\n        var subStart = subfeature.get('start')\n        var subEnd = subfeature.get('end')\n        var featLength = displayEnd - displayStart\n        var type = subfeature.get('type')\n        var className\n        if (this.config.style.subfeatureClasses) {\n          className = this.config.style.subfeatureClasses[type]\n          // if no class mapping specified for type, default to subfeature.get('type')\n          if (className === undefined) {\n            className = type\n          }\n          // if subfeatureClasses specifies that subfeature type explicitly maps to null className\n          //     then don't render the feature\n          else if (className === null) {\n            return null\n          }\n        } else {\n          // if no config.style.subfeatureClasses to specify subfeature class mapping, default to subfeature.get('type')\n          className = type\n        }\n\n        // a className of 'hidden' causes things to not even be rendered\n        if (className == 'hidden') {return null}\n\n        var subDiv = document.createElement('div')\n        // used by boolean tracks to do positiocning\n        subDiv.subfeatureEdges = { s: subStart, e: subEnd }\n\n        dojo.addClass(subDiv, 'subfeature')\n        // check for className to avoid adding \"null\", \"plus-null\", \"minus-null\"\n        if (className) {\n          switch (subfeature.get('strand')) {\n            case 1:\n            case '+':\n              dojo.addClass(subDiv, 'plus-' + className)\n              break\n            case -1:\n            case '-':\n              dojo.addClass(subDiv, 'minus-' + className)\n              break\n            default:\n              dojo.addClass(subDiv, className)\n          }\n        }\n\n        // if the feature has been truncated to where it doesn't cover\n        // this subfeature anymore, just skip this subfeature\n\n        var truncate = false\n        if (\n          typeof this.config.truncateFeatures !== 'undefined' &&\n          this.config.truncateFeatures === true\n        )\n          {truncate = true}\n\n        if (truncate && (subEnd <= displayStart || subStart >= displayEnd))\n          {return null}\n\n        if (Util.is_ie6) {subDiv.appendChild(document.createComment())}\n\n        subDiv.style.cssText =\n          'left: ' +\n          100 * ((subStart - displayStart) / featLength) +\n          '%;' +\n          'width: ' +\n          100 * ((subEnd - subStart) / featLength) +\n          '%;'\n        featDiv.appendChild(subDiv)\n\n        block.featureNodes[subfeature.id()] = subDiv\n\n        return subDiv\n      },\n\n      _getLayout: function (scale) {\n        //determine the glyph height, arrowhead width, label text dimensions, etc.\n        if (!this.haveMeasurements) {\n          this.measureStyles()\n          this.haveMeasurements = true\n        }\n\n        // create the layout if we need to, and we can\n        if ((!this.layout || this.layout.pitchX != 4 / scale) && scale)\n          {this.layout = new Layout({\n            pitchX: 4 / scale,\n            pitchY:\n              this.config.layoutPitchY ||\n              this.glyphHeight + this.glyphHeightPad,\n            maxHeight: this.getConf('maxHeight'),\n          })}\n\n        return this.layout\n      },\n      _clearLayout: function () {\n        delete this.layout\n      },\n\n      clear: function () {\n        delete this.layout\n        this.inherited(arguments)\n      },\n\n      /**\n       *   indicates a change to this track has happened that may require a re-layout\n       *   clearing layout here, and relying on superclass BlockBased.changed() call and\n       *   standard _changedCallback function passed in track constructor to trigger relayout\n       */\n      changed: function () {\n        this._clearLayout()\n        this.inherited(arguments)\n      },\n\n      _exportFormats: function () {\n        return [\n          { name: 'GFF3', label: 'GFF3', fileExt: 'gff3' },\n          { name: 'BED', label: 'BED', fileExt: 'bed' },\n          {\n            name: 'SequinTable',\n            label: 'Sequin Table',\n            fileExt: 'sqn',\n          },\n        ]\n      },\n\n      _trackMenuOptions: function () {\n        var o = this.inherited(arguments)\n        var track = this\n\n        o.push.apply(o, [\n          { type: 'dijit/MenuSeparator' },\n          {\n            label: 'Show labels',\n            type: 'dijit/CheckedMenuItem',\n            checked: !!('showLabels' in this\n              ? this.showLabels\n              : this.config.style.showLabels),\n            onClick: function (event) {\n              track.showLabels = this.checked\n              track.changed()\n            },\n          },\n        ])\n\n        return o\n      },\n    },\n  )\n\n  return HTMLFeatures\n})\n\n/*\n\n Copyright (c) 2007-2010 The Evolutionary Software Foundation\n\n Created by Mitchell Skinner <mitch_skinner@berkeley.edu>\n\n This package and its accompanying libraries are free software; you can\n redistribute it and/or modify it under the terms of the LGPL (either\n version 2.1, or at your option, any later version) or the Artistic\n License 2.0.  Refer to LICENSE for the full license text.\n\n */\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/Track/HTMLVariants.js":{"size":714,"mtime":1738905963132,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/Track/HTMLVariants.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/Track/LocationScale.js":{"size":2672,"mtime":1738905963135,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/Track/LocationScale.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'dojo/dom-construct',\n  'JBrowse/View/Track/BlockBased',\n  'JBrowse/Util',\n], function (declare, dom, BlockBased, Util) {\n  return declare(\n    BlockBased,\n    /**\n     * @lends JBrowse.View.Track.LocationScale.prototype\n     */\n    {\n      /**\n       * This track is for (e.g.) position and sequence information that should\n       * always stay visible at the top of the view.\n       * @constructs\n       */\n\n      constructor: function (args) {\n        //name, labelClass, posHeight) {\n        this.loaded = true\n        this.labelClass = args.labelClass\n        this.posHeight = args.posHeight\n        this.height = Math.round(args.posHeight * 1.2)\n      },\n\n      // this track has no track label or track menu, stub them out\n      makeTrackLabel: function () {},\n      makeTrackMenu: function () {},\n\n      fillBlock: function (args) {\n        var blockIndex = args.blockIndex\n        var block = args.block\n        var leftBase = args.leftBase\n        var scale = args.scale\n        var thisB = this\n\n        // find the number that is within 2 px of the left boundary of\n        // the block that ends with the most zeroes, or a 5 if no\n        // zeroes\n        var labelNumber = this.chooseLabel(args)\n        var labelOffset = ((leftBase + 1 - labelNumber) * scale) / 10\n        // console.log( leftBase+1, labelNumber, labelOffset );\n\n        var posLabel = document.createElement('div')\n        var numtext = Util.addCommas(labelNumber)\n        posLabel.className = this.labelClass\n\n        // give the position label a negative left offset in ex's to\n        // more-or-less center it over the left boundary of the block\n        posLabel.style.left =\n          '-' + Number(numtext.length) / 1.7 + labelOffset + 'ex'\n\n        posLabel.appendChild(document.createTextNode(numtext))\n        block.domNode.appendChild(posLabel)\n\n        var highlight = this.browser.getHighlight()\n        if (highlight && highlight.ref == this.refSeq.name) {\n          this.renderRegionHighlight(args, highlight)\n        }\n\n        var bookmarks = this.browser.getBookmarks()\n        if (bookmarks) {\n          this.renderRegionBookmark(args, bookmarks, this.refSeq.name, true)\n        }\n\n        this.heightUpdate(Math.round(this.posHeight * 1.2), blockIndex)\n        args.finishCallback()\n      },\n\n      chooseLabel: function (viewArgs) {\n        var left = viewArgs.leftBase + 1\n        var width = viewArgs.rightBase - left + 1\n        var scale = viewArgs.scale\n        for (var mod = 1000000; mod > 0; mod /= 10) {\n          if ((left % mod) * scale <= 3) {return left - (left % mod)}\n        }\n        return left\n      },\n    },\n  )\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/Track/Sequence.js":{"size":13449,"mtime":1738905963148,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/Track/Sequence.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'dojo/_base/array',\n  'dojo/_base/lang',\n  'dojo/dom-construct',\n  'dojo/dom-class',\n  'dojo/query',\n  'JBrowse/View/Track/BlockBased',\n  'JBrowse/View/Track/_ExportMixin',\n  'JBrowse/CodonTable',\n  'JBrowse/Util',\n], function (\n  declare,\n  array,\n  lang,\n  dom,\n  domClass,\n  query,\n  BlockBased,\n  ExportMixin,\n  CodonTable,\n  Util,\n) {\n  return declare(\n    [BlockBased, ExportMixin, CodonTable],\n    /**\n     * @lends JBrowse.View.Track.Sequence.prototype\n     */\n    {\n      /**\n       * Track to display the underlying reference sequence, when zoomed in\n       * far enough.\n       *\n       * @constructs\n       * @extends JBrowse.View.Track.BlockBased\n       */\n      constructor: function (args) {\n        this._charMeasurements = {}\n        this._codonTable = this.generateCodonTable(\n          lang.mixin(this.defaultCodonTable, this.config.codonTable),\n        )\n        this._codonStarts = this.config.codonStarts || this.defaultStarts\n        this._codonStops = this.config.codonStops || this.defaultStops\n      },\n\n      _defaultConfig: function () {\n        return {\n          maxExportSpan: 500000,\n          showForwardStrand: true,\n          showReverseStrand: true,\n          showTranslation: true,\n          showColor: true,\n          seqType: 'dna',\n          proteinColorScheme: 'taylor',\n        }\n      },\n      _exportFormats: function () {\n        return [{ name: 'FASTA', label: 'FASTA', fileExt: 'fasta' }]\n      },\n\n      endZoom: function (destScale, destBlockBases) {\n        this.clear()\n      },\n\n      setViewInfo: function (\n        genomeView,\n        heightUpdate,\n        numBlocks,\n        trackDiv,\n        widthPct,\n        widthPx,\n        scale,\n      ) {\n        this.inherited(arguments)\n        this.show()\n      },\n\n      nbsp: String.fromCharCode(160),\n\n      fillBlock: function (args) {\n        var blockIndex = args.blockIndex\n        var block = args.block\n        var leftBase = args.leftBase\n        var rightBase = args.rightBase\n        var scale = args.scale\n\n        var leftExtended = leftBase - 2\n        var rightExtended = rightBase + 2\n\n        var thisB = this\n\n        var blur = dojo.create(\n          'div',\n          {\n            className: 'sequence_blur',\n            innerHTML: '<span class=\"loading\">Loading</span>',\n          },\n          block.domNode,\n        )\n\n        this.heightUpdate(blur.offsetHeight + 2 * blur.offsetTop, blockIndex)\n\n        // if we are zoomed in far enough to draw bases, then draw them\n        if (scale >= 1.3) {\n          this.store.getReferenceSequence(\n            {\n              ref: this.refSeq.name,\n              start: leftExtended,\n              end: rightExtended,\n            },\n            function (seq) {\n              if (seq.trim() == '') {\n                blur.innerHTML =\n                  '<span class=\"zoom\">No sequence available</span>'\n              } else {\n                dom.empty(block.domNode)\n                thisB._fillSequenceBlock(block, blockIndex, scale, seq)\n              }\n              args.finishCallback()\n            },\n            function (error) {\n              if (args.errorCallback) {args.errorCallback(error)}\n              else {\n                console.error(error)\n                args.finishCallback()\n              }\n            },\n          )\n        }\n        // otherwise, just draw a sort of line (possibly dotted) that\n        // suggests there are bases there if you zoom in far enough\n        else {\n          blur.innerHTML = '<span class=\"zoom\">Zoom in to see sequence</span>'\n          args.finishCallback()\n        }\n      },\n\n      _fillSequenceBlock: function (block, blockIndex, scale, seq) {\n        seq = seq.replace(/\\s/g, this.nbsp)\n\n        var blockStart = block.startBase\n        var blockEnd = block.endBase\n        var blockSeq = seq.substring(2, seq.length - 2)\n        var blockLength = blockSeq.length\n\n        var extStart = blockStart - 2\n        var extEnd = blockStart + 2\n        var leftover = (seq.length - 2) % 3\n        var extStartSeq = seq.substring(0, seq.length - 2)\n        var extEndSeq = seq.substring(2)\n\n        if (this.config.showForwardStrand && this.config.showTranslation) {\n          var frameDiv = []\n          for (var i = 0; i < 3; i++) {\n            var transStart = blockStart + i\n            var frame = ((transStart % 3) + 3) % 3\n            var translatedDiv = this._renderTranslation(\n              extEndSeq,\n              i,\n              blockStart,\n              blockEnd,\n              blockLength,\n              scale,\n            )\n            frameDiv[frame] = translatedDiv\n            domClass.add(translatedDiv, 'frame' + frame)\n          }\n          for (var i = 2; i >= 0; i--) {\n            block.domNode.appendChild(frameDiv[i])\n          }\n        }\n\n        // make a table to contain the sequences\n        var charSize = this.getCharacterMeasurements('sequence')\n        var bigTiles = scale > charSize.w + 4 // whether to add .big styles to the base tiles\n        var seqNode\n        if (this.config.showReverseStrand || this.config.showForwardStrand)\n          {seqNode = dom.create(\n            'table',\n            {\n              className:\n                'sequence' +\n                (bigTiles ? ' big' : '') +\n                (this.config.showColor ? '' : ' nocolor'),\n              style: { width: '100%' },\n            },\n            block.domNode,\n          )}\n\n        // add a table for the forward strand\n        if (this.config.showForwardStrand)\n          {seqNode.appendChild(\n            this._renderSeqTr(blockStart, blockEnd, blockSeq, scale),\n          )}\n\n        // and one for the reverse strand\n        if (this.config.showReverseStrand) {\n          var comp = this._renderSeqTr(\n            blockStart,\n            blockEnd,\n            Util.complement(blockSeq),\n            scale,\n          )\n          comp.className = 'revcom'\n          seqNode.appendChild(comp)\n\n          if (this.config.showTranslation) {\n            var frameDiv = []\n            for (var i = 0; i < 3; i++) {\n              var transStart = blockStart + 1 - i\n              var frame = ((transStart % 3) + 3 + leftover) % 3\n              var translatedDiv = this._renderTranslation(\n                extStartSeq,\n                i,\n                blockStart,\n                blockEnd,\n                blockLength,\n                scale,\n                true,\n              )\n              frameDiv[frame] = translatedDiv\n              domClass.add(translatedDiv, 'frame' + frame)\n            }\n            for (var i = 0; i < 3; i++) {\n              block.domNode.appendChild(frameDiv[i])\n            }\n          }\n        }\n\n        var totalHeight = 0\n        array.forEach(block.domNode.childNodes, function (table) {\n          totalHeight += table.clientHeight || table.offsetHeight\n        })\n        this.heightUpdate(totalHeight, blockIndex)\n      },\n\n      _renderTranslation: function (\n        seq,\n        offset,\n        blockStart,\n        blockEnd,\n        blockLength,\n        scale,\n        reverse,\n      ) {\n        seq = reverse ? Util.revcom(seq) : seq\n\n        var extraBases = (seq.length - offset) % 3\n        var seqSliced = seq.slice(offset, seq.length - extraBases)\n\n        var translated = ''\n        for (var i = 0; i < seqSliced.length; i += 3) {\n          var nextCodon = seqSliced.slice(i, i + 3)\n          var aminoAcid = this._codonTable[nextCodon] || this.nbsp\n          translated += aminoAcid\n        }\n\n        translated = reverse\n          ? translated.split('').reverse().join('')\n          : translated // Flip the translated seq for left-to-right rendering\n        var orientedSeqSliced = reverse\n          ? seqSliced.split('').reverse().join('')\n          : seqSliced\n\n        var charSize = this.getCharacterMeasurements('aminoAcid')\n        var bigTiles = scale > charSize.w + 4 // whether to add .big styles to the base tiles\n\n        var charWidth = 100 / (blockLength / 3)\n\n        var container = dom.create('div', {\n          className: 'translatedSequence',\n        })\n        var table = dom.create(\n          'table',\n          {\n            className:\n              'translatedSequence offset' + offset + (bigTiles ? ' big' : ''),\n            style: {\n              width: charWidth * translated.length + '%',\n            },\n          },\n          container,\n        )\n        var tr = dom.create('tr', {}, table)\n\n        table.style.left =\n          (reverse\n            ? 100 - charWidth * (translated.length + offset / 3)\n            : (charWidth * offset) / 3) + '%'\n\n        charWidth = 100 / translated.length + '%'\n\n        var drawChars = scale >= charSize.w\n        if (drawChars) {table.className += ' big'}\n\n        for (var i = 0; i < translated.length; i++) {\n          var aminoAcidSpan = document.createElement('td')\n          var originalCodon = orientedSeqSliced.slice(3 * i, 3 * i + 3)\n          originalCodon = reverse\n            ? originalCodon.split('').reverse().join('')\n            : originalCodon\n          aminoAcidSpan.className =\n            'aminoAcid aminoAcid_' + translated.charAt(i).toLowerCase()\n\n          // However, if it's known to be a start/stop, apply those CSS classes instead.\n          if (this._codonStarts.indexOf(originalCodon.toUpperCase()) != -1) {\n            aminoAcidSpan.className = 'aminoAcid aminoAcid_start'\n          }\n          if (this._codonStops.indexOf(originalCodon.toUpperCase()) != -1) {\n            aminoAcidSpan.className = 'aminoAcid aminoAcid_stop'\n          }\n\n          aminoAcidSpan.style.width = charWidth\n          if (drawChars) {\n            aminoAcidSpan.innerHTML = translated.charAt(i)\n          }\n          tr.appendChild(aminoAcidSpan)\n        }\n        return container\n      },\n\n      /**\n       * Given the start and end coordinates, and the sequence bases,\n       * makes a table row containing the sequence.\n       * @private\n       */\n      _renderSeqTr: function (start, end, seq, scale) {\n        var charSize = this.getCharacterMeasurements('sequence')\n        var container = document.createElement('tr')\n        var charWidth = 100 / (end - start) + '%'\n        var drawChars = scale >= charSize.w\n        var baseClassDefault = 'base'\n        if (this.config.seqType === 'protein') {\n          baseClassDefault += ' aaScheme_' + this.config.proteinColorScheme\n        }\n        for (var i = 0; i < seq.length; i++) {\n          var base = document.createElement('td')\n          base.className =\n            baseClassDefault + ' base_' + seq.charAt(i).toLowerCase()\n          base.style.width = charWidth\n          if (drawChars) {\n            base.innerHTML = seq.charAt(i)\n          }\n          container.appendChild(base)\n        }\n        return container\n      },\n\n      startZoom: function () {\n        query('.base', this.div).empty()\n      },\n\n      /**\n       * @returns {Object} containing <code>h</code> and <code>w</code>,\n       *      in pixels, of the characters being used for sequences\n       */\n      getCharacterMeasurements: function (className) {\n        return (\n          this._charMeasurements[className] ||\n          (this._charMeasurements[className] =\n            this._measureSequenceCharacterSize(this.div, className))\n        )\n      },\n\n      /**\n       * Conducts a test with DOM elements to measure sequence text width\n       * and height.\n       */\n      _measureSequenceCharacterSize: function (containerElement, className) {\n        var widthTest = document.createElement('td')\n        widthTest.className = className\n        widthTest.style.visibility = 'hidden'\n        var widthText = '12345678901234567890123456789012345678901234567890'\n        widthTest.appendChild(document.createTextNode(widthText))\n        containerElement.appendChild(widthTest)\n        var result = {\n          w: widthTest.clientWidth / widthText.length + 1,\n          h: widthTest.clientHeight,\n        }\n        containerElement.removeChild(widthTest)\n        return result\n      },\n\n      _trackMenuOptions: function () {\n        var track = this\n        var o = this.inherited(arguments)\n        o.push({ type: 'dijit/MenuSeparator' })\n        o.push.apply(o, [\n          {\n            label: 'Show forward strand',\n            type: 'dijit/CheckedMenuItem',\n            checked: !!this.config.showForwardStrand,\n            onClick: function (event) {\n              track.config.showForwardStrand = this.checked\n              track.changed()\n            },\n          },\n          {\n            label: 'Show reverse strand',\n            type: 'dijit/CheckedMenuItem',\n            checked: !!this.config.showReverseStrand,\n            onClick: function (event) {\n              track.config.showReverseStrand = this.checked\n              track.changed()\n            },\n          },\n          {\n            label: 'Show translation',\n            type: 'dijit/CheckedMenuItem',\n            checked: !!this.config.showTranslation,\n            onClick: function (event) {\n              track.config.showTranslation = this.checked\n              track.changed()\n            },\n          },\n          {\n            label: 'Show color',\n            type: 'dijit/CheckedMenuItem',\n            checked: !!this.config.showColor,\n            onClick: function (event) {\n              track.config.showColor = this.checked\n              track.changed()\n            },\n          },\n        ])\n        return o\n      },\n    },\n  )\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/Track/SNPCoverage.js":{"size":12609,"mtime":1738905963160,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/Track/SNPCoverage.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'dojo/_base/array',\n  'JBrowse/View/Track/Wiggle/XYPlot',\n  'JBrowse/Util',\n  'JBrowse/View/Track/_AlignmentsMixin',\n  'JBrowse/Store/SeqFeature/SNPCoverage',\n], function (\n  declare,\n  array,\n  WiggleXY,\n  Util,\n  AlignmentsMixin,\n  SNPCoverageStore,\n) {\n  var dojof = Util.dojof\n\n  return declare([WiggleXY, AlignmentsMixin], {\n    constructor: function () {\n      // force conf variables that are meaningless for this kind of track, and maybe harmful\n      delete this.config.bicolor_pivot\n      delete this.config.scale\n      delete this.config.align\n\n      var thisB = this\n      this.store = new SNPCoverageStore({\n        store: this.store,\n        config: {\n          mismatchScale: this.config.mismatchScale,\n          indicatorProp: this.config.indicatorProp,\n          indicatorDepth: this.config.indicatorDepth,\n        },\n        browser: this.browser,\n        filter: function (f) {\n          return thisB.filterFeature(f)\n        },\n      })\n    },\n\n    _defaultConfig: function () {\n      return Util.deepUpdate(dojo.clone(this.inherited(arguments)), {\n        autoscale: 'local',\n        min_score: 0,\n\n        mismatchScale: 1 / 10,\n        indicatorProp: 0.5,\n        indicatorDepth: 1,\n\n        hideDuplicateReads: true,\n        logScaleOption: false,\n        hideQCFailingReads: true,\n        hideSecondary: true,\n        hideSupplementary: true,\n        hideMissingMatepairs: false,\n        hideImproperPairs: false,\n        hideUnmapped: true,\n      })\n    },\n\n    /*\n     * Draw a set of features on the canvas.\n     * @private\n     */\n    _drawFeatures: function (\n      scale,\n      leftBase,\n      rightBase,\n      block,\n      canvas,\n      features,\n      featureRects,\n      dataScale,\n    ) {\n      var thisB = this\n      var context = canvas.getContext('2d')\n      var canvasHeight = canvas.height\n\n      var ratio = Util.getResolution(\n        context,\n        this.browser.config.highResolutionMode,\n      )\n      var toY = dojo.hitch(this, function (val) {\n        return (canvasHeight * (1 - dataScale.normalize(val))) / ratio\n      })\n      var originY = toY(dataScale.origin)\n\n      // a canvas element below the histogram that will contain indicators of likely SNPs\n      var snpCanvasHeight = 20\n      var snpCanvas = dojo.create(\n        'canvas',\n        {\n          height: snpCanvasHeight,\n          width: canvas.width,\n          style: {\n            cursor: 'default',\n            width: '100%',\n            height: snpCanvasHeight + 'px',\n          },\n          innerHTML: 'Your web browser cannot display this type of track.',\n          className: 'SNP-indicator-track',\n        },\n        block.domNode,\n      )\n      var snpContext = snpCanvas.getContext('2d')\n\n      // finally query the various pixel ratios\n      var ratio = Util.getResolution(\n        snpContext,\n        this.browser.config.highResolutionMode,\n      )\n      // upscale canvas if the two ratios don't match\n      if (this.browser.config.highResolutionMode != 'disabled' && ratio != 1) {\n        var oldWidth = snpCanvas.width\n        var oldHeight = snpCanvas.height\n\n        snpCanvas.width = oldWidth * ratio\n        snpCanvas.height = oldHeight * ratio\n\n        //c.style.width = oldWidth + 'px';\n        snpCanvas.style.height = oldHeight + 'px'\n\n        // now scale the context to counter\n        // the fact that we've manually scaled\n        // our canvas element\n        snpContext.scale(ratio, ratio)\n      }\n\n      var negColor = this.config.style.neg_color\n      var clipColor = this.config.style.clip_marker_color\n      var bgColor = this.config.style.bg_color\n      var disableClipMarkers = this.config.disable_clip_markers\n\n      var drawRectangle = function (ID, yPos, height, fRect) {\n        if (yPos <= canvasHeight) {\n          // if the rectangle is visible at all\n          context.fillStyle = thisB.colorForBase(ID)\n          if (yPos <= originY) {\n            // bar goes upward\n            thisB._fillRectMod(context, fRect.l, yPos, fRect.w, height)\n            if (!disableClipMarkers && yPos < 0) {\n              // draw clip marker if necessary\n              context.fillStyle = clipColor || negColor\n              thisB._fillRectMod(context, fRect.l, 0, fRect.w, 2)\n            }\n          } else {\n            // bar goes downward\n            thisB._fillRectMod(context, fRect.l, originY, fRect.w, height)\n            if (!disableClipMarkers && yPos >= canvasHeight) {\n              // draw clip marker if necessary\n              context.fillStyle = clipColor || thisB.colorForBase(ID)\n              thisB._fillRectMod(context, fRect.l, canvasHeight - 3, fRect.w, 2)\n            }\n          }\n        }\n      }\n\n      // Note: 'reference' is done first to ensure the grey part of the graph is on top\n      dojo.forEach(features, function (f, i) {\n        var fRect = featureRects[i]\n        var score = f.get('score')\n\n        // draw the background color if we are configured to do so\n        if (bgColor) {\n          context.fillStyle = bgColor\n          thisB._fillRectMod(context, fRect.l, 0, fRect.w, canvasHeight)\n        }\n\n        drawRectangle(\n          'reference',\n          toY(score.total()),\n          originY - toY(score.get('reference')) + 1,\n          fRect,\n        )\n      })\n\n      var indicatorMinHeightProp = this.config.indicatorProp\n      var indicatorMinHeight = this.config.indicatorDepth\n\n      dojo.forEach(\n        features,\n        function (f, i) {\n          var fRect = featureRects[i]\n          var score = f.get('score')\n          var totalHeight = score.total()\n\n          // draw indicators of SNPs if base coverage is greater than 50% of total coverage\n          score.forEach(function (count, category) {\n            if (\n              !{ reference: true, skip: true, deletion: true }[category] &&\n              count >= indicatorMinHeightProp * totalHeight &&\n              count >= indicatorMinHeight\n            ) {\n              snpContext.save()\n              if (thisB.browser.config.highResolutionMode != 'disabled')\n                {snpContext.scale(ratio, 1)}\n              snpContext.beginPath()\n              snpContext.arc(\n                fRect.l + 0.5 * fRect.w,\n                (0.4 * snpCanvas.height) / ratio,\n                (0.2 * snpCanvas.height) / ratio,\n                1.75 * Math.PI,\n                1.25 * Math.PI,\n                false,\n              )\n              snpContext.lineTo(fRect.l + 0.5 * fRect.w, 0)\n              snpContext.closePath()\n              snpContext.fillStyle = thisB.colorForBase(category)\n              snpContext.fill()\n              snpContext.lineWidth = 1\n              snpContext.strokeStyle = 'black'\n              snpContext.stroke()\n              if (thisB.browser.config.highResolutionMode != 'disabled')\n                {snpContext.restore()}\n            }\n          })\n\n          totalHeight -= score.get('reference')\n\n          score.forEach(function (count, category) {\n            if (category != 'reference') {\n              drawRectangle(\n                category,\n                toY(totalHeight),\n                originY - toY(count) + 1,\n                fRect,\n              )\n              totalHeight -= count\n            }\n          })\n        },\n        this,\n      )\n    },\n\n    // Overwrites the method from WiggleBase\n    _draw: function (\n      scale,\n      leftBase,\n      rightBase,\n      block,\n      canvas,\n      features,\n      featureRects,\n      dataScale,\n      pixels,\n      spans,\n    ) {\n      // Note: pixels currently has no meaning, as the function that generates it is not yet defined for this track\n      this._preDraw(\n        scale,\n        leftBase,\n        rightBase,\n        block,\n        canvas,\n        features,\n        featureRects,\n        dataScale,\n      )\n      this._drawFeatures(\n        scale,\n        leftBase,\n        rightBase,\n        block,\n        canvas,\n        features,\n        featureRects,\n        dataScale,\n      )\n      if (spans) {\n        this._maskBySpans(scale, leftBase, canvas, spans)\n      }\n      this._postDraw(\n        scale,\n        leftBase,\n        rightBase,\n        block,\n        canvas,\n        features,\n        featureRects,\n        dataScale,\n      )\n    },\n\n    /* If it's a boolean track, mask accordingly */\n    _maskBySpans: function (scale, leftBase, canvas, spans) {\n      var context = canvas.getContext('2d')\n      var canvasHeight = canvas.height\n      var booleanAlpha = this.config.style.masked_transparancy || 0.17\n      this.config.style.masked_transparancy = booleanAlpha\n\n      // make a temporary canvas to store image data\n      var tempCan = dojo.create('canvas', {\n        height: canvasHeight,\n        width: canvas.width,\n      })\n      var ctx2 = tempCan.getContext('2d')\n\n      for (var index in spans) {\n        if (spans.hasOwnProperty(index)) {\n          var w = Math.round((spans[index].end - spans[index].start) * scale)\n          var l = Math.round((spans[index].start - leftBase) * scale)\n          if (l + w >= canvas.width) {w = canvas.width - l} // correct possible rounding errors\n          if (w == 0) {continue} // skip if there's no width.\n          ctx2.drawImage(canvas, l, 0, w, canvasHeight, l, 0, w, canvasHeight)\n          context.globalAlpha = booleanAlpha\n          // clear masked region and redraw at lower opacity.\n          context.clearRect(l, 0, w, canvasHeight)\n          context.drawImage(\n            tempCan,\n            l,\n            0,\n            w,\n            canvasHeight,\n            l,\n            0,\n            w,\n            canvasHeight,\n          )\n          context.globalAlpha = 1\n        }\n      }\n    },\n\n    /*\n     * The following method is required to override the equivalent method in \"WiggleBase.js\"\n     * It displays more complete data.\n     */\n    _showPixelValue: function (scoreDisplay, score) {\n      if (!score || !score.score) {return false}\n      score = score.score\n\n      function fmtNum(num) {\n        return parseFloat(num)\n          .toPrecision(6)\n          .replace(/0+$/, '')\n          .replace(/\\.$/, '')\n      }\n      function pctString(count) {\n        count = Math.round((count / total) * 100)\n        if (typeof count == 'number' && !isNaN(count)) {return count + '%'}\n        return ''\n      }\n      if (score.snpsCounted) {\n        var total = score.total()\n        var scoreSummary = '<table>'\n\n        score.forEach(function (count, category) {\n          // if this count has more nested categories, do counts of those\n          var subdistribution = ''\n          if (count.forEach) {\n            subdistribution = []\n            count.forEach(function (count, category) {\n              subdistribution.push(fmtNum(count) + ' ' + category)\n            })\n            subdistribution = subdistribution.join(', ')\n            if (subdistribution) {subdistribution = '(' + subdistribution + ')'}\n          }\n\n          category =\n            { '*': 'del', reference: 'Ref', skip: 'Skip/intron' }[category] ||\n            category\n          scoreSummary +=\n            '<tr><td>' +\n            category +\n            '</td><td class=\"count\">' +\n            fmtNum(count) +\n            '</td><td class=\"pct\">' +\n            pctString(count) +\n            '</td><td class=\"subdist\">' +\n            subdistribution +\n            '</td></tr>'\n        })\n        scoreSummary +=\n          '<tr class=\"total\"><td>Total</td><td class=\"count\">' +\n          fmtNum(total) +\n          '</td><td class=\"pct\">&nbsp;</td><td class=\"subdist\">&nbsp;</td></tr>'\n        scoreDisplay.innerHTML = scoreSummary + '</table>'\n        return true\n      } else {\n        scoreDisplay.innerHTML =\n          '<table><tr><td>Total</td><td class=\"count\">' +\n          fmtNum(score) +\n          '</td></tr></table>'\n        return true\n      }\n    },\n\n    _trackMenuOptions: function () {\n      var thisB = this\n      var displayOptions = []\n\n      displayOptions.push({\n        label: 'View alignments',\n        onClick: function (event) {\n          thisB.config.type = 'JBrowse/View/Track/Alignments2'\n          thisB.config._oldSnpCoverageHeight = thisB.config.style.height\n          thisB.config.style.height = thisB.config._oldAlignmentsHeight\n          thisB.browser.publish('/jbrowse/v1/v/tracks/replace', [thisB.config])\n        },\n      })\n\n      return Promise.all([\n        this.inherited(arguments),\n        this._alignmentsFilterTrackMenuOptions(),\n        displayOptions,\n      ]).then(function (options) {\n        var o = options.shift()\n        options.unshift({ type: 'dijit/MenuSeparator' })\n        return o.concat.apply(o, options)\n      })\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/Track/Wiggle.js":{"size":84,"mtime":1738905963162,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/Track/Wiggle.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/Track/Wiggle/_Scale.js":{"size":5805,"mtime":1738905963171,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/Track/Wiggle/_Scale.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"/**\n * The scaling used for drawing a Wiggle track, which is the data's\n * origin.\n *\n * Has numeric attributes range, min, max, origin, and offset.\n */\n\ndefine(['dojo/_base/lang', 'JBrowse/Util', 'JBrowse/Digest/Crc32'], function (\n  lang,\n  Util,\n  Digest,\n) {\n  return Util.fastDeclare({\n    // Returns a boolean value saying whether a stats object is needed\n    // to calculate the scale for the given configuration.\n    //\n    // This is invokable either on the class (prototype) or on\n    // the object itself, so does not use `this` in its implementation.\n    needStats: function (config) {\n      return !(\n        'min_score' in config &&\n        'max_score' in config &&\n        config.bicolor_pivot != 'z_score' &&\n        config.bicolor_pivot != 'mean' &&\n        config.scale != 'z_score'\n      )\n    },\n\n    constructor: function (config, stats) {\n      var needStats = this.needStats(config)\n      if (needStats && !stats)\n        {throw 'No stats object provided, cannot calculate scale'}\n\n      if (needStats && stats.scoreMin == stats.scoreMax) {\n        stats = lang.mixin({}, stats)\n        if (stats.scoreMin < 0) {stats.scoreMax = 0}\n        else {stats.scoreMin = 0}\n      }\n\n      // if either autoscale or scale is set to z_score, the other one should default to z_score\n      if (\n        (config.autoscale == 'z_score' && !config.scale) ||\n        (config.scale == 'z_score' && !config.autoscale)\n      ) {\n        config.scale = 'z_score'\n        config.autoscale = 'z_score'\n      }\n\n      var z_score_bound = parseFloat(config.z_score_bound) || 4\n      var min =\n        'min_score' in config\n          ? parseFloat(config.min_score)\n          : (function () {\n              switch (config.autoscale) {\n                case 'z_score':\n                  return Math.max(\n                    -z_score_bound,\n                    (stats.scoreMin - stats.scoreMean) / stats.scoreStdDev,\n                  )\n                case 'global':\n                case 'local':\n                  return stats.scoreMin\n                case 'clipped_global':\n                /* fall through */\n                default:\n                  return Math.max(\n                    stats.scoreMin,\n                    stats.scoreMean - z_score_bound * stats.scoreStdDev,\n                  )\n              }\n            })()\n      var max =\n        'max_score' in config\n          ? parseFloat(config.max_score)\n          : (function () {\n              switch (config.autoscale) {\n                case 'z_score':\n                  return Math.min(\n                    z_score_bound,\n                    (stats.scoreMax - stats.scoreMean) / stats.scoreStdDev,\n                  )\n                case 'global':\n                case 'local':\n                  return stats.scoreMax\n                case 'clipped_global':\n                /* fall through */\n                default:\n                  return Math.min(\n                    stats.scoreMax,\n                    stats.scoreMean + z_score_bound * stats.scoreStdDev,\n                  )\n              }\n            })()\n\n      if (typeof min != 'number' || isNaN(min)) {\n        min = 0\n      }\n      if (typeof max != 'number' || isNaN(max)) {\n        max = min + 10\n      }\n\n      var offset = parseFloat(config.data_offset) || 0\n\n      if (config.scale == 'log') {\n        max = this.log(max + offset)\n        min = this.log(min + offset)\n      } else {\n        max += offset\n        min += offset\n      }\n\n      var origin = (function () {\n        if ('bicolor_pivot' in config) {\n          if (config.bicolor_pivot == 'mean') {\n            return stats.scoreMean || 0\n          } else if (config.bicolor_pivot == 'zero') {\n            return 0\n          } else {\n            return parseFloat(config.bicolor_pivot)\n          }\n        } else if (config.scale == 'z_score') {\n          return stats.scoreMean || 0\n        } else if (config.scale == 'log') {\n          return 1\n        } else {\n          return 0\n        }\n      })()\n\n      lang.mixin(this, {\n        offset: offset,\n        min: min,\n        max: max,\n        range: max - min,\n        origin: origin,\n        _statsFingerprint: Digest.objectFingerprint(stats),\n      })\n      if (needStats) {\n        this.scoreMean = stats.scoreMean\n        this.scoreStdDev = stats.scoreStdDev\n      }\n\n      // make this.normalize a func that converts wiggle values to a\n      // range between 0 and 1, depending on what kind of scale we\n      // are using\n      this.normalize = (function (config) {\n        switch (config.scale) {\n          case 'z_score':\n            return function (value) {\n              return (\n                (value + this.offset - this.scoreMean) / this.scoreStdDev -\n                this.min / this.range\n              )\n            }\n          case 'log':\n            return function (value) {\n              return (this.log(value + this.offset) - this.min) / this.range\n            }\n          case 'linear':\n          /* fall through */\n          default:\n            return function (value) {\n              return (value + this.offset - this.min) / this.range\n            }\n        }\n      })(config)\n    },\n\n    log: function (value) {\n      return value ? Math.log(Math.abs(value)) * (value < 0 ? -1 : 1) : 0\n    },\n\n    /**\n     * Standard comparison function, compare this scale to another one.\n     */\n    compare: function (b) {\n      if (!b) {return 1}\n\n      var a = this\n      return (\n        a.offset - b.offset ||\n        a.min - b.min ||\n        a.max - b.max ||\n        a.range - b.range ||\n        a.origin - b.origin\n      )\n    },\n\n    /**\n     * Return true if this scaling was generated from the same set of stats.\n     */\n    sameStats: function (stats) {\n      return this._statsFingerprint == Digest.objectFingerprint(stats)\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/Track/Wiggle/Density.js":{"size":4448,"mtime":1738905963178,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/Track/Wiggle/Density.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/Track/Wiggle/XYPlot.js":{"size":10199,"mtime":1738905963187,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/Track/Wiggle/XYPlot.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'dojo/_base/array',\n  'dojo/_base/Color',\n  'dojo/on',\n  'JBrowse/View/Track/WiggleBase',\n  'JBrowse/View/Track/_YScaleMixin',\n  'JBrowse/Util',\n  './_Scale',\n], function (declare, array, Color, on, WiggleBase, YScaleMixin, Util, Scale) {\n  var XYPlot = declare(\n    [WiggleBase, YScaleMixin],\n\n    /**\n     * Wiggle track that shows data with an X-Y plot along the reference.\n     *\n     * @lends JBrowse.View.Track.Wiggle.XYPlot\n     * @extends JBrowse.View.Track.WiggleBase\n     */\n    {\n      _defaultConfig: function () {\n        return Util.deepUpdate(dojo.clone(this.inherited(arguments)), {\n          style: {\n            pos_color: 'blue',\n            neg_color: 'red',\n            origin_color: '#888',\n            variance_band_color: 'rgba(0,0,0,0.3)',\n          },\n        })\n      },\n\n      _trackMenuOptions: function () {\n        var track = this\n        var options = this.inherited(arguments) || []\n\n        options.push({\n          label: 'No fill',\n          type: 'dijit/CheckedMenuItem',\n          checked: !!(this.config.noFill == true),\n          onClick: function (event) {\n            if (this.checked) {\n              track.config.noFill = true\n            } else {\n              track.config.noFill = false\n            }\n            track.browser.publish('/jbrowse/v1/v/tracks/replace', [\n              track.config,\n            ])\n          },\n        })\n\n        return options\n      },\n\n      _getScaling: function (viewArgs, successCallback, errorCallback) {\n        this._getScalingStats(\n          viewArgs,\n          dojo.hitch(this, function (stats) {\n            //calculate the scaling if necessary\n            if (\n              !this.lastScaling ||\n              !this.lastScaling.sameStats(stats) ||\n              this.trackHeightChanged\n            ) {\n              var scaling = new Scale(this.config, stats)\n\n              // bump minDisplayed to 0 if it is within 0.5% of it\n              if (Math.abs(scaling.min / scaling.max) < 0.005) {scaling.min = 0}\n\n              // update our track y-scale to reflect it\n              this.makeYScale({\n                fixBounds:\n                  'fixBounds' in this.config ? this.config.fixBounds : true,\n                min: scaling.min,\n                max: scaling.max,\n              })\n\n              // and finally adjust the scaling to match the ruler's scale rounding\n              scaling.min = this.ruler.scaler.bounds.lower\n              scaling.max = this.ruler.scaler.bounds.upper\n              scaling.range = scaling.max - scaling.min\n\n              this.lastScaling = scaling\n              this.trackHeightChanged = false //reset flag\n            }\n\n            successCallback(this.lastScaling)\n          }),\n          errorCallback,\n        )\n      },\n\n      updateStaticElements: function (coords) {\n        this.inherited(arguments)\n        this.updateYScaleFromViewDimensions(coords)\n      },\n\n      /**\n       * Draw a set of features on the canvas.\n       * @private\n       */\n      _drawFeatures: function (\n        scale,\n        leftBase,\n        rightBase,\n        block,\n        canvas,\n        pixels,\n        dataScale,\n      ) {\n        var thisB = this\n        var context = canvas.getContext('2d')\n        var canvasHeight = canvas.height\n\n        var ratio = Util.getResolution(\n          context,\n          this.browser.config.highResolutionMode,\n        )\n        var toY = dojo.hitch(this, function (val) {\n          return (canvasHeight * (1 - dataScale.normalize(val))) / ratio\n        })\n        var originY = toY(dataScale.origin)\n\n        var disableClipMarkers = this.config.disable_clip_markers\n\n        dojo.forEach(\n          pixels,\n          function (p, i) {\n            if (!p) {return}\n            var score = toY(p['score'])\n            var f = p['feat']\n\n            // draw the background color if we are configured to do so\n            if (score >= 0) {\n              var bgColor = this.getConfForFeature('style.bg_color', f)\n              if (bgColor) {\n                context.fillStyle = bgColor\n                thisB._fillRectMod(context, i, 0, 1, canvasHeight)\n              }\n            }\n\n            if (score <= canvasHeight || score > originY) {\n              // if the rectangle is visible at all\n              if (score <= originY) {\n                // bar goes upward\n                context.fillStyle = this.getConfForFeature('style.pos_color', f)\n                var height = originY - score + 1\n                if (this.getConfForFeature('noFill', f) == true) {\n                  height = 1\n                }\n                thisB._fillRectMod(context, i, score, 1, height)\n                if (!disableClipMarkers && score < 0) {\n                  // draw clip marker if necessary\n                  context.fillStyle =\n                    this.getConfForFeature('style.clip_marker_color', f) ||\n                    this.getConfForFeature('style.neg_color', f)\n                  thisB._fillRectMod(context, i, 0, 1, 3)\n                }\n              } else {\n                // bar goes downward\n                context.fillStyle = this.getConfForFeature('style.neg_color', f)\n                var top = originY\n                var height = score - originY\n                if (this.getConfForFeature('noFill', f) == true) {\n                  top = score - 1\n                  height = 1\n                }\n                thisB._fillRectMod(context, i, top, 1, height)\n                if (!disableClipMarkers && score >= canvasHeight) {\n                  // draw clip marker if necessary\n                  context.fillStyle =\n                    this.getConfForFeature('style.clip_marker_color', f) ||\n                    this.getConfForFeature('style.pos_color', f)\n                  thisB._fillRectMod(context, i, canvasHeight - 3, 1, 3)\n                }\n              }\n            }\n          },\n          this,\n        )\n      },\n\n      /* If it's a boolean track, mask accordingly */\n      _maskBySpans: function (\n        scale,\n        leftBase,\n        rightBase,\n        block,\n        canvas,\n        pixels,\n        dataScale,\n        spans,\n      ) {\n        var context = canvas.getContext('2d')\n        var canvasHeight = canvas.height\n\n        for (var index in spans) {\n          if (spans.hasOwnProperty(index)) {\n            var w = Math.ceil((spans[index].end - spans[index].start) * scale)\n            var l = Math.round((spans[index].start - leftBase) * scale)\n            context.clearRect(l, 0, w, canvasHeight)\n          }\n        }\n        context.globalAlpha = this.config.style.masked_transparancy || 0.2\n        this.config.style.masked_transparancy = context.globalAlpha\n        this._drawFeatures(\n          scale,\n          leftBase,\n          rightBase,\n          block,\n          canvas,\n          pixels,\n          dataScale,\n        )\n      },\n\n      /**\n       * Draw anything needed after the features are drawn.\n       */\n      _postDraw: function (\n        scale,\n        leftBase,\n        rightBase,\n        block,\n        canvas,\n        features,\n        featureRects,\n        dataScale,\n      ) {\n        var context = canvas.getContext('2d')\n        var canvasHeight = canvas.height\n\n        var ratio = Util.getResolution(\n          context,\n          this.browser.config.highResolutionMode,\n        )\n        var toY = dojo.hitch(this, function (val) {\n          return (canvasHeight * (1 - dataScale.normalize(val))) / ratio\n        })\n        var thisB = this\n\n        // draw the variance_band if requested\n        if (this.config.variance_band) {\n          var bandPositions =\n            typeof this.config.variance_band == 'object'\n              ? array\n                  .map(this.config.variance_band, function (v) {\n                    return parseFloat(v)\n                  })\n                  .sort()\n                  .reverse()\n              : [2, 1]\n          this.getGlobalStats(\n            dojo.hitch(this, function (stats) {\n              if ('scoreMean' in stats && 'scoreStdDev' in stats) {\n                var drawVarianceBand = function (plusminus, fill, label) {\n                  context.fillStyle = fill\n                  var varTop = toY(stats.scoreMean + plusminus)\n                  var varHeight = toY(stats.scoreMean - plusminus) - varTop\n                  varHeight = Math.max(1, varHeight)\n                  thisB._fillRectMod(\n                    context,\n                    0,\n                    varTop,\n                    canvas.width,\n                    varHeight,\n                  )\n                  context.font = '12px sans-serif'\n                  if (plusminus > 0) {\n                    context.fillText('+' + label, 2, varTop)\n                    context.fillText('-' + label, 2, varTop + varHeight)\n                  } else {\n                    context.fillText(label, 2, varTop)\n                  }\n                }\n\n                var maxColor = new Color(this.config.style.variance_band_color)\n                var minColor = new Color(this.config.style.variance_band_color)\n                minColor.a /= bandPositions.length\n\n                var bandOpacityStep = 1 / bandPositions.length\n                var minOpacity = bandOpacityStep\n\n                array.forEach(bandPositions, function (pos, i) {\n                  drawVarianceBand(\n                    pos * stats.scoreStdDev,\n                    Color.blendColors(\n                      minColor,\n                      maxColor,\n                      (i + 1) / bandPositions.length,\n                    ).toCss(true),\n                    pos + 'σ',\n                  )\n                })\n                drawVarianceBand(0, 'rgba(255,255,0,0.7)', 'mean')\n              }\n            }),\n          )\n        }\n\n        // draw the origin line if it is not disabled\n        var originColor = this.config.style.origin_color\n        if (\n          typeof originColor == 'string' &&\n          !{ none: 1, off: 1, no: 1, zero: 1 }[originColor]\n        ) {\n          var originY = toY(dataScale.origin)\n          context.fillStyle = originColor\n          context.fillRect(0, originY, canvas.width, 1)\n        }\n      },\n    },\n  )\n\n  return XYPlot\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/Track/WiggleBase.js":{"size":22008,"mtime":1738905963208,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/Track/WiggleBase.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'dojo/_base/array',\n  'dojo/_base/lang',\n  'dojo/_base/event',\n  'dojo/dom-construct',\n  'dojo/on',\n  'dojo/mouse',\n  'JBrowse/View/Track/BlockBased',\n  'JBrowse/View/Track/_ExportMixin',\n  'JBrowse/View/Track/_TrackDetailsStatsMixin',\n  'JBrowse/View/Dialog/SetTrackHeight',\n  'JBrowse/Util',\n  'JBrowse/has',\n  './Wiggle/_Scale',\n], function (\n  declare,\n  array,\n  lang,\n  domEvent,\n  dom,\n  on,\n  mouse,\n  BlockBasedTrack,\n  ExportMixin,\n  DetailStatsMixin,\n  TrackHeightDialog,\n  Util,\n  has,\n  Scale,\n) {\n  return declare([BlockBasedTrack, ExportMixin, DetailStatsMixin], {\n    constructor: function (args) {\n      this.trackPadding = args.trackPadding || 0\n\n      if (!('style' in this.config)) {\n        this.config.style = {}\n      }\n\n      this.store = args.store\n\n      this._setupEventHandlers()\n    },\n\n    _defaultConfig: function () {\n      return {\n        maxExportSpan: 500000,\n        autoscale: 'global',\n        logScaleOption: true,\n      }\n    },\n\n    _setupEventHandlers: function () {\n      // make a default click event handler\n      var eventConf = dojo.clone(this.config.events || {})\n      if (!eventConf.click) {\n        // unlike CanvasFeatures, linkTemplate or nothing here... no default contentDialog since no equivalent to defaultFeatureDetail\n        if ((this.config.style || {}).linkTemplate) {\n          eventConf.click = {\n            action: 'newWindow',\n            url: this.config.style.linkTemplate,\n          }\n        }\n      }\n\n      // process the configuration to set up our event handlers\n      this.eventHandlers = function () {\n        var handlers = dojo.clone(eventConf)\n        // find conf vars that set events, like `onClick`\n        for (var key in this.config) {\n          var handlerName = key.replace(/^on(?=[A-Z])/, '')\n          if (handlerName != key)\n            {handlers[handlerName.toLowerCase()] = this.config[key]}\n        }\n        // interpret handlers that are just strings to be URLs that should be opened\n        for (key in handlers) {\n          if (typeof handlers[key] == 'string')\n            {handlers[key] = { url: handlers[key] }}\n        }\n        return handlers\n      }.call(this)\n      // only call _makeClickHandler() if we have related settings in config\n      if (this.eventHandlers.click)\n        {this.eventHandlers.click = this._makeClickHandler(\n          this.eventHandlers.click,\n        )}\n    },\n\n    _getScaling: function (viewArgs, successCallback, errorCallback) {\n      this._getScalingStats(\n        viewArgs,\n        dojo.hitch(this, function (stats) {\n          //calculate the scaling if necessary\n          if (!this.lastScaling || !this.lastScaling.sameStats(stats)) {\n            try {\n              this.lastScaling = new Scale(this.config, stats)\n              successCallback(this.lastScaling)\n            } catch (e) {\n              errorCallback(e)\n            }\n          } else {\n            successCallback(this.lastScaling)\n          }\n        }),\n        errorCallback,\n      )\n    },\n\n    // get the statistics to use for scaling, if necessary, either\n    // from the global stats for the store, or from the local region\n    // if config.autoscale is 'local'\n    _getScalingStats: function (viewArgs, callback, errorCallback) {\n      if (!Scale.prototype.needStats(this.config)) {\n        callback(null)\n        return null\n      } else if (this.config.autoscale == 'local') {\n        var region = lang.mixin(\n          { scale: viewArgs.scale },\n          this.browser.view.visibleRegion(),\n        )\n        region.start = Math.ceil(region.start)\n        region.end = Math.floor(region.end)\n        return this.getRegionStats.call(this, region, callback, errorCallback)\n      } else {\n        return this.getGlobalStats.call(this, callback, errorCallback)\n      }\n    },\n\n    getFeatures: function (query, callback, errorCallback) {\n      this.store.getFeatures.apply(this.store, arguments)\n    },\n\n    getGlobalStats: function (successCallback, errorCallback) {\n      this.store.getGlobalStats(successCallback, errorCallback)\n    },\n\n    getRegionStats: function (region, successCallback, errorCallback) {\n      this.store.getRegionStats(region, successCallback, errorCallback)\n    },\n\n    // the canvas width in pixels for a block\n    _canvasWidth: function (block) {\n      return Math.ceil((block.endBase - block.startBase) * block.scale)\n    },\n\n    // the canvas height in pixels for a block\n    _canvasHeight: function () {\n      return parseInt((this.config.style || {}).height) || 100\n    },\n\n    _getBlockFeatures: function (args) {\n      var thisB = this\n      var blockIndex = args.blockIndex\n      var block = args.block\n\n      var leftBase = args.leftBase\n      var rightBase = args.rightBase\n\n      var scale = args.scale\n      var finishCallback = args.finishCallback || function () {}\n\n      var canvasWidth = this._canvasWidth(args.block)\n\n      var features = []\n      this.getFeatures(\n        {\n          ref: this.refSeq.name,\n          basesPerSpan: 1 / scale,\n          scale: scale,\n          start: leftBase,\n          end: rightBase + 1,\n        },\n\n        function (f) {\n          if (thisB.filterFeature(f)) {features.push(f)}\n        },\n        dojo.hitch(this, function (args) {\n          // if the block has been freed in the meantime,\n          // don't try to render\n          if (!(block.domNode && block.domNode.parentNode)) {return}\n\n          var featureRects = array.map(\n            features,\n            function (f) {\n              return this._featureRect(scale, leftBase, canvasWidth, f)\n            },\n            this,\n          )\n\n          block.features = features //< TODO: remove this\n          block.featureRects = featureRects\n          block.pixelScores = this._calculatePixelScores(\n            this._canvasWidth(block),\n            features,\n            featureRects,\n          )\n\n          if (args && args.maskingSpans) {block.maskingSpans = args.maskingSpans} // used for masking\n\n          finishCallback()\n        }),\n        dojo.hitch(this, function (e) {\n          console.error(e.stack || '' + e, e)\n          this._handleError(e, args)\n        }),\n      )\n    },\n\n    // render the actual graph display for the block.  should be called only after a scaling\n    // has been decided upon and stored in this.scaling\n    renderBlock: function (args) {\n      var block = args.block\n\n      // don't render this block again if we have already rendered\n      // it with this scaling scheme\n      if (!this.scaling.compare(block.scaling) || !block.pixelScores) {return}\n\n      block.scaling = this.scaling\n\n      dom.empty(block.domNode)\n\n      try {\n        dojo.create('canvas').getContext('2d').fillStyle = 'red'\n      } catch (e) {\n        this.fatalError = 'This browser does not support HTML canvas elements.'\n        this.fillBlockError(args.blockIndex, block, this.fatalError)\n        return\n      }\n\n      var features = block.features\n      var featureRects = block.featureRects\n      var dataScale = this.scaling\n      var canvasHeight = this._canvasHeight()\n\n      var c = dojo.create(\n        'canvas',\n        {\n          height: canvasHeight,\n          width: this._canvasWidth(block),\n          style: {\n            cursor: 'default',\n            height: canvasHeight + 'px',\n            width: has('inaccurate-html-width') ? '' : '100%',\n            'min-width': has('inaccurate-html-width') ? '100%' : '',\n            'max-width': has('inaccurate-html-width') ? '102%' : '',\n          },\n          innerHTML: 'Your web browser cannot display this type of track.',\n          className: 'canvas-track',\n        },\n        block.domNode,\n      )\n\n      var ctx = c.getContext('2d')\n      var ratio = Util.getResolution(\n        ctx,\n        this.browser.config.highResolutionMode,\n      )\n\n      // upscale canvas if the two ratios don't match\n      if (this.browser.config.highResolutionMode != 'disabled' && ratio >= 1) {\n        var oldWidth = c.width\n        var oldHeight = c.height\n\n        c.width = Math.round(oldWidth * ratio)\n        c.height = Math.round(oldHeight * ratio)\n\n        //c.style.width = oldWidth + 'px';\n        c.style.height = oldHeight + 'px'\n\n        // now scale the context to counter\n        // the fact that we've manually scaled\n        // our canvas element\n        ctx.scale(ratio, ratio)\n      }\n\n      c.startBase = block.startBase\n      block.canvas = c\n\n      //Calculate the score for each pixel in the block\n      var pixels = this._calculatePixelScores(c.width, features, featureRects)\n\n      this._draw(\n        block.scale,\n        block.startBase,\n        block.endBase,\n        block,\n        c,\n        features,\n        featureRects,\n        dataScale,\n        pixels,\n        block.maskingSpans,\n      ) // note: spans may be undefined.\n\n      this.heightUpdate(c.height / ratio, args.blockIndex)\n      if (!(c.parentNode && c.parentNode.parentNode)) {\n        var blockWidth = block.endBase - block.startBase\n\n        c.style.position = 'absolute'\n        c.style.left =\n          100 * ((c.startBase - block.startBase) / blockWidth) + '%'\n        switch (this.config.align) {\n          case 'top':\n            c.style.top = '0px'\n            break\n          case 'bottom':\n          /* fall through */\n          default:\n            c.style.bottom = this.trackPadding + 'px'\n            break\n        }\n      }\n    },\n\n    fillBlock: function (args) {\n      var thisB = this\n      this.heightUpdate(this._canvasHeight(), args.blockIndex)\n\n      // hook updateGraphs onto the end of the block feature fetch\n      var oldFinish = args.finishCallback || function () {}\n      args.finishCallback = function () {\n        thisB.updateGraphs(args, oldFinish)\n      }\n\n      // get the features for this block, and then set in motion the\n      // updating of the graphs\n      this._getBlockFeatures(args)\n    },\n\n    updateGraphs: function (viewArgs, callback) {\n      var thisB = this\n\n      // update the global scaling\n      this._getScaling(\n        viewArgs,\n        function (scaling) {\n          thisB.scaling = scaling\n          // render all of the blocks that need it\n          array.forEach(thisB.blocks, function (block, blockIndex) {\n            if (block && block.domNode.parentNode)\n              {thisB.renderBlock({\n                block: block,\n                blockIndex: blockIndex,\n              })}\n          })\n          callback()\n        },\n        function (e) {\n          thisB._handleError(e, viewArgs)\n        },\n      )\n    },\n\n    // Draw features\n    _draw: function (\n      scale,\n      leftBase,\n      rightBase,\n      block,\n      canvas,\n      features,\n      featureRects,\n      dataScale,\n      pixels,\n      spans,\n    ) {\n      this._preDraw(\n        scale,\n        leftBase,\n        rightBase,\n        block,\n        canvas,\n        features,\n        featureRects,\n        dataScale,\n      )\n      this._drawFeatures(\n        scale,\n        leftBase,\n        rightBase,\n        block,\n        canvas,\n        pixels,\n        dataScale,\n      )\n      if (spans) {\n        this._maskBySpans(\n          scale,\n          leftBase,\n          rightBase,\n          block,\n          canvas,\n          pixels,\n          dataScale,\n          spans,\n        )\n      }\n      this._postDraw(\n        scale,\n        leftBase,\n        rightBase,\n        block,\n        canvas,\n        features,\n        featureRects,\n        dataScale,\n      )\n    },\n\n    startZoom: function (destScale, destStart, destEnd) {},\n\n    endZoom: function (destScale, destBlockBases) {\n      this.clear()\n    },\n\n    /**\n     * Calculate the left and width, in pixels, of where this feature\n     * will be drawn on the canvas.\n     * @private\n     * @returns {Object} with l, r, and w\n     */\n    _featureRect: function (scale, leftBase, canvasWidth, feature) {\n      var fRect = {\n        w: Math.ceil((feature.get('end') - feature.get('start')) * scale),\n        l: Math.round((feature.get('start') - leftBase) * scale),\n      }\n\n      // if fRect.l is negative (off the left\n      // side of the canvas), clip off the\n      // (possibly large!) non-visible\n      // portion\n      if (fRect.l < 0) {\n        fRect.w += fRect.l\n        fRect.l = 0\n      }\n\n      // also don't let fRect.w get overly big\n      fRect.w = Math.min(canvasWidth - fRect.l, fRect.w)\n      fRect.r = fRect.w + fRect.l\n\n      return fRect\n    },\n\n    _preDraw: function (canvas) {},\n\n    /**\n     * Draw a set of features on the canvas.\n     * @private\n     */\n    _drawFeatures: function (\n      scale,\n      leftBase,\n      rightBase,\n      block,\n      canvas,\n      features,\n      featureRects,\n    ) {},\n\n    // If we are making a boolean track, this will be called. Overwrite.\n    _maskBySpans: function (scale, leftBase, canvas, spans, pixels) {},\n\n    _postDraw: function () {},\n\n    _calculatePixelScores: function (canvasWidth, features, featureRects) {\n      var scoreType = this.config.scoreType || 'maxScore'\n      var pixelValues = new Array(canvasWidth)\n      if (scoreType == 'maxScore' || scoreType == 'score') {\n        // make an array of the max score at each pixel on the canvas\n        dojo.forEach(\n          features,\n          function (f, i) {\n            var store = f.source\n            var fRect = featureRects[i]\n            var jEnd = fRect.r\n            var score = f.get(scoreType)\n\n            if (score === undefined) {\n              score = f.get('score') // we are not in a summary block and have no maxScore so use regular score\n            }\n            for (var j = Math.round(fRect.l); j < jEnd; j++) {\n              if (pixelValues[j] && pixelValues[j]['lastUsedStore'] == store) {\n                /* Note: if the feature is from a different store, the condition should fail,\n                 *       and we will add to the value, rather than adjusting for overlap */\n                pixelValues[j]['score'] = Math.max(\n                  pixelValues[j]['score'],\n                  score,\n                )\n              } else if (pixelValues[j]) {\n                pixelValues[j]['score'] = pixelValues[j]['score'] + score\n                pixelValues[j]['lastUsedStore'] = store\n              } else {\n                pixelValues[j] = {\n                  score: score,\n                  lastUsedStore: store,\n                  feat: f,\n                }\n              }\n            }\n          },\n          this,\n        )\n        // when done looping through features, forget the store information.\n        for (var i = 0; i < pixelValues.length; i++) {\n          if (pixelValues[i]) {\n            delete pixelValues[i]['lastUsedStore']\n          }\n        }\n      } else if (scoreType == 'avgScore') {\n        // make an array of the average score at each pixel on the canvas\n        dojo.forEach(\n          features,\n          function (f, i) {\n            var store = f.source\n            var fRect = featureRects[i]\n            var jEnd = fRect.r\n            var score = f.get('score')\n            for (var j = Math.round(fRect.l); j < jEnd; j++) {\n              // bin scores according to store\n              if (pixelValues[j] && store in pixelValues[j]['scores']) {\n                pixelValues[j]['scores'][store].push(score)\n              } else if (pixelValues[j]) {\n                pixelValues[j]['scores'][store] = [score]\n              } else {\n                pixelValues[j] = { scores: {}, feat: f }\n                pixelValues[j]['scores'][store] = [score]\n              }\n            }\n          },\n          this,\n        )\n        // when done looping through features, average the scores in the same store then add them all together as the final score\n        for (var i = 0; i < pixelValues.length; i++) {\n          if (pixelValues[i]) {\n            pixelValues[i]['score'] = 0\n            for (var store in pixelValues[i]['scores']) {\n              var j,\n                sum = 0,\n                len = pixelValues[i]['scores'][store].length\n              for (j = 0; j < len; j++) {\n                sum += pixelValues[i]['scores'][store][j]\n              }\n              pixelValues[i]['score'] += sum / len\n            }\n            delete pixelValues[i]['scores']\n          }\n        }\n      }\n      return pixelValues\n    },\n\n    setViewInfo: function () {\n      this.inherited(arguments)\n      this._makeScoreDisplay()\n    },\n\n    _makeScoreDisplay: function () {\n      var gv = this.browser.view\n      var thisB = this\n\n      if (!this._mouseoverEvent)\n        {this._mouseoverEvent = this.own(\n          on(this.div, 'mousemove', function (evt) {\n            evt = domEvent.fix(evt)\n            var bpX = gv.absXtoBp(evt.clientX)\n            thisB.mouseover(bpX, evt)\n          }),\n        )[0]}\n      if (!this._mouseoutEvent)\n        {this._mouseoutEvent = this.own(\n          on(this.div, mouse.leave, function (evt) {\n            thisB.mouseover(undefined)\n          }),\n        )[0]}\n\n      // only add if we have config setting a click eventHandler for this track\n      if (thisB.eventHandlers.click && !this._mouseClickEvent)\n        {this._mouseClickEvent = this.own(\n          on(this.div, 'click', thisB.eventHandlers.click),\n        )[0]}\n\n      // make elements and events to display it\n      if (!this.scoreDisplay)\n        {this.scoreDisplay = {\n          flag: dojo.create(\n            'div',\n            {\n              className: 'wiggleValueDisplay',\n              style: {\n                position: 'fixed',\n                display: 'none',\n                zIndex: 15,\n              },\n            },\n            this.div,\n          ),\n          pole: dojo.create(\n            'div',\n            {\n              className: 'wigglePositionIndicator',\n              style: {\n                position: 'fixed',\n                display: 'none',\n                zIndex: 15,\n              },\n            },\n            this.div,\n          ),\n        }}\n    },\n\n    mouseover: function (bpX, evt) {\n      // if( this._scoreDisplayHideTimeout )\n      //     window.clearTimeout( this._scoreDisplayHideTimeout );\n      if (bpX === undefined) {\n        var thisB = this\n        //this._scoreDisplayHideTimeout = window.setTimeout( function() {\n        thisB.scoreDisplay.flag.style.display = 'none'\n        thisB.scoreDisplay.pole.style.display = 'none'\n        //}, 1000 );\n      } else {\n        var block\n        array.some(this.blocks, function (b) {\n          if (b && b.startBase <= bpX && b.endBase >= bpX) {\n            block = b\n            return true\n          }\n          return false\n        })\n\n        if (!(block && block.canvas && block.pixelScores && evt)) {return}\n\n        var pixelValues = block.pixelScores\n        var canvas = block.canvas\n        var cPos = dojo.position(canvas)\n        var x = evt.pageX\n        var cx = evt.pageX - cPos.x\n\n        if (\n          this._showPixelValue(\n            this.scoreDisplay.flag,\n            pixelValues[Math.round(cx)],\n          )\n        ) {\n          this.scoreDisplay.flag.style.display = 'block'\n          this.scoreDisplay.pole.style.display = 'block'\n\n          this.scoreDisplay.flag.style.left = evt.clientX + 'px'\n          this.scoreDisplay.flag.style.top = cPos.y + 'px'\n          this.scoreDisplay.pole.style.left = evt.clientX + 'px'\n          this.scoreDisplay.pole.style.height = cPos.h + 'px'\n          this.scoreDisplay.pole.style.top = cPos.y + 'px'\n        }\n      }\n    },\n\n    _showPixelValue: function (scoreDisplay, score) {\n      if (typeof score == 'number') {\n        // display the score with only 6\n        // significant digits, avoiding\n        // most confusion about the\n        // approximative properties of\n        // IEEE floating point numbers\n        // parsed out of BigWig files\n        scoreDisplay.innerHTML = parseFloat(score.toPrecision(6))\n        return true\n      } else if (score && typeof score['score'] == 'number') {\n        // \"score\" may be an object.\n        scoreDisplay.innerHTML = parseFloat(score['score'].toPrecision(6))\n        return true\n      } else {\n        return false\n      }\n    },\n\n    _exportFormats: function () {\n      return [\n        { name: 'bedGraph', label: 'bedGraph', fileExt: 'bedgraph' },\n        { name: 'Wiggle', label: 'Wiggle', fileExt: 'wig' },\n        { name: 'GFF3', label: 'GFF3', fileExt: 'gff3' },\n      ]\n    },\n\n    _trackMenuOptions: function () {\n      var track = this\n      var options = this.inherited(arguments) || []\n\n      options.push({\n        label: 'Change height',\n        iconClass: 'jbrowseIconVerticalResize',\n        action: function () {\n          new TrackHeightDialog({\n            height: track._canvasHeight(),\n            setCallback: function (newHeight) {\n              track.trackHeightChanged = true\n              track.updateUserStyles({ height: newHeight })\n            },\n          }).show()\n        },\n      })\n      if (this.config.logScaleOption) {\n        options.push({\n          label: 'Log scale',\n          type: 'dijit/CheckedMenuItem',\n          checked: !!(this.config.scale == 'log'),\n          onClick: function (event) {\n            if (this.checked) {\n              track.config.scale = 'log'\n            } else {\n              track.config.scale = 'linear'\n            }\n            track.browser.publish('/jbrowse/v1/v/tracks/replace', [\n              track.config,\n            ])\n          },\n        })\n      }\n\n      return options\n    },\n\n    // this draws either one or two width pixels based on whether there is a fractional devicePixelRatio\n    _fillRectMod: function (ctx, left, top, width, height) {\n      var devicePixelRatio = window.devicePixelRatio || 1\n      var drawWidth = width\n      // check for fractional devicePixelRatio, and if so, draw wider pixels to avoid subpixel rendering\n      if (\n        this.browser.config.highResolutionMode != 'disabled' &&\n        devicePixelRatio - Math.floor(devicePixelRatio) > 0\n      ) {\n        drawWidth = width + 0.3 // Minimal for subpixel gap, heuristic\n      }\n      ctx.fillRect(left, top, drawWidth, height)\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/TrackConfigEditor.js":{"size":4516,"mtime":1738905963215,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/TrackConfigEditor.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"/**\n * Pops up a dialog to edit the configuration of a single track.\n */\ndefine([\n  'dojo/_base/declare',\n  'dojo/aspect',\n  'dojo/json',\n  'dojo/on',\n  'dojo/dom-construct',\n  'dijit/Dialog',\n  'dijit/form/Button',\n], function (declare, aspect, JSON, on, dom, Dialog, Button) {\n  return declare(null, {\n    constructor: function (trackConfig) {\n      this.trackConfig = trackConfig\n    },\n\n    _makeActionBar: function (editCallback, cancelCallback) {\n      var actionBar = dom.create('div', {\n        className: 'dijitDialogPaneActionBar',\n      })\n\n      new Button({\n        iconClass: 'dijitIconDelete',\n        label: 'Cancel',\n        onClick: dojo.hitch(this, function () {\n          cancelCallback && cancelCallback()\n          this.dialog.hide()\n        }),\n      }).placeAt(actionBar)\n      this.applyButton = new Button({\n        iconClass: 'dijitIconEdit',\n        label: 'Apply',\n        onClick: dojo.hitch(this, function () {\n          if (this.newConfig) {\n            editCallback &&\n              editCallback({\n                conf: this.newConfig,\n              })\n          } else {\n            cancelCallback && cancelCallback()\n          }\n          this.dialog.hide()\n        }),\n      })\n      this.applyButton.placeAt(actionBar)\n\n      return { domNode: actionBar }\n    },\n\n    show: function (editCallback, cancelCallback) {\n      var dialog = (this.dialog = new Dialog({\n        title: 'Edit track configuration',\n        className: 'trackConfigEditor',\n      }))\n\n      var content = [\n        this._makeEditControls().domNode,\n        this._makeActionBar(editCallback, cancelCallback).domNode,\n      ]\n      dialog.set('content', content)\n      dialog.show()\n\n      aspect.after(\n        dialog,\n        'hide',\n        dojo.hitch(this, function () {\n          setTimeout(function () {\n            dialog.destroyRecursive()\n          }, 500)\n        }),\n      )\n    },\n\n    _makeEditControls: function () {\n      var realChange = dojo.hitch(this, function () {\n        this.newConfig = this._parseNewConfig(textArea.value)\n      })\n\n      var container = dom.create('div', { className: 'editControls' })\n\n      var confString = this._stringifyConfig(this.trackConfig)\n      var textArea = dom.create(\n        'textarea',\n        {\n          rows: Math.min((confString || '').match(/\\n/g).length + 4, 20),\n          cols: 70,\n          value: confString,\n          spellcheck: false,\n          onchange: realChange,\n        },\n        container,\n      )\n      // watch the input text for changes.  just do it every 700ms\n      // because there are many ways that text can get changed (like\n      // pasting), not all of which fire the same events.  not using\n      // the onchange event, because that doesn't fire until the\n      // textarea loses focus.\n      var previousText = ''\n      var checkFrequency = 700\n      var that = this\n      var checkForChange = function () {\n        if (that.dialog.get('open')) {\n          if (textArea.value != previousText) {\n            realChange()\n            previousText = textArea.value\n          }\n          // TODO: do not renew this timeout if the dialog is destroyed\n          window.setTimeout(checkForChange, checkFrequency)\n        }\n      }\n      window.setTimeout(checkForChange, checkFrequency)\n\n      var errorArea = dom.create('div', { className: 'errors' }, container)\n      this.errorReportArea = errorArea\n\n      return { domNode: container }\n    },\n\n    _stringifyConfig: function (config) {\n      // don't let people edit the store configuration, just the\n      // track configuration.  make a shallow copy and delete the\n      // store conf.  will add back in later.\n      var c = dojo.mixin({}, config) // shallow copy\n      delete c.store\n\n      // put a style in there if there isn't already one, for convenience\n      if (!c.style) {c.style = {}}\n      if (!c.metadata) {c.metadata = {}}\n\n      return JSON.stringify(c, undefined, 2)\n    },\n\n    _reportError: function (error) {\n      this.errorReportArea.innerHTML = '<div class=\"error\">' + error + '</div>'\n      this.applyButton.set('disabled', true)\n    },\n    _clearErrors: function () {\n      dom.empty(this.errorReportArea)\n      this.applyButton.set('disabled', false)\n    },\n\n    _parseNewConfig: function (conf) {\n      var newconf\n      try {\n        newconf = JSON.parse(conf, true)\n        this._clearErrors()\n      } catch (e) {\n        this._reportError(e)\n      }\n      if (newconf) {newconf.store = this.trackConfig.store}\n      return newconf\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/TrackList/_TextFilterMixin.js":{"size":2939,"mtime":1738905963222,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/TrackList/_TextFilterMixin.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'dojo/_base/lang',\n  'dojo/dom-construct',\n  'dojo/dom-class',\n  'dojo/keys',\n  'dojo/query',\n], function (declare, lang, dom, domClass, keys, query) {\n  return declare(null, {\n    _makeTextFilterNodes: function (trackListDiv) {\n      this.textFilterDiv = dom.create(\n        'div',\n        {\n          className: 'textfilter',\n          style: {\n            position: 'relative',\n            overflow: 'hidden',\n          },\n        },\n        trackListDiv,\n      )\n      this.textFilterInput = dom.create(\n        'input',\n        {\n          type: 'text',\n          placeholder: 'filter tracks',\n          onkeypress: lang.hitch(this, function (evt) {\n            if (evt.keyCode == keys.ESCAPE) {\n              this.textFilterInput.value = ''\n            }\n\n            if (this.textFilterTimeout)\n              {window.clearTimeout(this.textFilterTimeout)}\n            this.textFilterTimeout = window.setTimeout(\n              lang.hitch(this, function () {\n                this._updateTextFilterControl()\n                this._textFilter(this.textFilterInput.value)\n              }),\n              500,\n            )\n            this._updateTextFilterControl()\n\n            evt.stopPropagation()\n          }),\n        },\n        this.textFilterDiv,\n      )\n\n      // make a \"clear\" button for the text filtering input\n      this.textFilterClearButton = dom.create(\n        'div',\n        {\n          className: 'jbrowseIconCancel',\n          onclick: lang.hitch(this, function () {\n            this._clearTextFilterControl()\n            this._textFilter(this.textFilterInput.value)\n          }),\n        },\n        this.textFilterDiv,\n      )\n    },\n\n    /**\n     * Clear the text filter control input.\n     * @private\n     */\n    _clearTextFilterControl: function () {\n      this.textFilterInput.value = ''\n      this._updateTextFilterControl()\n    },\n    /**\n     * Update the display of the text filter control based on whether\n     * it has any text in it.\n     * @private\n     */\n    _updateTextFilterControl: function () {\n      if (this.textFilterInput.value.length)\n        {domClass.remove(this.textFilterDiv, 'dijitDisabled')}\n      else {domClass.add(this.textFilterDiv, 'dijitDisabled')}\n    },\n\n    _textFilter: function (text) {\n      if (text && /\\S/.test(text)) {\n        text = text.toLowerCase()\n\n        query('.tracklist-label', this.containerNode).forEach(\n          function (labelNode, i) {\n            if (labelNode.innerHTML.toLowerCase().indexOf(text) != -1) {\n              domClass.remove(labelNode, 'collapsed')\n              domClass.add(labelNode, 'shown')\n            } else {\n              domClass.add(labelNode, 'collapsed')\n              domClass.remove(labelNode, 'shown')\n            }\n          },\n        )\n      } else {\n        query('.tracklist-label', this.containerNode)\n          .removeClass('collapsed')\n          .addClass('shown')\n      }\n    },\n  })\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/TrackList/Faceted.js":{"size":35182,"mtime":1738905963252,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/TrackList/Faceted.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'dojo/_base/array',\n  'dojo/_base/lang',\n  'dojo/Deferred',\n  'dojo/promise/all',\n  'dijit/TitlePane',\n  'dijit/layout/ContentPane',\n  'JBrowse/Util',\n  'dojox/grid/EnhancedGrid',\n  'dojox/grid/enhanced/plugins/IndirectSelection',\n], function (\n  declare,\n  array,\n  lang,\n  Deferred,\n  all,\n  TitlePane,\n  ContentPane,\n  Util,\n  EnhancedGrid,\n) {\n  var dojof = Util.dojof\n  return declare(\n    'JBrowse.View.TrackList.Faceted',\n    null,\n    /**\n     * @lends JBrowse.View.TrackList.Faceted.prototype\n     */\n    {\n      /**\n       * Track selector with facets and text searching.\n       * @constructs\n       */\n      constructor: function (args) {\n        this.browser = args.browser\n        this.tracksActive = {}\n        this.config = args\n\n        this.storeReady = new Deferred()\n        this.gridReady = new Deferred()\n        this.ready = all([this.storeReady, this.gridReady])\n\n        // construct the discriminator for whether we will display a\n        // facet selector for this facet\n        this._isSelectableFacet = this._coerceFilter(\n          args.selectableFacetFilter ||\n            // default facet filtering function\n            function (facetName, store) {\n              return (\n                // has an avg bucket size > 1\n                store.getFacetStats(facetName).avgBucketSize > 1 &&\n                // and not an ident or label attribute\n                !array.some(\n                  store\n                    .getLabelAttributes()\n                    .concat(store.getIdentityAttributes()),\n                  function (l) {\n                    return l == facetName\n                  },\n                )\n              )\n            },\n        )\n\n        // construct a similar discriminator for which columns will be displayed\n        this.displayColumns = args.displayColumns\n        this._isDisplayableColumn = this._coerceFilter(\n          args.displayColumnFilter ||\n            function (l) {\n              return l.toLowerCase() != 'label'\n            },\n        )\n\n        // data store that fetches and filters our track metadata\n        this.trackDataStore = args.trackMetaData\n\n        // subscribe to commands coming from the the controller\n        this.browser.subscribe(\n          '/jbrowse/v1/c/tracks/show',\n          lang.hitch(this, 'setTracksActive'),\n        )\n        // subscribe to commands coming from the the controller\n        this.browser.subscribe(\n          '/jbrowse/v1/c/tracks/hide',\n          lang.hitch(this, 'setTracksInactive'),\n        )\n        this.browser.subscribe(\n          '/jbrowse/v1/c/tracks/delete',\n          lang.hitch(this, 'setTracksInactive'),\n        )\n\n        this.renderInitial()\n\n        // once its data is loaded and ready\n        this.trackDataStore.onReady(this, function () {\n          // render our controls and so forth\n          this.renderSelectors()\n\n          // connect events so that when a grid row is selected or\n          // deselected (with the checkbox), publish a message\n          // indicating that the user wants that track turned on or\n          // off\n          dojo.connect(\n            this.dataGrid.selection,\n            'onSelected',\n            this,\n            function (index) {\n              this._ifNotSuppressed('selectionEvents', function () {\n                this._suppress('gridUpdate', function () {\n                  this.browser.publish('/jbrowse/v1/v/tracks/show', [\n                    this.dataGrid.getItem(index).conf,\n                  ])\n                })\n              })\n            },\n          )\n          dojo.connect(\n            this.dataGrid.selection,\n            'onDeselected',\n            this,\n            function (index) {\n              this._ifNotSuppressed('selectionEvents', function () {\n                this._suppress('gridUpdate', function () {\n                  this.browser.publish('/jbrowse/v1/v/tracks/hide', [\n                    this.dataGrid.getItem(index).conf,\n                  ])\n                })\n              })\n            },\n          )\n\n          this._updateFacetCounts()\n          this._updateMatchCount()\n          this.storeReady.resolve()\n\n          dojo.connect(this.trackDataStore, 'onFetchSuccess', this, () => {\n            this._updateGridSelections()\n            this._updateMatchCount()\n          })\n        })\n      },\n\n      /**\n       * Coerces a string or array of strings into a function that,\n       * given a string, returns true if the string matches one of the\n       * given strings.  If passed a function, just returns that\n       * function.\n       * @private\n       */\n      _coerceFilter: function (filter) {\n        // if we have a non-function filter, coerce to an array,\n        // then convert that array to a function\n        if (typeof filter == 'string') {filter = [filter]}\n        if (dojo.isArray(filter)) {\n          filter = function (store, facetName) {\n            return array.some(filter, function (fn) {\n              return facetName == fn\n            })\n          }\n        }\n        return filter\n      },\n\n      /**\n       * Call the given callback if none of the given event suppression flags are set.\n       * @private\n       */\n      _ifNotSuppressed: function (suppressFlags, callback) {\n        if (typeof suppressFlags == 'string') {suppressFlags = [suppressFlags]}\n        if (!this.suppress) {this.suppress = {}}\n        if (\n          array.some(\n            suppressFlags,\n            function (f) {\n              return this.suppress[f]\n            },\n            this,\n          )\n        )\n          {return undefined}\n        return callback.call(this)\n      },\n\n      /**\n       * Call the given callback while setting the given event suppression flags.\n       * @private\n       */\n      _suppress: function (suppressFlags, callback) {\n        if (typeof suppressFlags == 'string') {suppressFlags = [suppressFlags]}\n        if (!this.suppress) {this.suppress = {}}\n        dojo.forEach(\n          suppressFlags,\n          function (f) {\n            this.suppress[f] = true\n          },\n          this,\n        )\n        var retval = callback.call(this)\n        dojo.forEach(\n          suppressFlags,\n          function (f) {\n            this.suppress[f] = false\n          },\n          this,\n        )\n        return retval\n      },\n\n      _suppressAsync: function (suppressFlags, callback) {\n        if (typeof suppressFlags == 'string') {suppressFlags = [suppressFlags]}\n        if (!this.suppress) {this.suppress = {}}\n        dojo.forEach(\n          suppressFlags,\n          function (f) {\n            this.suppress[f] = true\n          },\n          this,\n        )\n        return callback.call(this).then(\n          retval => {\n            suppressFlags.forEach(f => (this.suppress[f] = false))\n            return retval\n          },\n          err => {\n            suppressFlags.forEach(f => (this.suppress[f] = false))\n            console.error(err)\n          },\n        )\n      },\n\n      /**\n       * Call a method of our object such that it cannot call itself\n       * by way of event cycles.\n       * @private\n       */\n      _suppressRecursion: function (methodName) {\n        var flag = ['method_' + methodName]\n        var method = this[methodName]\n        return this._ifNotSuppressed(flag, function () {\n          this._suppress(flag, method)\n        })\n      },\n\n      renderInitial: function () {\n        this.containerElem = dojo.create(\n          'div',\n          {\n            id: 'faceted_tracksel',\n            className: 'jbrowse',\n            style: {\n              left: '-95%',\n              width: '95%',\n              zIndex: 500,\n            },\n          },\n          document.body,\n        )\n\n        // make the tab that turns the selector on and off\n        dojo.create(\n          'div',\n          {\n            className: 'faceted_tracksel_on_off tab',\n            innerHTML:\n              '<img src=\"' +\n              this.browser.resolveUrl('img/left_arrow.png') +\n              '\"><div>Select<br>tracks</div>',\n          },\n          this.containerElem,\n        )\n        this.mainContainer = new dijit.layout.BorderContainer(\n          { design: 'headline', gutters: false },\n          dojo.create(\n            'div',\n            { className: 'mainContainer' },\n            this.containerElem,\n          ),\n        )\n\n        this.topPane = new dijit.layout.ContentPane({\n          region: 'top',\n          id: 'faceted_tracksel_top',\n          content:\n            '<div class=\"title\">Select Tracks</div> ' +\n            '<div class=\"topLink\" style=\"cursor: help\"><a title=\"Track selector help\">Help</a></div>',\n        })\n        dojo\n          .query(\n            'div.topLink a[title=\"Track selector help\"]',\n            this.topPane.domNode,\n          )\n          .forEach(function (helplink) {\n            var helpdialog = new dijit.Dialog({\n              class: 'jbrowse help_dialog',\n              refocus: false,\n              draggable: false,\n              title: 'Track Selection',\n              content:\n                '<div class=\"main\">' +\n                '<p>The JBrowse Faceted Track Selector makes it easy to search through' +\n                ' large numbers of available tracks to find exactly the ones you want.' +\n                ' You can incrementally filter the track display to narrow it down to' +\n                ' those your are interested in.  There are two types of filtering available,' +\n                ' which can be used together:' +\n                ' <b>filtering with data fields</b>, and free-form <b>filtering with text</b>.' +\n                '</p>' +\n                '  <dl><dt>Filtering with Data Fields</dt>' +\n                '  <dd>The left column of the display contains the available <b>data fields</b>.  Click on the data field name to expand it, and then select one or more values for that field.  This narrows the search to display only tracks that have one of those values for that field.  You can do this for any number of fields.<dd>' +\n                '  <dt>Filtering with Text</dt>' +\n                '  <dd>Type text in the \"Contains text\" box to filter for tracks whose data contains that text.  If you type multiple words, tracks are filtered such that they must contain all of those words, in any order.  Placing \"quotation marks\" around the text filters for tracks that contain that phrase exactly.  All text matching is case insensitive.</dd>' +\n                '  <dt>Activating Tracks</dt>' +\n                '  <dd>To activate and deactivate a track, click its check-box in the left-most column.  When the box contains a check mark, the track is activated.  You can also turn whole groups of tracks on and off using the check-box in the table heading.</dd>' +\n                '  </dl>' +\n                '</div>',\n            })\n            dojo.connect(helplink, 'onclick', this, function (evt) {\n              helpdialog.show()\n              return false\n            })\n          }, this)\n\n        this.mainContainer.addChild(this.topPane)\n\n        // make both buttons toggle this track selector\n        dojo\n          .query('.faceted_tracksel_on_off')\n          .onclick(lang.hitch(this, 'toggle'))\n\n        this.centerPane = new dijit.layout.BorderContainer({\n          region: 'center',\n          class: 'gridPane',\n          gutters: false,\n        })\n        this.mainContainer.addChild(this.centerPane)\n        var textFilterContainer = this.renderTextFilter()\n\n        this.busyIndicator = dojo.create(\n          'div',\n          {\n            innerHTML:\n              '<img src=\"' + this.browser.resolveUrl('img/spinner.gif') + '\">',\n            className: 'busy_indicator',\n          },\n          this.containerElem,\n        )\n\n        this.centerPane.addChild(\n          new dijit.layout.ContentPane({\n            region: 'top',\n            class: 'gridControls',\n            content: [\n              dojo.create('button', {\n                className: 'faceted_tracksel_on_off',\n                innerHTML:\n                  '<img src=\"' +\n                  this.browser.resolveUrl('img/left_arrow.png') +\n                  '\"> <div>Back to browser</div>',\n                onclick: lang.hitch(this, 'hide'),\n              }),\n              dojo.create('button', {\n                className: 'clear_filters',\n                innerHTML:\n                  '<img src=\"' +\n                  this.browser.resolveUrl('img/red_x.png') +\n                  '\">' +\n                  '<div>Clear All Filters</div>',\n                onclick: lang.hitch(this, function (evt) {\n                  this._clearTextFilterControl()\n                  this._clearAllFacetControls()\n                  this._async(function () {\n                    this.updateQuery()\n                    this._updateFacetCounts()\n                  }, this).call()\n                }),\n              }),\n              this.busyIndicator,\n              textFilterContainer,\n              dojo.create('div', {\n                className: 'matching_record_count',\n              }),\n            ],\n          }),\n        )\n      },\n      renderSelectors: function () {\n        // make our main components\n        var facetContainer = this.renderFacetSelectors()\n        // put them in their places in the overall layout of the track selector\n        facetContainer.set('region', 'left')\n        this.mainContainer.addChild(facetContainer)\n\n        this.dataGrid = this.renderGrid()\n        this.dataGrid.set('region', 'center')\n\n        // code around a dijit bug with width calculation in IE.\n        // doesn't seem to harm other browsers, the width gets overwritten anyway\n        // by dijit's calculations.\n        this.dataGrid.domNode.style.width = '500px'\n\n        this.centerPane.addChild(this.dataGrid)\n\n        this.mainContainer.startup()\n        this.gridReady.resolve()\n      },\n\n      /** do something in a timeout to avoid blocking the UI */\n      _async: function (func, scope) {\n        var that = this\n        return function () {\n          var args = arguments\n          var nativeScope = this\n          that._busy(true)\n          window.setTimeout(function () {\n            func.apply(scope || nativeScope, args)\n            that._busy(false)\n          }, 50)\n        }\n      },\n\n      _busy: function (busy) {\n        this.busyCount = Math.max(0, (this.busyCount || 0) + (busy ? 1 : -1))\n        if (this.busyCount > 0) {dojo.addClass(this.containerElem, 'busy')}\n        else {dojo.removeClass(this.containerElem, 'busy')}\n      },\n\n      renderGrid: function () {\n        var displayColumns =\n          this.displayColumns ||\n          dojo.filter(\n            this.trackDataStore.getFacetNames(),\n            lang.hitch(this, '_isDisplayableColumn'),\n          )\n\n        var colWidth = 90 / displayColumns.length\n\n        var grid = new EnhancedGrid({\n          id: 'trackSelectGrid',\n          store: this.trackDataStore,\n          selectable: true,\n          escapeHTMLInData:\n            'escapeHTMLInData' in this.config\n              ? this.config.escapeHTMLInData\n              : false,\n          noDataMessage: 'No tracks match the filtering criteria.',\n          structure: [\n            dojo.map(\n              displayColumns,\n              function (facetName) {\n                // rename name to key to avoid configuration confusion\n                facetName =\n                  { name: 'key' }[facetName.toLowerCase()] || facetName\n                return {\n                  name: this._facetDisplayName(facetName),\n                  field: facetName.toLowerCase(),\n                  width: colWidth + '%',\n                }\n              },\n              this,\n            ),\n          ],\n          plugins: {\n            indirectSelection: {\n              headerSelector: true,\n            },\n          },\n        })\n\n        // set the grid's initial sort index\n        var sortIndex = this.config.initialSortColumn || 0\n        if (typeof sortIndex == 'string')\n          {sortIndex = array.indexOf(displayColumns, sortIndex)}\n        grid.setSortIndex(sortIndex + 1)\n\n        // monkey-patch the grid to customize some of its behaviors\n        this._monkeyPatchGrid(grid)\n\n        return grid\n      },\n\n      /**\n       * Given a raw facet name, format it for user-facing display.\n       * @private\n       */\n      _facetDisplayName: function (facetName) {\n        // make renameFacets if needed, and lowercase all the keys to\n        // make it case-insensitive\n        this.renameFacets =\n          this.renameFacets ||\n          function () {\n            var renameFacets = this.config.renameFacets\n            var lc = {}\n            for (var k in renameFacets) {\n              lc[k.toLowerCase()] = renameFacets[k]\n            }\n            lc.key = lc.key || 'Name'\n            return lc\n          }.call(this)\n\n        return (\n          this.renameFacets[facetName.toLowerCase()] ||\n          Util.ucFirst(facetName.replace('_', ' '))\n        )\n      },\n\n      /**\n       * Apply several run-time patches to the dojox.grid.EnhancedGrid\n       * code to fix bugs and customize the behavior in ways that aren't\n       * quite possible using the regular Dojo APIs.\n       * @private\n       */\n      _monkeyPatchGrid: function (grid) {\n        // 1. monkey-patch the grid's onRowClick handler to not do\n        // anything.  without this, clicking on a row selects it, and\n        // deselects everything else, which is quite undesirable.\n        grid.onRowClick = function () {}\n\n        // 2. monkey-patch the grid's range-selector to refuse to select\n        // if the selection is too big\n        var origSelectRange = grid.selection.selectRange\n        grid.selection.selectRange = function (inFrom, inTo) {\n          var selectionLimit = 30\n          if (inTo - inFrom > selectionLimit) {\n            alert(\n              'Too many tracks selected, please select fewer than ' +\n                selectionLimit +\n                ' tracks. Note: you can use shift+click to select a range of tracks',\n            )\n            return undefined\n          }\n          return origSelectRange.apply(this, arguments)\n        }\n      },\n\n      renderTextFilter: function (parent) {\n        // make the text input for text filtering\n        this.textFilterLabel = dojo.create(\n          'label',\n          {\n            className: 'textFilterControl',\n            innerHTML: 'Contains text ',\n            id: 'tracklist_textfilter',\n            style: { position: 'relative' },\n          },\n          parent,\n        )\n        this.textFilterInput = dojo.create(\n          'input',\n          {\n            type: 'text',\n            size: 40,\n            disabled: true, // disabled until shown\n            onkeypress: lang.hitch(this, function (evt) {\n              // don't pay attention to modifier keys\n              if (\n                evt.keyCode == dojo.keys.SHIFT ||\n                evt.keyCode == dojo.keys.CTRL ||\n                evt.keyCode == dojo.keys.ALT\n              )\n                {return}\n\n              // use a timeout to avoid updating the display too fast\n              if (this.textFilterTimeout)\n                {window.clearTimeout(this.textFilterTimeout)}\n              this.textFilterTimeout = window.setTimeout(\n                lang.hitch(this, function () {\n                  // do a new search and update the display\n                  this._updateTextFilterControl()\n                  this._async(function () {\n                    this.updateQuery()\n                    this._updateFacetCounts()\n                    this.textFilterInput.focus()\n                  }, this).call()\n                  this.textFilterInput.focus()\n                }),\n                500,\n              )\n              this._updateTextFilterControl()\n\n              evt.stopPropagation()\n            }),\n          },\n          this.textFilterLabel,\n        )\n        // make a \"clear\" button for the text filtering input\n        this.textFilterClearButton = dojo.create(\n          'img',\n          {\n            src: this.browser.resolveUrl('img/red_x.png'),\n            className: 'text_filter_clear',\n            onclick: lang.hitch(this, function () {\n              this._clearTextFilterControl()\n              this._async(function () {\n                this.updateQuery()\n                this._updateFacetCounts()\n              }, this).call()\n            }),\n            style: {\n              position: 'absolute',\n              right: '4px',\n              top: '20%',\n            },\n          },\n          this.textFilterLabel,\n        )\n\n        return this.textFilterLabel\n      },\n\n      /**\n       * Clear the text filter control input.\n       * @private\n       */\n      _clearTextFilterControl: function () {\n        this.textFilterInput.value = ''\n        this._updateTextFilterControl()\n      },\n      /**\n       * Update the display of the text filter control based on whether\n       * it has any text in it.\n       * @private\n       */\n      _updateTextFilterControl: function () {\n        if (this.textFilterInput.value.length)\n          {dojo.addClass(this.textFilterLabel, 'selected')}\n        else {dojo.removeClass(this.textFilterLabel, 'selected')}\n      },\n\n      /**\n       * Create selection boxes for each searchable facet.\n       */\n      renderFacetSelectors: function () {\n        var container = new ContentPane({ style: 'width: 200px' })\n\n        var store = this.trackDataStore\n        this.facetSelectors = {}\n\n        // render a facet selector for a pseudo-facet holding\n        // attributes regarding the tracks the user has been working\n        // with\n        var usageFacet = this._renderFacetSelector('My Tracks', [\n          'Currently Active',\n          'Recently Used',\n        ])\n        usageFacet.set('class', 'myTracks')\n        container.addChild(usageFacet)\n\n        // for the facets from the store, only render facet selectors\n        // for ones that are not identity attributes, and have an\n        // average bucket size greater than 1\n        var selectableFacets = dojo.filter(\n          this.config.selectableFacets || store.getFacetNames(),\n          function (facetName) {\n            return this._isSelectableFacet(facetName, this.trackDataStore)\n          },\n          this,\n        )\n\n        dojo.forEach(\n          selectableFacets,\n          function (facetName) {\n            // get the values of this facet\n            var values = store.getFacetValues(facetName).sort()\n            if (!values || !values.length) {return}\n\n            var facetPane = this._renderFacetSelector(facetName, values)\n            container.addChild(facetPane)\n          },\n          this,\n        )\n\n        return container\n      },\n\n      /**\n       * Make HTML elements for a single facet selector.\n       * @private\n       * @returns {dijit.layout.TitlePane}\n       */\n      _renderFacetSelector: function (\n        /**String*/ facetName,\n        /**Array[String]*/ values,\n      ) {\n        var facetPane = new TitlePane({\n          title:\n            '<span id=\"facet_title_' +\n            facetName +\n            '\" ' +\n            'class=\"facetTitle\">' +\n            this._facetDisplayName(facetName) +\n            ' <a class=\"clearFacet\"><img src=\"' +\n            this.browser.resolveUrl('img/red_x.png') +\n            '\" /></a>' +\n            '</span>',\n        })\n\n        // make a selection control for the values of this facet\n        var facetControl = dojo.create(\n          'table',\n          { className: 'facetSelect' },\n          facetPane.containerNode,\n        )\n        // populate selector's options\n        this.facetSelectors[facetName] = dojo.map(\n          values,\n          function (val) {\n            var that = this\n            var node = dojo.create(\n              'tr',\n              {\n                className: 'facetValue',\n                innerHTML:\n                  '<td class=\"count\"></td><td class=\"value\">' + val + '</td>',\n                onclick: function (evt) {\n                  dojo.toggleClass(this, 'selected')\n                  that._updateFacetControl(facetName)\n                  that\n                    ._async(function () {\n                      that.updateQuery()\n                      that._updateFacetCounts(facetName)\n                    })\n                    .call()\n                },\n              },\n              facetControl,\n            )\n            node.facetValue = val\n            return node\n          },\n          this,\n        )\n\n        return facetPane\n      },\n\n      /**\n       * Clear all the selections from all of the facet controls.\n       * @private\n       */\n      _clearAllFacetControls: function () {\n        dojo.forEach(\n          dojof.keys(this.facetSelectors),\n          function (facetName) {\n            this._clearFacetControl(facetName)\n          },\n          this,\n        )\n      },\n\n      /**\n       * Clear all the selections from the facet control with the given name.\n       * @private\n       */\n      _clearFacetControl: function (facetName) {\n        dojo.forEach(\n          this.facetSelectors[facetName] || [],\n          function (selector) {\n            dojo.removeClass(selector, 'selected')\n          },\n          this,\n        )\n        this._updateFacetControl(facetName)\n      },\n\n      /**\n       * Incrementally update the facet counts as facet values are selected.\n       * @private\n       */\n      _updateFacetCounts: function (/**String*/ skipFacetName) {\n        dojo.forEach(\n          dojof.keys(this.facetSelectors),\n          function (facetName) {\n            if (facetName == 'My Tracks')\n              // || facetName == skipFacetName )\n              {return}\n            var thisFacetCounts = this.trackDataStore.getFacetCounts(facetName)\n            dojo.forEach(\n              this.facetSelectors[facetName] || [],\n              function (selectorNode) {\n                dojo.query('.count', selectorNode).forEach(function (\n                  countNode,\n                ) {\n                  var count = thisFacetCounts\n                    ? thisFacetCounts[selectorNode.facetValue] || 0\n                    : 0\n                  countNode.innerHTML = Util.addCommas(count)\n                  if (count) {dojo.removeClass(selectorNode, 'disabled')}\n                  else {dojo.addClass(selectorNode, 'disabled')}\n                }, this)\n                //dojo.removeClass(selector,'selected');\n              },\n              this,\n            )\n            this._updateFacetControl(facetName)\n          },\n          this,\n        )\n      },\n\n      /**\n       * Update the title bar of the given facet control to reflect\n       * whether it has selected values in it.\n       */\n      _updateFacetControl: function (facetName) {\n        var titleContent = dojo.byId('facet_title_' + facetName)\n\n        // if all our values are disabled, add 'disabled' to our\n        // title's CSS classes\n        if (\n          array.every(\n            this.facetSelectors[facetName] || [],\n            function (sel) {\n              return dojo.hasClass(sel, 'disabled')\n            },\n            this,\n          )\n        ) {\n          dojo.addClass(titleContent, 'disabled')\n        }\n\n        // if we have some selected values, make a \"clear\" button, and\n        // add 'selected' to our title's CSS classes\n        if (\n          array.some(\n            this.facetSelectors[facetName] || [],\n            function (sel) {\n              return dojo.hasClass(sel, 'selected')\n            },\n            this,\n          )\n        ) {\n          var clearFunc = lang.hitch(this, function (evt) {\n            this._clearFacetControl(facetName)\n            this._async(function () {\n              this.updateQuery()\n              this._updateFacetCounts(facetName)\n            }, this).call()\n            evt.stopPropagation()\n          })\n          dojo.addClass(titleContent.parentNode.parentNode, 'activeFacet')\n          dojo\n            .query('> a', titleContent)\n            .forEach(function (node) {\n              node.onclick = clearFunc\n            }, this)\n            .attr('title', 'clear selections')\n        }\n        // otherwise, no selected values\n        else {\n          dojo.removeClass(titleContent.parentNode.parentNode, 'activeFacet')\n          dojo\n            .query('> a', titleContent)\n            .onclick(function () {\n              return false\n            })\n            .removeAttr('title')\n        }\n      },\n\n      /**\n       * Update the query we are using with the track metadata store\n       * based on the values of the search form elements.\n       */\n      updateQuery: function () {\n        this._suppressRecursion('_updateQuery')\n      },\n      _updateQuery: function () {\n        var newQuery = {}\n\n        var is_selected = function (node) {\n          return dojo.hasClass(node, 'selected')\n        }\n\n        // update from the My Tracks pseudofacet\n        ;(function () {\n          var mytracks_options = this.facetSelectors['My Tracks']\n\n          // index the optoins by name\n          var byname = {}\n          dojo.forEach(mytracks_options, function (opt) {\n            byname[opt.facetValue] = opt\n          })\n\n          // if filtering for active tracks, add the labels for the\n          // currently selected tracks to the query\n          if (is_selected(byname['Currently Active'])) {\n            var activeTrackLabels = dojof.keys(this.tracksActive || {})\n            newQuery.label = Util.uniq(\n              (newQuery.label || []).concat(activeTrackLabels),\n            )\n          }\n\n          // if filtering for recently used tracks, add the labels of recently used tracks\n          if (is_selected(byname['Recently Used'])) {\n            var recentlyUsed = dojo.map(\n              this.browser.getRecentlyUsedTracks(),\n              function (t) {\n                return t.label\n              },\n            )\n\n            newQuery.label = Util.uniq(\n              (newQuery.label || []).concat(recentlyUsed),\n            )\n          }\n\n          // finally, if something is selected in here, but we have\n          // not come up with any track labels, then insert a dummy\n          // track label value that will never match, because the\n          // query engine ignores empty arrayrefs.\n          if (\n            (!newQuery.label || !newQuery.label.length) &&\n            array.some(mytracks_options, is_selected)\n          ) {\n            newQuery.label = [\n              'FAKE LABEL THAT IS HIGHLY UNLIKELY TO EVER MATCH ANYTHING',\n            ]\n          }\n        }).call(this)\n\n        // update from the text filter\n        if (this.textFilterInput.value.length) {\n          newQuery.text = this.textFilterInput.value\n        }\n\n        // update from the data-based facet selectors\n        dojo.forEach(\n          this.trackDataStore.getFacetNames(),\n          function (facetName) {\n            var options = this.facetSelectors[facetName]\n            if (!options) {return}\n\n            var selectedFacets = dojo.map(\n              dojo.filter(options, is_selected),\n              function (opt) {\n                return opt.facetValue\n              },\n            )\n            if (selectedFacets.length) {newQuery[facetName] = selectedFacets}\n          },\n          this,\n        )\n\n        this.query = newQuery\n        this.dataGrid.setQuery(this.query)\n        this._updateMatchCount()\n      },\n\n      /**\n       * Update the match-count text in the grid controls bar based\n       * on the last query that was run against the store.\n       * @private\n       */\n      _updateMatchCount: function () {\n        var count = this.dataGrid.store.getCount()\n        dojo\n          .query('.matching_record_count', this.containerElem)\n          .forEach(function (n) {\n            n.innerHTML =\n              Util.addCommas(count) +\n              ' ' +\n              (dojof.keys(this.query || {}).length ? 'matching ' : '') +\n              'track' +\n              (count == 1 ? '' : 's')\n          }, this)\n      },\n\n      /**\n       * Update the grid to have only rows checked that correspond to\n       * tracks that are currently active.\n       * @private\n       */\n      _updateGridSelections: function () {\n        this.ready.then(() => {\n          // keep selection events from firing while we mess with the\n          // grid\n          this._ifNotSuppressed(['gridUpdate', 'selectionEvents'], function () {\n            this._suppress('selectionEvents', function () {\n              this.dataGrid.selection.deselectAll()\n\n              // check the boxes that should be checked, based on our\n              // internal memory of what tracks should be on.\n              for (\n                var i = 0;\n                i <\n                Math.min(\n                  this.dataGrid.get('rowCount'),\n                  this.dataGrid.get('rowsPerPage'),\n                );\n                i++\n              ) {\n                var item = this.dataGrid.getItem(i)\n                if (item) {\n                  var label = this.dataGrid.store.getIdentity(item)\n                  if (this.tracksActive[label])\n                    {this.dataGrid.rowSelectCell.toggleRow(i, true)}\n                }\n              }\n            })\n          })\n        })\n      },\n\n      /**\n       * Given an array of track configs, update the track list to show\n       * that they are turned on.\n       */\n      setTracksActive: function (/**Array[Object]*/ trackConfigs) {\n        dojo.forEach(\n          trackConfigs,\n          function (conf) {\n            this.tracksActive[conf.label] = true\n          },\n          this,\n        )\n        this._updateGridSelections()\n      },\n\n      /**\n       * Given an array of track configs, update the track list to show\n       * that they are turned off.\n       */\n      setTracksInactive: function (/**Array[Object]*/ trackConfigs) {\n        dojo.forEach(\n          trackConfigs,\n          function (conf) {\n            delete this.tracksActive[conf.label]\n          },\n          this,\n        )\n        this._updateGridSelections()\n      },\n\n      /**\n       * Make the track selector visible.\n       */\n      show: function () {\n        window.setTimeout(\n          lang.hitch(this, function () {\n            this.textFilterInput.disabled = false\n            this.textFilterInput.focus()\n          }),\n          300,\n        )\n\n        dojo.addClass(this.containerElem, 'active')\n        dojo\n          .animateProperty({\n            node: this.containerElem,\n            properties: {\n              left: { start: -95, end: 0, units: '%' },\n            },\n          })\n          .play()\n\n        this.shown = true\n      },\n\n      /**\n       * Make the track selector invisible.\n       */\n      hide: function () {\n        dojo.removeClass(this.containerElem, 'active')\n\n        dojo\n          .animateProperty({\n            node: this.containerElem,\n            properties: {\n              left: { start: 0, end: -95, units: '%' },\n            },\n          })\n          .play()\n\n        this.textFilterInput.blur()\n        this.textFilterInput.disabled = true\n\n        this.shown = false\n      },\n\n      /**\n       * Toggle whether the track selector is visible.\n       */\n      toggle: function () {\n        this.shown ? this.hide() : this.show()\n      },\n    },\n  )\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/TrackList/Hierarchical.js":{"size":13385,"mtime":1738905963266,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/TrackList/Hierarchical.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'dojo/_base/array',\n  'dojo/_base/lang',\n  'dojo/dom-construct',\n  'dojo/query',\n  'dojo/on',\n  'dojo/json',\n  'dijit/TitlePane',\n  'dijit/layout/ContentPane',\n  'JBrowse/Util',\n  './_TextFilterMixin',\n], function (\n  declare,\n  array,\n  lang,\n  dom,\n  query,\n  on,\n  JSON,\n  TitlePane,\n  ContentPane,\n  Util,\n  _TextFilterMixin,\n) {\n  return declare(\n    'JBrowse.View.TrackList.Hierarchical',\n    [ContentPane, _TextFilterMixin],\n    {\n      region: 'left',\n      splitter: true,\n      style: 'width: 25%',\n\n      id: 'hierarchicalTrackPane',\n      baseClass: 'jbrowseHierarchicalTrackSelector',\n\n      categoryFacet: 'category',\n\n      constructor(args) {\n        this.categories = {}\n        this.config = lang.mixin(\n          {\n            sortHierarchical: true,\n          },\n          args,\n        )\n\n        this._loadState()\n      },\n      postCreate() {\n        this.placeAt(this.browser.container)\n\n        // subscribe to commands coming from the the controller\n        this.browser.subscribe(\n          '/jbrowse/v1/c/tracks/show',\n          lang.hitch(this, 'setTracksActive'),\n        )\n        this.browser.subscribe(\n          '/jbrowse/v1/c/tracks/hide',\n          lang.hitch(this, 'setTracksInactive'),\n        )\n        this.browser.subscribe(\n          '/jbrowse/v1/c/tracks/new',\n          lang.hitch(this, 'addTracks'),\n        )\n        this.browser.subscribe(\n          '/jbrowse/v1/c/tracks/replace',\n          lang.hitch(this, 'replaceTracks'),\n        )\n        this.browser.subscribe(\n          '/jbrowse/v1/c/tracks/delete',\n          lang.hitch(this, 'deleteTracks'),\n        )\n      },\n\n      buildRendering() {\n        this.inherited('buildRendering', arguments)\n\n        var topPane = dom.create(\n          'div',\n          { className: 'header' },\n          this.containerNode,\n        )\n        dom.create(\n          'h2',\n          { className: 'title', innerHTML: 'Available Tracks' },\n          topPane,\n        )\n\n        this._makeTextFilterNodes(\n          dom.create('div', { className: 'textfilterContainer' }, topPane),\n        )\n        this._updateTextFilterControl()\n      },\n      induceCategoryOrder(tracks, categoryOrder) {\n        const order = categoryOrder\n          .split(',')\n          .map(s => s.trim())\n          .map(s =>\n            s\n              .split('/')\n              .map(s => s.trim())\n              .join('/'),\n          )\n        tracks.forEach(t => {\n          if (t.category) {\n            t.cat = t.category\n              .trim()\n              .split('/')\n              .map(s => s.trim())\n              .join('/')\n          }\n        })\n        var unordered = tracks.filter(t => order.indexOf(t.cat) === -1)\n        var ordered = tracks.filter(t => order.indexOf(t.cat) !== -1)\n        ordered.sort((a, b) => {\n          return order.indexOf(a.cat) - order.indexOf(b.cat)\n        })\n        tracks.forEach(t => delete t.cat)\n        return ordered.concat(unordered)\n      },\n\n      startup() {\n        this.inherited('startup', arguments)\n\n        var tracks = []\n        var categoryFacet = this.get('categoryFacet')\n        var sorter\n        if (this.config.sortHierarchical) {\n          sorter = [\n            { attribute: categoryFacet.toLowerCase() },\n            { attribute: 'key' },\n            { attribute: 'label' },\n          ]\n        }\n\n        // add initally collapsed categories to the local storage\n        var arr = (this.get('collapsedCategories') || '')\n          .split(',')\n          .map(s => s.trim())\n          .map(s =>\n            s\n              .split('/')\n              .map(s => s.trim())\n              .join('/'),\n          )\n        for (var i = 0; i < arr.length; i++) {\n          lang.setObject('collapsed.' + arr[i], true, this.state)\n        }\n        this._saveState()\n\n        this.get('trackMetaData').fetch({\n          onItem: function (i) {\n            if (i.conf) {tracks.push(i)}\n          },\n          onComplete: () => {\n            // make a pane at the top to hold uncategorized tracks\n            this.categories.Uncategorized = {\n              pane: new ContentPane({\n                className: 'uncategorized',\n              }).placeAt(this.containerNode),\n              tracks: {},\n              categories: {},\n            }\n            if (this.config.categoryOrder) {\n              tracks = this.induceCategoryOrder(\n                tracks,\n                this.config.categoryOrder,\n              )\n            }\n\n            this.addTracks(tracks, true)\n\n            // hide the uncategorized pane if it is empty\n            if (\n              !this.categories.Uncategorized.pane.containerNode.children.length\n            ) {\n              this.categories.Uncategorized.pane.domNode.style.display = 'none'\n            }\n          },\n          sort: sorter,\n        })\n      },\n\n      addTracks: function (tracks, inStartup) {\n        this.pane = this\n        var thisB = this\n\n        array.forEach(\n          tracks,\n          function (track) {\n            var trackConf = track.conf || track\n\n            var categoryFacet = this.get('categoryFacet')\n            var categoryNames = (\n              (trackConf.metadata && trackConf.metadata[categoryFacet]) ||\n              trackConf[categoryFacet] ||\n              track[categoryFacet] ||\n              'Uncategorized'\n            ).split(/\\s*\\/\\s*/)\n\n            var category = _findCategory(this, categoryNames, [])\n\n            function _findCategory(obj, names, path) {\n              var categoryName = names.shift()\n              path = path.concat(categoryName)\n              var categoryPath = path.join('/')\n\n              var cat =\n                obj.categories[categoryName] ||\n                (obj.categories[categoryName] = function () {\n                  var isCollapsed = lang.getObject(\n                    'collapsed.' + categoryPath,\n                    false,\n                    thisB.state,\n                  )\n                  var c = new TitlePane({\n                    title:\n                      '<span class=\"categoryName\">' +\n                      categoryName +\n                      '</span>' +\n                      ' <span class=\"trackCount\">0</span>',\n                    open: !isCollapsed,\n                  })\n                  // save our open/collapsed state in local storage\n                  c.watch('open', function (attr, oldval, newval) {\n                    lang.setObject(\n                      'collapsed.' + categoryPath,\n                      !newval,\n                      thisB.state,\n                    )\n                    thisB._saveState()\n                  })\n                  obj.pane.addChild(c, inStartup ? undefined : 1)\n                  return {\n                    parent: obj,\n                    pane: c,\n                    categories: {},\n                    tracks: {},\n                  }\n                }.call(thisB))\n\n              return names.length ? _findCategory(cat, names, path) : cat\n            }\n\n            category.pane.domNode.style.display = 'block'\n\n            // note: sometimes trackConf.description is defined as numeric, so in this case, ignore it\n            var labelNode = dom.create(\n              'label',\n              {\n                className: 'tracklist-label shown',\n                title: Util.escapeHTML(\n                  trackConf.shortDescription ||\n                    track.shortDescription ||\n                    (trackConf.description === 1\n                      ? undefined\n                      : trackConf.description) ||\n                    track.description ||\n                    trackConf.Description ||\n                    track.Description ||\n                    (trackConf.metadata &&\n                      (trackConf.metadata.shortDescription ||\n                        trackConf.metadata.description ||\n                        trackConf.metadata.Description)) ||\n                    track.key ||\n                    trackConf.key ||\n                    trackConf.label,\n                ),\n              },\n              category.pane.containerNode,\n            )\n\n            var checkBoxProps = {\n              type: 'checkbox',\n              className: 'check',\n            }\n\n            // hook point\n            if (typeof thisB.extendCheckbox === 'function')\n              {var checkBoxProps = thisB.extendCheckbox(checkBoxProps, trackConf)}\n\n            var checkbox = dom.create('input', checkBoxProps, labelNode)\n            var trackLabel = trackConf.label\n            var checkListener\n            this.own(\n              (checkListener = on(checkbox, 'click', function () {\n                thisB.itemClick(this, trackConf)\n              })),\n            )\n            dom.create(\n              'span',\n              {\n                className: 'key',\n                innerHTML: trackConf.key || trackConf.label,\n              },\n              labelNode,\n            )\n\n            category.tracks[trackLabel] = {\n              checkbox: checkbox,\n              checkListener: checkListener,\n              labelNode: labelNode,\n            }\n          },\n          this,\n        )\n        this._updateAllTitles()\n      },\n      // called when item checkbox is clicked.\n      itemClick: function (checkbox, trackConf) {\n        this.browser.publish(\n          '/jbrowse/v1/v/tracks/' + (checkbox.checked ? 'show' : 'hide'),\n          [trackConf],\n        )\n      },\n\n      _loadState: function () {\n        this.state = {}\n        try {\n          this.state = JSON.parse(\n            localStorage.getItem('JBrowse-Hierarchical-Track-Selector') || '{}',\n          )\n        } catch (e) {}\n        return this.state\n      },\n      _saveState: function (state) {\n        try {\n          localStorage.setItem(\n            'JBrowse-Hierarchical-Track-Selector',\n            JSON.stringify(this.state),\n          )\n        } catch (e) {}\n      },\n\n      // depth-first traverse and update the titles of all the categories\n      _updateAllTitles: function (r) {\n        var root = r || this\n        for (var c in root.categories) {\n          this._updateTitle(root.categories[c])\n          this._updateAllTitles(root.categories[c])\n        }\n      },\n\n      _updateTitle: function (category) {\n        category.pane.set(\n          'title',\n          category.pane\n            .get('title')\n            .replace(\n              />\\s*\\d+\\s*</,\n              '>' +\n                query('label.shown', category.pane.containerNode).length +\n                '<',\n            ),\n        )\n      },\n\n      // update the titles of the given category and its parents\n      _updateTitles: function (category) {\n        this._updateTitle(category)\n        if (category.parent) {this._updateTitles(category.parent)}\n      },\n\n      _findTrack: function _findTrack(trackLabel, callback, r) {\n        var root = r || this\n        for (var c in root.categories) {\n          var category = root.categories[c]\n          if (category.tracks[trackLabel]) {\n            callback(category.tracks[trackLabel], category)\n            return true\n          } else {\n            if (this._findTrack(trackLabel, callback, category)) {return true}\n          }\n        }\n        return false\n      },\n      //  hook point\n      replaceTracks: function (trackConfigs) {\n        // notification\n      },\n\n      /**\n       * Given an array of track configs, update the track list to show\n       * that they are turned on.\n       */\n      setTracksActive: function (/**Array[Object]*/ trackConfigs) {\n        array.forEach(\n          trackConfigs,\n          function (conf) {\n            this._findTrack(conf.label, function (trackRecord, category) {\n              trackRecord.checkbox.checked = true\n            })\n          },\n          this,\n        )\n      },\n\n      deleteTracks: function (/**Array[Object]*/ trackConfigs) {\n        array.forEach(\n          trackConfigs,\n          function (conf) {\n            this._findTrack(conf.label, function (trackRecord, category) {\n              trackRecord.labelNode.parentNode.removeChild(\n                trackRecord.labelNode,\n              )\n              trackRecord.checkListener.remove()\n              delete category.tracks[conf.label]\n            })\n          },\n          this,\n        )\n      },\n\n      /**\n       * Given an array of track configs, update the track list to show\n       * that they are turned off.\n       */\n      setTracksInactive: function (/**Array[Object]*/ trackConfigs) {\n        array.forEach(\n          trackConfigs,\n          function (conf) {\n            this._findTrack(conf.label, function (trackRecord, category) {\n              trackRecord.checkbox.checked = false\n            })\n          },\n          this,\n        )\n      },\n\n      _textFilter: function () {\n        this.inherited(arguments)\n        this._updateAllTitles()\n      },\n\n      /**\n       * Make the track selector visible.\n       * This does nothing for this track selector, since it is always visible.\n       */\n      show: function () {},\n\n      /**\n       * Make the track selector invisible.\n       * This does nothing for this track selector, since it is always visible.\n       */\n      hide: function () {},\n\n      /**\n       * Toggle visibility of this track selector.\n       * This does nothing for this track selector, since it is always visible.\n       */\n      toggle: function () {},\n    },\n  )\n})\n"}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/TrackList/Null.js":{"size":335,"mtime":1738905963269,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/TrackList/Null.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/src/JBrowse/View/TrackList/Simple.js":{"size":12037,"mtime":1738905963282,"hashOfConfig":"5tvz5j","results":{"filePath":"/home/cdiesh/src/jbrowse/src/JBrowse/View/TrackList/Simple.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"define([\n  'dojo/_base/declare',\n  'dojo/_base/array',\n  'dojo/_base/event',\n  'dojo/keys',\n  'dojo/on',\n  'dojo/dom-construct',\n  'dojo/dom-class',\n  'dijit/layout/ContentPane',\n  'dojo/dnd/Source',\n  'dojo/fx/easing',\n  'dijit/form/TextBox',\n\n  './_TextFilterMixin',\n], function (\n  declare,\n  array,\n  event,\n  keys,\n  on,\n  dom,\n  domClass,\n  ContentPane,\n  dndSource,\n  animationEasing,\n  dijitTextBox,\n\n  _TextFilterMixin,\n) {\n  return declare(\n    'JBrowse.View.TrackList.Simple',\n    _TextFilterMixin,\n\n    /** @lends JBrowse.View.TrackList.Simple.prototype */\n    {\n      /**\n       * Simple drag-and-drop track selector.\n       * @constructs\n       */\n      constructor: function (args) {\n        this.browser = args.browser\n\n        // make the track list DOM nodes and widgets\n        this.createTrackList(args.browser.container)\n\n        // maintain a list of the HTML nodes of inactive tracks, so we\n        // can flash them and whatnot\n        this.inactiveTrackNodes = {}\n\n        // populate our track list (in the right order)\n        this.trackListWidget.insertNodes(false, args.trackConfigs)\n\n        // subscribe to drop events for tracks being DND'ed\n        this.browser.subscribe(\n          '/dnd/drop',\n          dojo.hitch(this, function (source, nodes, copy, target) {\n            if (target !== this.trackListWidget) {return}\n\n            // get the configs from the tracks being dragged in\n            var confs = dojo.filter(\n              dojo.map(nodes, function (n) {\n                return n.track && n.track.config\n              }),\n              function (c) {\n                return c\n              },\n            )\n\n            // return if no confs; whatever was\n            // dragged here probably wasn't a\n            // track\n            if (!confs.length) {return}\n\n            this.dndDrop = true\n            this.browser.publish('/jbrowse/v1/v/tracks/hide', confs)\n            this.dndDrop = false\n          }),\n        )\n\n        // subscribe to commands coming from the the controller\n        this.browser.subscribe(\n          '/jbrowse/v1/c/tracks/show',\n          dojo.hitch(this, 'setTracksActive'),\n        )\n        this.browser.subscribe(\n          '/jbrowse/v1/c/tracks/hide',\n          dojo.hitch(this, 'setTracksInactive'),\n        )\n        this.browser.subscribe(\n          '/jbrowse/v1/c/tracks/new',\n          dojo.hitch(this, 'addTracks'),\n        )\n        this.browser.subscribe(\n          '/jbrowse/v1/c/tracks/replace',\n          dojo.hitch(this, 'replaceTracks'),\n        )\n        this.browser.subscribe(\n          '/jbrowse/v1/c/tracks/delete',\n          dojo.hitch(this, 'deleteTracks'),\n        )\n      },\n\n      addTracks: function (trackConfigs) {\n        // note that new tracks are, by default, hidden, so we just put them in the list\n        this.trackListWidget.insertNodes(false, trackConfigs)\n\n        this._blinkTracks(trackConfigs)\n      },\n\n      replaceTracks: function (trackConfigs) {\n        // for each one\n        array.forEach(\n          trackConfigs,\n          function (conf) {\n            var oldNode = this.inactiveTrackNodes[conf.label]\n            if (!oldNode) {return}\n            delete this.inactiveTrackNodes[conf.label]\n\n            this.trackListWidget.delItem(oldNode.id)\n            if (oldNode.parentNode) {oldNode.parentNode.removeChild(oldNode)}\n\n            this.trackListWidget.insertNodes(\n              false,\n              [conf],\n              false,\n              oldNode.previousSibling,\n            )\n          },\n          this,\n        )\n      },\n\n      /** @private */\n      createTrackList: function (renderTo) {\n        var leftPane = dojo.create(\n          'div',\n          {\n            id: 'trackPane',\n            className: 'jbrowseSimpleTrackSelector',\n            style: { width: '12em' },\n          },\n          renderTo,\n        )\n\n        //splitter on left side\n        var leftWidget = new ContentPane(\n          { region: 'left', splitter: true },\n          leftPane,\n        )\n\n        var trackListDiv =\n          (this.div =\n          this.containerNode =\n            dojo.create(\n              'div',\n              {\n                id: 'tracksAvail',\n                className: 'container handles',\n                style: {\n                  width: '100%',\n                  height: '100%',\n                  overflowX: 'hidden',\n                  overflowY: 'auto',\n                },\n                innerHTML: '<h2>Available Tracks</h2>',\n              },\n              leftPane,\n            ))\n\n        this._makeTextFilterNodes(trackListDiv)\n        this._updateTextFilterControl()\n\n        this.trackListWidget = new dndSource(trackListDiv, {\n          accept: ['track'], // accepts only tracks into left div\n          withHandles: false,\n          creator: dojo.hitch(this, function (trackConfig, hint) {\n            var key = trackConfig.key || trackConfig.name || trackConfig.label\n            var node = dojo.create('div', {\n              className: 'tracklist-label',\n              title: key + ' (drag or double-click to activate)',\n              innerHTML: key,\n            })\n\n            //in the list, wrap the list item in a container for\n            //border drag-insertion-point monkeying\n            if ('avatar' != hint) {\n              on(\n                node,\n                'dblclick',\n                dojo.hitch(this, function () {\n                  this.browser.publish('/jbrowse/v1/v/tracks/show', [\n                    trackConfig,\n                  ])\n                }),\n              )\n\n              var container = dojo.create('div', {\n                className: 'tracklist-container',\n              })\n              container.appendChild(node)\n              node = container\n              node.id = dojo.dnd.getUniqueId()\n              this.inactiveTrackNodes[trackConfig.label] = node\n            }\n            return {\n              node: node,\n              data: trackConfig,\n              type: ['track'],\n            }\n          }),\n        })\n\n        // The dojo onMouseDown and onMouseUp methods don't support the functionality we're looking for,\n        // so we'll substitute our own\n        this.trackListWidget.onMouseDown = dojo.hitch(this, 'onMouseDown')\n        this.trackListWidget.onMouseUp = dojo.hitch(this, 'onMouseUp')\n\n        // We want the escape key to deselect all tracks\n        on(document, 'keydown', dojo.hitch(this, 'onKeyDown'))\n\n        return trackListDiv\n      },\n\n      onKeyDown: function (e) {\n        switch (e.keyCode) {\n          case keys.ESCAPE:\n            this.trackListWidget.selectNone()\n            break\n        }\n      },\n\n      onMouseDown: function (e) {\n        var thisW = this.trackListWidget\n        if (!thisW.mouseDown && thisW._legalMouseDown(e)) {\n          thisW.mouseDown = true\n          thisW._lastX = e.pageX\n          thisW._lastY = e.pageY\n          this._onMouseDown(thisW.current, e)\n        }\n      },\n\n      _onMouseDown: function (current, e) {\n        if (!current) {return}\n        var thisW = this.trackListWidget\n        if (!e.ctrlKey && !e.shiftKey) {\n          thisW.simpleSelection = true\n          if (!this._isSelected(current)) {\n            thisW.selectNone()\n            thisW.simpleSelection = false\n          }\n        }\n        if (e.shiftKey && this.anchor) {\n          var i = 0\n          var nodes = thisW.getAllNodes()\n          this._select(current)\n          if (current != this.anchor) {\n            for (; i < nodes.length; i++) {\n              if (nodes[i] == this.anchor || nodes[i] == current) {break}\n            }\n            i++\n            for (; i < nodes.length; i++) {\n              if (nodes[i] == this.anchor || nodes[i] == current) {break}\n              this._select(nodes[i])\n            }\n          }\n        } else {\n          e.ctrlKey ? this._toggle(current) : this._select(current)\n          this.anchor = current\n        }\n        event.stop(e)\n      },\n\n      onMouseUp: function (e) {\n        var thisW = this.trackListWidget\n        if (thisW.mouseDown) {\n          thisW.mouseDown = false\n          this._onMouseUp(e)\n        }\n      },\n\n      _onMouseUp: function (e) {\n        var thisW = this.trackListWidget\n        if (thisW.simpleSelection && thisW.current) {\n          thisW.selectNone()\n          this._select(thisW.current)\n        }\n      },\n\n      _isSelected: function (node) {\n        return this.trackListWidget.selection[node.id]\n      },\n\n      _select: function (node) {\n        this.trackListWidget.selection[node.id] = 1\n        this.trackListWidget._addItemClass(node, 'Selected')\n      },\n\n      _deselect: function (node) {\n        delete this.trackListWidget.selection[node.id]\n        this.trackListWidget._removeItemClass(node, 'Selected')\n      },\n\n      _toggle: function (node) {\n        if (this.trackListWidget.selection[node.id]) {\n          this._deselect(node)\n        } else {\n          this._select(node)\n        }\n      },\n\n      /**\n       * Given an array of track configs, update the track list to show\n       * that they are turned on.  For this list, that just means\n       * deleting them from our widget.\n       */\n      setTracksActive: function (/**Array[Object]*/ trackConfigs) {\n        this.deleteTracks(trackConfigs)\n      },\n\n      deleteTracks: function (/**Array[Object]*/ trackConfigs) {\n        // remove any tracks in our track list that are being set as visible\n        array.forEach(\n          trackConfigs || [],\n          function (conf) {\n            var oldNode = this.inactiveTrackNodes[conf.label]\n            if (!oldNode) {return}\n            delete this.inactiveTrackNodes[conf.label]\n\n            if (oldNode.parentNode) {oldNode.parentNode.removeChild(oldNode)}\n\n            this.trackListWidget.delItem(oldNode.id)\n          },\n          this,\n        )\n      },\n\n      /**\n       * Given an array of track configs, update the track list to show\n       * that they are turned off.\n       */\n      setTracksInactive: function (/**Array[Object]*/ trackConfigs) {\n        // remove any tracks in our track list that are being set as visible\n        if (!this.dndDrop) {\n          var n = this.trackListWidget.insertNodes(false, trackConfigs)\n\n          // blink the track(s) that we just turned off to make it\n          // easier for users to tell where they went.\n          // note that insertNodes will have put its html element in\n          // inactivetracknodes\n          this._blinkTracks(trackConfigs)\n        }\n      },\n\n      _blinkTracks: function (trackConfigs) {\n        // scroll the tracklist all the way to the bottom so we can see the blinking nodes\n        this.trackListWidget.node.scrollTop =\n          this.trackListWidget.node.scrollHeight\n\n        array.forEach(\n          trackConfigs,\n          function (c) {\n            var label = this.inactiveTrackNodes[c.label].firstChild\n            if (label) {\n              dojo\n                .animateProperty({\n                  node: label,\n                  duration: 400,\n                  properties: {\n                    backgroundColor: {\n                      start: '#DEDEDE',\n                      end: '#FFDE2B',\n                    },\n                  },\n                  easing: animationEasing.sine,\n                  repeat: 2,\n                  onEnd: function () {\n                    label.style.backgroundColor = null\n                  },\n                })\n                .play()\n            }\n          },\n          this,\n        )\n      },\n\n      /**\n       * Make the track selector visible.\n       * This does nothing for the Simple track selector, since it is always visible.\n       */\n      show: function () {},\n\n      /**\n       * Make the track selector invisible.\n       * This does nothing for the Simple track selector, since it is always visible.\n       */\n      hide: function () {},\n\n      /**\n       * Toggle visibility of this track selector.\n       * This does nothing for the Simple track selector, since it is always visible.\n       */\n      toggle: function () {},\n    },\n  )\n})\n"}},"/home/cdiesh/src/jbrowse/tests/js_tests/spec/AddFiles.spec.js":{"size":7854,"mtime":1738685446140,"hashOfConfig":"12q3b0o","results":{"filePath":"/home/cdiesh/src/jbrowse/tests/js_tests/spec/AddFiles.spec.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/tests/js_tests/spec/BAM.spec.js":{"size":47042,"mtime":1738685446141,"hashOfConfig":"12q3b0o","results":{"filePath":"/home/cdiesh/src/jbrowse/tests/js_tests/spec/BAM.spec.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/tests/js_tests/spec/BED.spec.js":{"size":2415,"mtime":1738685446142,"hashOfConfig":"12q3b0o","results":{"filePath":"/home/cdiesh/src/jbrowse/tests/js_tests/spec/BED.spec.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/tests/js_tests/spec/BEDTabix.spec.js":{"size":2653,"mtime":1738685446142,"hashOfConfig":"12q3b0o","results":{"filePath":"/home/cdiesh/src/jbrowse/tests/js_tests/spec/BEDTabix.spec.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/tests/js_tests/spec/BigBed.spec.js":{"size":6401,"mtime":1738685446142,"hashOfConfig":"12q3b0o","results":{"filePath":"/home/cdiesh/src/jbrowse/tests/js_tests/spec/BigBed.spec.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"\nrequire([\n            'dojo/_base/array',\n            'JBrowse/Browser',\n            'JBrowse/Store/SeqFeature/BigBed',\n            'JBrowse/Model/XHRBlob'\n        ], function(\n            array,\n            Browser,\n            BigBed,\n            XHRBlob\n        ) {\n\n    var errorFunc = function(e) { console.error(e); };\n\n    describe( 'BigBed with volvox eden genes', function() {\n        var browser = new Browser({ unitTestMode: true });\n        var b = new BigBed({\n            browser: browser,\n            blob: new XHRBlob('../../sample_data/raw/volvox/volvox.bb')\n        });\n\n        it('constructs', function(){ expect(b).toBeTruthy(); });\n\n        it('accesses volvox bigbed', function(){\n            const features = [];\n            const expectedFeatureData = cjsRequire('../../data/volvox.bb.expected.json')\n            deleteUniqueIDSerial(expectedFeatureData)\n\n            b.getFeatures(\n                { ref: 'ctgA', start: 1, end: 50000 },\n                f => features.push(f),\n                () => { features.done = true },\n                e => { console.error(e.stack||''+e) }\n            )\n\n            waitsFor( function() { return features.done; } )\n            runs( function() {\n                deleteUniqueIDSerial(expectedFeatureData)\n                // console.log(JSON.stringify(features,undefined,2))\n                const featureData = JSON.parse(JSON.stringify(features))\n                deleteUniqueIDSerial(featureData)\n                expect(featureData).toEqual(expectedFeatureData)\n            })\n        })\n    })\n\n    describe( 'BigBed with human peaks', function() {\n        var browser = new Browser({ unitTestMode: true });\n        var b = new BigBed({\n            browser: browser,\n            blob: new XHRBlob('../data/human_bigbed/peaks.bb')\n        });\n\n        it('constructs', function(){ expect(b).toBeTruthy(); });\n\n        it('accesses peaks bigbed', function(){\n            var features = [];\n            b.getFeatures(\n                { ref: 'chr1', start: 18000000, end: 19000000 },\n                function(f) { features.push(f); },\n                function() { features.done = true },\n                function(e) { console.error(e.stack||''+e); }\n            );\n\n            waitsFor( function() { return features.done; } );\n            runs( function() {\n                expect( features.length ).toEqual( 33 );\n            });\n        });\n    });\n\n\n    describe( 'malformed bigbed', function() {\n        var browser = new Browser({ unitTestMode: true });\n        var b = new BigBed({\n            browser: browser,\n            blob: new XHRBlob('../data/malformed.bb')\n        });\n\n        it('constructs', function(){ expect(b).toBeTruthy(); });\n\n        it('calls the error callback', function(){\n            const features = [];\n            let error\n            b.getFeatures(\n                { ref: 'chr1', start: 18000000, end: 19000000 },\n                f => features.push(f),\n                () => { features.done = true },\n                e => { error = e }\n            );\n\n            waitsFor( () => error || features.done );\n            runs( function() {\n                expect( features.length ).toEqual( 0 );\n                expect(error).toContain('Not a BigWig or BigBed file')\n            });\n        });\n    });\n\n\n    describe( 'BigBed with less than bed12 and autosql', function() {\n        var browser = new Browser({ unitTestMode: true });\n        var b = new BigBed({\n            browser: browser,\n            blob: new XHRBlob('../data/human_bigbed/genes.bb')\n        });\n\n        it('constructs', function(){ expect(b).toBeTruthy(); });\n\n        it('accesses gene bigbed', function(){\n            var features = [];\n            b.getFeatures(\n                { ref: 'chr1', start: 18000000, end: 19000000 },\n                function(f) { features.push(f); },\n                function() { features.done = true },\n                function(e) { console.error(e.stack||''+e); }\n            );\n\n            waitsFor( function() { return features.done; } );\n            runs( function() {\n                expect( features.length ).toEqual( 14 );\n                expect(features[0].get('gene_symbol')).toEqual('PRPS1L1');\n                expect(features[0].get('name')).toEqual('uc003stz.1');\n                expect(features[0].get('strand')).toEqual(-1);\n                expect(features[13].get('gene_symbol')).toEqual('HDAC9');\n                expect(features[13].get('name')).toEqual('uc003suk.1');\n                expect(features[13].get('strand')).toEqual(1);\n            });\n        });\n    });\n\n    describe( 'BigBed GENCODE bed12+4 and autosql', () => {\n        const browser = new Browser({ unitTestMode: true });\n        const b = new BigBed({\n            browser: browser,\n            blob: new XHRBlob('../data/human_bigbed/gencode.bb')\n        });\n        const expectedFeatureData = cjsRequire('../../data/human_bigbed/ENST00000610940.4.json')\n\n        it('constructs', function(){ expect(b).toBeTruthy(); });\n\n        it('accesses gencode bigbed', () => {\n            const features = [];\n            b.getFeatures(\n                { ref: 'chr1', start: 18000000, end: 19000000 },\n                f => features.push(f),\n                () => { features.done = true },\n                e => { console.error(e.stack||''+e); }\n            );\n\n            waitsFor( () => features.done );\n            runs( () => {\n                expect( features.length ).toEqual( 114 )\n                let featureData = JSON.parse(JSON.stringify(features[88], undefined, 2))\n                // console.log(JSON.stringify(features[88],undefined,2))\n                deleteUniqueIDSerial(featureData)\n                deleteUniqueIDSerial(expectedFeatureData)\n                expect(featureData).toEqual(expectedFeatureData)\n            });\n        });\n    });\n\n});\n\n// recursively delete the unique serial numbers in all the _uniqueID properties of an\n// object containing feature data\nfunction deleteUniqueIDSerial(featureData) {\n    Object.entries(featureData).forEach(([name,val]) => {\n        if (!val) {return}\n\n        if (name === '_uniqueID') {\n            featureData[name] = val.replace(/_\\d+$/,'_(serial redacted)')\n        } else if (Array.isArray(val)) {\n            val.forEach(v => deleteUniqueIDSerial(v))\n        } else if (typeof val === 'object') {\n            deleteUniqueIDSerial(val)\n        }\n    })\n}\n"}},"/home/cdiesh/src/jbrowse/tests/js_tests/spec/BigWig.spec.js":{"size":12336,"mtime":1738685446142,"hashOfConfig":"12q3b0o","results":{"filePath":"/home/cdiesh/src/jbrowse/tests/js_tests/spec/BigWig.spec.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/tests/js_tests/spec/ConfigManager.spec.js":{"size":6003,"mtime":1738685446143,"hashOfConfig":"12q3b0o","results":{"filePath":"/home/cdiesh/src/jbrowse/tests/js_tests/spec/ConfigManager.spec.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/tests/js_tests/spec/CRAM.spec.js":{"size":3237,"mtime":1738685446143,"hashOfConfig":"12q3b0o","results":{"filePath":"/home/cdiesh/src/jbrowse/tests/js_tests/spec/CRAM.spec.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/tests/js_tests/spec/ExportGFF3.spec.js":{"size":220,"mtime":1738685446143,"hashOfConfig":"12q3b0o","results":{"filePath":"/home/cdiesh/src/jbrowse/tests/js_tests/spec/ExportGFF3.spec.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/tests/js_tests/spec/FeatureLayout.spec.js":{"size":2429,"mtime":1738685446143,"hashOfConfig":"12q3b0o","results":{"filePath":"/home/cdiesh/src/jbrowse/tests/js_tests/spec/FeatureLayout.spec.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/tests/js_tests/spec/GBrowseParser.spec.js":{"size":5179,"mtime":1738685446143,"hashOfConfig":"12q3b0o","results":{"filePath":"/home/cdiesh/src/jbrowse/tests/js_tests/spec/GBrowseParser.spec.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/tests/js_tests/spec/GFF3.spec.js":{"size":3938,"mtime":1738685446144,"hashOfConfig":"12q3b0o","results":{"filePath":"/home/cdiesh/src/jbrowse/tests/js_tests/spec/GFF3.spec.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/tests/js_tests/spec/GFF3ParserCheckDeeperFeatures.js":{"size":32426,"mtime":1738685446144,"hashOfConfig":"12q3b0o","results":{"filePath":"/home/cdiesh/src/jbrowse/tests/js_tests/spec/GFF3ParserCheckDeeperFeatures.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/tests/js_tests/spec/GFF3ParserSpec.js":{"size":11384,"mtime":1738685446145,"hashOfConfig":"12q3b0o","results":{"filePath":"/home/cdiesh/src/jbrowse/tests/js_tests/spec/GFF3ParserSpec.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/tests/js_tests/spec/GFF3Tabix.spec.js":{"size":24245,"mtime":1738685446145,"hashOfConfig":"12q3b0o","results":{"filePath":"/home/cdiesh/src/jbrowse/tests/js_tests/spec/GFF3Tabix.spec.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/tests/js_tests/spec/GFF3toJbrowseJsonSpec.js":{"size":13216,"mtime":1738685446146,"hashOfConfig":"12q3b0o","results":{"filePath":"/home/cdiesh/src/jbrowse/tests/js_tests/spec/GFF3toJbrowseJsonSpec.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/tests/js_tests/spec/Hash.spec.js":{"size":1153,"mtime":1738685446146,"hashOfConfig":"12q3b0o","results":{"filePath":"/home/cdiesh/src/jbrowse/tests/js_tests/spec/Hash.spec.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/tests/js_tests/spec/Hierarchical.spec.js":{"size":2370,"mtime":1738685446146,"hashOfConfig":"12q3b0o","results":{"filePath":"/home/cdiesh/src/jbrowse/tests/js_tests/spec/Hierarchical.spec.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/tests/js_tests/spec/LazyArray.spec.js":{"size":2898,"mtime":1738685446146,"hashOfConfig":"12q3b0o","results":{"filePath":"/home/cdiesh/src/jbrowse/tests/js_tests/spec/LazyArray.spec.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/tests/js_tests/spec/NestedFrequencyTable.spec.js":{"size":1208,"mtime":1738685446146,"hashOfConfig":"12q3b0o","results":{"filePath":"/home/cdiesh/src/jbrowse/tests/js_tests/spec/NestedFrequencyTable.spec.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/tests/js_tests/spec/QueryParamConfigMapper.spec.js":{"size":8912,"mtime":1738685446147,"hashOfConfig":"12q3b0o","results":{"filePath":"/home/cdiesh/src/jbrowse/tests/js_tests/spec/QueryParamConfigMapper.spec.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/tests/js_tests/spec/RegularizeRefSeqs.spec.js":{"size":2452,"mtime":1738685446147,"hashOfConfig":"12q3b0o","results":{"filePath":"/home/cdiesh/src/jbrowse/tests/js_tests/spec/RegularizeRefSeqs.spec.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/tests/js_tests/spec/RESTStore.spec.js":{"size":8381,"mtime":1738685446147,"hashOfConfig":"12q3b0o","results":{"filePath":"/home/cdiesh/src/jbrowse/tests/js_tests/spec/RESTStore.spec.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"output":"require([\n            'dojo/_base/lang',\n            'JBrowse/Store/SeqFeature/REST'\n        ], function( lang, RESTStore ) {\n\nfunction testWithConfig(config) {\n    var store = new RESTStore({\n                      browser: {},\n                      baseUrl: '../data/rest_store_test',\n                      refSeq: { name: 'ctgA', start: 1, end: 500001 },\n                      config: config || {}\n                  });\n\n    return function() {\n              it( 'constructs', function() {\n                      expect( store ).toBeTruthy();\n                  });\n\n              it( 'loads some data', function() {\n                      var features = [];\n                      var done;\n                      store.getFeatures({ start: 0, end: 50000 },\n                                 function( feature ) {\n                                     features.push( feature );\n                                 },\n                                 function() {\n                                     done = true;\n                                 }\n                               );\n                      waitsFor( function() { return done; }, 2000 );\n                      runs( function() {\n                                expect(features.length).toEqual(6);\n                                expect( features[0].get('start') ).toEqual( 1 );\n                                expect( features[4].children().length ).toEqual( 2 );\n                                expect( features[4].children()[1].children()[0].get('type') ).toEqual( 'SNV' );\n                            });\n                  });\n\n              it( 'supports global stats', function() {\n                      var stats;\n                      var done;\n                      store.getGlobalStats(\n                                 function(s) {\n                                     stats = s;\n                                 }\n                               );\n                      waitsFor( function() { return stats; }, 2000 );\n                      runs( function() {\n                                expect( stats.featureDensity ).toEqual(20);\n                            });\n                  });\n\n              it( 'emulates region stats', function() {\n                      var stats;\n                      var done;\n                      store.getRegionStats({ start: 0, end: 50000 },\n                                 function(s) {\n                                     stats = s;\n                                 }\n                               );\n                      waitsFor( function() { return stats; }, 2000 );\n                      runs( function() {\n                                expect( stats.featureDensity ).toEqual( 0.00012 );\n                            });\n                  });\n\n             it( 'supports region stats if implemented', function() {\n                     var store = new RESTStore(\n                         {\n                             browser: {},\n                             baseUrl: '../data/rest_store_test',\n                             refSeq: { name: 'ctgC', start: 1, end: 200 },\n                             config: lang.mixin( { region_stats: true }, config || {} )\n                         });\n                      var stats;\n                      var done;\n                      store.getRegionStats({ start: 0, end: 50000 },\n                                 function(s) {\n                                     stats = s;\n                                 }\n                               );\n                      waitsFor( function() { return stats; }, 2000 );\n                      runs( function() {\n                                expect( stats.featureDensity ).toEqual( 123 );\n                                expect( stats.featureCount ).toEqual( 456 );\n                                expect( stats.scoreMin ).toEqual( -1 );\n                                expect( stats.scoreMax ).toEqual( 4 );\n                            });\n             });\n\n             if( ! config.noCache ) // this test does not work under noCache because the backend is not dynamic\n                 {it( 'supports feature_range_cache', function() {\n                     var withRangeCache = new RESTStore(\n                         {\n                             browser: {},\n                             baseUrl: '../data/rest_store_test',\n                             refSeq: { name: 'ctgA', start: 0, end: 50000 },\n                             config: lang.mixin( { feature_range_cache: true }, config || {} )\n                         });\n\n                     expect( withRangeCache.region_cache_hits ).toEqual( 0 );\n\n                     var features = [];\n                     var done1, done2;\n                     withRangeCache.getFeatures({ start: 0, end: 50000 },\n                                                function( feature ) {\n                                                    features.push( feature );\n                                                },\n                                                function() {\n                                                    done1 = true;\n                                                }\n                                               );\n                     waitsFor( function() { return done1; }, 2000 );\n                     runs( function() {\n                               expect( withRangeCache.region_cache_hits ).toEqual( 0 );\n                               expect(features.length).toEqual(6);\n                               expect( features[0].get('start') ).toEqual( 1 );\n                               expect( features[4].children().length ).toEqual( 2 );\n                               expect( features[4].children()[1].children()[0].get('type') ).toEqual( 'SNV' );\n\n                               features = [];\n                               withRangeCache.getFeatures({ start: 100, end: 400 },\n                                                          function( feature ) {\n                                                              features.push( feature );\n                                                          },\n                                                          function() {\n                                                              done2 = true;\n                                                          }\n                                                         );\n                           });\n                     waitsFor( function() { return done2; }, 2000 );\n                     runs( function() {\n                               expect( withRangeCache.region_cache_hits ).toEqual( 1 );\n                               expect(features.length).toEqual(4);\n                               expect( features[0].get('start') ).toEqual( 300 );\n                               expect( features[3].children().length ).toEqual( 2 );\n                               expect( features[3].children()[1].children()[0].get('type') ).toEqual( 'SNV' );\n                           });\n\n                 });}\n\n             it( 'supports feature histograms if implemented', function() {\n                     expect( store.getRegionFeatureDensities ).toBeFalsy();\n\n                     var withHist = new RESTStore(\n                         {\n                             browser: {},\n                             baseUrl: '../data/rest_store_test',\n                             refSeq: { name: 'ctgA', start: 1, end: 200 },\n                             config: lang.mixin( { region_feature_densities: true }, config || {} )\n                         });\n\n\n                      var hist;\n                      var done;\n                      withHist.getRegionFeatureDensities({ start: 0, end: 50000 },\n                                 function(s) {\n                                     hist = s;\n                                 }\n                               );\n                      waitsFor( function() { return hist; }, 2000 );\n                      runs( function() {\n                                expect( hist.bins.length ).toEqual( 25 );\n                                expect( hist.stats.basesPerBin ).toEqual( 200 );\n                                expect( hist.stats.mean ).toEqual( 57.772 );\n                            });\n             });\n    };\n};\n\ndescribe( 'REST store', testWithConfig({ foo: 1 }));\ndescribe( 'REST store with nocache', testWithConfig({ noCache: true, foo:2 }) );\n\n});\n"}},"/home/cdiesh/src/jbrowse/tests/js_tests/spec/SequenceChunkStore.spec.js":{"size":6931,"mtime":1738685446148,"hashOfConfig":"12q3b0o","results":{"filePath":"/home/cdiesh/src/jbrowse/tests/js_tests/spec/SequenceChunkStore.spec.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/tests/js_tests/spec/SequenceTrack.spec.js":{"size":3255,"mtime":1738685446148,"hashOfConfig":"12q3b0o","results":{"filePath":"/home/cdiesh/src/jbrowse/tests/js_tests/spec/SequenceTrack.spec.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/tests/js_tests/spec/SPARQLStore.spec.js":{"size":11573,"mtime":1738685446147,"hashOfConfig":"12q3b0o","results":{"filePath":"/home/cdiesh/src/jbrowse/tests/js_tests/spec/SPARQLStore.spec.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/tests/js_tests/spec/TabixIndex.spec.js":{"size":1669,"mtime":1738685446148,"hashOfConfig":"12q3b0o","results":{"filePath":"/home/cdiesh/src/jbrowse/tests/js_tests/spec/TabixIndex.spec.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/tests/js_tests/spec/TwoBit.spec.js":{"size":21401,"mtime":1738685446149,"hashOfConfig":"12q3b0o","results":{"filePath":"/home/cdiesh/src/jbrowse/tests/js_tests/spec/TwoBit.spec.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/tests/js_tests/spec/Util.spec.js":{"size":4695,"mtime":1738685446149,"hashOfConfig":"12q3b0o","results":{"filePath":"/home/cdiesh/src/jbrowse/tests/js_tests/spec/Util.spec.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}},"/home/cdiesh/src/jbrowse/tests/js_tests/spec/VCF.spec.js":{"size":14125,"mtime":1738685446149,"hashOfConfig":"12q3b0o","results":{"filePath":"/home/cdiesh/src/jbrowse/tests/js_tests/spec/VCF.spec.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}}}